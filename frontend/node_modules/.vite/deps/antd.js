"use client";
import {
  require_dayjs_min
} from "./chunk-EIERH5WB.js";
import {
  require_client
} from "./chunk-MKOUTKN7.js";
import {
  BarsOutlined_default,
  CalendarOutlined_default,
  CaretDownFilled_default,
  CaretDownOutlined_default,
  CaretUpOutlined_default,
  CheckCircleFilled_default,
  CheckOutlined_default,
  ClockCircleOutlined_default,
  CloseCircleFilled_default,
  CloseOutlined_default,
  Context_default,
  CopyOutlined_default,
  DeleteOutlined_default,
  DoubleLeftOutlined_default,
  DoubleRightOutlined_default,
  DownOutlined_default,
  DownloadOutlined_default,
  EditOutlined_default,
  EllipsisOutlined_default,
  EnterOutlined_default,
  ExclamationCircleFilled_default,
  EyeInvisibleOutlined_default,
  EyeOutlined_default,
  FastColor,
  FileOutlined_default,
  FileTextOutlined_default,
  FileTwoTone_default,
  FilterFilled_default,
  FolderOpenOutlined_default,
  FolderOutlined_default,
  HolderOutlined_default,
  InfoCircleFilled_default,
  LeftOutlined_default,
  LoadingOutlined_default,
  MinusOutlined_default,
  MinusSquareOutlined_default,
  PaperClipOutlined_default,
  PictureTwoTone_default,
  PlusOutlined_default,
  PlusSquareOutlined_default,
  QuestionCircleOutlined_default,
  ReloadOutlined_default,
  RightOutlined_default,
  RotateLeftOutlined_default,
  RotateRightOutlined_default,
  SearchOutlined_default,
  StarFilled_default,
  SwapOutlined_default,
  SwapRightOutlined_default,
  UpOutlined_default,
  VerticalAlignTopOutlined_default,
  WarningFilled_default,
  ZoomInOutlined_default,
  ZoomOutOutlined_default,
  blue,
  canUseDom,
  clsx,
  composeRef,
  contains,
  fillRef,
  generate,
  getNodeRef,
  getShadowRoot,
  gold,
  isFragment,
  noteOnce,
  presetPalettes,
  presetPrimaryColors,
  removeCSS,
  supportNodeRef,
  supportRef,
  updateCSS,
  useComposeRef,
  useMemo,
  warning,
  warning_default
} from "./chunk-V5BYLBTA.js";
import {
  require_react_dom
} from "./chunk-3XAYWQIW.js";
import {
  require_react
} from "./chunk-MGW7ERZY.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/dayjs/plugin/weekday.js
var require_weekday = __commonJS({
  "node_modules/dayjs/plugin/weekday.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekday = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekday = function(e4) {
          var t3 = this.$locale().weekStart || 0, i = this.$W, n2 = (i < t3 ? i + 7 : i) - t3;
          return this.$utils().u(e4) ? n2 : this.subtract(n2, "day").add(e4, "day");
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "node_modules/dayjs/plugin/localeData.js"(exports, module2) {
    !function(n2, e3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (n2 = "undefined" != typeof globalThis ? globalThis : n2 || self).dayjs_plugin_localeData = e3();
    }(exports, function() {
      "use strict";
      return function(n2, e3, t2) {
        var r2 = e3.prototype, o3 = function(n3) {
          return n3 && (n3.indexOf ? n3 : n3.s);
        }, u = function(n3, e4, t3, r3, u2) {
          var i2 = n3.name ? n3 : n3.$locale(), a2 = o3(i2[e4]), s2 = o3(i2[t3]), f = a2 || s2.map(function(n4) {
            return n4.slice(0, r3);
          });
          if (!u2)
            return f;
          var d = i2.weekStart;
          return f.map(function(n4, e5) {
            return f[(e5 + (d || 0)) % 7];
          });
        }, i = function() {
          return t2.Ls[t2.locale()];
        }, a = function(n3, e4) {
          return n3.formats[e4] || function(n4) {
            return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e5, t3) {
              return e5 || t3.slice(1);
            });
          }(n3.formats[e4.toUpperCase()]);
        }, s = function() {
          var n3 = this;
          return { months: function(e4) {
            return e4 ? e4.format("MMMM") : u(n3, "months");
          }, monthsShort: function(e4) {
            return e4 ? e4.format("MMM") : u(n3, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n3.$locale().weekStart || 0;
          }, weekdays: function(e4) {
            return e4 ? e4.format("dddd") : u(n3, "weekdays");
          }, weekdaysMin: function(e4) {
            return e4 ? e4.format("dd") : u(n3, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e4) {
            return e4 ? e4.format("ddd") : u(n3, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e4) {
            return a(n3.$locale(), e4);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r2.localeData = function() {
          return s.bind(this)();
        }, t2.localeData = function() {
          var n3 = i();
          return { firstDayOfWeek: function() {
            return n3.weekStart || 0;
          }, weekdays: function() {
            return t2.weekdays();
          }, weekdaysShort: function() {
            return t2.weekdaysShort();
          }, weekdaysMin: function() {
            return t2.weekdaysMin();
          }, months: function() {
            return t2.months();
          }, monthsShort: function() {
            return t2.monthsShort();
          }, longDateFormat: function(e4) {
            return a(n3, e4);
          }, meridiem: n3.meridiem, ordinal: n3.ordinal };
        }, t2.months = function() {
          return u(i(), "months");
        }, t2.monthsShort = function() {
          return u(i(), "monthsShort", "months", 3);
        }, t2.weekdays = function(n3) {
          return u(i(), "weekdays", null, null, n3);
        }, t2.weekdaysShort = function(n3) {
          return u(i(), "weekdaysShort", "weekdays", 3, n3);
        }, t2.weekdaysMin = function(n3) {
          return u(i(), "weekdaysMin", "weekdays", 2, n3);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "node_modules/dayjs/plugin/weekOfYear.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekOfYear = t2();
    }(exports, function() {
      "use strict";
      var e3 = "week", t2 = "year";
      return function(i, n2, r2) {
        var f = n2.prototype;
        f.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2)
            return this.add(7 * (i2 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e3);
            if (f2.isBefore(s))
              return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e3).subtract(1, "millisecond"), o3 = this.diff(a, e3, true);
          return o3 < 0 ? r2(this).startOf("week").week() : Math.ceil(o3);
        }, f.weeks = function(e4) {
          return void 0 === e4 && (e4 = null), this.week(e4);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "node_modules/dayjs/plugin/weekYear.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_weekYear = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        t2.prototype.weekYear = function() {
          var e4 = this.month(), t3 = this.week(), n2 = this.year();
          return 1 === t3 && 11 === e4 ? n2 + 1 : 0 === e4 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/dayjs/plugin/advancedFormat.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_advancedFormat = t2();
    }(exports, function() {
      "use strict";
      return function(e3, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e4) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid())
            return n2.bind(this)(e4);
          var s = this.$utils(), a = (e4 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e5) {
            switch (e5) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s.s(t3.week(), "w" === e5 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t3.isoWeek(), "W" === e5 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e5 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e5;
            }
          });
          return n2.bind(this)(a);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module2) {
    !function(e3, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).dayjs_plugin_customParseFormat = t2();
    }(exports, function() {
      "use strict";
      var e3 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i = /\d\d?/, o3 = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e4) {
        return (e4 = +e4) + (e4 > 68 ? 1900 : 2e3);
      };
      var f = function(e4) {
        return function(t3) {
          this[e4] = +t3;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e4) {
        (this.zone || (this.zone = {})).offset = function(e5) {
          if (!e5)
            return 0;
          if ("Z" === e5)
            return 0;
          var t3 = e5.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        }(e4);
      }], u = function(e4) {
        var t3 = s[e4];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, d = function(e4, t3) {
        var n3, r3 = s.meridiem;
        if (r3) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e4.indexOf(r3(i2, 0, t3)) > -1) {
              n3 = i2 > 12;
              break;
            }
        } else
          n3 = e4 === (t3 ? "pm" : "PM");
        return n3;
      }, c = { A: [o3, function(e4) {
        this.afternoon = d(e4, false);
      }], a: [o3, function(e4) {
        this.afternoon = d(e4, true);
      }], Q: [n2, function(e4) {
        this.month = 3 * (e4 - 1) + 1;
      }], S: [n2, function(e4) {
        this.milliseconds = 100 * +e4;
      }], SS: [r2, function(e4) {
        this.milliseconds = 10 * +e4;
      }], SSS: [/\d{3}/, function(e4) {
        this.milliseconds = +e4;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r2, f("day")], Do: [o3, function(e4) {
        var t3 = s.ordinal, n3 = e4.match(/\d+/);
        if (this.day = n3[0], t3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            t3(r3).replace(/\[|\]/g, "") === e4 && (this.day = r3);
      }], w: [i, f("week")], ww: [r2, f("week")], M: [i, f("month")], MM: [r2, f("month")], MMM: [o3, function(e4) {
        var t3 = u("months"), n3 = (u("monthsShort") || t3.map(function(e5) {
          return e5.slice(0, 3);
        })).indexOf(e4) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [o3, function(e4) {
        var t3 = u("months").indexOf(e4) + 1;
        if (t3 < 1)
          throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r2, function(e4) {
        this.year = a(e4);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l2(n3) {
        var r3, i2;
        r3 = n3, i2 = s && s.formats;
        for (var o4 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
          var o5 = r4 && r4.toUpperCase();
          return n4 || i2[r4] || e3[r4] || i2[o5].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e4, t4, n5) {
            return t4 || n5.slice(1);
          });
        })).match(t2), a2 = o4.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o4[f2], u2 = c[h2], d2 = u2 && u2[0], l3 = u2 && u2[1];
          o4[f2] = l3 ? { regex: d2, parser: l3 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e4) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i3 = o4[n4];
            if ("string" == typeof i3)
              r4 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e4.slice(r4), u3 = s2.exec(h3)[0];
              f3.call(t3, u3), e4 = e4.replace(u3, "");
            }
          }
          return function(e5) {
            var t4 = e5.afternoon;
            if (void 0 !== t4) {
              var n5 = e5.hours;
              t4 ? n5 < 12 && (e5.hours += 12) : 12 === n5 && (e5.hours = 0), delete e5.afternoon;
            }
          }(t3), t3;
        };
      }
      return function(e4, t3, n3) {
        n3.p.customParseFormat = true, e4 && e4.parseTwoDigitYear && (a = e4.parseTwoDigitYear);
        var r3 = t3.prototype, i2 = r3.parse;
        r3.parse = function(e5) {
          var t4 = e5.date, r4 = e5.utc, o4 = e5.args;
          this.$u = r4;
          var a2 = o4[1];
          if ("string" == typeof a2) {
            var f2 = true === o4[2], h2 = true === o4[3], u2 = f2 || h2, d2 = o4[2];
            h2 && (d2 = o4[2]), s = this.$locale(), !f2 && d2 && (s = n3.Ls[d2]), this.$d = function(e6, t5, n4, r5) {
              try {
                if (["x", "X"].indexOf(t5) > -1)
                  return new Date(("X" === t5 ? 1e3 : 1) * e6);
                var i3 = l2(t5)(e6), o5 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o5 || s2 ? 1 : M2.getDate()), p = o5 || M2.getFullYear(), v = 0;
                o5 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n4 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r5(D).week(m2).toDate()), D);
              } catch (e7) {
                return /* @__PURE__ */ new Date("");
              }
            }(t4, a2, r4, n3), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array)
            for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
              o4[1] = a2[m - 1];
              var M = n3.apply(this, o4);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e5);
        };
      };
    });
  }
});

// node_modules/is-mobile/index.js
var require_is_mobile = __commonJS({
  "node_modules/is-mobile/index.js"(exports, module2) {
    "use strict";
    module2.exports = isMobile2;
    module2.exports.isMobile = isMobile2;
    module2.exports.default = isMobile2;
    var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|redmi|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
    var notMobileRE = /CrOS/;
    var tabletRE = /android|ipad|playbook|silk/i;
    function isMobile2(opts) {
      if (!opts)
        opts = {};
      let ua = opts.ua;
      if (!ua && typeof navigator !== "undefined")
        ua = navigator.userAgent;
      if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
        ua = ua.headers["user-agent"];
      }
      if (typeof ua !== "string")
        return false;
      let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
      if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
        result = true;
      }
      return result;
    }
  }
});

// node_modules/string-convert/camel2hyphen.js
var require_camel2hyphen = __commonJS({
  "node_modules/string-convert/camel2hyphen.js"(exports, module2) {
    var camel2hyphen = function(str) {
      return str.replace(/[A-Z]/g, function(match3) {
        return "-" + match3.toLowerCase();
      }).toLowerCase();
    };
    module2.exports = camel2hyphen;
  }
});

// node_modules/json2mq/index.js
var require_json2mq = __commonJS({
  "node_modules/json2mq/index.js"(exports, module2) {
    var camel2hyphen = require_camel2hyphen();
    var isDimension = function(feature) {
      var re = /[height|width]$/;
      return re.test(feature);
    };
    var obj2mq = function(obj) {
      var mq = "";
      var features = Object.keys(obj);
      features.forEach(function(feature, index2) {
        var value = obj[feature];
        feature = camel2hyphen(feature);
        if (isDimension(feature) && typeof value === "number") {
          value = value + "px";
        }
        if (value === true) {
          mq += feature;
        } else if (value === false) {
          mq += "not " + feature;
        } else {
          mq += "(" + feature + ": " + value + ")";
        }
        if (index2 < features.length - 1) {
          mq += " and ";
        }
      });
      return mq;
    };
    var json2mq2 = function(query) {
      var mq = "";
      if (typeof query === "string") {
        return query;
      }
      if (query instanceof Array) {
        query.forEach(function(q, index2) {
          mq += obj2mq(q);
          if (index2 < query.length - 1) {
            mq += ", ";
          }
        });
        return mq;
      }
      return obj2mq(query);
    };
    module2.exports = json2mq2;
  }
});

// node_modules/antd/es/_util/getReactMajorVersionCanDelMe.js
var import_react = __toESM(require_react());
function getReactMajorVersion() {
  const majorVersion = Number.parseInt(import_react.version.split(".")[0], 10);
  return majorVersion;
}

// node_modules/antd/es/_util/warning.js
var React5 = __toESM(require_react());

// node_modules/@rc-component/util/es/hooks/useEvent.js
var React = __toESM(require_react());
function useEvent(callback) {
  const fnRef = React.useRef(callback);
  fnRef.current = callback;
  const memoFn = React.useCallback((...args) => {
    var _a;
    return (_a = fnRef.current) == null ? void 0 : _a.call(fnRef, ...args);
  }, []);
  return memoFn;
}
var useEvent_default = useEvent;

// node_modules/@rc-component/util/es/hooks/useLayoutEffect.js
var React2 = __toESM(require_react());
var useInternalLayoutEffect = canUseDom() ? React2.useLayoutEffect : React2.useEffect;
var useLayoutEffect2 = (callback, deps) => {
  const firstMountRef = React2.useRef(true);
  useInternalLayoutEffect(() => {
    return callback(firstMountRef.current);
  }, deps);
  useInternalLayoutEffect(() => {
    firstMountRef.current = false;
    return () => {
      firstMountRef.current = true;
    };
  }, []);
};
var useLayoutUpdateEffect = (callback, deps) => {
  useLayoutEffect2((firstMount) => {
    if (!firstMount) {
      return callback();
    }
  }, deps);
};
var useLayoutEffect_default = useLayoutEffect2;

// node_modules/@rc-component/util/es/hooks/useState.js
var React3 = __toESM(require_react());
function useSafeState(defaultValue) {
  const destroyRef = React3.useRef(false);
  const [value, setValue] = React3.useState(defaultValue);
  React3.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}

// node_modules/@rc-component/util/es/hooks/useControlledState.js
var import_react2 = __toESM(require_react());
function useControlledState(defaultStateValue, value) {
  const [innerValue, setInnerValue] = (0, import_react2.useState)(defaultStateValue);
  const mergedValue = value !== void 0 ? value : innerValue;
  useLayoutEffect_default((mount) => {
    if (!mount) {
      setInnerValue(value);
    }
  }, [value]);
  return [
    // Value
    mergedValue,
    // Update function
    setInnerValue
  ];
}

// node_modules/@rc-component/util/es/utils/get.js
function get(entity, path2) {
  let current = entity;
  for (let i = 0; i < path2.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i]];
  }
  return current;
}

// node_modules/@rc-component/util/es/utils/set.js
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  const [path2, ...restPath] = paths;
  let clone;
  if (!entity && typeof path2 === "number") {
    clone = [];
  } else if (Array.isArray(entity)) {
    clone = [...entity];
  } else {
    clone = {
      ...entity
    };
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone[path2][restPath[0]];
  } else {
    clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined);
  }
  return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
  return Array.isArray(source) ? [] : {};
}
var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
function mergeWith(sources, config = {}) {
  const {
    prepareArray
  } = config;
  const finalPrepareArray = prepareArray || (() => []);
  let clone = createEmpty(sources[0]);
  sources.forEach((src) => {
    function internalMerge(path2, parentLoopSet) {
      const loopSet = new Set(parentLoopSet);
      const value = get(src, path2);
      const isArr = Array.isArray(value);
      if (isArr || isObject(value)) {
        if (!loopSet.has(value)) {
          loopSet.add(value);
          const originValue = get(clone, path2);
          if (isArr) {
            clone = set(clone, path2, finalPrepareArray(originValue, value));
          } else if (!originValue || typeof originValue !== "object") {
            clone = set(clone, path2, createEmpty(value));
          }
          keys(value).forEach((key) => {
            internalMerge([...path2, key], loopSet);
          });
        }
      } else {
        clone = set(clone, path2, value);
      }
    }
    internalMerge([]);
  });
  return clone;
}
function merge(...sources) {
  return mergeWith(sources);
}

// node_modules/@rc-component/util/es/omit.js
function omit(obj, fields) {
  const clone = Object.assign({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach((key) => {
      delete clone[key];
    });
  }
  return clone;
}

// node_modules/@rc-component/util/es/Children/toArray.js
var import_react3 = __toESM(require_react());
function toArray(children, option = {}) {
  let ret = [];
  import_react3.default.Children.forEach(children, (child) => {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray(child));
    } else if (isFragment(child) && child.props) {
      ret = ret.concat(toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}

// node_modules/antd/es/_util/warning.js
function noop() {
}
var {
  resetWarned: rcResetWarned
} = warning_default;
var deprecatedWarnList = null;
var _warning = noop;
if (true) {
  _warning = (valid, component, message2) => {
    warning_default(valid, `[antd: ${component}] ${message2}`);
    if (false) {
      resetWarned();
    }
  };
}
var warning2 = _warning;
var WarningContext = React5.createContext({});
var devUseWarning = true ? (component) => {
  const {
    strict
  } = React5.useContext(WarningContext);
  const typeWarning = (valid, type5, message2) => {
    if (!valid) {
      if (strict === false && type5 === "deprecated") {
        const existWarning = deprecatedWarnList;
        if (!deprecatedWarnList) {
          deprecatedWarnList = {};
        }
        deprecatedWarnList[component] = deprecatedWarnList[component] || [];
        if (!deprecatedWarnList[component].includes(message2 || "")) {
          deprecatedWarnList[component].push(message2 || "");
        }
        if (!existWarning) {
          console.warn("[antd] There exists deprecated usage in your code:", deprecatedWarnList);
        }
      } else {
        true ? warning2(valid, component, message2) : void 0;
      }
    }
  };
  typeWarning.deprecated = (valid, oldProp, newProp, message2 = "") => {
    typeWarning(valid, "deprecated", `\`${oldProp}\` is deprecated. Please use \`${newProp}\` instead.${message2 ? ` ${message2}` : ""}`);
  };
  return typeWarning;
} : () => {
  const noopWarning = () => {
  };
  noopWarning.deprecated = noop;
  return noopWarning;
};
var warning_default2 = warning2;

// node_modules/antd/es/affix/index.js
var import_react12 = __toESM(require_react());

// node_modules/@rc-component/resize-observer/es/index.js
var React8 = __toESM(require_react());

// node_modules/@rc-component/util/es/Dom/findDOMNode.js
function isDOM(node2) {
  return node2 instanceof HTMLElement || node2 instanceof SVGElement;
}
function getDOM(node2) {
  if (node2 && typeof node2 === "object" && isDOM(node2.nativeElement)) {
    return node2.nativeElement;
  }
  if (isDOM(node2)) {
    return node2;
  }
  return null;
}

// node_modules/@rc-component/resize-observer/es/SingleObserver/index.js
var React7 = __toESM(require_react());

// node_modules/@rc-component/resize-observer/es/Collection.js
var React6 = __toESM(require_react());
var CollectionContext = React6.createContext(null);
function Collection({
  children,
  onBatchResize
}) {
  const resizeIdRef = React6.useRef(0);
  const resizeInfosRef = React6.useRef([]);
  const onCollectionResize = React6.useContext(CollectionContext);
  const onResize2 = React6.useCallback((size, element, data) => {
    resizeIdRef.current += 1;
    const currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data
    });
    Promise.resolve().then(() => {
      if (currentId === resizeIdRef.current) {
        onBatchResize == null ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize == null ? void 0 : onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return React6.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}

// node_modules/@rc-component/resize-observer/es/utils/observerUtil.js
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach((entity) => {
    var _a;
    const {
      target
    } = entity;
    (_a = elementListeners.get(target)) == null ? void 0 : _a.forEach((listener) => listener(target));
  });
}
var observer;
function ensureResizeObserver() {
  if (!observer) {
    observer = new ResizeObserver(onResize);
  }
  return observer;
}
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    ensureResizeObserver().observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      ensureResizeObserver().unobserve(element);
      elementListeners.delete(element);
    }
  }
}

// node_modules/@rc-component/resize-observer/es/SingleObserver/index.js
function SingleObserver(props, ref) {
  const {
    children,
    disabled
  } = props;
  const elementRef = React7.useRef(null);
  const onCollectionResize = React7.useContext(CollectionContext);
  const isRenderProps = typeof children === "function";
  const mergedChildren = isRenderProps ? children(elementRef) : children;
  const sizeRef = React7.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  const canRef = !isRenderProps && React7.isValidElement(mergedChildren) && supportRef(mergedChildren);
  const originRef = canRef ? getNodeRef(mergedChildren) : null;
  const mergedRef = useComposeRef(originRef, elementRef);
  const getDomElement = () => {
    return getDOM(elementRef.current);
  };
  React7.useImperativeHandle(ref, () => getDomElement());
  const propsRef = React7.useRef(props);
  propsRef.current = props;
  const onInternalResize = React7.useCallback((target) => {
    const {
      onResize: onResize2,
      data
    } = propsRef.current;
    const {
      width,
      height
    } = target.getBoundingClientRect();
    const {
      offsetWidth,
      offsetHeight
    } = target;
    const fixedWidth = Math.floor(width);
    const fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      const size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      const sizeInfo = {
        ...size,
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      };
      onCollectionResize == null ? void 0 : onCollectionResize(sizeInfo, target, data);
      if (onResize2) {
        Promise.resolve().then(() => {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  React7.useEffect(() => {
    const currentElement = getDomElement();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return () => unobserve(currentElement, onInternalResize);
  }, [elementRef.current, disabled]);
  return canRef ? React7.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren;
}
var RefSingleObserver = React7.forwardRef(SingleObserver);
if (true) {
  RefSingleObserver.displayName = "SingleObserver";
}
var SingleObserver_default = RefSingleObserver;

// node_modules/@rc-component/resize-observer/es/index.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver2(props, ref) {
  const {
    children
  } = props;
  const childNodes = typeof children === "function" ? [children] : toArray(children);
  if (true) {
    if (childNodes.length > 1) {
      warning(false, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.");
    } else if (childNodes.length === 0) {
      warning(false, "`children` of ResizeObserver is empty. Nothing is in observe.");
    }
  }
  return childNodes.map((child, index2) => {
    const key = (child == null ? void 0 : child.key) || `${INTERNAL_PREFIX_KEY}-${index2}`;
    return React8.createElement(SingleObserver_default, _extends({}, props, {
      key,
      ref: index2 === 0 ? ref : void 0
    }), child);
  });
}
var RefResizeObserver = React8.forwardRef(ResizeObserver2);
if (true) {
  RefResizeObserver.displayName = "ResizeObserver";
}
RefResizeObserver.Collection = Collection;
var es_default = RefResizeObserver;

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e3 = 0, n2 = Array(a); e3 < a; e3++)
    n2[e3] = r2[e3];
  return n2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2))
    return _arrayLikeToArray(r2);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"])
    return Array.from(r2);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2)
      return _arrayLikeToArray(r2, a);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}

// node_modules/@rc-component/util/es/raf.js
var raf = (callback) => +setTimeout(callback, 16);
var caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = (callback) => window.requestAnimationFrame(callback);
  caf = (handle) => window.cancelAnimationFrame(handle);
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf = (callback, times = 1) => {
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(id);
  return caf(realId);
};
if (true) {
  wrapperRaf.ids = () => rafIds;
}
var raf_default = wrapperRaf;

// node_modules/antd/es/_util/throttleByAnimationFrame.js
function throttleByAnimationFrame(fn) {
  let requestId = null;
  const later = (args) => () => {
    requestId = null;
    fn.apply(void 0, _toConsumableArray(args));
  };
  const throttled = (...args) => {
    if (requestId === null) {
      requestId = raf_default(later(args));
    }
  };
  throttled.cancel = () => {
    raf_default.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
var throttleByAnimationFrame_default = throttleByAnimationFrame;

// node_modules/antd/es/config-provider/context.js
var React9 = __toESM(require_react());
var defaultPrefixCls = "ant";
var defaultIconPrefixCls = "anticon";
var Variants = ["outlined", "borderless", "filled", "underlined"];
var defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
  if (customizePrefixCls) {
    return customizePrefixCls;
  }
  return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
};
var ConfigContext = React9.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
});
var {
  Consumer: ConfigConsumer
} = ConfigContext;
var EMPTY_OBJECT = {};
function useComponentConfig(propName) {
  const context = React9.useContext(ConfigContext);
  const {
    getPrefixCls,
    direction,
    getPopupContainer,
    renderEmpty
  } = context;
  const propValue = context[propName];
  return {
    classNames: EMPTY_OBJECT,
    styles: EMPTY_OBJECT,
    ...propValue,
    getPrefixCls,
    direction,
    getPopupContainer,
    renderEmpty
  };
}

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

// node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var import_react5 = __toESM(require_react());

// node_modules/@rc-component/util/es/isEqual.js
function isEqual(obj1, obj2, shallow = false) {
  const refSet = /* @__PURE__ */ new Set();
  function deepEqual(a, b, level = 1) {
    const circular = refSet.has(a);
    warning_default(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    const newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      const keys2 = Object.keys(a);
      if (keys2.length !== Object.keys(b).length) {
        return false;
      }
      return keys2.every((key) => deepEqual(a[key], b[key], newLevel));
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
var isEqual_default = isEqual;

// node_modules/@ant-design/cssinjs/es/StyleContext.js
var React10 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/Cache.js
var SPLIT = "%";
function pathKey(keys2) {
  return keys2.join(SPLIT);
}
var updateId = 0;
var Entity = class {
  constructor(instanceId) {
    __publicField(this, "instanceId");
    /** @private Internal cache map. Do not access this directly */
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    /** @private Record update times for each key */
    __publicField(this, "updateTimes", /* @__PURE__ */ new Map());
    __publicField(this, "extracted", /* @__PURE__ */ new Set());
    this.instanceId = instanceId;
  }
  get(keys2) {
    return this.opGet(pathKey(keys2));
  }
  /** A fast get cache with `get` concat. */
  opGet(keyPathStr) {
    return this.cache.get(keyPathStr) || null;
  }
  update(keys2, valueFn) {
    return this.opUpdate(pathKey(keys2), valueFn);
  }
  /** A fast get cache with `get` concat. */
  opUpdate(keyPathStr, valueFn) {
    const prevValue = this.cache.get(keyPathStr);
    const nextValue = valueFn(prevValue);
    if (nextValue === null) {
      this.cache.delete(keyPathStr);
      this.updateTimes.delete(keyPathStr);
    } else {
      this.cache.set(keyPathStr, nextValue);
      this.updateTimes.set(keyPathStr, updateId);
      updateId += 1;
    }
  }
};
var Cache_default = Entity;

// node_modules/@ant-design/cssinjs/es/StyleContext.js
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var ATTR_CACHE_PATH = "data-cache-path";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
  const cssinjsInstanceId = Math.random().toString(12).slice(2);
  if (typeof document !== "undefined" && document.head && document.body) {
    const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
    const {
      firstChild
    } = document.head;
    Array.from(styles).forEach((style2) => {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
      if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
        document.head.insertBefore(style2, firstChild);
      }
    });
    const styleHash = {};
    Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style2) => {
      var _a;
      const hash2 = style2.getAttribute(ATTR_MARK);
      if (styleHash[hash2]) {
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          (_a = style2.parentNode) == null ? void 0 : _a.removeChild(style2);
        }
      } else {
        styleHash[hash2] = true;
      }
    });
  }
  return new Cache_default(cssinjsInstanceId);
}
var StyleContext = React10.createContext({
  hashPriority: "low",
  cache: createCache(),
  defaultCache: true,
  autoPrefix: false
});
var StyleContext_default = StyleContext;

// node_modules/@ant-design/cssinjs/es/theme/calc/CSSCalculator.js
var CALC_UNIT = "CALC_UNIT";
var regexp = new RegExp(CALC_UNIT, "g");

// node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (let i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) {
      return false;
    }
  }
  return true;
}
var _ThemeCache = class _ThemeCache {
  constructor() {
    __publicField(this, "cache");
    __publicField(this, "keys");
    __publicField(this, "cacheCallTimes");
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(derivativeOption, updateCallTimes = false) {
    let cache = {
      map: this.cache
    };
    derivativeOption.forEach((derivative4) => {
      var _a;
      if (!cache) {
        cache = void 0;
      } else {
        cache = (_a = cache == null ? void 0 : cache.map) == null ? void 0 : _a.get(derivative4);
      }
    });
    if ((cache == null ? void 0 : cache.value) && updateCallTimes) {
      cache.value[1] = this.cacheCallTimes++;
    }
    return cache == null ? void 0 : cache.value;
  }
  get(derivativeOption) {
    var _a;
    return (_a = this.internalGet(derivativeOption, true)) == null ? void 0 : _a[0];
  }
  has(derivativeOption) {
    return !!this.internalGet(derivativeOption);
  }
  set(derivativeOption, value) {
    if (!this.has(derivativeOption)) {
      if (this.size() + 1 > _ThemeCache.MAX_CACHE_SIZE + _ThemeCache.MAX_CACHE_OFFSET) {
        const [targetKey] = this.keys.reduce((result, key) => {
          const [, callTimes] = result;
          if (this.internalGet(key)[1] < callTimes) {
            return [key, this.internalGet(key)[1]];
          }
          return result;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(targetKey);
      }
      this.keys.push(derivativeOption);
    }
    let cache = this.cache;
    derivativeOption.forEach((derivative4, index2) => {
      if (index2 === derivativeOption.length - 1) {
        cache.set(derivative4, {
          value: [value, this.cacheCallTimes++]
        });
      } else {
        const cacheValue = cache.get(derivative4);
        if (!cacheValue) {
          cache.set(derivative4, {
            map: /* @__PURE__ */ new Map()
          });
        } else if (!cacheValue.map) {
          cacheValue.map = /* @__PURE__ */ new Map();
        }
        cache = cache.get(derivative4).map;
      }
    });
  }
  deleteByPath(currentCache, derivatives) {
    var _a;
    const cache = currentCache.get(derivatives[0]);
    if (derivatives.length === 1) {
      if (!cache.map) {
        currentCache.delete(derivatives[0]);
      } else {
        currentCache.set(derivatives[0], {
          map: cache.map
        });
      }
      return (_a = cache.value) == null ? void 0 : _a[0];
    }
    const result = this.deleteByPath(cache.map, derivatives.slice(1));
    if ((!cache.map || cache.map.size === 0) && !cache.value) {
      currentCache.delete(derivatives[0]);
    }
    return result;
  }
  delete(derivativeOption) {
    if (this.has(derivativeOption)) {
      this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
      return this.deleteByPath(this.cache, derivativeOption);
    }
    return void 0;
  }
};
__publicField(_ThemeCache, "MAX_CACHE_SIZE", 20);
__publicField(_ThemeCache, "MAX_CACHE_OFFSET", 5);
var ThemeCache = _ThemeCache;

// node_modules/@ant-design/cssinjs/es/theme/Theme.js
var uuid = 0;
var Theme = class {
  constructor(derivatives) {
    __publicField(this, "derivatives");
    __publicField(this, "id");
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid;
    if (derivatives.length === 0) {
      warning(derivatives.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function.");
    }
    uuid += 1;
  }
  getDerivativeToken(token2) {
    return this.derivatives.reduce((result, derivative4) => derivative4(token2, result), void 0);
  }
};

// node_modules/@ant-design/cssinjs/es/theme/createTheme.js
var cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}

// node_modules/@ant-design/cssinjs/es/util/index.js
var resultCache = /* @__PURE__ */ new WeakMap();
var RESULT_VALUE = {};
function memoResult(callback, deps) {
  let current = resultCache;
  for (let i = 0; i < deps.length; i += 1) {
    const dep = deps[i];
    if (!current.has(dep)) {
      current.set(dep, /* @__PURE__ */ new WeakMap());
    }
    current = current.get(dep);
  }
  if (!current.has(RESULT_VALUE)) {
    current.set(RESULT_VALUE, callback());
  }
  return current.get(RESULT_VALUE);
}
var flattenTokenCache = /* @__PURE__ */ new WeakMap();
function flattenToken(token2) {
  let str = flattenTokenCache.get(token2) || "";
  if (!str) {
    Object.keys(token2).forEach((key) => {
      const value = token2[key];
      str += key;
      if (value instanceof Theme) {
        str += value.id;
      } else if (value && typeof value === "object") {
        str += flattenToken(value);
      } else {
        str += value;
      }
    });
    str = hash_browser_esm_default(str);
    flattenTokenCache.set(token2, str);
  }
  return str;
}
function token2key(token2, salt) {
  return hash_browser_esm_default(`${salt}_${flattenToken(token2)}`);
}
var randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
var isClientSide = canUseDom();
function unit(num) {
  if (typeof num === "number") {
    return `${num}px`;
  }
  return num;
}
function toStyleStr(style2, tokenKey, styleId, customizeAttrs = {}, plain = false) {
  if (plain) {
    return style2;
  }
  const attrs = {
    ...customizeAttrs,
    [ATTR_TOKEN]: tokenKey,
    [ATTR_MARK]: styleId
  };
  const attrStr = Object.keys(attrs).map((attr) => {
    const val = attrs[attr];
    return val ? `${attr}="${val}"` : null;
  }).filter((v) => v).join(" ");
  return `<style ${attrStr}>${style2}</style>`;
}
function where(options) {
  const {
    hashCls,
    hashPriority = "low"
  } = options || {};
  if (!hashCls) {
    return "";
  }
  const hashSelector = `.${hashCls}`;
  return hashPriority === "low" ? `:where(${hashSelector})` : hashSelector;
}

// node_modules/@ant-design/cssinjs/es/util/css-variables.js
var token2CSSVar = (token2, prefix2 = "") => {
  return `--${prefix2 ? `${prefix2}-` : ""}${token2}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
};
var serializeCSSVar = (cssVars, hashId, options) => {
  const {
    hashCls,
    hashPriority = "low"
  } = options || {};
  if (!Object.keys(cssVars).length) {
    return "";
  }
  return `${where({
    hashCls,
    hashPriority
  })}.${hashId}${(options == null ? void 0 : options.scope) ? `.${options.scope}` : ""}{${Object.entries(cssVars).map(([key, value]) => `${key}:${value};`).join("")}}`;
};
var transformToken = (token2, themeKey, config) => {
  const {
    hashCls,
    hashPriority = "low",
    prefix: prefix2,
    unitless: unitless2,
    ignore: ignore2,
    preserve: preserve2
  } = config || {};
  const cssVars = {};
  const result = {};
  Object.entries(token2).forEach(([key, value]) => {
    if (preserve2 == null ? void 0 : preserve2[key]) {
      result[key] = value;
    } else if ((typeof value === "string" || typeof value === "number") && !(ignore2 == null ? void 0 : ignore2[key])) {
      const cssVar = token2CSSVar(key, prefix2);
      cssVars[cssVar] = typeof value === "number" && !(unitless2 == null ? void 0 : unitless2[key]) ? `${value}px` : String(value);
      result[key] = `var(${cssVar})`;
    }
  });
  return [result, serializeCSSVar(cssVars, themeKey, {
    scope: config == null ? void 0 : config.scope,
    hashCls,
    hashPriority
  })];
};

// node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
var React11 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
var webpackHMR = false;
function useDevHMR() {
  return webpackHMR;
}
var useHMR_default = false ? useProdHMR : useDevHMR;
if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
  const win = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : null;
  if (win && typeof win.webpackHotUpdate === "function") {
    const originWebpackHotUpdate = win.webpackHotUpdate;
    win.webpackHotUpdate = (...args) => {
      webpackHMR = true;
      setTimeout(() => {
        webpackHMR = false;
      }, 0);
      return originWebpackHotUpdate(...args);
    };
  }
}

// node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js
var effectMap = /* @__PURE__ */ new Map();
function useGlobalCache(prefix2, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
  const {
    cache: globalCache
  } = React11.useContext(StyleContext_default);
  const fullPath = [prefix2, ...keyPath];
  const fullPathStr = pathKey(fullPath);
  const HMRUpdate = useHMR_default();
  const buildCache = (updater) => {
    globalCache.opUpdate(fullPathStr, (prevCache) => {
      const [times = 0, cache] = prevCache || [void 0, void 0];
      let tmpCache = cache;
      if (cache && HMRUpdate) {
        onCacheRemove == null ? void 0 : onCacheRemove(tmpCache, HMRUpdate);
        tmpCache = null;
      }
      const mergedCache = tmpCache || cacheFn();
      const data = [times, mergedCache];
      return updater ? updater(data) : data;
    });
  };
  React11.useMemo(
    () => {
      buildCache();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [fullPathStr]
    /* eslint-enable */
  );
  let cacheEntity = globalCache.opGet(fullPathStr);
  if (!cacheEntity) {
    buildCache();
    cacheEntity = globalCache.opGet(fullPathStr);
  }
  const cacheContent = cacheEntity[1];
  (0, import_react4.useInsertionEffect)(() => {
    buildCache(([times, cache]) => [times + 1, cache]);
    if (!effectMap.has(fullPathStr)) {
      onCacheEffect == null ? void 0 : onCacheEffect(cacheContent);
      effectMap.set(fullPathStr, true);
      Promise.resolve().then(() => {
        effectMap.delete(fullPathStr);
      });
    }
    return () => {
      globalCache.opUpdate(fullPathStr, (prevCache) => {
        const [times = 0, cache] = prevCache || [];
        const nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove == null ? void 0 : onCacheRemove(cache, false);
          effectMap.delete(fullPathStr);
          return null;
        }
        return [times - 1, cache];
      });
    };
  }, [fullPathStr]);
  return cacheContent;
}

// node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js
var EMPTY_OVERRIDE = {};
var hashPrefix = true ? "css-dev-only-do-not-override" : "css";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
  if (typeof document !== "undefined") {
    const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
    styles.forEach((style2) => {
      var _a;
      if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
        (_a = style2.parentNode) == null ? void 0 : _a.removeChild(style2);
      }
    });
  }
}
var TOKEN_THRESHOLD = -1;
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  const cleanableKeyList = /* @__PURE__ */ new Set();
  tokenKeys.forEach((value, key) => {
    if (value <= 0)
      cleanableKeyList.add(key);
  });
  if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) {
    cleanableKeyList.forEach((key) => {
      removeStyleTags(key, instanceId);
      tokenKeys.delete(key);
    });
  }
}
var getComputedToken = (originToken, overrideToken, theme, format3) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  let mergedDerivativeToken = {
    ...derivativeToken,
    ...overrideToken
  };
  if (format3) {
    mergedDerivativeToken = format3(mergedDerivativeToken);
  }
  return mergedDerivativeToken;
};
var TOKEN_PREFIX = "token";
function useCacheToken(theme, tokens, option) {
  const {
    cache: {
      instanceId
    },
    container,
    hashPriority
  } = (0, import_react5.useContext)(StyleContext_default);
  const {
    salt = "",
    override = EMPTY_OVERRIDE,
    formatToken: formatToken2,
    getComputedToken: compute,
    cssVar
  } = option;
  const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
  const tokenStr = flattenToken(mergedToken);
  const overrideTokenStr = flattenToken(override);
  const cssVarStr = flattenToken(cssVar);
  const cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], () => {
    const mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken2);
    const actualToken = {
      ...mergedDerivativeToken
    };
    const mergedSalt = `${salt}_${cssVar.prefix}`;
    const hashId = hash_browser_esm_default(mergedSalt);
    const hashCls = `${hashPrefix}-${hash_browser_esm_default(mergedSalt)}`;
    actualToken._tokenKey = token2key(actualToken, mergedSalt);
    const [tokenWithCssVar, cssVarsStr] = transformToken(mergedDerivativeToken, cssVar.key, {
      prefix: cssVar.prefix,
      ignore: cssVar.ignore,
      unitless: cssVar.unitless,
      preserve: cssVar.preserve,
      hashPriority,
      hashCls: cssVar.hashed ? hashCls : void 0
    });
    tokenWithCssVar._hashId = hashId;
    recordCleanToken(cssVar.key);
    return [tokenWithCssVar, hashCls, actualToken, cssVarsStr, cssVar.key];
  }, ([, , , , themeKey]) => {
    cleanTokenStyle(themeKey, instanceId);
  }, ([, , , cssVarsStr, themeKey]) => {
    if (!cssVarsStr) {
      return;
    }
    const style2 = updateCSS(cssVarsStr, hash_browser_esm_default(`css-var-${themeKey}`), {
      mark: ATTR_MARK,
      prepend: "queue",
      attachTo: container,
      priority: -999
    });
    style2[CSS_IN_JS_INSTANCE] = instanceId;
    style2.setAttribute(ATTR_TOKEN, themeKey);
  });
  return cachedToken;
}
var extract = (cache, effectStyles, options) => {
  const [, , realToken, styleStr, cssVarKey] = cache;
  const {
    plain
  } = options || {};
  if (!styleStr) {
    return null;
  }
  const styleId = realToken._tokenKey;
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};

// node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
var import_react6 = __toESM(require_react());

// node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var React12 = __toESM(require_react());

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var NAMESPACE = "@namespace";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern6) {
  return (value = pattern6.exec(value)) ? value[0] : value;
}
function replace(value, pattern6, replacement) {
  return value.replace(pattern6, replacement);
}
function indexof(value, search, position3) {
  return value.indexOf(search, position3);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array4) {
  return array4.push(value), value;
}
function combine(array4, callback) {
  return array4.map(callback).join("");
}
function filter(array4, pattern6) {
  return array4.filter(function(value) {
    return !match(value, pattern6);
  });
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type5, props, children, length2, siblings) {
  return { value, root, parent, type: type5, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type5) {
  switch (type5) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type5) {
  return trim(slice(position - 1, delimiter(type5 === 91 ? type5 + 2 : type5 === 40 ? type5 + 1 : type5)));
}
function whitespace(type5) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type5) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type5) {
  while (next())
    switch (character) {
      case type5:
        return position;
      case 34:
      case 39:
        if (type5 !== 34 && type5 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type5 === 41)
          delimiter(type5);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type5, index2) {
  while (next())
    if (type5 + character === 47 + 10)
      break;
    else if (type5 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type5 === 47 ? type5 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type5 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type5;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ")
              characters2 += " ";
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset3, rules, points, type5, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else {
                switch (atrule) {
                  case 99:
                    if (charat(characters2, 3) === 110)
                      break;
                  case 108:
                    if (charat(characters2, 2) === 97)
                      break;
                  default:
                    offset3 = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                if (offset3)
                  parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type5, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                else
                  parse(characters2, reference, reference, reference, [""], children, 0, points, children);
              }
        }
        index2 = offset3 = property = 0, variable = ampersand = 1, type5 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type5 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset3, rules, points, type5, props, children, length2, siblings) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset3 === 0 ? RULESET : type5, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
      return WEBKIT + value + value;
    case 4855:
      return WEBKIT + value.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /space-between/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/))
        return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_, a, b, c, d, e3, f) {
        return MS + a + ":" + b + f + (c ? MS + a + "-span:" + (d ? e3 : +e3 - +b) + f : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case NAMESPACE:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function prefixer(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/@ant-design/cssinjs/es/linters/utils.js
function lintWarning(message2, info) {
  const {
    path: path2,
    parentSelectors
  } = info;
  warning_default(false, `[Ant Design CSS-in-JS] ${path2 ? `Error in ${path2}: ` : ""}${message2}${parentSelectors.length ? ` Selector: ${parentSelectors.join(" | ")}` : ""}`);
}

// node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js
var linter = (key, value, info) => {
  if (key === "content") {
    const contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    const contentValues = ["normal", "none", "initial", "inherit", "unset"];
    if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && !value.startsWith("var(") && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
      lintWarning(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${value}"'\`.`, info);
    }
  }
};
var contentQuotesLinter_default = linter;

// node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js
var linter2 = (key, value, info) => {
  if (key === "animation") {
    if (info.hashId && value !== "none") {
      lintWarning(`You seem to be using hashed animation '${value}', in which case 'animationName' with Keyframe as value is recommended.`, info);
    }
  }
};
var hashedAnimationLinter_default = linter2;

// node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js
var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
var CSS_FILE_STYLE = "_FILE_STYLE__";
var cachePathMap;
var fromCSSFile = true;
function prepare() {
  var _a;
  if (!cachePathMap) {
    cachePathMap = {};
    if (canUseDom()) {
      const div = document.createElement("div");
      div.className = ATTR_CACHE_MAP;
      div.style.position = "fixed";
      div.style.visibility = "hidden";
      div.style.top = "-9999px";
      document.body.appendChild(div);
      let content = getComputedStyle(div).content || "";
      content = content.replace(/^"/, "").replace(/"$/, "");
      content.split(";").forEach((item) => {
        const [path2, hash2] = item.split(":");
        cachePathMap[path2] = hash2;
      });
      const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
      if (inlineMapStyle) {
        fromCSSFile = false;
        (_a = inlineMapStyle.parentNode) == null ? void 0 : _a.removeChild(inlineMapStyle);
      }
      document.body.removeChild(div);
    }
  }
}
function existPath(path2) {
  prepare();
  return !!cachePathMap[path2];
}
function getStyleAndHash(path2) {
  const hash2 = cachePathMap[path2];
  let styleStr = null;
  if (hash2 && canUseDom()) {
    if (fromCSSFile) {
      styleStr = CSS_FILE_STYLE;
    } else {
      const style2 = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path2]}"]`);
      if (style2) {
        styleStr = style2.innerHTML;
      } else {
        delete cachePathMap[path2];
      }
    }
  }
  return [styleStr, hash2];
}

// node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js
var SKIP_CHECK = "_skip_check_";
var MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr, autoPrefix) {
  const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify])) : serialize(compile(styleStr), stringify);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
  return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  const hashClassName = `.${hashId}`;
  const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
  const keys2 = key.split(",").map((k) => {
    var _a;
    const fullPath = k.trim().split(/\s+/);
    let firstPath = fullPath[0] || "";
    const htmlElement = ((_a = firstPath.match(/^\w+/)) == null ? void 0 : _a[0]) || "";
    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
    return [firstPath, ...fullPath.slice(1)].join(" ");
  });
  return keys2.join(",");
}
var parseStyle = (interpolation, config = {}, {
  root,
  injectHash,
  parentSelectors
} = {
  root: true,
  parentSelectors: []
}) => {
  const {
    hashId,
    layer,
    path: path2,
    hashPriority,
    transformers = [],
    linters = []
  } = config;
  let styleStr = "";
  let effectStyle = {};
  function parseKeyframes(keyframes) {
    const animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      const [parsedStr] = parseStyle(keyframes.style, config, {
        root: false,
        parentSelectors
      });
      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
    }
  }
  function flattenList(list, fullList = []) {
    list.forEach((item) => {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach((originStyle) => {
    const style2 = typeof originStyle === "string" && !root ? {} : originStyle;
    if (typeof style2 === "string") {
      styleStr += `${style2}
`;
    } else if (style2._keyframe) {
      parseKeyframes(style2);
    } else {
      const mergedStyle = transformers.reduce((prev2, trans) => {
        var _a;
        return ((_a = trans == null ? void 0 : trans.visit) == null ? void 0 : _a.call(trans, prev2)) || prev2;
      }, style2);
      Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          let subInjectHash = false;
          let mergedKey = key.trim();
          let nextRoot = false;
          if ((root || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else if (mergedKey === "&") {
              mergedKey = injectSelectorHash("", hashId, hashPriority);
            } else {
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          const [parsedStr, childEffectStyle] = parseStyle(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [...parentSelectors, mergedKey]
          });
          effectStyle = {
            ...effectStyle,
            ...childEffectStyle
          };
          styleStr += `${mergedKey}${parsedStr}`;
        } else {
          let appendStyle = function(cssKey, cssValue) {
            if (typeof value !== "object" || !(value == null ? void 0 : value[SKIP_CHECK])) {
              [contentQuotesLinter_default, hashedAnimationLinter_default, ...linters].forEach((linter3) => linter3(cssKey, cssValue, {
                path: path2,
                hashId,
                parentSelectors
              }));
            }
            const styleName = cssKey.replace(/[A-Z]/g, (match3) => `-${match3.toLowerCase()}`);
            let formatValue2 = cssValue;
            if (!unitless_browser_esm_default[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
              formatValue2 = `${formatValue2}px`;
            }
            if (cssKey === "animationName" && (cssValue == null ? void 0 : cssValue._keyframe)) {
              parseKeyframes(cssValue);
              formatValue2 = cssValue.getName(hashId);
            }
            styleStr += `${styleName}:${formatValue2};`;
          };
          const actualValue = (value == null ? void 0 : value.value) ?? value;
          if (typeof value === "object" && (value == null ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {
            actualValue.forEach((item) => {
              appendStyle(key, item);
            });
          } else {
            appendStyle(key, actualValue);
          }
        }
      });
    }
  });
  if (!root) {
    styleStr = `{${styleStr}}`;
  } else if (layer) {
    if (styleStr) {
      styleStr = `@layer ${layer.name} {${styleStr}}`;
    }
    if (layer.dependencies) {
      effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
    }
  }
  return [styleStr, effectStyle];
};
function uniqueHash(path2, styleStr) {
  return hash_browser_esm_default(`${path2.join("%")}${styleStr}`);
}
var STYLE_PREFIX = "style";
function useStyleRegister(info, styleFn) {
  const {
    path: path2,
    hashId,
    layer,
    nonce,
    clientOnly,
    order = 0
  } = info;
  const {
    mock,
    hashPriority,
    container,
    transformers,
    linters,
    cache,
    layer: enableLayer,
    autoPrefix
  } = React12.useContext(StyleContext_default);
  const fullPath = [hashId || ""];
  if (enableLayer) {
    fullPath.push("layer");
  }
  fullPath.push(...path2);
  let isMergedClientSide = isClientSide;
  if (mock !== void 0) {
    isMergedClientSide = mock === "client";
  }
  useGlobalCache(
    STYLE_PREFIX,
    fullPath,
    // Create cache if needed
    () => {
      const cachePath = fullPath.join("|");
      if (existPath(cachePath)) {
        const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
        if (inlineCacheStyleStr) {
          return [inlineCacheStyleStr, styleHash, {}, clientOnly, order];
        }
      }
      const styleObj = styleFn();
      const [parsedStyle, effectStyle] = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer: enableLayer ? layer : void 0,
        path: path2.join("-"),
        transformers,
        linters
      });
      const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);
      const styleId = uniqueHash(fullPath, styleStr);
      return [styleStr, styleId, effectStyle, clientOnly, order];
    },
    // Remove cache if no need
    (cacheValue, fromHMR) => {
      const [, styleId] = cacheValue;
      if (fromHMR && isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK,
          attachTo: container
        });
      }
    },
    // Effect: Inject style here
    (cacheValue) => {
      const [styleStr, styleId, effectStyle, , priority] = cacheValue;
      if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
        const mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: enableLayer ? false : "queue",
          attachTo: container,
          priority
        };
        const nonceStr = typeof nonce === "function" ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = {
            nonce: nonceStr
          };
        }
        const effectLayerKeys = [];
        const effectRestKeys = [];
        Object.keys(effectStyle).forEach((key) => {
          if (key.startsWith("@layer")) {
            effectLayerKeys.push(key);
          } else {
            effectRestKeys.push(key);
          }
        });
        effectLayerKeys.forEach((effectKey) => {
          updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {
            ...mergedCSSConfig,
            prepend: true
          });
        });
        const style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
        style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
        if (true) {
          style2.setAttribute(ATTR_CACHE_PATH, fullPath.join("|"));
        }
        effectRestKeys.forEach((effectKey) => {
          updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);
        });
      }
    }
  );
}
var extract2 = (cache, effectStyles, options) => {
  const [styleStr, styleId, effectStyle, clientOnly, order] = cache;
  const {
    plain,
    autoPrefix
  } = options || {};
  if (clientOnly) {
    return null;
  }
  let keyStyleText = styleStr;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  keyStyleText = toStyleStr(styleStr, void 0, styleId, sharedAttrs, plain);
  if (effectStyle) {
    Object.keys(effectStyle).forEach((effectKey) => {
      if (!effectStyles[effectKey]) {
        effectStyles[effectKey] = true;
        const effectStyleStr = normalizeStyle(effectStyle[effectKey], autoPrefix || false);
        const effectStyleHTML = toStyleStr(effectStyleStr, void 0, `_effect-${effectKey}`, sharedAttrs, plain);
        if (effectKey.startsWith("@layer")) {
          keyStyleText = effectStyleHTML + keyStyleText;
        } else {
          keyStyleText += effectStyleHTML;
        }
      }
    });
  }
  return [order, styleId, keyStyleText];
};

// node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js
var CSS_VAR_PREFIX = "cssVar";
var useCSSVarRegister = (config, fn) => {
  const {
    key,
    prefix: prefix2,
    unitless: unitless2,
    ignore: ignore2,
    token: token2,
    hashId,
    scope = ""
  } = config;
  const {
    cache: {
      instanceId
    },
    container,
    hashPriority
  } = (0, import_react6.useContext)(StyleContext_default);
  const {
    _tokenKey: tokenKey
  } = token2;
  const stylePath = [...config.path, key, scope, tokenKey];
  const cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, () => {
    const originToken = fn();
    const [mergedToken, cssVarsStr] = transformToken(originToken, key, {
      prefix: prefix2,
      unitless: unitless2,
      ignore: ignore2,
      scope,
      hashPriority,
      hashCls: hashId
    });
    const styleId = uniqueHash(stylePath, cssVarsStr);
    return [mergedToken, cssVarsStr, styleId, key];
  }, ([, , styleId]) => {
    if (isClientSide) {
      removeCSS(styleId, {
        mark: ATTR_MARK,
        attachTo: container
      });
    }
  }, ([, cssVarsStr, styleId]) => {
    if (!cssVarsStr) {
      return;
    }
    const style2 = updateCSS(cssVarsStr, styleId, {
      mark: ATTR_MARK,
      prepend: "queue",
      attachTo: container,
      priority: -999
    });
    style2[CSS_IN_JS_INSTANCE] = instanceId;
    style2.setAttribute(ATTR_TOKEN, key);
  });
  return cache;
};
var extract3 = (cache, effectStyles, options) => {
  const [, styleStr, styleId, cssVarKey] = cache;
  const {
    plain
  } = options || {};
  if (!styleStr) {
    return null;
  }
  const order = -999;
  const sharedAttrs = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": `${order}`
  };
  const styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};
var useCSSVarRegister_default = useCSSVarRegister;

// node_modules/@ant-design/cssinjs/es/extractStyle.js
var ExtractStyleFns = {
  [STYLE_PREFIX]: extract2,
  [TOKEN_PREFIX]: extract,
  [CSS_VAR_PREFIX]: extract3
};

// node_modules/@ant-design/cssinjs/es/Keyframes.js
var Keyframe = class {
  constructor(name, style2) {
    __publicField(this, "name");
    __publicField(this, "style");
    __publicField(this, "_keyframe", true);
    this.name = name;
    this.style = style2;
  }
  getName(hashId = "") {
    return hashId ? `${hashId}-${this.name}` : this.name;
  }
};
var Keyframes_default = Keyframe;

// node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js
function noSplit(list) {
  list.notSplit = true;
  return list;
}
var keyMap = {
  // Inset
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  // Margin
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  // Padding
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  // Border
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  // Border width
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  // Border style
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  // Border color
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  // Border radius
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
};

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o3) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof(o3);
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r2) {
  if (Array.isArray(r2))
    return r2;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2["return"] && (u = t2["return"](), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r2, e3) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e3) || _unsupportedIterableToArray(r2, e3) || _nonIterableRest();
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e3, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t2, e3;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}

// node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
var import_react8 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n2) {
  if (!(a instanceof n2))
    throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e3, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o3 = r2[t2];
    o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(e3, toPropertyKey(o3.key), o3);
  }
}
function _createClass(e3, r2, t2) {
  return r2 && _defineProperties(e3.prototype, r2), t2 && _defineProperties(e3, t2), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e3) {
  if (void 0 === e3)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e4) {
    return t3.__proto__ = e4, t3;
  }, _setPrototypeOf(t2, e3);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t2, e3) {
  if ("function" != typeof e3 && null !== e3)
    throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t2, e3);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf(t2);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t2, e3) {
  if (e3 && ("object" == _typeof(e3) || "function" == typeof e3))
    return e3;
  if (void 0 !== e3)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t2);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t2) {
  var r2 = _isNativeReflectConstruct();
  return function() {
    var e3, o3 = _getPrototypeOf(t2);
    if (r2) {
      var s = _getPrototypeOf(this).constructor;
      e3 = Reflect.construct(o3, arguments, s);
    } else
      e3 = o3.apply(this, arguments);
    return _possibleConstructorReturn(this, e3);
  };
}

// node_modules/@ant-design/cssinjs-utils/es/util/calc/calculator.js
var AbstractCalculator = _createClass(function AbstractCalculator2() {
  _classCallCheck(this, AbstractCalculator2);
});
var calculator_default2 = AbstractCalculator;

// node_modules/@ant-design/cssinjs-utils/es/util/calc/CSSCalculator.js
var CALC_UNIT2 = "CALC_UNIT";
var regexp2 = new RegExp(CALC_UNIT2, "g");
function unit2(value) {
  if (typeof value === "number") {
    return "".concat(value).concat(CALC_UNIT2);
  }
  return value;
}
var CSSCalculator2 = function(_AbstractCalculator) {
  _inherits(CSSCalculator3, _AbstractCalculator);
  var _super = _createSuper(CSSCalculator3);
  function CSSCalculator3(num, unitlessCssVar) {
    var _this;
    _classCallCheck(this, CSSCalculator3);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "result", "");
    _defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
    _defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
    var numType = _typeof(num);
    _this.unitlessCssVar = unitlessCssVar;
    if (num instanceof CSSCalculator3) {
      _this.result = "(".concat(num.result, ")");
    } else if (numType === "number") {
      _this.result = unit2(num);
    } else if (numType === "string") {
      _this.result = num;
    }
    return _this;
  }
  _createClass(CSSCalculator3, [{
    key: "add",
    value: function add(num) {
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " + ").concat(num.getResult());
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " + ").concat(unit2(num));
      }
      this.lowPriority = true;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(num) {
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " - ").concat(num.getResult());
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " - ").concat(unit2(num));
      }
      this.lowPriority = true;
      return this;
    }
  }, {
    key: "mul",
    value: function mul(num) {
      if (this.lowPriority) {
        this.result = "(".concat(this.result, ")");
      }
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " * ").concat(num.getResult(true));
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " * ").concat(num);
      }
      this.lowPriority = false;
      return this;
    }
  }, {
    key: "div",
    value: function div(num) {
      if (this.lowPriority) {
        this.result = "(".concat(this.result, ")");
      }
      if (num instanceof CSSCalculator3) {
        this.result = "".concat(this.result, " / ").concat(num.getResult(true));
      } else if (typeof num === "number" || typeof num === "string") {
        this.result = "".concat(this.result, " / ").concat(num);
      }
      this.lowPriority = false;
      return this;
    }
  }, {
    key: "getResult",
    value: function getResult(force) {
      return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function equal(options) {
      var _this2 = this;
      var _ref = options || {}, cssUnit = _ref.unit;
      var mergedUnit = true;
      if (typeof cssUnit === "boolean") {
        mergedUnit = cssUnit;
      } else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
        return _this2.result.includes(cssVar);
      })) {
        mergedUnit = false;
      }
      this.result = this.result.replace(regexp2, mergedUnit ? "px" : "");
      if (typeof this.lowPriority !== "undefined") {
        return "calc(".concat(this.result, ")");
      }
      return this.result;
    }
  }]);
  return CSSCalculator3;
}(calculator_default2);

// node_modules/@ant-design/cssinjs-utils/es/util/calc/NumCalculator.js
var NumCalculator2 = function(_AbstractCalculator) {
  _inherits(NumCalculator3, _AbstractCalculator);
  var _super = _createSuper(NumCalculator3);
  function NumCalculator3(num) {
    var _this;
    _classCallCheck(this, NumCalculator3);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "result", 0);
    if (num instanceof NumCalculator3) {
      _this.result = num.result;
    } else if (typeof num === "number") {
      _this.result = num;
    }
    return _this;
  }
  _createClass(NumCalculator3, [{
    key: "add",
    value: function add(num) {
      if (num instanceof NumCalculator3) {
        this.result += num.result;
      } else if (typeof num === "number") {
        this.result += num;
      }
      return this;
    }
  }, {
    key: "sub",
    value: function sub(num) {
      if (num instanceof NumCalculator3) {
        this.result -= num.result;
      } else if (typeof num === "number") {
        this.result -= num;
      }
      return this;
    }
  }, {
    key: "mul",
    value: function mul(num) {
      if (num instanceof NumCalculator3) {
        this.result *= num.result;
      } else if (typeof num === "number") {
        this.result *= num;
      }
      return this;
    }
  }, {
    key: "div",
    value: function div(num) {
      if (num instanceof NumCalculator3) {
        this.result /= num.result;
      } else if (typeof num === "number") {
        this.result /= num;
      }
      return this;
    }
  }, {
    key: "equal",
    value: function equal() {
      return this.result;
    }
  }]);
  return NumCalculator3;
}(calculator_default2);
var NumCalculator_default = NumCalculator2;

// node_modules/@ant-design/cssinjs-utils/es/util/calc/index.js
var genCalc = function genCalc2(type5, unitlessCssVar) {
  var Calculator = type5 === "css" ? CSSCalculator2 : NumCalculator_default;
  return function(num) {
    return new Calculator(num, unitlessCssVar);
  };
};
var calc_default2 = genCalc;

// node_modules/@ant-design/cssinjs-utils/es/util/getCompVarPrefix.js
var getCompVarPrefix = function getCompVarPrefix2(component, prefix2) {
  return "".concat([prefix2, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
var getCompVarPrefix_default = getCompVarPrefix;

// node_modules/@ant-design/cssinjs-utils/es/util/getComponentToken.js
function getComponentToken(component, token2, defaultToken, options) {
  var customToken = _objectSpread2({}, token2[component]);
  if (options !== null && options !== void 0 && options.deprecatedTokens) {
    var deprecatedTokens = options.deprecatedTokens;
    deprecatedTokens.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
      if (true) {
        warning_default(!(customToken !== null && customToken !== void 0 && customToken[oldTokenKey]), "Component Token `".concat(String(oldTokenKey), "` of ").concat(String(component), " is deprecated. Please use `").concat(String(newTokenKey), "` instead."));
      }
      if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
        var _customToken$newToken;
        (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
      }
    });
  }
  var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
  Object.keys(mergedToken).forEach(function(key) {
    if (mergedToken[key] === token2[key]) {
      delete mergedToken[key];
    }
  });
  return mergedToken;
}
var getComponentToken_default = getComponentToken;

// node_modules/@ant-design/cssinjs-utils/es/util/statistic.js
var enableStatistic = true;
var recording = true;
function merge2() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic) {
    return Object.assign.apply(Object, [{}].concat(objs));
  }
  recording = false;
  var ret = {};
  objs.forEach(function(obj) {
    if (_typeof(obj) !== "object") {
      return;
    }
    var keys2 = Object.keys(obj);
    keys2.forEach(function(key) {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: function get2() {
          return obj[key];
        }
      });
    });
  });
  recording = true;
  return ret;
}
var statistic = {};
function noop2() {
}
var statisticToken = function statisticToken2(token2) {
  var tokenKeys2;
  var proxy = token2;
  var flush = noop2;
  if (enableStatistic && typeof Proxy !== "undefined") {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get: function get2(obj, prop) {
        if (recording) {
          var _tokenKeys;
          (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
        }
        return obj[prop];
      }
    });
    flush = function flush2(componentName, componentToken) {
      var _statistic$componentN;
      statistic[componentName] = {
        global: Array.from(tokenKeys2),
        component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
      };
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
};
var statistic_default = statisticToken;

// node_modules/@ant-design/cssinjs-utils/es/util/getDefaultComponentToken.js
function getDefaultComponentToken(component, token2, getDefaultToken) {
  if (typeof getDefaultToken === "function") {
    var _token$component;
    return getDefaultToken(merge2(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
  }
  return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
}
var getDefaultComponentToken_default = getDefaultComponentToken;

// node_modules/@ant-design/cssinjs-utils/es/util/maxmin.js
function genMaxMin(type5) {
  if (type5 === "js") {
    return {
      max: Math.max,
      min: Math.min
    };
  }
  return {
    max: function max() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return "max(".concat(args.map(function(value) {
        return unit(value);
      }).join(","), ")");
    },
    min: function min() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return "min(".concat(args.map(function(value) {
        return unit(value);
      }).join(","), ")");
    }
  };
}
var maxmin_default = genMaxMin;

// node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js
var import_react7 = __toESM(require_react());
var BEAT_LIMIT = 1e3 * 60 * 10;
var ArrayKeyMap = function() {
  function ArrayKeyMap2() {
    _classCallCheck(this, ArrayKeyMap2);
    _defineProperty(this, "map", /* @__PURE__ */ new Map());
    _defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
    _defineProperty(this, "nextID", 0);
    _defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
    _defineProperty(this, "accessBeat", 0);
  }
  _createClass(ArrayKeyMap2, [{
    key: "set",
    value: function set2(keys2, value) {
      this.clear();
      var compositeKey = this.getCompositeKey(keys2);
      this.map.set(compositeKey, value);
      this.lastAccessBeat.set(compositeKey, Date.now());
    }
  }, {
    key: "get",
    value: function get2(keys2) {
      var compositeKey = this.getCompositeKey(keys2);
      var cache = this.map.get(compositeKey);
      this.lastAccessBeat.set(compositeKey, Date.now());
      this.accessBeat += 1;
      return cache;
    }
  }, {
    key: "getCompositeKey",
    value: function getCompositeKey(keys2) {
      var _this = this;
      var ids = keys2.map(function(key) {
        if (key && _typeof(key) === "object") {
          return "obj_".concat(_this.getObjectID(key));
        }
        return "".concat(_typeof(key), "_").concat(key);
      });
      return ids.join("|");
    }
  }, {
    key: "getObjectID",
    value: function getObjectID(obj) {
      if (this.objectIDMap.has(obj)) {
        return this.objectIDMap.get(obj);
      }
      var id = this.nextID;
      this.objectIDMap.set(obj, id);
      this.nextID += 1;
      return id;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this2 = this;
      if (this.accessBeat > 1e4) {
        var now2 = Date.now();
        this.lastAccessBeat.forEach(function(beat, key) {
          if (now2 - beat > BEAT_LIMIT) {
            _this2.map.delete(key);
            _this2.lastAccessBeat.delete(key);
          }
        });
        this.accessBeat = 0;
      }
    }
  }]);
  return ArrayKeyMap2;
}();
var uniqueMap = new ArrayKeyMap();
function useUniqueMemo(memoFn, deps) {
  return import_react7.default.useMemo(function() {
    var cachedValue = uniqueMap.get(deps);
    if (cachedValue) {
      return cachedValue;
    }
    var newValue = memoFn();
    uniqueMap.set(deps, newValue);
    return newValue;
  }, deps);
}
var useUniqueMemo_default = useUniqueMemo;

// node_modules/@ant-design/cssinjs-utils/es/hooks/useCSP.js
var useDefaultCSP = function useDefaultCSP2() {
  return {};
};
var useCSP_default = useDefaultCSP;

// node_modules/@ant-design/cssinjs-utils/es/util/genStyleUtils.js
function genStyleUtils(config) {
  var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useCSP_default : _config$useCSP, useToken3 = config.useToken, usePrefix = config.usePrefix, getResetStyles2 = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
  function genStyleHooks2(component, styleFn, getDefaultToken, options) {
    var componentName = Array.isArray(component) ? component[0] : component;
    function prefixToken(key) {
      return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
    }
    var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
    var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
    var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
    Object.keys(originUnitless).forEach(function(key) {
      compUnitless[prefixToken(key)] = originUnitless[key];
    });
    var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
      unitless: compUnitless,
      prefixToken
    });
    var useStyle = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions);
    var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      var hashId = useStyle(prefixCls, rootCls);
      var cssVarCls = useCSSVar(rootCls);
      return [hashId, cssVarCls];
    };
  }
  function genCSSVarRegister(component, getDefaultToken, options) {
    var compUnitless = options.unitless, prefixToken = options.prefixToken, ignore2 = options.ignore;
    return function(rootCls) {
      var _useToken = useToken3(), cssVar = _useToken.cssVar, realToken = _useToken.realToken;
      useCSSVarRegister_default({
        path: [component],
        prefix: cssVar.prefix,
        key: cssVar.key,
        unitless: compUnitless,
        ignore: ignore2,
        token: realToken,
        scope: rootCls
      }, function() {
        var defaultToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
        var componentToken = getComponentToken_default(component, realToken, defaultToken, {
          deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
        });
        if (defaultToken) {
          Object.keys(defaultToken).forEach(function(key) {
            componentToken[prefixToken(key)] = componentToken[key];
            delete componentToken[key];
          });
        }
        return componentToken;
      });
      return cssVar === null || cssVar === void 0 ? void 0 : cssVar.key;
    };
  }
  function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
    var _cells = _slicedToArray(cells, 1), component = _cells[0];
    var concatComponent = cells.join("-");
    var mergedLayer = config.layer || {
      name: "antd"
    };
    return function(prefixCls) {
      var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      var _useToken2 = useToken3(), theme = _useToken2.theme, realToken = _useToken2.realToken, hashId = _useToken2.hashId, token2 = _useToken2.token, cssVar = _useToken2.cssVar, zeroRuntime = _useToken2.zeroRuntime;
      var memoizedZeroRuntime = (0, import_react8.useMemo)(function() {
        return zeroRuntime;
      }, []);
      if (memoizedZeroRuntime) {
        return hashId;
      }
      var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
      var csp = useCSP();
      var type5 = "css";
      var calc = useUniqueMemo_default(function() {
        var unitlessCssVar = /* @__PURE__ */ new Set();
        Object.keys(options.unitless || {}).forEach(function(key) {
          unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
          unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)));
        });
        return calc_default2(type5, unitlessCssVar);
      }, [type5, component, cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix]);
      var _genMaxMin = maxmin_default(type5), max = _genMaxMin.max, min = _genMaxMin.min;
      var sharedConfig = {
        theme,
        token: token2,
        hashId,
        nonce: function nonce() {
          return csp.nonce;
        },
        clientOnly: options.clientOnly,
        layer: mergedLayer,
        // antd is always at top of styles
        order: options.order || -999
      };
      if (typeof getResetStyles2 === "function") {
        useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
          clientOnly: false,
          path: ["Shared", rootPrefixCls]
        }), function() {
          return getResetStyles2(token2, {
            prefix: {
              rootPrefixCls,
              iconPrefixCls
            },
            csp
          });
        });
      }
      useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
        path: [concatComponent, prefixCls, iconPrefixCls]
      }), function() {
        if (options.injectStyle === false) {
          return [];
        }
        var _statisticToken = statistic_default(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
        var defaultComponentToken = getDefaultComponentToken_default(component, realToken, getDefaultToken);
        var componentCls = ".".concat(prefixCls);
        var componentToken = getComponentToken_default(component, realToken, defaultComponentToken, {
          deprecatedTokens: options.deprecatedTokens
        });
        if (defaultComponentToken && _typeof(defaultComponentToken) === "object") {
          Object.keys(defaultComponentToken).forEach(function(key) {
            defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix_default(component, cssVar.prefix)), ")");
          });
        }
        var mergedToken = merge2(proxyToken, {
          componentCls,
          prefixCls,
          iconCls: ".".concat(iconPrefixCls),
          antCls: ".".concat(rootPrefixCls),
          calc,
          max,
          min
        }, defaultComponentToken);
        var styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls
        });
        flush(component, componentToken);
        var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
        return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
      });
      return hashId;
    };
  }
  function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var useStyle = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2({
      resetStyle: false,
      // Sub Style should default after root one
      order: -998
    }, options));
    var StyledComponent = function StyledComponent2(_ref) {
      var prefixCls = _ref.prefixCls, _ref$rootCls = _ref.rootCls, rootCls = _ref$rootCls === void 0 ? prefixCls : _ref$rootCls;
      useStyle(prefixCls, rootCls);
      return null;
    };
    if (true) {
      StyledComponent.displayName = "SubStyle_".concat(String(Array.isArray(componentName) ? componentName.join(".") : componentName));
    }
    return StyledComponent;
  }
  return {
    genStyleHooks: genStyleHooks2,
    genSubStyleComponent: genSubStyleComponent2,
    genComponentStyleHook: genComponentStyleHook2
  };
}
var genStyleUtils_default = genStyleUtils;

// node_modules/antd/es/theme/interface/presetColors.js
var PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];

// node_modules/antd/es/theme/themes/shared/genFontSizes.js
function getLineHeight(fontSize) {
  return (fontSize + 8) / fontSize;
}
function getFontSizes(base) {
  const fontSizes = Array.from({
    length: 10
  }).map((_, index2) => {
    const i = index2 - 1;
    const baseSize = base * Math.E ** (i / 5);
    const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base;
  return fontSizes.map((size) => ({
    size,
    lineHeight: getLineHeight(size)
  }));
}

// node_modules/antd/es/theme/useToken.js
var import_react10 = __toESM(require_react());

// node_modules/antd/es/version/version.js
var version_default = "6.1.0";

// node_modules/antd/es/version/index.js
var version_default2 = version_default;

// node_modules/antd/es/theme/context.js
var import_react9 = __toESM(require_react());

// node_modules/antd/es/theme/themes/seed.js
var defaultPresetColors = {
  blue: "#1677FF",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  /**
   * @deprecated Use magenta instead
   */
  pink: "#EB2F96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
var seedToken = {
  // preset color palettes
  ...defaultPresetColors,
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: false,
  // Motion
  motion: true
};
var seed_default = seedToken;

// node_modules/antd/es/theme/themes/shared/genColorMapToken.js
function genColorMapToken(seed, {
  generateColorPalettes: generateColorPalettes3,
  generateNeutralColorPalettes: generateNeutralColorPalettes3
}) {
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed;
  const primaryColors = generateColorPalettes3(colorPrimaryBase);
  const successColors = generateColorPalettes3(colorSuccessBase);
  const warningColors = generateColorPalettes3(colorWarningBase);
  const errorColors = generateColorPalettes3(colorErrorBase);
  const infoColors = generateColorPalettes3(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes3(colorBgBase, colorTextBase);
  const colorLink = seed.colorLink || seed.colorInfo;
  const linkColors = generateColorPalettes3(colorLink);
  const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
  return {
    ...neutralColors,
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBgFilledHover,
    colorErrorBgActive: errorColors[3],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorLinkHover: linkColors[4],
    colorLink: linkColors[6],
    colorLinkActive: linkColors[7],
    colorBgMask: new FastColor("#000").setA(0.45).toRgbString(),
    colorWhite: "#fff"
  };
}

// node_modules/antd/es/theme/themes/shared/genRadius.js
var genRadius = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
var genRadius_default = genRadius;

// node_modules/antd/es/theme/themes/shared/genCommonMapToken.js
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return {
    // motion
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    // line
    lineWidthBold: lineWidth + 1,
    // radius
    ...genRadius_default(borderRadius)
  };
}

// node_modules/antd/es/theme/themes/shared/genControlHeight.js
var genControlHeight = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
var genControlHeight_default = genControlHeight;

// node_modules/antd/es/theme/themes/shared/genFontMapToken.js
var genFontMapToken = (fontSize) => {
  const fontSizePairs = getFontSizes(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  const fontSizeMD = fontSizes[1];
  const fontSizeSM = fontSizes[0];
  const fontSizeLG = fontSizes[2];
  const lineHeight = lineHeights[1];
  const lineHeightSM = lineHeights[0];
  const lineHeightLG = lineHeights[2];
  return {
    fontSizeSM,
    fontSize: fontSizeMD,
    fontSizeLG,
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight,
    lineHeightLG,
    lineHeightSM,
    fontHeight: Math.round(lineHeight * fontSizeMD),
    fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
    fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
var genFontMapToken_default = genFontMapToken;

// node_modules/antd/es/theme/themes/shared/genSizeMapToken.js
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    // 48
    sizeXL: sizeUnit * (sizeStep + 4),
    // 32
    sizeLG: sizeUnit * (sizeStep + 2),
    // 24
    sizeMD: sizeUnit * (sizeStep + 1),
    // 20
    sizeMS: sizeUnit * sizeStep,
    // 16
    size: sizeUnit * sizeStep,
    // 16
    sizeSM: sizeUnit * (sizeStep - 1),
    // 12
    sizeXS: sizeUnit * (sizeStep - 2),
    // 8
    sizeXXS: sizeUnit * (sizeStep - 3)
    // 4
  };
}

// node_modules/antd/es/theme/themes/default/colorAlgorithm.js
var getAlphaColor = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
var getSolidColor = (baseColor, brightness) => {
  const instance = new FastColor(baseColor);
  return instance.darken(brightness).toHexString();
};

// node_modules/antd/es/theme/themes/default/colors.js
var generateColorPalettes = (baseColor) => {
  const colors = generate(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
  };
};
var generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.02),
    colorBgSolid: getAlphaColor(colorTextBase, 1),
    colorBgSolidHover: getAlphaColor(colorTextBase, 0.75),
    colorBgSolidActive: getAlphaColor(colorTextBase, 0.95),
    colorBgLayout: getSolidColor(colorBgBase, 4),
    colorBgContainer: getSolidColor(colorBgBase, 0),
    colorBgElevated: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor(colorTextBase, 0.85),
    colorBgBlur: "transparent",
    colorBorder: getSolidColor(colorBgBase, 15),
    colorBorderDisabled: getSolidColor(colorBgBase, 15),
    colorBorderSecondary: getSolidColor(colorBgBase, 6)
  };
};

// node_modules/antd/es/theme/themes/default/index.js
function derivative(token2) {
  presetPrimaryColors.pink = presetPrimaryColors.magenta;
  presetPalettes.pink = presetPalettes.magenta;
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate(token2[colorKey]);
    return Array.from({
      length: 10
    }, () => 1).reduce((prev2, _, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors[i];
      prev2[`${colorKey}${i + 1}`] = colors[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = {
      ...prev2,
      ...cur
    };
    return prev2;
  }, {});
  return {
    ...token2,
    ...colorPalettes,
    // Colors
    ...genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    }),
    // Font
    ...genFontMapToken_default(token2.fontSize),
    // Size
    ...genSizeMapToken(token2),
    // Height
    ...genControlHeight_default(token2),
    // Others
    ...genCommonMapToken(token2)
  };
}

// node_modules/antd/es/theme/themes/default/theme.js
var defaultTheme = createTheme(derivative);
var theme_default = defaultTheme;

// node_modules/antd/es/theme/context.js
var defaultConfig = {
  token: seed_default,
  override: {
    override: seed_default
  },
  hashed: true
};
var DesignTokenContext = import_react9.default.createContext(defaultConfig);

// node_modules/antd/es/theme/util/getAlphaColor.js
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
function getAlphaColor2(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new FastColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new FastColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g = Math.round((fG - bG * (1 - fA)) / fA);
    const b = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g) && isStableColor(b)) {
      return new FastColor({
        r: r2,
        g,
        b,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new FastColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var getAlphaColor_default = getAlphaColor2;

// node_modules/antd/es/theme/util/alias.js
function formatToken(derivativeToken) {
  const {
    override,
    ...restToken
  } = derivativeToken;
  const overrideTokens = {
    ...override
  };
  Object.keys(seed_default).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = {
    ...restToken,
    ...overrideTokens
  };
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  if (mergedToken.motion === false) {
    const fastDuration = "0s";
    mergedToken.motionDurationFast = fastDuration;
    mergedToken.motionDurationMid = fastDuration;
    mergedToken.motionDurationSlow = fastDuration;
  }
  const aliasToken = {
    ...mergedToken,
    // ============== Background ============== //
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor_default(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor_default(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor_default(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    // Font
    fontSizeIcon: mergedToken.fontSizeSM,
    // Line
    lineWidthFocus: mergedToken.lineWidth * 3,
    // Control
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor_default(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    // Override AliasToken
    ...overrideTokens
  };
  return aliasToken;
}

// node_modules/antd/es/theme/useToken.js
var unitless = {
  lineHeight: true,
  lineHeightSM: true,
  lineHeightLG: true,
  lineHeightHeading1: true,
  lineHeightHeading2: true,
  lineHeightHeading3: true,
  lineHeightHeading4: true,
  lineHeightHeading5: true,
  opacityLoading: true,
  fontWeightStrong: true,
  zIndexPopupBase: true,
  zIndexBase: true,
  opacityImage: true
};
var ignore = {
  motionBase: true,
  motionUnit: true
};
var preserve = {
  screenXS: true,
  screenXSMin: true,
  screenXSMax: true,
  screenSM: true,
  screenSMMin: true,
  screenSMMax: true,
  screenMD: true,
  screenMDMin: true,
  screenMDMax: true,
  screenLG: true,
  screenLGMin: true,
  screenLGMax: true,
  screenXL: true,
  screenXLMin: true,
  screenXLMax: true,
  screenXXL: true,
  screenXXLMin: true
};
var getComputedToken2 = (originToken, overrideToken, theme) => {
  const derivativeToken = theme.getDerivativeToken(originToken);
  const {
    override,
    ...components2
  } = overrideToken;
  let mergedDerivativeToken = {
    ...derivativeToken,
    override
  };
  mergedDerivativeToken = formatToken(mergedDerivativeToken);
  if (components2) {
    Object.entries(components2).forEach(([key, value]) => {
      const {
        theme: componentTheme,
        ...componentTokens
      } = value;
      let mergedComponentToken = componentTokens;
      if (componentTheme) {
        mergedComponentToken = getComputedToken2({
          ...mergedDerivativeToken,
          ...componentTokens
        }, {
          override: componentTokens
        }, componentTheme);
      }
      mergedDerivativeToken[key] = mergedComponentToken;
    });
  }
  return mergedDerivativeToken;
};
function useToken() {
  const {
    token: rootDesignToken,
    hashed,
    theme,
    override,
    cssVar: ctxCssVar,
    zeroRuntime
  } = import_react10.default.useContext(DesignTokenContext);
  const cssVar = {
    prefix: (ctxCssVar == null ? void 0 : ctxCssVar.prefix) || "ant",
    key: (ctxCssVar == null ? void 0 : ctxCssVar.key) || "css-var-root"
  };
  const salt = `${version_default2}-${hashed || ""}`;
  const mergedTheme = theme || theme_default;
  const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seed_default, rootDesignToken], {
    salt,
    override,
    getComputedToken: getComputedToken2,
    cssVar: {
      ...cssVar,
      unitless,
      ignore,
      preserve
    }
  });
  return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar, !!zeroRuntime];
}

// node_modules/antd/es/theme/util/genStyleUtils.js
var import_react11 = __toESM(require_react());

// node_modules/antd/es/style/index.js
var textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
var resetComponent = (token2, needInheritFontFamily = false) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: token2.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
});
var resetIcon = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
});
var clearFix = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
});
var genLinkStyle = (token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
});
var genCommonStyle = (token2, componentPrefixCls, rootCls, resetFont) => {
  const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
  const resetStyle = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let resetFontStyle = {};
  if (resetFont !== false) {
    resetFontStyle = {
      fontFamily: token2.fontFamily,
      fontSize: token2.fontSize
    };
  }
  return {
    [rootPrefixSelector]: {
      ...resetFontStyle,
      ...resetStyle,
      [prefixSelector]: resetStyle
    }
  };
};
var genFocusOutline = (token2, offset3) => ({
  outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
  outlineOffset: offset3 ?? 1,
  transition: "outline-offset 0s, outline 0s"
});
var genFocusStyle = (token2, offset3) => ({
  "&:focus-visible": genFocusOutline(token2, offset3)
});
var genIconStyle = (iconPrefixCls) => ({
  [`.${iconPrefixCls}`]: {
    ...resetIcon(),
    [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
      display: "block"
    }
  }
});
var operationUnit = (token2) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: token2.colorLink,
  textDecoration: token2.linkDecoration,
  outline: "none",
  cursor: "pointer",
  transition: `all ${token2.motionDurationSlow}`,
  border: 0,
  padding: 0,
  background: "none",
  userSelect: "none",
  ...genFocusStyle(token2),
  "&:hover": {
    color: token2.colorLinkHover,
    textDecoration: token2.linkHoverDecoration
  },
  "&:focus": {
    color: token2.colorLinkHover,
    textDecoration: token2.linkFocusDecoration
  },
  "&:active": {
    color: token2.colorLinkActive,
    textDecoration: token2.linkHoverDecoration
  }
});

// node_modules/antd/es/theme/util/genStyleUtils.js
var {
  genStyleHooks,
  genComponentStyleHook,
  genSubStyleComponent
} = genStyleUtils_default({
  usePrefix: () => {
    const {
      getPrefixCls,
      iconPrefixCls
    } = (0, import_react11.useContext)(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    return {
      rootPrefixCls,
      iconPrefixCls
    };
  },
  useToken: () => {
    const [theme, realToken, hashId, token2, cssVar, zeroRuntime] = useToken();
    return {
      theme,
      realToken,
      hashId,
      token: token2,
      cssVar,
      zeroRuntime
    };
  },
  useCSP: () => {
    const {
      csp
    } = (0, import_react11.useContext)(ConfigContext);
    return csp ?? {};
  },
  getResetStyles: (token2, config) => {
    const linkStyle = genLinkStyle(token2);
    return [linkStyle, {
      "&": linkStyle
    }, genIconStyle((config == null ? void 0 : config.prefix.iconPrefixCls) ?? defaultIconPrefixCls)];
  },
  getCommonStyle: genCommonStyle,
  getCompUnitless: () => unitless
});
var genCssVar = (antCls, componentAbbr) => {
  const cssPrefix = `--${antCls.replace(".", "")}-${componentAbbr}-`;
  return (name, withVar = false) => {
    const raw = `${cssPrefix}${name}`;
    return withVar ? `var(${raw})` : raw;
  };
};

// node_modules/antd/es/theme/util/genPresetColor.js
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}1`];
    const lightBorderColor = token2[`${colorKey}3`];
    const darkColor = token2[`${colorKey}6`];
    const textColor = token2[`${colorKey}7`];
    return {
      ...prev2,
      ...genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      })
    };
  }, {});
}

// node_modules/antd/es/theme/util/useResetIconStyle.js
var useResetIconStyle = (iconPrefixCls, csp) => {
  const [theme, token2] = useToken();
  return useStyleRegister({
    theme,
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls],
    nonce: () => csp == null ? void 0 : csp.nonce,
    layer: {
      name: "antd"
    }
  }, () => genIconStyle(iconPrefixCls));
};
var useResetIconStyle_default = useResetIconStyle;

// node_modules/antd/es/affix/style/index.js
var genSharedAffixStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      position: "fixed",
      zIndex: token2.zIndexPopup
    }
  };
};
var prepareComponentToken = (token2) => ({
  zIndexPopup: token2.zIndexBase + 10
});
var style_default = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken);

// node_modules/antd/es/affix/utils.js
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderRect, targetRect, offsetTop) {
  if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) {
    return offsetTop + targetRect.top;
  }
  return void 0;
}
function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) {
    const targetBottomOffset = window.innerHeight - targetRect.bottom;
    return offsetBottom + targetBottomOffset;
  }
  return void 0;
}

// node_modules/antd/es/affix/index.js
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
var AFFIX_STATUS_NONE = 0;
var AFFIX_STATUS_PREPARE = 1;
var Affix = import_react12.default.forwardRef((props, ref) => {
  const {
    style: style2,
    offsetTop,
    offsetBottom,
    prefixCls,
    className,
    rootClassName,
    children,
    target,
    onChange,
    onTestUpdatePosition,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("affix");
  const {
    getTargetContainer
  } = import_react12.default.useContext(ConfigContext);
  const affixPrefixCls = getPrefixCls("affix", prefixCls);
  const [lastAffix, setLastAffix] = import_react12.default.useState(false);
  const [affixStyle, setAffixStyle] = import_react12.default.useState();
  const [placeholderStyle, setPlaceholderStyle] = import_react12.default.useState();
  const status = import_react12.default.useRef(AFFIX_STATUS_NONE);
  const prevTarget = import_react12.default.useRef(null);
  const prevListener = import_react12.default.useRef(null);
  const placeholderNodeRef = import_react12.default.useRef(null);
  const fixedNodeRef = import_react12.default.useRef(null);
  const timer = import_react12.default.useRef(null);
  const targetFunc = target ?? getTargetContainer ?? getDefaultTarget;
  const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
  const measure = () => {
    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {
      return;
    }
    const targetNode = targetFunc();
    if (targetNode) {
      const newState = {
        status: AFFIX_STATUS_NONE
      };
      const placeholderRect = getTargetRect(placeholderNodeRef.current);
      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
        return;
      }
      const targetRect = getTargetRect(targetNode);
      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
      if (fixedTop !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      } else if (fixedBottom !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width: placeholderRect.width,
          height: placeholderRect.height
        };
        newState.placeholderStyle = {
          width: placeholderRect.width,
          height: placeholderRect.height
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (lastAffix !== newState.lastAffix) {
        onChange == null ? void 0 : onChange(newState.lastAffix);
      }
      status.current = newState.status;
      setAffixStyle(newState.affixStyle);
      setPlaceholderStyle(newState.placeholderStyle);
      setLastAffix(newState.lastAffix);
    }
  };
  const prepareMeasure = () => {
    status.current = AFFIX_STATUS_PREPARE;
    measure();
    if (false) {
      onTestUpdatePosition == null ? void 0 : onTestUpdatePosition();
    }
  };
  const updatePosition = throttleByAnimationFrame_default(() => {
    prepareMeasure();
  });
  const lazyUpdatePosition = throttleByAnimationFrame_default(() => {
    if (targetFunc && affixStyle) {
      const targetNode = targetFunc();
      if (targetNode && placeholderNodeRef.current) {
        const targetRect = getTargetRect(targetNode);
        const placeholderRect = getTargetRect(placeholderNodeRef.current);
        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
        if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
          return;
        }
      }
    }
    prepareMeasure();
  });
  const addListeners = () => {
    const listenerTarget = targetFunc == null ? void 0 : targetFunc();
    if (!listenerTarget) {
      return;
    }
    TRIGGER_EVENTS.forEach((eventName) => {
      var _a;
      if (prevListener.current) {
        (_a = prevTarget.current) == null ? void 0 : _a.removeEventListener(eventName, prevListener.current);
      }
      listenerTarget == null ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);
    });
    prevTarget.current = listenerTarget;
    prevListener.current = lazyUpdatePosition;
  };
  const removeListeners = () => {
    const newTarget = targetFunc == null ? void 0 : targetFunc();
    TRIGGER_EVENTS.forEach((eventName) => {
      var _a;
      newTarget == null ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);
      if (prevListener.current) {
        (_a = prevTarget.current) == null ? void 0 : _a.removeEventListener(eventName, prevListener.current);
      }
    });
    updatePosition.cancel();
    lazyUpdatePosition.cancel();
  };
  import_react12.default.useImperativeHandle(ref, () => ({
    updatePosition
  }));
  import_react12.default.useEffect(() => {
    timer.current = setTimeout(addListeners);
    return () => {
      if (timer.current) {
        clearTimeout(timer.current);
        timer.current = null;
      }
      removeListeners();
    };
  }, []);
  import_react12.default.useEffect(() => {
    addListeners();
    return () => removeListeners();
  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);
  import_react12.default.useEffect(() => {
    updatePosition();
  }, [target, offsetTop, offsetBottom]);
  const [hashId, cssVarCls] = style_default(affixPrefixCls);
  const rootCls = clsx(rootClassName, hashId, affixPrefixCls, cssVarCls);
  const mergedCls = clsx({
    [rootCls]: affixStyle
  });
  return import_react12.default.createElement(es_default, {
    onResize: updatePosition
  }, import_react12.default.createElement("div", {
    style: {
      ...contextStyle,
      ...style2
    },
    className: clsx(className, contextClassName),
    ref: placeholderNodeRef,
    ...restProps
  }, affixStyle && import_react12.default.createElement("div", {
    style: placeholderStyle,
    "aria-hidden": "true"
  }), import_react12.default.createElement("div", {
    className: mergedCls,
    ref: fixedNodeRef,
    style: affixStyle
  }, import_react12.default.createElement(es_default, {
    onResize: updatePosition
  }, children))));
});
if (true) {
  Affix.displayName = "Affix";
}
var affix_default = Affix;

// node_modules/antd/es/alert/Alert.js
var React35 = __toESM(require_react());

// node_modules/@rc-component/motion/es/CSSMotion.js
var React23 = __toESM(require_react());
var import_react16 = __toESM(require_react());

// node_modules/@rc-component/motion/es/context.js
var React17 = __toESM(require_react());
var Context = React17.createContext({});
function MotionProvider({
  children,
  ...props
}) {
  return React17.createElement(Context.Provider, {
    value: props
  }, children);
}

// node_modules/@rc-component/util/es/hooks/useSyncState.js
var React18 = __toESM(require_react());
function useSyncState(defaultValue) {
  const [, forceUpdate] = React18.useReducer((x) => x + 1, 0);
  const currentValueRef = React18.useRef(defaultValue);
  const getValue2 = useEvent_default(() => {
    return currentValueRef.current;
  });
  const setValue = useEvent_default((updater) => {
    currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
    forceUpdate();
  });
  return [getValue2, setValue];
}

// node_modules/@rc-component/motion/es/hooks/useStatus.js
var React22 = __toESM(require_react());
var import_react15 = __toESM(require_react());

// node_modules/@rc-component/motion/es/interface.js
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
var STEP_PREPARED = "prepared";

// node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js
var React19 = __toESM(require_react());
var import_react13 = __toESM(require_react());

// node_modules/@rc-component/motion/es/util/motion.js
function makePrefixMap(styleProp, eventName) {
  const prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
  prefixes[`Moz${styleProp}`] = `moz${eventName}`;
  prefixes[`ms${styleProp}`] = `MS${eventName}`;
  prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  const prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) {
  ({
    style
  } = document.createElement("div"));
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  const prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    const stylePropList = Object.keys(prefixMap);
    const len = stylePropList.length;
    for (let i = 0; i < len; i += 1) {
      const styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(transitionName, transitionType) {
  if (!transitionName)
    return null;
  if (typeof transitionName === "object") {
    const type5 = transitionType.replace(/-\w/g, (match3) => match3[1].toUpperCase());
    return transitionName[type5];
  }
  return `${transitionName}-${transitionType}`;
}

// node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js
var useDomMotionEvents_default = (onInternalMotionEnd) => {
  const cacheElementRef = (0, import_react13.useRef)();
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  React19.useEffect(() => () => {
    removeMotionEvents(cacheElementRef.current);
    cacheElementRef.current = null;
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};

// node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js
var import_react14 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDom() ? import_react14.useLayoutEffect : import_react14.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect;

// node_modules/@rc-component/motion/es/hooks/useStepQueue.js
var React21 = __toESM(require_react());

// node_modules/@rc-component/motion/es/hooks/useNextFrame.js
var React20 = __toESM(require_react());
var useNextFrame_default = () => {
  const nextFrameRef = React20.useRef(null);
  function cancelNextFrame() {
    raf_default.cancel(nextFrameRef.current);
  }
  function nextFrame(callback, delay = 2) {
    cancelNextFrame();
    const nextFrameId = raf_default(() => {
      if (delay <= 1) {
        callback({
          isCanceled: () => nextFrameId !== nextFrameRef.current
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  React20.useEffect(() => () => {
    cancelNextFrame();
  }, []);
  return [nextFrame, cancelNextFrame];
};

// node_modules/@rc-component/motion/es/hooks/useStepQueue.js
var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue_default = (status, prepareOnly, callback) => {
  const [step, setStep] = useSafeState(STEP_NONE);
  const [nextFrame, cancelNextFrame] = useNextFrame_default();
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
  useIsomorphicLayoutEffect_default(() => {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      const index2 = STEP_QUEUE.indexOf(step);
      const nextStep = STEP_QUEUE[index2 + 1];
      const result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else if (nextStep) {
        nextFrame((info) => {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  React21.useEffect(() => () => {
    cancelNextFrame();
  }, []);
  return [startQueue, step];
};

// node_modules/@rc-component/motion/es/hooks/useStatus.js
function useStatus(supportMotion, visible, getElement, {
  motionEnter = true,
  motionAppear = true,
  motionLeave = true,
  motionDeadline,
  motionLeaveImmediately,
  onAppearPrepare,
  onEnterPrepare,
  onLeavePrepare,
  onAppearStart,
  onEnterStart,
  onLeaveStart,
  onAppearActive,
  onEnterActive,
  onLeaveActive,
  onAppearEnd,
  onEnterEnd,
  onLeaveEnd,
  onVisibleChanged
}) {
  const [asyncVisible, setAsyncVisible] = useSafeState();
  const [getStatus2, setStatus] = useSyncState(STATUS_NONE);
  const [style2, setStyle] = useSafeState(null);
  const currentStatus = getStatus2();
  const mountedRef = (0, import_react15.useRef)(false);
  const deadlineRef = (0, import_react15.useRef)(null);
  function getDomElement() {
    return getElement();
  }
  const activeRef = (0, import_react15.useRef)(false);
  function updateMotionEndStatus() {
    setStatus(STATUS_NONE);
    setStyle(null, true);
  }
  const onInternalMotionEnd = useEvent_default((event) => {
    const status = getStatus2();
    if (status === STATUS_NONE) {
      return;
    }
    const element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    const currentActive = activeRef.current;
    let canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd == null ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd == null ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd == null ? void 0 : onLeaveEnd(element, event);
    }
    if (currentActive && canEnd !== false) {
      updateMotionEndStatus();
    }
  });
  const [patchMotionEvents] = useDomMotionEvents_default(onInternalMotionEnd);
  const getEventHandlers = (targetStatus) => {
    switch (targetStatus) {
      case STATUS_APPEAR:
        return {
          [STEP_PREPARE]: onAppearPrepare,
          [STEP_START]: onAppearStart,
          [STEP_ACTIVE]: onAppearActive
        };
      case STATUS_ENTER:
        return {
          [STEP_PREPARE]: onEnterPrepare,
          [STEP_START]: onEnterStart,
          [STEP_ACTIVE]: onEnterActive
        };
      case STATUS_LEAVE:
        return {
          [STEP_PREPARE]: onLeavePrepare,
          [STEP_START]: onLeaveStart,
          [STEP_ACTIVE]: onLeaveActive
        };
      default:
        return {};
    }
  };
  const eventHandlers = React22.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);
  const [startStep, step] = useStepQueue_default(currentStatus, !supportMotion, (newStep) => {
    var _a;
    if (newStep === STEP_PREPARE) {
      const onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      setStyle(((_a = eventHandlers[step]) == null ? void 0 : _a.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(() => {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    if (step === STEP_PREPARED) {
      updateMotionEndStatus();
    }
    return DoStep;
  });
  const active = isActive(step);
  activeRef.current = active;
  const visibleRef = (0, import_react15.useRef)(null);
  useIsomorphicLayoutEffect_default(() => {
    if (mountedRef.current && visibleRef.current === visible) {
      return;
    }
    setAsyncVisible(visible);
    const isMounted = mountedRef.current;
    mountedRef.current = true;
    let nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    const nextEventHandlers = getEventHandlers(nextStatus);
    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
      setStatus(nextStatus);
      startStep();
    } else {
      setStatus(STATUS_NONE);
    }
    visibleRef.current = visible;
  }, [visible]);
  (0, import_react15.useEffect)(() => {
    if (
      // Cancel appear
      currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter
      currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave
      currentStatus === STATUS_LEAVE && !motionLeave
    ) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  (0, import_react15.useEffect)(() => () => {
    mountedRef.current = false;
    clearTimeout(deadlineRef.current);
  }, []);
  const firstMountChangeRef = React22.useRef(false);
  (0, import_react15.useEffect)(() => {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged == null ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, currentStatus]);
  let mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = {
      transition: "none",
      ...mergedStyle
    };
  }
  return [getStatus2, step, mergedStyle, asyncVisible ?? visible];
}

// node_modules/@rc-component/motion/es/CSSMotion.js
function genCSSMotion(config) {
  let transitionSupport = config;
  if (typeof config === "object") {
    ({
      transitionSupport
    } = config);
  }
  function isSupportTransition(props, contextMotion) {
    return !!(props.motionName && transitionSupport && contextMotion !== false);
  }
  const CSSMotion = React23.forwardRef((props, ref) => {
    const {
      // Default config
      visible = true,
      removeOnLeave = true,
      forceRender,
      children,
      motionName,
      leavedClassName,
      eventProps
    } = props;
    const {
      motion: contextMotion
    } = React23.useContext(Context);
    const supportMotion = isSupportTransition(props, contextMotion);
    const nodeRef = (0, import_react16.useRef)();
    function getDomElement() {
      return getDOM(nodeRef.current);
    }
    const [getStatus2, statusStep, statusStyle, mergedVisible] = useStatus(supportMotion, visible, getDomElement, props);
    const status = getStatus2();
    const renderedRef = React23.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    const refObj = React23.useMemo(() => {
      const obj = {};
      Object.defineProperties(obj, {
        nativeElement: {
          enumerable: true,
          get: getDomElement
        },
        inMotion: {
          enumerable: true,
          get: () => () => getStatus2() !== STATUS_NONE
        },
        enableMotion: {
          enumerable: true,
          get: () => () => supportMotion
        }
      });
      return obj;
    }, []);
    React23.useImperativeHandle(ref, () => refObj, []);
    let motionChildren;
    const mergedProps = {
      ...eventProps,
      visible
    };
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE) {
      if (mergedVisible) {
        motionChildren = children({
          ...mergedProps
        }, nodeRef);
      } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
        motionChildren = children({
          ...mergedProps,
          className: leavedClassName
        }, nodeRef);
      } else if (forceRender || !removeOnLeave && !leavedClassName) {
        motionChildren = children({
          ...mergedProps,
          style: {
            display: "none"
          }
        }, nodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      let statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      const motionCls = getTransitionName(motionName, `${status}-${statusSuffix}`);
      motionChildren = children({
        ...mergedProps,
        className: clsx(getTransitionName(motionName, status), {
          [motionCls]: motionCls && statusSuffix,
          [motionName]: typeof motionName === "string"
        }),
        style: statusStyle
      }, nodeRef);
    }
    if (React23.isValidElement(motionChildren) && supportRef(motionChildren)) {
      const originNodeRef = getNodeRef(motionChildren);
      if (!originNodeRef) {
        motionChildren = React23.cloneElement(motionChildren, {
          ref: nodeRef
        });
      }
    }
    return motionChildren;
  });
  CSSMotion.displayName = "CSSMotion";
  return CSSMotion;
}
var CSSMotion_default = genCSSMotion(supportTransition);

// node_modules/@rc-component/motion/es/CSSMotionList.js
var React24 = __toESM(require_react());

// node_modules/@rc-component/motion/es/util/diff.js
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  let keyObj;
  if (key && typeof key === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = {
      key
    };
  }
  return {
    ...keyObj,
    key: String(keyObj.key)
  };
}
function parseKeys(keys2 = []) {
  return keys2.map(wrapKeyToObject);
}
function diffKeys(prevKeys = [], currentKeys = []) {
  let list = [];
  let currentIndex = 0;
  const currentLen = currentKeys.length;
  const prevKeyObjects = parseKeys(prevKeys);
  const currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach((keyObj) => {
    let hit = false;
    for (let i = currentIndex; i < currentLen; i += 1) {
      const currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map((obj) => ({
            ...obj,
            status: STATUS_ADD
          })));
          currentIndex = i;
        }
        list.push({
          ...currentKeyObj,
          status: STATUS_KEEP
        });
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push({
        ...keyObj,
        status: STATUS_REMOVE
      });
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map((obj) => ({
      ...obj,
      status: STATUS_ADD
    })));
  }
  const keys2 = {};
  list.forEach(({
    key
  }) => {
    keys2[key] = (keys2[key] || 0) + 1;
  });
  const duplicatedKeys = Object.keys(keys2).filter((key) => keys2[key] > 1);
  duplicatedKeys.forEach((matchKey) => {
    list = list.filter(({
      key,
      status
    }) => key !== matchKey || status !== STATUS_REMOVE);
    list.forEach((node2) => {
      if (node2.key === matchKey) {
        node2.status = STATUS_KEEP;
      }
    });
  });
  return list;
}

// node_modules/@rc-component/motion/es/CSSMotionList.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport, CSSMotion = CSSMotion_default) {
  class CSSMotionList extends React24.Component {
    constructor() {
      super(...arguments);
      __publicField(this, "state", {
        keyEntities: []
      });
      // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
      __publicField(this, "removeKey", (removeKey) => {
        this.setState((prevState) => {
          const nextKeyEntities = prevState.keyEntities.map((entity) => {
            if (entity.key !== removeKey)
              return entity;
            return {
              ...entity,
              status: STATUS_REMOVED
            };
          });
          return {
            keyEntities: nextKeyEntities
          };
        }, () => {
          const {
            keyEntities
          } = this.state;
          const restKeysCount = keyEntities.filter(({
            status
          }) => status !== STATUS_REMOVED).length;
          if (restKeysCount === 0 && this.props.onAllRemoved) {
            this.props.onAllRemoved();
          }
        });
      });
    }
    static getDerivedStateFromProps({
      keys: keys2
    }, {
      keyEntities
    }) {
      const parsedKeyObjects = parseKeys(keys2);
      const mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
      return {
        keyEntities: mixedKeyEntities.filter((entity) => {
          const prevEntity = keyEntities.find(({
            key
          }) => entity.key === key);
          if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
            return false;
          }
          return true;
        })
      };
    }
    render() {
      const {
        keyEntities
      } = this.state;
      const {
        component,
        children,
        onVisibleChanged,
        onAllRemoved,
        ...restProps
      } = this.props;
      const Component8 = component || React24.Fragment;
      const motionProps = {};
      MOTION_PROP_NAMES.forEach((prop) => {
        motionProps[prop] = restProps[prop];
        delete restProps[prop];
      });
      delete restProps.keys;
      return React24.createElement(Component8, restProps, keyEntities.map(({
        status,
        ...eventProps
      }, index2) => {
        const visible = status === STATUS_ADD || status === STATUS_KEEP;
        return React24.createElement(CSSMotion, _extends2({}, motionProps, {
          key: eventProps.key,
          visible,
          eventProps,
          onVisibleChanged: (changedVisible) => {
            onVisibleChanged == null ? void 0 : onVisibleChanged(changedVisible, {
              key: eventProps.key
            });
            if (!changedVisible) {
              this.removeKey(eventProps.key);
            }
          }
        }), (props, ref) => children({
          ...props,
          index: index2
        }, ref));
      }));
    }
  }
  __publicField(CSSMotionList, "defaultProps", {
    component: "div"
  });
  return CSSMotionList;
}
var CSSMotionList_default = genCSSMotionList(supportTransition);

// node_modules/@rc-component/motion/es/index.js
var es_default2 = CSSMotion_default;

// node_modules/@rc-component/util/es/pickAttrs.js
var attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
var eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
var propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match2(key, prefix2) {
  return key.indexOf(prefix2) === 0;
}
function pickAttrs(props, ariaOnly = false) {
  let mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = {
      ...ariaOnly
    };
  }
  const attrs = {};
  Object.keys(props).forEach((key) => {
    if (
      // Aria
      mergedConfig.aria && (key === "role" || match2(key, ariaPrefix)) || // Data
      mergedConfig.data && match2(key, dataPrefix) || // Attr
      mergedConfig.attr && propList.includes(key)
    ) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}

// node_modules/antd/es/_util/hooks/useClosable.js
var import_react18 = __toESM(require_react());

// node_modules/antd/es/locale/index.js
var React26 = __toESM(require_react());

// node_modules/@rc-component/pagination/es/locale/en_US.js
var locale = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var en_US_default = locale;

// node_modules/@rc-component/picker/es/locale/common.js
var commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: true
};

// node_modules/@rc-component/picker/es/locale/en_US.js
function _typeof2(o3) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof2(o3);
}
function ownKeys2(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
      _defineProperty2(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == _typeof2(i) ? i : String(i);
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof2(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof2(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var locale2 = _objectSpread(_objectSpread({}, commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
var en_US_default2 = locale2;

// node_modules/antd/es/time-picker/locale/en_US.js
var locale3 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var en_US_default3 = locale3;

// node_modules/antd/es/date-picker/locale/en_US.js
var locale4 = {
  lang: {
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"],
    ...en_US_default2
  },
  timePickerLocale: {
    ...en_US_default3
  }
};
var en_US_default4 = locale4;

// node_modules/antd/es/calendar/locale/en_US.js
var en_US_default5 = en_US_default4;

// node_modules/antd/es/locale/en_US.js
var typeTemplate = "${label} is not a valid ${type}";
var localeValues = {
  locale: "en",
  Pagination: en_US_default,
  DatePicker: en_US_default4,
  TimePicker: en_US_default3,
  Calendar: en_US_default5,
  global: {
    placeholder: "Please select",
    close: "Close",
    sortable: "sortable"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckAll: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
var en_US_default6 = localeValues;

// node_modules/antd/es/modal/locale.js
var runtimeLocale = {
  ...en_US_default6.Modal
};
var localeList = [];
var generateLocale = () => localeList.reduce((merged, locale6) => ({
  ...merged,
  ...locale6
}), en_US_default6.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    const cloneLocale = {
      ...newLocale
    };
    localeList.push(cloneLocale);
    runtimeLocale = generateLocale();
    return () => {
      localeList = localeList.filter((locale6) => locale6 !== cloneLocale);
      runtimeLocale = generateLocale();
    };
  }
  runtimeLocale = {
    ...en_US_default6.Modal
  };
}
function getConfirmLocale() {
  return runtimeLocale;
}

// node_modules/antd/es/locale/context.js
var import_react17 = __toESM(require_react());
var LocaleContext = (0, import_react17.createContext)(void 0);
var context_default = LocaleContext;

// node_modules/antd/es/locale/useLocale.js
var React25 = __toESM(require_react());
var useLocale = (componentName, defaultLocale) => {
  const fullLocale = React25.useContext(context_default);
  const getLocale = React25.useMemo(() => {
    const locale6 = defaultLocale || en_US_default6[componentName];
    const localeFromContext = (fullLocale == null ? void 0 : fullLocale[componentName]) ?? {};
    return {
      ...typeof locale6 === "function" ? locale6() : locale6,
      ...localeFromContext || {}
    };
  }, [componentName, defaultLocale, fullLocale]);
  const getLocaleCode = React25.useMemo(() => {
    const localeCode = fullLocale == null ? void 0 : fullLocale.locale;
    if ((fullLocale == null ? void 0 : fullLocale.exist) && !localeCode) {
      return en_US_default6.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
};
var useLocale_default = useLocale;

// node_modules/antd/es/locale/index.js
var ANT_MARK = "internalMark";
var LocaleProvider = (props) => {
  const {
    locale: locale6 = {},
    children,
    _ANT_MARK__
  } = props;
  if (true) {
    const warning5 = devUseWarning("LocaleProvider");
    true ? warning5(_ANT_MARK__ === ANT_MARK, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale") : void 0;
  }
  React26.useEffect(() => {
    const clearLocale = changeConfirmLocale(locale6 == null ? void 0 : locale6.Modal);
    return clearLocale;
  }, [locale6]);
  const getMemoizedContextValue = React26.useMemo(() => ({
    ...locale6,
    exist: true
  }), [locale6]);
  return React26.createElement(context_default.Provider, {
    value: getMemoizedContextValue
  }, children);
};
if (true) {
  LocaleProvider.displayName = "LocaleProvider";
}
var locale_default = LocaleProvider;

// node_modules/antd/es/_util/extendsObject.js
function mergeProps(...items) {
  const ret = {};
  items.forEach((item) => {
    if (item) {
      Object.keys(item).forEach((key) => {
        if (item[key] !== void 0) {
          ret[key] = item[key];
        }
      });
    }
  });
  return ret;
}
var extendsObject_default = mergeProps;

// node_modules/antd/es/_util/isNonNullable.js
var isNonNullable = (val) => {
  return val !== void 0 && val !== null;
};
var isNonNullable_default = isNonNullable;

// node_modules/antd/es/_util/hooks/useClosable.js
var pickClosable = (context) => {
  if (!context) {
    return void 0;
  }
  const {
    closable,
    closeIcon
  } = context;
  return {
    closable,
    closeIcon
  };
};
var EmptyFallbackCloseCollection = {};
var computeClosableConfig = (closable, closeIcon) => {
  if (!closable && (closable === false || closeIcon === false || closeIcon === null)) {
    return false;
  }
  if (closable === void 0 && closeIcon === void 0) {
    return null;
  }
  let closableConfig = {
    closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
  };
  if (closable && typeof closable === "object") {
    closableConfig = {
      ...closableConfig,
      ...closable
    };
  }
  return closableConfig;
};
var mergeClosableConfigs = (propConfig, contextConfig, fallbackConfig) => {
  if (propConfig === false) {
    return false;
  }
  if (propConfig) {
    return extendsObject_default(fallbackConfig, contextConfig, propConfig);
  }
  if (contextConfig === false) {
    return false;
  }
  if (contextConfig) {
    return extendsObject_default(fallbackConfig, contextConfig);
  }
  return fallbackConfig.closable ? fallbackConfig : false;
};
var computeCloseIcon = (mergedConfig, fallbackCloseCollection, closeLabel) => {
  const {
    closeIconRender
  } = fallbackCloseCollection;
  const {
    closeIcon,
    ...restConfig
  } = mergedConfig;
  let finalCloseIcon = closeIcon;
  const ariaOrDataProps = pickAttrs(restConfig, true);
  if (isNonNullable_default(finalCloseIcon)) {
    if (closeIconRender) {
      finalCloseIcon = closeIconRender(finalCloseIcon);
    }
    finalCloseIcon = import_react18.default.isValidElement(finalCloseIcon) ? import_react18.default.cloneElement(finalCloseIcon, {
      "aria-label": closeLabel,
      ...finalCloseIcon.props,
      ...ariaOrDataProps
    }) : import_react18.default.createElement("span", {
      "aria-label": closeLabel,
      ...ariaOrDataProps
    }, finalCloseIcon);
  }
  return [finalCloseIcon, ariaOrDataProps];
};
var computeClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection, closeLabel = "Close") => {
  const propConfig = computeClosableConfig(propCloseCollection == null ? void 0 : propCloseCollection.closable, propCloseCollection == null ? void 0 : propCloseCollection.closeIcon);
  const contextConfig = computeClosableConfig(contextCloseCollection == null ? void 0 : contextCloseCollection.closable, contextCloseCollection == null ? void 0 : contextCloseCollection.closeIcon);
  const mergedFallback = {
    closeIcon: import_react18.default.createElement(CloseOutlined_default, null),
    ...fallbackCloseCollection
  };
  const mergedConfig = mergeClosableConfigs(propConfig, contextConfig, mergedFallback);
  const closeBtnIsDisabled = typeof mergedConfig !== "boolean" ? !!(mergedConfig == null ? void 0 : mergedConfig.disabled) : false;
  if (mergedConfig === false) {
    return [false, null, closeBtnIsDisabled, {}];
  }
  const [closeIcon, ariaProps] = computeCloseIcon(mergedConfig, mergedFallback, closeLabel);
  return [true, closeIcon, closeBtnIsDisabled, ariaProps];
};
var useClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) => {
  const [contextLocale] = useLocale_default("global", en_US_default6.global);
  return import_react18.default.useMemo(() => {
    return computeClosable(propCloseCollection, contextCloseCollection, {
      closeIcon: import_react18.default.createElement(CloseOutlined_default, null),
      ...fallbackCloseCollection
    }, contextLocale.close);
  }, [propCloseCollection, contextCloseCollection, fallbackCloseCollection, contextLocale.close]);
};

// node_modules/antd/es/_util/hooks/useForceUpdate.js
var import_react19 = __toESM(require_react());
var useForceUpdate = () => {
  return import_react19.default.useReducer((ori) => ori + 1, 0);
};

// node_modules/antd/es/_util/hooks/useMergedMask.js
var import_react20 = __toESM(require_react());
var normalizeMaskConfig = (mask) => {
  if (mask && typeof mask === "object") {
    return mask;
  }
  if (typeof mask === "boolean") {
    return {
      enabled: mask,
      blur: mask
    };
  }
  return {};
};
var useMergedMask = (mask, contextMask, prefixCls) => {
  return (0, import_react20.useMemo)(() => {
    const maskConfig = normalizeMaskConfig(mask);
    const contextMaskConfig = normalizeMaskConfig(contextMask);
    const mergedConfig = {
      ...contextMaskConfig,
      ...maskConfig
    };
    const className = mergedConfig.blur !== false ? `${prefixCls}-mask-blur` : void 0;
    return [mergedConfig.enabled !== false, {
      mask: className
    }];
  }, [mask, contextMask, prefixCls]);
};

// node_modules/antd/es/_util/hooks/useMergeSemantic.js
var React29 = __toESM(require_react());
var mergeClassNames = (schema, ...classNames) => {
  const mergedSchema = schema || {};
  return classNames.filter(Boolean).reduce((acc, cur) => {
    Object.keys(cur || {}).forEach((key) => {
      const keySchema = mergedSchema[key];
      const curVal = cur[key];
      if (keySchema && typeof keySchema === "object") {
        if (curVal && typeof curVal === "object") {
          acc[key] = mergeClassNames(keySchema, acc[key], curVal);
        } else {
          const {
            _default: defaultField
          } = keySchema;
          if (defaultField) {
            acc[key] = acc[key] || {};
            acc[key][defaultField] = clsx(acc[key][defaultField], curVal);
          }
        }
      } else {
        acc[key] = clsx(acc[key], curVal);
      }
    });
    return acc;
  }, {});
};
var useSemanticClassNames = (schema, ...classNames) => {
  return React29.useMemo(() => mergeClassNames.apply(void 0, [schema].concat(classNames)), [schema].concat(classNames));
};
var mergeStyles = (...styles) => {
  return styles.filter(Boolean).reduce((acc, cur = {}) => {
    Object.keys(cur).forEach((key) => {
      acc[key] = {
        ...acc[key],
        ...cur[key]
      };
    });
    return acc;
  }, {});
};
var useSemanticStyles = (...styles) => {
  return React29.useMemo(() => mergeStyles.apply(void 0, styles), [].concat(styles));
};
var fillObjectBySchema = (obj, schema) => {
  const newObj = {
    ...obj
  };
  Object.keys(schema).forEach((key) => {
    if (key !== "_default") {
      const nestSchema = schema[key];
      const nextValue = newObj[key] || {};
      newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
    }
  });
  return newObj;
};
var resolveStyleOrClass = (value, info) => {
  return typeof value === "function" ? value(info) : value;
};
var useMergeSemantic = (classNamesList, stylesList, info, schema) => {
  const resolvedClassNamesList = classNamesList.map((classNames) => classNames ? resolveStyleOrClass(classNames, info) : void 0);
  const resolvedStylesList = stylesList.map((styles) => styles ? resolveStyleOrClass(styles, info) : void 0);
  const mergedClassNames = useSemanticClassNames.apply(void 0, [schema].concat(_toConsumableArray(resolvedClassNamesList)));
  const mergedStyles = useSemanticStyles.apply(void 0, _toConsumableArray(resolvedStylesList));
  return React29.useMemo(() => {
    if (!schema) {
      return [mergedClassNames, mergedStyles];
    }
    return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
  }, [mergedClassNames, mergedStyles, schema]);
};

// node_modules/antd/es/_util/hooks/useMultipleSelect.js
var import_react21 = __toESM(require_react());
var useMultipleSelect = (getKey5) => {
  const [prevSelectedIndex, setPrevSelectedIndex] = (0, import_react21.useState)(null);
  const multipleSelect = (0, import_react21.useCallback)((currentSelectedIndex, data, selectedKeys) => {
    const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex;
    const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
    const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
    const rangeKeys = data.slice(startIndex, endIndex + 1).map(getKey5);
    const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
    const changedKeys = [];
    rangeKeys.forEach((item) => {
      if (shouldSelected) {
        if (!selectedKeys.has(item)) {
          changedKeys.push(item);
        }
        selectedKeys.add(item);
      } else {
        selectedKeys.delete(item);
        changedKeys.push(item);
      }
    });
    setPrevSelectedIndex(shouldSelected ? endIndex : null);
    return changedKeys;
  }, [prevSelectedIndex]);
  return [multipleSelect, setPrevSelectedIndex];
};

// node_modules/antd/es/_util/hooks/useOrientation.js
var import_react22 = __toESM(require_react());
var isValidOrientation = (orientation) => {
  return orientation === "horizontal" || orientation === "vertical";
};
var useOrientation = (orientation, vertical, legacyDirection) => {
  return (0, import_react22.useMemo)(() => {
    const validOrientation = isValidOrientation(orientation);
    let mergedOrientation;
    if (validOrientation) {
      mergedOrientation = orientation;
    } else if (typeof vertical === "boolean") {
      mergedOrientation = vertical ? "vertical" : "horizontal";
    } else {
      const validLegacyDirection = isValidOrientation(legacyDirection);
      mergedOrientation = validLegacyDirection ? legacyDirection : "horizontal";
    }
    return [mergedOrientation, mergedOrientation === "vertical"];
  }, [legacyDirection, orientation, vertical]);
};

// node_modules/antd/es/_util/hooks/usePatchElement.js
var React30 = __toESM(require_react());
var usePatchElement = () => {
  const [elements, setElements] = React30.useState([]);
  const patchElement = React30.useCallback((element) => {
    setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
    return () => {
      setElements((originElements) => originElements.filter((ele) => ele !== element));
    };
  }, []);
  return [elements, patchElement];
};

// node_modules/antd/es/_util/hooks/useProxyImperativeHandle.js
var import_react23 = __toESM(require_react());
var fillProxy = (element, handler) => {
  element._antProxy = element._antProxy || {};
  Object.keys(handler).forEach((key) => {
    if (!(key in element._antProxy)) {
      const ori = element[key];
      element._antProxy[key] = ori;
      element[key] = handler[key];
    }
  });
  return element;
};
var useProxyImperativeHandle = (ref, init) => {
  return (0, import_react23.useImperativeHandle)(ref, () => {
    const refObj = init();
    const {
      nativeElement
    } = refObj;
    if (typeof Proxy !== "undefined") {
      return new Proxy(nativeElement, {
        get(obj, prop) {
          if (refObj[prop]) {
            return refObj[prop];
          }
          return Reflect.get(obj, prop);
        }
      });
    }
    return fillProxy(nativeElement, refObj);
  });
};

// node_modules/antd/es/_util/hooks/useSyncState.js
var React31 = __toESM(require_react());
var useSyncState2 = (initialValue) => {
  const ref = React31.useRef(initialValue);
  const [, forceUpdate] = useForceUpdate();
  return [() => ref.current, (newValue) => {
    ref.current = newValue;
    forceUpdate();
  }];
};

// node_modules/antd/es/_util/hooks/useZIndex.js
var import_react25 = __toESM(require_react());

// node_modules/antd/es/_util/zindexContext.js
var import_react24 = __toESM(require_react());
var zIndexContext = import_react24.default.createContext(void 0);
if (true) {
  zIndexContext.displayName = "zIndexContext";
}
var zindexContext_default = zIndexContext;

// node_modules/antd/es/_util/hooks/useZIndex.js
var CONTAINER_OFFSET = 100;
var CONTAINER_OFFSET_MAX_COUNT = 10;
var CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
var CONTAINER_MAX_OFFSET_WITH_CHILDREN = CONTAINER_MAX_OFFSET + CONTAINER_OFFSET;
var containerBaseZIndexOffset = {
  Modal: CONTAINER_OFFSET,
  Drawer: CONTAINER_OFFSET,
  Popover: CONTAINER_OFFSET,
  Popconfirm: CONTAINER_OFFSET,
  Tooltip: CONTAINER_OFFSET,
  Tour: CONTAINER_OFFSET,
  FloatButton: CONTAINER_OFFSET
};
var consumerBaseZIndexOffset = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
var isContainerType = (type5) => {
  return type5 in containerBaseZIndexOffset;
};
var useZIndex = (componentType, customZIndex) => {
  const [, token2] = useToken();
  const parentZIndex = import_react25.default.useContext(zindexContext_default);
  const isContainer = isContainerType(componentType);
  let result;
  if (customZIndex !== void 0) {
    result = [customZIndex, customZIndex];
  } else {
    let zIndex = parentZIndex ?? 0;
    if (isContainer) {
      zIndex += // Use preset token zIndex by default but not stack when has parent container
      (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
      containerBaseZIndexOffset[componentType];
    } else {
      zIndex += consumerBaseZIndexOffset[componentType];
    }
    result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
  }
  if (true) {
    const warning5 = devUseWarning(componentType);
    const maxZIndex = token2.zIndexPopupBase + CONTAINER_MAX_OFFSET_WITH_CHILDREN;
    const currentZIndex = result[0] || 0;
    true ? warning5(customZIndex !== void 0 || currentZIndex <= maxZIndex, "usage", "`zIndex` is over design token `zIndexPopupBase` too much. It may cause unexpected override.") : void 0;
  }
  return result;
};

// node_modules/antd/es/_util/reactNode.js
var import_react26 = __toESM(require_react());
function isFragment2(child) {
  return child && import_react26.default.isValidElement(child) && child.type === import_react26.default.Fragment;
}
var replaceElement = (element, replacement, props) => {
  if (!import_react26.default.isValidElement(element)) {
    return replacement;
  }
  return import_react26.default.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
};
function cloneElement3(element, props) {
  return replaceElement(element, element, props);
}

// node_modules/antd/es/alert/style/index.js
var genAlertTypeStyle = (bgColor, borderColor, iconColor, token2, alertCls) => ({
  background: bgColor,
  border: `${unit(token2.lineWidth)} ${token2.lineType} ${borderColor}`,
  [`${alertCls}-icon`]: {
    color: iconColor
  }
});
var genBaseStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow: duration,
    marginXS,
    marginSM,
    fontSize,
    fontSizeLG,
    lineHeight,
    borderRadiusLG: borderRadius,
    motionEaseInOutCirc,
    withDescriptionIconSize,
    colorText,
    colorTextHeading,
    withDescriptionPadding,
    defaultPadding
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: defaultPadding,
      wordWrap: "break-word",
      borderRadius,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-section`]: {
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginXS,
        lineHeight: 0
      },
      "&-description": {
        display: "none",
        fontSize,
        lineHeight
      },
      "&-title": {
        color: colorTextHeading
      },
      [`&${componentCls}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
      },
      [`&${componentCls}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    },
    [`${componentCls}-with-description`]: {
      alignItems: "flex-start",
      padding: withDescriptionPadding,
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginSM,
        fontSize: withDescriptionIconSize,
        lineHeight: 0
      },
      [`${componentCls}-title`]: {
        display: "block",
        marginBottom: marginXS,
        color: colorTextHeading,
        fontSize: fontSizeLG
      },
      [`${componentCls}-description`]: {
        display: "block",
        color: colorText
      }
    },
    [`${componentCls}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
};
var genTypeStyle = (token2) => {
  const {
    componentCls,
    colorSuccess,
    colorSuccessBorder,
    colorSuccessBg,
    colorWarning,
    colorWarningBorder,
    colorWarningBg,
    colorError,
    colorErrorBorder,
    colorErrorBg,
    colorInfo,
    colorInfoBorder,
    colorInfoBg
  } = token2;
  return {
    [componentCls]: {
      "&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token2, componentCls),
      "&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token2, componentCls),
      "&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token2, componentCls),
      "&-error": {
        ...genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token2, componentCls),
        [`${componentCls}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      }
    }
  };
};
var genActionStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    motionDurationMid,
    marginXS,
    fontSizeIcon,
    colorIcon,
    colorIconHover
  } = token2;
  return {
    [componentCls]: {
      "&-actions": {
        marginInlineStart: marginXS
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: marginXS,
        padding: 0,
        overflow: "hidden",
        fontSize: fontSizeIcon,
        lineHeight: unit(fontSizeIcon),
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${iconCls}-close`]: {
          color: colorIcon,
          transition: `color ${motionDurationMid}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
      "&-close-text": {
        color: colorIcon,
        transition: `color ${motionDurationMid}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
};
var prepareComponentToken2 = (token2) => {
  const paddingHorizontal = 12;
  return {
    withDescriptionIconSize: token2.fontSizeHeading3,
    defaultPadding: `${token2.paddingContentVerticalSM}px ${paddingHorizontal}px`,
    withDescriptionPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
  };
};
var style_default2 = genStyleHooks("Alert", (token2) => [genBaseStyle(token2), genTypeStyle(token2), genActionStyle(token2)], prepareComponentToken2);

// node_modules/antd/es/alert/Alert.js
var iconMapFilled = {
  success: CheckCircleFilled_default,
  info: InfoCircleFilled_default,
  error: CloseCircleFilled_default,
  warning: ExclamationCircleFilled_default
};
var IconNode = (props) => {
  const {
    icon,
    prefixCls,
    type: type5,
    className,
    style: style2
  } = props;
  const iconType = iconMapFilled[type5] || null;
  if (icon) {
    return replaceElement(icon, React35.createElement("span", {
      className: `${prefixCls}-icon`
    }, icon), () => ({
      className: clsx(icon.props.className, className),
      style: style2
    }));
  }
  return React35.createElement(iconType, {
    className,
    style: style2
  });
};
var CloseIconNode = (props) => {
  const {
    isClosable,
    prefixCls,
    closeIcon,
    handleClose,
    ariaProps,
    className,
    style: style2
  } = props;
  const mergedCloseIcon = closeIcon === true || closeIcon === void 0 ? React35.createElement(CloseOutlined_default, null) : closeIcon;
  return isClosable ? React35.createElement("button", {
    type: "button",
    onClick: handleClose,
    className: clsx(`${prefixCls}-close-icon`, className),
    tabIndex: 0,
    style: style2,
    ...ariaProps
  }, mergedCloseIcon) : null;
};
var Alert = React35.forwardRef((props, ref) => {
  const {
    description,
    prefixCls: customizePrefixCls,
    message: message2,
    title,
    banner,
    className,
    rootClassName,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onClick,
    afterClose,
    showIcon,
    closable,
    closeText,
    closeIcon,
    action,
    id,
    styles,
    classNames,
    ...otherProps
  } = props;
  const mergedTitle = title ?? message2;
  const [closed, setClosed] = React35.useState(false);
  if (true) {
    const warning5 = devUseWarning("Alert");
    [["closeText", "closable.closeIcon"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const internalRef = React35.useRef(null);
  React35.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const {
    getPrefixCls,
    direction,
    closable: contextClosable,
    closeIcon: contextCloseIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("alert");
  const prefixCls = getPrefixCls("alert", customizePrefixCls);
  const [hashId, cssVarCls] = style_default2(prefixCls);
  const {
    onClose: closableOnClose,
    afterClose: closableAfterClose
  } = closable && typeof closable === "object" ? closable : {};
  const handleClose = (e3) => {
    var _a;
    setClosed(true);
    (_a = closableOnClose ?? props.onClose) == null ? void 0 : _a(e3);
  };
  const type5 = React35.useMemo(() => {
    if (props.type !== void 0) {
      return props.type;
    }
    return banner ? "warning" : "info";
  }, [props.type, banner]);
  const isClosable = React35.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon) {
      return true;
    }
    if (closeText) {
      return true;
    }
    if (typeof closable === "boolean") {
      return closable;
    }
    if (closeIcon !== false && isNonNullable_default(closeIcon)) {
      return true;
    }
    return !!contextClosable;
  }, [closeText, closeIcon, closable, contextClosable]);
  const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
  const mergedProps = {
    ...props,
    prefixCls,
    type: type5,
    showIcon: isShowIcon,
    closable: isClosable
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const alertCls = clsx(prefixCls, `${prefixCls}-${type5}`, {
    [`${prefixCls}-with-description`]: !!description,
    [`${prefixCls}-no-icon`]: !isShowIcon,
    [`${prefixCls}-banner`]: !!banner,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, cssVarCls, hashId);
  const restProps = pickAttrs(otherProps, {
    aria: true,
    data: true
  });
  const mergedCloseIcon = React35.useMemo(() => {
    if (typeof closable === "object" && closable.closeIcon) {
      return closable.closeIcon;
    }
    if (closeText) {
      return closeText;
    }
    if (closeIcon !== void 0) {
      return closeIcon;
    }
    if (typeof contextClosable === "object" && contextClosable.closeIcon) {
      return contextClosable.closeIcon;
    }
    return contextCloseIcon;
  }, [closeIcon, closable, contextClosable, closeText, contextCloseIcon]);
  const mergedAriaProps = React35.useMemo(() => {
    const merged = closable ?? contextClosable;
    if (typeof merged === "object") {
      return pickAttrs(merged, {
        data: true,
        aria: true
      });
    }
    return {};
  }, [closable, contextClosable]);
  return React35.createElement(es_default2, {
    visible: !closed,
    motionName: `${prefixCls}-motion`,
    motionAppear: false,
    motionEnter: false,
    onLeaveStart: (node2) => ({
      maxHeight: node2.offsetHeight
    }),
    onLeaveEnd: closableAfterClose ?? afterClose
  }, ({
    className: motionClassName,
    style: motionStyle
  }, setRef) => React35.createElement("div", {
    id,
    ref: composeRef(internalRef, setRef),
    "data-show": !closed,
    className: clsx(alertCls, motionClassName),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2,
      ...motionStyle
    },
    onMouseEnter,
    onMouseLeave,
    onClick,
    role: "alert",
    ...restProps
  }, isShowIcon ? React35.createElement(IconNode, {
    className: clsx(`${prefixCls}-icon`, mergedClassNames.icon),
    style: mergedStyles.icon,
    description,
    icon: props.icon,
    prefixCls,
    type: type5
  }) : null, React35.createElement("div", {
    className: clsx(`${prefixCls}-section`, mergedClassNames.section),
    style: mergedStyles.section
  }, mergedTitle ? React35.createElement("div", {
    className: clsx(`${prefixCls}-title`, mergedClassNames.title),
    style: mergedStyles.title
  }, mergedTitle) : null, description ? React35.createElement("div", {
    className: clsx(`${prefixCls}-description`, mergedClassNames.description),
    style: mergedStyles.description
  }, description) : null), action ? React35.createElement("div", {
    className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
    style: mergedStyles.actions
  }, action) : null, React35.createElement(CloseIconNode, {
    className: mergedClassNames.close,
    style: mergedStyles.close,
    isClosable,
    prefixCls,
    closeIcon: mergedCloseIcon,
    handleClose,
    ariaProps: mergedAriaProps
  })));
});
if (true) {
  Alert.displayName = "Alert";
}
var Alert_default = Alert;

// node_modules/@babel/runtime/helpers/esm/callSuper.js
function _callSuper(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}

// node_modules/antd/es/alert/ErrorBoundary.js
var React36 = __toESM(require_react());
var ErrorBoundary = function(_React$Component) {
  function ErrorBoundary2() {
    var _this;
    _classCallCheck(this, ErrorBoundary2);
    _this = _callSuper(this, ErrorBoundary2, arguments);
    _this.state = {
      error: void 0,
      info: {
        componentStack: ""
      }
    };
    return _this;
  }
  _inherits(ErrorBoundary2, _React$Component);
  return _createClass(ErrorBoundary2, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error, info) {
      this.setState({
        error,
        info
      });
    }
  }, {
    key: "render",
    value: function render2() {
      const {
        message: message2,
        title,
        description,
        id,
        children
      } = this.props;
      const {
        error,
        info
      } = this.state;
      const mergedTitle = title ?? message2;
      const componentStack = (info == null ? void 0 : info.componentStack) || null;
      const errorMessage = typeof mergedTitle === "undefined" ? (error || "").toString() : mergedTitle;
      const errorDescription = typeof description === "undefined" ? componentStack : description;
      if (error) {
        return React36.createElement(Alert_default, {
          id,
          type: "error",
          title: errorMessage,
          description: React36.createElement("pre", {
            style: {
              fontSize: "0.9em",
              overflowX: "auto"
            }
          }, errorDescription)
        });
      }
      return children;
    }
  }]);
}(React36.Component);
var ErrorBoundary_default = ErrorBoundary;

// node_modules/antd/es/alert/index.js
var Alert2 = Alert_default;
Alert2.ErrorBoundary = ErrorBoundary_default;
var alert_default = Alert2;

// node_modules/antd/es/anchor/Anchor.js
var React64 = __toESM(require_react());

// node_modules/compute-scroll-into-view/dist/index.js
var t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
var e = (t2, e3) => (!e3 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2);
var n = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o3 = getComputedStyle(t2, null);
    return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t3) => {
      const e3 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e3 && (e3.clientHeight < t3.scrollHeight || e3.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
};
var o = (t2, e3, n2, o3, l2, r2, i, s) => r2 < t2 && i > e3 || r2 > t2 && i < e3 ? 0 : r2 <= t2 && s <= n2 || i >= e3 && s >= n2 ? r2 - t2 - o3 : i > e3 && s < n2 || r2 < t2 && s > n2 ? i - e3 + l2 : 0;
var l = (t2) => {
  const e3 = t2.parentElement;
  return null == e3 ? t2.getRootNode().host || null : e3;
};
var r = (e3, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t2) => t2 !== a;
  if (!t(e3))
    throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w = [];
  let W = e3;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);
  }
  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e3.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {
    const e4 = window.getComputedStyle(t2);
    return { top: parseFloat(e4.scrollMarginTop) || 0, right: parseFloat(e4.scrollMarginRight) || 0, bottom: parseFloat(e4.scrollMarginBottom) || 0, left: parseFloat(e4.scrollMarginLeft) || 0 };
  })(e3);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w.length; t2++) {
    const e4 = w[t2], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e4.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b && (e4 === m && !n(e4) || x >= i2 && I <= d2 && R >= h2 && C <= s2))
      return L;
    const a2 = getComputedStyle(e4), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
    let B2 = 0, F2 = 0;
    const V2 = "offsetWidth" in e4 ? e4.offsetWidth - e4.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e4 ? e4.offsetHeight - e4.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e4 ? 0 === e4.offsetWidth ? 0 : r3 / e4.offsetWidth : 0, Y = "offsetHeight" in e4 ? 0 === e4.offsetHeight ? 0 : l2 / e4.offsetHeight : 0;
    if (m === e4)
      B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p2, T2, M + k, M + k + v, v) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o(y, y + b, b, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
    else {
      B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o(i2, d2, l2, p2, T2 + S, k, k + v, v) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h2 - g2 : "center" === u ? D - (h2 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o(h2, s2, r3, g2, W2 + V2, D, D + E, E);
      const { scrollLeft: t3, scrollTop: n2 } = e4;
      B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e4.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t3 + F2 / X, e4.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t3 - F2;
    }
    L.push({ el: e4, top: B2, left: F2 });
  }
  return L;
};

// node_modules/scroll-into-view-if-needed/dist/index.js
var o2 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
function e2(e3, r2) {
  if (!e3.isConnected || !((t2) => {
    let o3 = t2;
    for (; o3 && o3.parentNode; ) {
      if (o3.parentNode === document)
        return true;
      o3 = o3.parentNode instanceof ShadowRoot ? o3.parentNode.host : o3.parentNode;
    }
    return false;
  })(e3))
    return;
  const n2 = ((t2) => {
    const o3 = window.getComputedStyle(t2);
    return { top: parseFloat(o3.scrollMarginTop) || 0, right: parseFloat(o3.scrollMarginRight) || 0, bottom: parseFloat(o3.scrollMarginBottom) || 0, left: parseFloat(o3.scrollMarginLeft) || 0 };
  })(e3);
  if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2))
    return r2.behavior(r(e3, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a, top: i, left: s } of r(e3, o2(r2))) {
    const t2 = i - n2.top + n2.bottom, o3 = s - n2.left + n2.right;
    a.scroll({ top: t2, left: o3, behavior: l2 });
  }
}

// node_modules/antd/es/_util/getScroll.js
function isWindow(obj) {
  return isNonNullable_default(obj) && obj === obj.window;
}
var getScroll = (target) => {
  var _a;
  if (typeof window === "undefined") {
    return 0;
  }
  let result = 0;
  if (isWindow(target)) {
    result = target.pageYOffset;
  } else if (target instanceof Document) {
    result = target.documentElement.scrollTop;
  } else if (target instanceof HTMLElement) {
    result = target.scrollTop;
  } else if (target) {
    result = target["scrollTop"];
  }
  if (target && !isWindow(target) && typeof result !== "number") {
    result = (_a = (target.ownerDocument ?? target).documentElement) == null ? void 0 : _a.scrollTop;
  }
  return result;
};
var getScroll_default = getScroll;

// node_modules/antd/es/_util/easings.js
function easeInOutCubic(t2, b, c, d) {
  const cc = c - b;
  t2 /= d / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
}

// node_modules/antd/es/_util/scrollTo.js
function scrollTo(y, options = {}) {
  const {
    getContainer = () => window,
    callback,
    duration = 450
  } = options;
  const container = getContainer();
  const scrollTop = getScroll_default(container);
  const startTime = Date.now();
  let rafId;
  const frameFunc = () => {
    const timestamp = Date.now();
    const time = timestamp - startTime;
    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
    if (isWindow(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      rafId = raf_default(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  rafId = raf_default(frameFunc);
  return () => {
    raf_default.cancel(rafId);
  };
}

// node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = (prefixCls) => `${prefixCls}-css-var`;
var useCSSVarCls_default = useCSSVarCls;

// node_modules/antd/es/anchor/AnchorLink.js
var React63 = __toESM(require_react());

// node_modules/antd/es/config-provider/index.js
var React61 = __toESM(require_react());

// node_modules/antd/es/form/validateMessagesContext.js
var import_react27 = __toESM(require_react());
var validateMessagesContext_default = (0, import_react27.createContext)(void 0);

// node_modules/antd/es/tooltip/UniqueProvider/index.js
var import_react31 = __toESM(require_react());

// node_modules/@rc-component/portal/es/Portal.js
var React40 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@rc-component/portal/es/Context.js
var React37 = __toESM(require_react());
var OrderContext = React37.createContext(null);
var Context_default2 = OrderContext;

// node_modules/@rc-component/portal/es/mock.js
var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === "boolean") {
    inline = nextInline;
  }
  return inline;
}

// node_modules/@rc-component/portal/es/useDom.js
var React38 = __toESM(require_react());
var EMPTY_LIST = [];
function useDom(render2, debug) {
  const [ele] = React38.useState(() => {
    if (!canUseDom()) {
      return null;
    }
    const defaultEle = document.createElement("div");
    if (debug) {
      defaultEle.setAttribute("data-debug", debug);
    }
    return defaultEle;
  });
  const appendedRef = React38.useRef(false);
  const queueCreate = React38.useContext(Context_default2);
  const [queue, setQueue] = React38.useState(EMPTY_LIST);
  const mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : (appendFn) => {
    setQueue((origin) => {
      const newQueue = [appendFn, ...origin];
      return newQueue;
    });
  });
  function append2() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  function cleanup2() {
    var _a;
    (_a = ele.parentElement) == null ? void 0 : _a.removeChild(ele);
    appendedRef.current = false;
  }
  useLayoutEffect_default(() => {
    if (render2) {
      if (queueCreate) {
        queueCreate(append2);
      } else {
        append2();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render2]);
  useLayoutEffect_default(() => {
    if (queue.length) {
      queue.forEach((appendFn) => appendFn());
      setQueue(EMPTY_LIST);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}

// node_modules/@rc-component/portal/es/useScrollLocker.js
var React39 = __toESM(require_react());

// node_modules/@rc-component/util/es/getScrollBarSize.js
var cached;
function measureScrollbarSize(ele) {
  const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
  const measureEle = document.createElement("div");
  measureEle.id = randomId;
  const measureStyle = measureEle.style;
  measureStyle.position = "absolute";
  measureStyle.left = "0";
  measureStyle.top = "0";
  measureStyle.width = "100px";
  measureStyle.height = "100px";
  measureStyle.overflow = "scroll";
  let fallbackWidth;
  let fallbackHeight;
  if (ele) {
    const targetStyle = getComputedStyle(ele);
    measureStyle.scrollbarColor = targetStyle.scrollbarColor;
    measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
    const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
    const width = parseInt(webkitScrollbarStyle.width, 10);
    const height = parseInt(webkitScrollbarStyle.height, 10);
    try {
      const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : "";
      const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : "";
      updateCSS(`
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`, randomId);
    } catch (e3) {
      console.error(e3);
      fallbackWidth = width;
      fallbackHeight = height;
    }
  }
  document.body.appendChild(measureEle);
  const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
  const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
  document.body.removeChild(measureEle);
  removeCSS(randomId);
  return {
    width: scrollWidth,
    height: scrollHeight
  };
}
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    cached = measureScrollbarSize();
  }
  return cached.width;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  return measureScrollbarSize(target);
}

// node_modules/@rc-component/portal/es/util.js
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

// node_modules/@rc-component/portal/es/useScrollLocker.js
var UNIQUE_ID = `rc-util-locker-${Date.now()}`;
var uuid2 = 0;
function useScrollLocker(lock) {
  const mergedLock = !!lock;
  const [id] = React39.useState(() => {
    uuid2 += 1;
    return `${UNIQUE_ID}_${uuid2}`;
  });
  useLayoutEffect_default(() => {
    if (mergedLock) {
      const scrollbarSize = getTargetScrollBarSize(document.body).width;
      const isOverflow = isBodyOverflowing();
      updateCSS(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
    } else {
      removeCSS(id);
    }
    return () => {
      removeCSS(id);
    };
  }, [mergedLock, id]);
}

// node_modules/@rc-component/portal/es/Portal.js
var getPortalContainer = (getContainer) => {
  if (getContainer === false) {
    return false;
  }
  if (!canUseDom() || !getContainer) {
    return null;
  }
  if (typeof getContainer === "string") {
    return document.querySelector(getContainer);
  }
  if (typeof getContainer === "function") {
    return getContainer();
  }
  return getContainer;
};
var Portal = React40.forwardRef((props, ref) => {
  const {
    open: open3,
    autoLock,
    getContainer,
    debug,
    autoDestroy = true,
    children
  } = props;
  const [shouldRender, setShouldRender] = React40.useState(open3);
  const mergedRender = shouldRender || open3;
  if (true) {
    warning_default(canUseDom() || !open3, `Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.`);
  }
  React40.useEffect(() => {
    if (autoDestroy || open3) {
      setShouldRender(open3);
    }
  }, [open3, autoDestroy]);
  const [innerContainer, setInnerContainer] = React40.useState(() => getPortalContainer(getContainer));
  React40.useEffect(() => {
    const customizeContainer = getPortalContainer(getContainer);
    setInnerContainer(customizeContainer ?? null);
  });
  const [defaultContainer2, queueCreate] = useDom(mergedRender && !innerContainer, debug);
  const mergedContainer = innerContainer ?? defaultContainer2;
  useScrollLocker(autoLock && open3 && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
  let childRef = null;
  if (children && supportRef(children) && ref) {
    childRef = getNodeRef(children);
  }
  const mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0) {
    return null;
  }
  const renderInline = mergedContainer === false || inlineMock();
  let reffedChildren = children;
  if (ref) {
    reffedChildren = React40.cloneElement(children, {
      ref: mergedRef
    });
  }
  return React40.createElement(Context_default2.Provider, {
    value: queueCreate
  }, renderInline ? reffedChildren : (0, import_react_dom.createPortal)(reffedChildren, mergedContainer));
});
if (true) {
  Portal.displayName = "Portal";
}
var Portal_default = Portal;

// node_modules/@rc-component/portal/es/index.js
var es_default3 = Portal_default;

// node_modules/@rc-component/util/es/hooks/useId.js
var React41 = __toESM(require_react());
function getUseId() {
  const fullClone = {
    ...React41
  };
  return fullClone.useId;
}
var uuid3 = 0;
var useOriginId = getUseId();
var useId_default = useOriginId ? (
  // Use React `useId`
  function useId(id) {
    const reactId = useOriginId();
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return reactId;
  }
) : (
  // Use compatible of `useId`
  function useCompatId(id) {
    const [innerId, setInnerId] = React41.useState("ssr-id");
    React41.useEffect(() => {
      const nextId = uuid3;
      uuid3 += 1;
      setInnerId(`rc_unique_${nextId}`);
    }, []);
    if (id) {
      return id;
    }
    if (false) {
      return "test-id";
    }
    return innerId;
  }
);

// node_modules/@rc-component/trigger/es/index.js
var React54 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/Popup/index.js
var React45 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/Popup/Arrow.js
var React42 = __toESM(require_react());
function Arrow(props) {
  const {
    prefixCls,
    align,
    arrow,
    arrowPos
  } = props;
  const {
    className,
    content,
    style: style2
  } = arrow || {};
  const {
    x = 0,
    y = 0
  } = arrowPos;
  const arrowRef = React42.useRef(null);
  if (!align || !align.points) {
    return null;
  }
  const alignStyle = {
    position: "absolute"
  };
  if (align.autoArrow !== false) {
    const popupPoints = align.points[0];
    const targetPoints = align.points[1];
    const popupTB = popupPoints[0];
    const popupLR = popupPoints[1];
    const targetTB = targetPoints[0];
    const targetLR = targetPoints[1];
    if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
      alignStyle.top = y;
    } else if (popupTB === "t") {
      alignStyle.top = 0;
    } else {
      alignStyle.bottom = 0;
    }
    if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
      alignStyle.left = x;
    } else if (popupLR === "l") {
      alignStyle.left = 0;
    } else {
      alignStyle.right = 0;
    }
  }
  return React42.createElement("div", {
    ref: arrowRef,
    className: clsx(`${prefixCls}-arrow`, className),
    style: {
      ...alignStyle,
      ...style2
    }
  }, content);
}

// node_modules/@rc-component/trigger/es/Popup/Mask.js
var React43 = __toESM(require_react());
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function Mask(props) {
  const {
    prefixCls,
    open: open3,
    zIndex,
    mask,
    motion: motion2,
    mobile
  } = props;
  if (!mask) {
    return null;
  }
  return React43.createElement(es_default2, _extends3({}, motion2, {
    motionAppear: true,
    visible: open3,
    removeOnLeave: true
  }), ({
    className
  }) => React43.createElement("div", {
    style: {
      zIndex
    },
    className: clsx(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
  }));
}

// node_modules/@rc-component/trigger/es/Popup/PopupContent.js
var React44 = __toESM(require_react());
var PopupContent = React44.memo(({
  children
}) => children, (_, next2) => next2.cache);
if (true) {
  PopupContent.displayName = "PopupContent";
}
var PopupContent_default = PopupContent;

// node_modules/@rc-component/trigger/es/hooks/useOffsetStyle.js
function useOffsetStyle(isMobile2, ready, open3, align, offsetR, offsetB, offsetX, offsetY) {
  var _a;
  const AUTO = "auto";
  const offsetStyle = isMobile2 ? {} : {
    left: "-1000vw",
    top: "-1000vh",
    right: AUTO,
    bottom: AUTO
  };
  if (!isMobile2 && (ready || !open3)) {
    const {
      points
    } = align;
    const dynamicInset = align.dynamicInset || ((_a = align._experimental) == null ? void 0 : _a.dynamicInset);
    const alignRight = dynamicInset && points[0][1] === "r";
    const alignBottom = dynamicInset && points[0][0] === "b";
    if (alignRight) {
      offsetStyle.right = offsetR;
      offsetStyle.left = AUTO;
    } else {
      offsetStyle.left = offsetX;
      offsetStyle.right = AUTO;
    }
    if (alignBottom) {
      offsetStyle.bottom = offsetB;
      offsetStyle.top = AUTO;
    } else {
      offsetStyle.top = offsetY;
      offsetStyle.bottom = AUTO;
    }
  }
  return offsetStyle;
}

// node_modules/@rc-component/trigger/es/Popup/index.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var Popup = React45.forwardRef((props, ref) => {
  const {
    popup,
    className,
    prefixCls,
    style: style2,
    target,
    onVisibleChanged,
    // Open
    open: open3,
    keepDom,
    fresh,
    // Click
    onClick,
    // Mask
    mask,
    // Arrow
    arrow,
    arrowPos,
    align,
    // Motion
    motion: motion2,
    maskMotion,
    // Mobile
    mobile,
    // Portal
    forceRender,
    getPopupContainer,
    autoDestroy,
    portal: Portal2,
    children,
    zIndex,
    onMouseEnter,
    onMouseLeave,
    onPointerEnter,
    onPointerDownCapture,
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    onAlign,
    onPrepare,
    // Resize
    onResize: onResize2,
    stretch,
    targetWidth,
    targetHeight
  } = props;
  const popupContent = typeof popup === "function" ? popup() : popup;
  const isNodeVisible = open3 || keepDom;
  const isMobile2 = !!mobile;
  const [mergedMask, mergedMaskMotion, mergedPopupMotion] = React45.useMemo(() => {
    if (mobile) {
      return [mobile.mask, mobile.maskMotion, mobile.motion];
    }
    return [mask, maskMotion, motion2];
  }, [mobile, mask, maskMotion, motion2]);
  const getPopupContainerNeedParams = (getPopupContainer == null ? void 0 : getPopupContainer.length) > 0;
  const [show, setShow] = React45.useState(!getPopupContainer || !getPopupContainerNeedParams);
  useLayoutEffect_default(() => {
    if (!show && getPopupContainerNeedParams && target) {
      setShow(true);
    }
  }, [show, getPopupContainerNeedParams, target]);
  const onInternalResize = useEvent_default((size, ele) => {
    onResize2 == null ? void 0 : onResize2(size, ele);
    onAlign();
  });
  const offsetStyle = useOffsetStyle(isMobile2, ready, open3, align, offsetR, offsetB, offsetX, offsetY);
  if (!show) {
    return null;
  }
  const miscStyle = {};
  if (stretch) {
    if (stretch.includes("height") && targetHeight) {
      miscStyle.height = targetHeight;
    } else if (stretch.includes("minHeight") && targetHeight) {
      miscStyle.minHeight = targetHeight;
    }
    if (stretch.includes("width") && targetWidth) {
      miscStyle.width = targetWidth;
    } else if (stretch.includes("minWidth") && targetWidth) {
      miscStyle.minWidth = targetWidth;
    }
  }
  if (!open3) {
    miscStyle.pointerEvents = "none";
  }
  return React45.createElement(Portal2, {
    open: forceRender || isNodeVisible,
    getContainer: getPopupContainer && (() => getPopupContainer(target)),
    autoDestroy
  }, React45.createElement(Mask, {
    prefixCls,
    open: open3,
    zIndex,
    mask: mergedMask,
    motion: mergedMaskMotion,
    mobile: isMobile2
  }), React45.createElement(es_default, {
    onResize: onInternalResize,
    disabled: !open3
  }, (resizeObserverRef) => {
    return React45.createElement(es_default2, _extends4({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      forceRender,
      leavedClassName: `${prefixCls}-hidden`
    }, mergedPopupMotion, {
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      visible: open3,
      onVisibleChanged: (nextVisible) => {
        var _a;
        (_a = motion2 == null ? void 0 : motion2.onVisibleChanged) == null ? void 0 : _a.call(motion2, nextVisible);
        onVisibleChanged(nextVisible);
      }
    }), ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => {
      const cls = clsx(prefixCls, motionClassName, className, {
        [`${prefixCls}-mobile`]: isMobile2
      });
      return React45.createElement("div", {
        ref: composeRef(resizeObserverRef, ref, motionRef),
        className: cls,
        style: {
          "--arrow-x": `${arrowPos.x || 0}px`,
          "--arrow-y": `${arrowPos.y || 0}px`,
          ...offsetStyle,
          ...miscStyle,
          ...motionStyle,
          boxSizing: "border-box",
          zIndex,
          ...style2
        },
        onMouseEnter,
        onMouseLeave,
        onPointerEnter,
        onClick,
        onPointerDownCapture
      }, arrow && React45.createElement(Arrow, {
        prefixCls,
        arrow,
        arrowPos,
        align
      }), React45.createElement(PopupContent_default, {
        cache: !open3 && !fresh
      }, popupContent));
    });
  }), children);
});
if (true) {
  Popup.displayName = "Popup";
}
var Popup_default = Popup;

// node_modules/@rc-component/trigger/es/context.js
var React46 = __toESM(require_react());
var TriggerContext = React46.createContext(null);
var context_default2 = TriggerContext;
var UniqueContext = React46.createContext(null);

// node_modules/@rc-component/trigger/es/hooks/useAction.js
var React47 = __toESM(require_react());
function toArray2(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(action, showAction, hideAction) {
  return React47.useMemo(() => {
    const mergedShowAction = toArray2(showAction ?? action);
    const mergedHideAction = toArray2(hideAction ?? action);
    const showActionSet = new Set(mergedShowAction);
    const hideActionSet = new Set(mergedHideAction);
    if (showActionSet.has("hover") && !showActionSet.has("click")) {
      showActionSet.add("touch");
    }
    if (hideActionSet.has("hover") && !hideActionSet.has("click")) {
      hideActionSet.add("touch");
    }
    return [showActionSet, hideActionSet];
  }, [action, showAction, hideAction]);
}

// node_modules/@rc-component/util/es/Dom/isVisible.js
var isVisible_default = (element) => {
  if (!element) {
    return false;
  }
  if (element instanceof Element) {
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      const {
        width,
        height
      } = element.getBBox();
      if (width || height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      if (width || height) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/@rc-component/trigger/es/hooks/useAlign.js
var React48 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/util.js
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var _a;
  const {
    points
  } = align;
  const placements5 = Object.keys(builtinPlacements);
  for (let i = 0; i < placements5.length; i += 1) {
    const placement = placements5[i];
    if (isPointsEq((_a = builtinPlacements[placement]) == null ? void 0 : _a.points, points, isAlignPoint)) {
      return `${prefixCls}-placement-${placement}`;
    }
  }
  return "";
}
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}
function collectScroller(ele) {
  const scrollerList = [];
  let current = ele == null ? void 0 : ele.parentElement;
  const scrollStyle = ["hidden", "scroll", "clip", "auto"];
  while (current) {
    const {
      overflowX,
      overflowY,
      overflow
    } = getWin(current).getComputedStyle(current);
    if ([overflowX, overflowY, overflow].some((o3) => scrollStyle.includes(o3))) {
      scrollerList.push(current);
    }
    current = current.parentElement;
  }
  return scrollerList;
}
function toNum(num, defaultValue = 1) {
  return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
  return toNum(parseFloat(val), 0);
}
function getVisibleArea(initArea, scrollerList) {
  const visibleArea = {
    ...initArea
  };
  (scrollerList || []).forEach((ele) => {
    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
      return;
    }
    const {
      overflow,
      overflowClipMargin,
      borderTopWidth,
      borderBottomWidth,
      borderLeftWidth,
      borderRightWidth
    } = getWin(ele).getComputedStyle(ele);
    const eleRect = ele.getBoundingClientRect();
    const {
      offsetHeight: eleOutHeight,
      clientHeight: eleInnerHeight,
      offsetWidth: eleOutWidth,
      clientWidth: eleInnerWidth
    } = ele;
    const borderTopNum = getPxValue(borderTopWidth);
    const borderBottomNum = getPxValue(borderBottomWidth);
    const borderLeftNum = getPxValue(borderLeftWidth);
    const borderRightNum = getPxValue(borderRightWidth);
    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
    const scaledBorderTopWidth = borderTopNum * scaleY;
    const scaledBorderBottomWidth = borderBottomNum * scaleY;
    const scaledBorderLeftWidth = borderLeftNum * scaleX;
    const scaledBorderRightWidth = borderRightNum * scaleX;
    let clipMarginWidth = 0;
    let clipMarginHeight = 0;
    if (overflow === "clip") {
      const clipNum = getPxValue(overflowClipMargin);
      clipMarginWidth = clipNum * scaleX;
      clipMarginHeight = clipNum * scaleY;
    }
    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
    visibleArea.left = Math.max(visibleArea.left, eleLeft);
    visibleArea.top = Math.max(visibleArea.top, eleTop);
    visibleArea.right = Math.min(visibleArea.right, eleRight);
    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
  });
  return visibleArea;
}

// node_modules/@rc-component/trigger/es/hooks/useAlign.js
function getUnitOffset(size, offset3 = 0) {
  const offsetStr = `${offset3}`;
  const cells = offsetStr.match(/^(.*)\%$/);
  if (cells) {
    return size * (parseFloat(cells[1]) / 100);
  }
  return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset3) {
  const [offsetX, offsetY] = offset3 || [];
  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints(points = "") {
  return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
  const topBottom = points[0];
  const leftRight = points[1];
  let x;
  let y;
  if (topBottom === "t") {
    y = rect.y;
  } else if (topBottom === "b") {
    y = rect.y + rect.height;
  } else {
    y = rect.y + rect.height / 2;
  }
  if (leftRight === "l") {
    x = rect.x;
  } else if (leftRight === "r") {
    x = rect.x + rect.width;
  } else {
    x = rect.x + rect.width / 2;
  }
  return {
    x,
    y
  };
}
function reversePoints(points, index2) {
  const reverseMap = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return points.map((point, i) => {
    if (i === index2) {
      return reverseMap[point] || "c";
    }
    return point;
  }).join("");
}
function useAlign(open3, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
  const [offsetInfo, setOffsetInfo] = React48.useState({
    ready: false,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: builtinPlacements[placement] || {}
  });
  const alignCountRef = React48.useRef(0);
  const scrollerList = React48.useMemo(() => {
    if (!popupEle || mobile) {
      return [];
    }
    return collectScroller(popupEle);
  }, [popupEle]);
  const prevFlipRef = React48.useRef({});
  const resetFlipCache = () => {
    prevFlipRef.current = {};
  };
  if (!open3) {
    resetFlipCache();
  }
  const onAlign = useEvent_default(() => {
    var _a, _b;
    if (popupEle && target && open3 && !mobile) {
      let getIntersectionVisibleArea = function(offsetX, offsetY, area = visibleArea) {
        const l2 = popupRect.x + offsetX;
        const t2 = popupRect.y + offsetY;
        const r2 = l2 + popupWidth;
        const b = t2 + popupHeight;
        const visibleL = Math.max(l2, area.left);
        const visibleT = Math.max(t2, area.top);
        const visibleR = Math.min(r2, area.right);
        const visibleB = Math.min(b, area.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }, syncNextPopupPosition = function() {
        nextPopupY = popupRect.y + nextOffsetY;
        nextPopupBottom = nextPopupY + popupHeight;
        nextPopupX = popupRect.x + nextOffsetX;
        nextPopupRight = nextPopupX + popupWidth;
      };
      const popupElement = popupEle;
      const doc = popupElement.ownerDocument;
      const win = getWin(popupElement);
      const {
        position: popupPosition
      } = win.getComputedStyle(popupElement);
      const originLeft = popupElement.style.left;
      const originTop = popupElement.style.top;
      const originRight = popupElement.style.right;
      const originBottom = popupElement.style.bottom;
      const originOverflow = popupElement.style.overflow;
      const placementInfo = {
        ...builtinPlacements[placement],
        ...popupAlign
      };
      const placeholderElement = doc.createElement("div");
      (_a = popupElement.parentElement) == null ? void 0 : _a.appendChild(placeholderElement);
      placeholderElement.style.left = `${popupElement.offsetLeft}px`;
      placeholderElement.style.top = `${popupElement.offsetTop}px`;
      placeholderElement.style.position = popupPosition;
      placeholderElement.style.height = `${popupElement.offsetHeight}px`;
      placeholderElement.style.width = `${popupElement.offsetWidth}px`;
      popupElement.style.left = "0";
      popupElement.style.top = "0";
      popupElement.style.right = "auto";
      popupElement.style.bottom = "auto";
      popupElement.style.overflow = "hidden";
      let targetRect;
      if (Array.isArray(target)) {
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      } else {
        const rect = target.getBoundingClientRect();
        rect.x = rect.x ?? rect.left;
        rect.y = rect.y ?? rect.top;
        targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      const popupRect = popupElement.getBoundingClientRect();
      const {
        height,
        width
      } = win.getComputedStyle(popupElement);
      popupRect.x = popupRect.x ?? popupRect.left;
      popupRect.y = popupRect.y ?? popupRect.top;
      const {
        clientWidth,
        clientHeight,
        scrollWidth,
        scrollHeight,
        scrollTop,
        scrollLeft
      } = doc.documentElement;
      const popupHeight = popupRect.height;
      const popupWidth = popupRect.width;
      const targetHeight = targetRect.height;
      const targetWidth = targetRect.width;
      const visibleRegion = {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      };
      const scrollRegion = {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      };
      let {
        htmlRegion
      } = placementInfo;
      const VISIBLE = "visible";
      const VISIBLE_FIRST = "visibleFirst";
      if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
        htmlRegion = VISIBLE;
      }
      const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
      const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
      const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
      const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
      const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
      popupElement.style.left = "auto";
      popupElement.style.top = "auto";
      popupElement.style.right = "0";
      popupElement.style.bottom = "0";
      const popupMirrorRect = popupElement.getBoundingClientRect();
      popupElement.style.left = originLeft;
      popupElement.style.top = originTop;
      popupElement.style.right = originRight;
      popupElement.style.bottom = originBottom;
      popupElement.style.overflow = originOverflow;
      (_b = popupElement.parentElement) == null ? void 0 : _b.removeChild(placeholderElement);
      const scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
      const scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
      if (scaleX === 0 || scaleY === 0 || isDOM(target) && !isVisible_default(target)) {
        return;
      }
      const {
        offset: offset3,
        targetOffset: targetOffset4
      } = placementInfo;
      let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset3);
      const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset4);
      targetRect.x -= targetOffsetX;
      targetRect.y -= targetOffsetY;
      const [popupPoint, targetPoint] = placementInfo.points || [];
      const targetPoints = splitPoints(targetPoint);
      const popupPoints = splitPoints(popupPoint);
      const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
      const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
      const nextAlignInfo = {
        ...placementInfo
      };
      let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
      let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
      const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
      const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
      const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
      const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
      const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
      const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
      const overflow = placementInfo.overflow || {};
      const {
        adjustX,
        adjustY,
        shiftX,
        shiftY
      } = overflow;
      const supportAdjust = (val) => {
        if (typeof val === "boolean") {
          return val;
        }
        return val >= 0;
      };
      let nextPopupY;
      let nextPopupBottom;
      let nextPopupX;
      let nextPopupRight;
      syncNextPopupPosition();
      const needAdjustY = supportAdjust(adjustY);
      const sameTB = popupPoints[0] === targetPoints[0];
      if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY -= popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.bt = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        } else {
          prevFlipRef.current.bt = false;
        }
      }
      if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
        let tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY += popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        }
        const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.tb = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        } else {
          prevFlipRef.current.tb = false;
        }
      }
      const needAdjustX = supportAdjust(adjustX);
      const sameLR = popupPoints[1] === targetPoints[1];
      if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX -= popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.rl = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        } else {
          prevFlipRef.current.rl = false;
        }
      }
      if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
        let tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX += popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        }
        const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
        const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
          // Of course use larger one
          newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
          newVisibleRecommendArea >= originIntersectionRecommendArea)
        ) {
          prevFlipRef.current.lr = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        } else {
          prevFlipRef.current.lr = false;
        }
      }
      syncNextPopupPosition();
      const numShiftX = shiftX === true ? 0 : shiftX;
      if (typeof numShiftX === "number") {
        if (nextPopupX < visibleRegionArea.left) {
          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
          }
        }
        if (nextPopupRight > visibleRegionArea.right) {
          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
          if (targetRect.x > visibleRegionArea.right - numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
          }
        }
      }
      const numShiftY = shiftY === true ? 0 : shiftY;
      if (typeof numShiftY === "number") {
        if (nextPopupY < visibleRegionArea.top) {
          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
          }
        }
        if (nextPopupBottom > visibleRegionArea.bottom) {
          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
          }
        }
      }
      const popupLeft = popupRect.x + nextOffsetX;
      const popupRight = popupLeft + popupWidth;
      const popupTop = popupRect.y + nextOffsetY;
      const popupBottom = popupTop + popupHeight;
      const targetLeft = targetRect.x;
      const targetRight = targetLeft + targetWidth;
      const targetTop = targetRect.y;
      const targetBottom = targetTop + targetHeight;
      const maxLeft = Math.max(popupLeft, targetLeft);
      const minRight = Math.min(popupRight, targetRight);
      const xCenter = (maxLeft + minRight) / 2;
      const nextArrowX = xCenter - popupLeft;
      const maxTop = Math.max(popupTop, targetTop);
      const minBottom = Math.min(popupBottom, targetBottom);
      const yCenter = (maxTop + minBottom) / 2;
      const nextArrowY = yCenter - popupTop;
      onPopupAlign == null ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
      let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
      let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
      if (scaleX === 1) {
        nextOffsetX = Math.round(nextOffsetX);
        offsetX4Right = Math.round(offsetX4Right);
      }
      if (scaleY === 1) {
        nextOffsetY = Math.round(nextOffsetY);
        offsetY4Bottom = Math.round(offsetY4Bottom);
      }
      const nextOffsetInfo = {
        ready: true,
        offsetX: nextOffsetX / scaleX,
        offsetY: nextOffsetY / scaleY,
        offsetR: offsetX4Right / scaleX,
        offsetB: offsetY4Bottom / scaleY,
        arrowX: nextArrowX / scaleX,
        arrowY: nextArrowY / scaleY,
        scaleX,
        scaleY,
        align: nextAlignInfo
      };
      setOffsetInfo(nextOffsetInfo);
    }
  });
  const triggerAlign = () => {
    alignCountRef.current += 1;
    const id = alignCountRef.current;
    Promise.resolve().then(() => {
      if (alignCountRef.current === id) {
        onAlign();
      }
    });
  };
  const resetReady = () => {
    setOffsetInfo((ori) => ({
      ...ori,
      ready: false
    }));
  };
  useLayoutEffect_default(resetReady, [placement]);
  useLayoutEffect_default(() => {
    if (!open3) {
      resetReady();
    }
  }, [open3]);
  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
}

// node_modules/@rc-component/trigger/es/hooks/useDelay.js
var React49 = __toESM(require_react());
function useDelay() {
  const delayRef = React49.useRef(null);
  const clearDelay = () => {
    if (delayRef.current) {
      clearTimeout(delayRef.current);
      delayRef.current = null;
    }
  };
  const delayInvoke = (callback, delay) => {
    clearDelay();
    if (delay === 0) {
      callback();
    } else {
      delayRef.current = setTimeout(() => {
        callback();
      }, delay * 1e3);
    }
  };
  React49.useEffect(() => {
    return () => {
      clearDelay();
    };
  }, []);
  return delayInvoke;
}

// node_modules/@rc-component/trigger/es/hooks/useWatch.js
function useWatch(open3, target, popup, onAlign, onScroll) {
  useLayoutEffect_default(() => {
    if (open3 && target && popup) {
      let notifyScroll = function() {
        onAlign();
        onScroll();
      };
      const targetElement = target;
      const popupElement = popup;
      const targetScrollList = collectScroller(targetElement);
      const popupScrollList = collectScroller(popupElement);
      const win = getWin(popupElement);
      const mergedList = /* @__PURE__ */ new Set([win, ...targetScrollList, ...popupScrollList]);
      mergedList.forEach((scroller) => {
        scroller.addEventListener("scroll", notifyScroll, {
          passive: true
        });
      });
      win.addEventListener("resize", notifyScroll, {
        passive: true
      });
      onAlign();
      return () => {
        mergedList.forEach((scroller) => {
          scroller.removeEventListener("scroll", notifyScroll);
          win.removeEventListener("resize", notifyScroll);
        });
      };
    }
  }, [open3, target, popup]);
}

// node_modules/@rc-component/trigger/es/hooks/useWinClick.js
var React50 = __toESM(require_react());
function useWinClick(open3, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
  const openRef = React50.useRef(open3);
  openRef.current = open3;
  const popupPointerDownRef = React50.useRef(false);
  React50.useEffect(() => {
    var _a, _b;
    if (clickToHide && popupEle && (!mask || maskClosable)) {
      const onPointerDown = () => {
        popupPointerDownRef.current = false;
      };
      const onTriggerClose = (e3) => {
        var _a2, _b2;
        if (openRef.current && !inPopupOrChild(((_b2 = (_a2 = e3.composedPath) == null ? void 0 : _a2.call(e3)) == null ? void 0 : _b2[0]) || e3.target) && !popupPointerDownRef.current) {
          triggerOpen(false);
        }
      };
      const win = getWin(popupEle);
      win.addEventListener("pointerdown", onPointerDown, true);
      win.addEventListener("mousedown", onTriggerClose, true);
      win.addEventListener("contextmenu", onTriggerClose, true);
      const targetShadowRoot = getShadowRoot(targetEle);
      if (targetShadowRoot) {
        targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
        targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
      }
      if (targetEle) {
        const targetRoot = (_a = targetEle.getRootNode) == null ? void 0 : _a.call(targetEle);
        const popupRoot = (_b = popupEle.getRootNode) == null ? void 0 : _b.call(popupEle);
        warning(targetRoot === popupRoot, `trigger element and popup element should in same shadow root.`);
      }
      return () => {
        win.removeEventListener("pointerdown", onPointerDown, true);
        win.removeEventListener("mousedown", onTriggerClose, true);
        win.removeEventListener("contextmenu", onTriggerClose, true);
        if (targetShadowRoot) {
          targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
          targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
        }
      };
    }
  }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
  function onPopupPointerDown() {
    popupPointerDownRef.current = true;
  }
  return onPopupPointerDown;
}

// node_modules/@rc-component/trigger/es/UniqueProvider/index.js
var React53 = __toESM(require_react());

// node_modules/@rc-component/trigger/es/UniqueProvider/useTargetState.js
var import_react28 = __toESM(require_react());
function useTargetState() {
  const [options, setOptions] = import_react28.default.useState(null);
  const [open3, setOpen] = import_react28.default.useState(false);
  const [isAnimating, setIsAnimating] = import_react28.default.useState(false);
  const pendingOptionsRef = import_react28.default.useRef(null);
  const trigger = useEvent_default((nextOptions) => {
    if (nextOptions === false) {
      pendingOptionsRef.current = null;
      setOpen(false);
    } else {
      if (isAnimating && open3) {
        pendingOptionsRef.current = nextOptions;
      } else {
        setOpen(true);
        setOptions(nextOptions);
        pendingOptionsRef.current = null;
        if (!open3) {
          setIsAnimating(true);
        }
      }
    }
  });
  const onVisibleChanged = useEvent_default((visible) => {
    if (visible) {
      setIsAnimating(false);
      if (pendingOptionsRef.current) {
        setOptions(pendingOptionsRef.current);
        pendingOptionsRef.current = null;
      }
    } else {
      setIsAnimating(false);
      pendingOptionsRef.current = null;
    }
  });
  return [trigger, open3, options, onVisibleChanged];
}

// node_modules/@rc-component/trigger/es/UniqueProvider/UniqueContainer.js
var import_react29 = __toESM(require_react());
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
var UniqueContainer = (props) => {
  const {
    prefixCls,
    isMobile: isMobile2,
    ready,
    open: open3,
    align,
    offsetR,
    offsetB,
    offsetX,
    offsetY,
    arrowPos,
    popupSize,
    motion: motion2,
    uniqueContainerClassName,
    uniqueContainerStyle
  } = props;
  const containerCls = `${prefixCls}-unique-container`;
  const [motionVisible, setMotionVisible] = import_react29.default.useState(false);
  const offsetStyle = useOffsetStyle(isMobile2, ready, open3, align, offsetR, offsetB, offsetX, offsetY);
  const cachedOffsetStyleRef = import_react29.default.useRef(offsetStyle);
  if (ready) {
    cachedOffsetStyleRef.current = offsetStyle;
  }
  const sizeStyle = {};
  if (popupSize) {
    sizeStyle.width = popupSize.width;
    sizeStyle.height = popupSize.height;
  }
  return import_react29.default.createElement(es_default2, _extends5({
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    removeOnLeave: false,
    leavedClassName: `${containerCls}-hidden`
  }, motion2, {
    visible: open3,
    onVisibleChanged: (nextVisible) => {
      setMotionVisible(nextVisible);
    }
  }), ({
    className: motionClassName,
    style: motionStyle
  }) => {
    const cls = clsx(containerCls, motionClassName, uniqueContainerClassName, {
      [`${containerCls}-visible`]: motionVisible
    });
    return import_react29.default.createElement("div", {
      className: cls,
      style: {
        "--arrow-x": `${(arrowPos == null ? void 0 : arrowPos.x) || 0}px`,
        "--arrow-y": `${(arrowPos == null ? void 0 : arrowPos.y) || 0}px`,
        ...cachedOffsetStyleRef.current,
        ...sizeStyle,
        ...motionStyle,
        ...uniqueContainerStyle
      }
    });
  });
};
var UniqueContainer_default = UniqueContainer;

// node_modules/@rc-component/trigger/es/UniqueProvider/index.js
var UniqueProvider = ({
  children,
  postTriggerProps
}) => {
  const [trigger, open3, options, onTargetVisibleChanged] = useTargetState();
  const mergedOptions = React53.useMemo(() => {
    if (!options || !postTriggerProps) {
      return options;
    }
    return postTriggerProps(options);
  }, [options, postTriggerProps]);
  const [popupEle, setPopupEle] = React53.useState(null);
  const [popupSize, setPopupSize] = React53.useState(null);
  const externalPopupRef = React53.useRef(null);
  const setPopupRef = useEvent_default((node2) => {
    externalPopupRef.current = node2;
    if (isDOM(node2) && popupEle !== node2) {
      setPopupEle(node2);
    }
  });
  const isOpenRef = React53.useRef(null);
  const delayInvoke = useDelay();
  const show = useEvent_default((showOptions, isOpen) => {
    isOpenRef.current = isOpen;
    delayInvoke(() => {
      trigger(showOptions);
    }, showOptions.delay);
  });
  const hide = (delay) => {
    delayInvoke(() => {
      var _a;
      if ((_a = isOpenRef.current) == null ? void 0 : _a.call(isOpenRef)) {
        return;
      }
      trigger(false);
    }, delay);
  };
  const onVisibleChanged = useEvent_default((visible) => {
    onTargetVisibleChanged(visible);
  });
  const [
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    arrowX,
    arrowY,
    // scaleX - not used in UniqueProvider
    ,
    ,
    // scaleY - not used in UniqueProvider
    alignInfo,
    onAlign
  ] = useAlign(
    open3,
    popupEle,
    mergedOptions == null ? void 0 : mergedOptions.target,
    mergedOptions == null ? void 0 : mergedOptions.popupPlacement,
    (mergedOptions == null ? void 0 : mergedOptions.builtinPlacements) || {},
    mergedOptions == null ? void 0 : mergedOptions.popupAlign,
    void 0,
    // onPopupAlign
    false
    // isMobile
  );
  const alignedClassName = React53.useMemo(() => {
    var _a;
    if (!mergedOptions) {
      return "";
    }
    const baseClassName = getAlignPopupClassName(
      mergedOptions.builtinPlacements || {},
      mergedOptions.prefixCls || "",
      alignInfo,
      false
      // alignPoint is false for UniqueProvider
    );
    return clsx(baseClassName, (_a = mergedOptions.getPopupClassNameFromAlign) == null ? void 0 : _a.call(mergedOptions, alignInfo));
  }, [alignInfo, mergedOptions == null ? void 0 : mergedOptions.getPopupClassNameFromAlign, mergedOptions == null ? void 0 : mergedOptions.builtinPlacements, mergedOptions == null ? void 0 : mergedOptions.prefixCls]);
  const contextValue = React53.useMemo(() => ({
    show,
    hide
  }), []);
  React53.useEffect(() => {
    onAlign();
  }, [mergedOptions == null ? void 0 : mergedOptions.target]);
  const onPrepare = useEvent_default(() => {
    onAlign();
    return Promise.resolve();
  });
  const subPopupElements = React53.useRef({});
  const parentContext = React53.useContext(context_default2);
  const triggerContextValue = React53.useMemo(() => ({
    registerSubPopup: (id, subPopupEle) => {
      subPopupElements.current[id] = subPopupEle;
      parentContext == null ? void 0 : parentContext.registerSubPopup(id, subPopupEle);
    }
  }), [parentContext]);
  const prefixCls = mergedOptions == null ? void 0 : mergedOptions.prefixCls;
  return React53.createElement(UniqueContext.Provider, {
    value: contextValue
  }, children, mergedOptions && React53.createElement(context_default2.Provider, {
    value: triggerContextValue
  }, React53.createElement(Popup_default, {
    ref: setPopupRef,
    portal: es_default3,
    prefixCls,
    popup: mergedOptions.popup,
    className: clsx(mergedOptions.popupClassName, alignedClassName, `${prefixCls}-unique-controlled`),
    style: mergedOptions.popupStyle,
    target: mergedOptions.target,
    open: open3,
    keepDom: true,
    fresh: true,
    autoDestroy: false,
    onVisibleChanged,
    ready,
    offsetX,
    offsetY,
    offsetR,
    offsetB,
    onAlign,
    onPrepare,
    onResize: (size) => setPopupSize({
      width: size.offsetWidth,
      height: size.offsetHeight
    }),
    arrowPos: {
      x: arrowX,
      y: arrowY
    },
    align: alignInfo,
    zIndex: mergedOptions.zIndex,
    mask: mergedOptions.mask,
    arrow: mergedOptions.arrow,
    motion: mergedOptions.popupMotion,
    maskMotion: mergedOptions.maskMotion,
    getPopupContainer: mergedOptions.getPopupContainer
  }, React53.createElement(UniqueContainer_default, {
    prefixCls,
    isMobile: false,
    ready,
    open: open3,
    align: alignInfo,
    offsetR,
    offsetB,
    offsetX,
    offsetY,
    arrowPos: {
      x: arrowX,
      y: arrowY
    },
    popupSize,
    motion: mergedOptions.popupMotion,
    uniqueContainerClassName: clsx(mergedOptions.uniqueContainerClassName, alignedClassName),
    uniqueContainerStyle: mergedOptions.uniqueContainerStyle
  }))));
};
var UniqueProvider_default = UniqueProvider;

// node_modules/@rc-component/trigger/es/index.js
function generateTrigger(PortalComponent = es_default3) {
  const Trigger = React54.forwardRef((props, ref) => {
    const {
      prefixCls = "rc-trigger-popup",
      children,
      // Action
      action = "hover",
      showAction,
      hideAction,
      // Open
      popupVisible,
      defaultPopupVisible,
      onOpenChange,
      afterOpenChange,
      onPopupVisibleChange,
      afterPopupVisibleChange,
      // Delay
      mouseEnterDelay,
      mouseLeaveDelay = 0.1,
      focusDelay,
      blurDelay,
      // Mask
      mask,
      maskClosable = true,
      // Portal
      getPopupContainer,
      forceRender,
      autoDestroy,
      // Popup
      popup,
      popupClassName,
      uniqueContainerClassName,
      uniqueContainerStyle,
      popupStyle,
      popupPlacement,
      builtinPlacements = {},
      popupAlign,
      zIndex,
      stretch,
      getPopupClassNameFromAlign,
      fresh,
      unique,
      alignPoint,
      onPopupClick,
      onPopupAlign,
      // Arrow
      arrow,
      // Motion
      popupMotion,
      maskMotion,
      // Private
      mobile,
      ...restProps
    } = props;
    const mergedAutoDestroy = autoDestroy || false;
    const openUncontrolled = popupVisible === void 0;
    const isMobile2 = !!mobile;
    const subPopupElements = React54.useRef({});
    const parentContext = React54.useContext(context_default2);
    const context = React54.useMemo(() => {
      return {
        registerSubPopup: (id2, subPopupEle) => {
          subPopupElements.current[id2] = subPopupEle;
          parentContext == null ? void 0 : parentContext.registerSubPopup(id2, subPopupEle);
        }
      };
    }, [parentContext]);
    const uniqueContext = React54.useContext(UniqueContext);
    const id = useId_default();
    const [popupEle, setPopupEle] = React54.useState(null);
    const externalPopupRef = React54.useRef(null);
    const setPopupRef = useEvent_default((node2) => {
      externalPopupRef.current = node2;
      if (isDOM(node2) && popupEle !== node2) {
        setPopupEle(node2);
      }
      parentContext == null ? void 0 : parentContext.registerSubPopup(id, node2);
    });
    const [targetEle, setTargetEle] = React54.useState(null);
    const externalForwardRef = React54.useRef(null);
    const setTargetRef = useEvent_default((node2) => {
      if (isDOM(node2) && targetEle !== node2) {
        setTargetEle(node2);
        externalForwardRef.current = node2;
      }
    });
    const cloneProps = {};
    const inPopupOrChild = useEvent_default((ele) => {
      var _a, _b;
      const childDOM = targetEle;
      return (childDOM == null ? void 0 : childDOM.contains(ele)) || ((_a = getShadowRoot(childDOM)) == null ? void 0 : _a.host) === ele || ele === childDOM || (popupEle == null ? void 0 : popupEle.contains(ele)) || ((_b = getShadowRoot(popupEle)) == null ? void 0 : _b.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle) => (subPopupEle == null ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle);
    });
    const innerArrow = arrow ? {
      // true and Object likely
      ...arrow !== true ? arrow : {}
    } : null;
    const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);
    const mergedOpen = internalOpen || false;
    const child = React54.useMemo(() => {
      const nextChild = typeof children === "function" ? children({
        open: mergedOpen
      }) : children;
      return React54.Children.only(nextChild);
    }, [children, mergedOpen]);
    const originChildProps = (child == null ? void 0 : child.props) || {};
    const isOpen = useEvent_default(() => mergedOpen);
    const getUniqueOptions = useEvent_default((delay = 0) => ({
      popup,
      target: targetEle,
      delay,
      prefixCls,
      popupClassName,
      uniqueContainerClassName,
      uniqueContainerStyle,
      popupStyle,
      popupPlacement,
      builtinPlacements,
      popupAlign,
      zIndex,
      mask,
      maskClosable,
      popupMotion,
      maskMotion,
      arrow: innerArrow,
      getPopupContainer,
      getPopupClassNameFromAlign,
      id
    }));
    useLayoutEffect_default(() => {
      if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {
        if (mergedOpen) {
          uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);
        } else {
          uniqueContext.hide(mouseLeaveDelay);
        }
      }
    }, [mergedOpen, targetEle]);
    const openRef = React54.useRef(mergedOpen);
    openRef.current = mergedOpen;
    const lastTriggerRef = React54.useRef([]);
    lastTriggerRef.current = [];
    const internalTriggerOpen = useEvent_default((nextOpen) => {
      setInternalOpen(nextOpen);
      if ((lastTriggerRef.current[lastTriggerRef.current.length - 1] ?? mergedOpen) !== nextOpen) {
        lastTriggerRef.current.push(nextOpen);
        onOpenChange == null ? void 0 : onOpenChange(nextOpen);
        onPopupVisibleChange == null ? void 0 : onPopupVisibleChange(nextOpen);
      }
    });
    const delayInvoke = useDelay();
    const triggerOpen = (nextOpen, delay = 0) => {
      if (popupVisible !== void 0) {
        delayInvoke(() => {
          internalTriggerOpen(nextOpen);
        }, delay);
        return;
      }
      if (uniqueContext && unique && openUncontrolled && !parentContext) {
        if (nextOpen) {
          uniqueContext.show(getUniqueOptions(delay), isOpen);
        } else {
          uniqueContext.hide(delay);
        }
        return;
      }
      delayInvoke(() => {
        internalTriggerOpen(nextOpen);
      }, delay);
    };
    const [inMotion, setInMotion] = React54.useState(false);
    useLayoutEffect_default((firstMount) => {
      if (!firstMount || mergedOpen) {
        setInMotion(true);
      }
    }, [mergedOpen]);
    const [motionPrepareResolve, setMotionPrepareResolve] = React54.useState(null);
    const [mousePos, setMousePos] = React54.useState(null);
    const setMousePosByEvent = (event) => {
      setMousePos([event.clientX, event.clientY]);
    };
    const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile2);
    const [showActions, hideActions] = useAction(action, showAction, hideAction);
    const clickToShow = showActions.has("click");
    const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
    const triggerAlign = useEvent_default(() => {
      if (!inMotion) {
        onAlign();
      }
    });
    const onScroll = () => {
      if (openRef.current && alignPoint && clickToHide) {
        triggerOpen(false);
      }
    };
    useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
    useLayoutEffect_default(() => {
      triggerAlign();
    }, [mousePos, popupPlacement]);
    useLayoutEffect_default(() => {
      if (mergedOpen && !(builtinPlacements == null ? void 0 : builtinPlacements[popupPlacement])) {
        triggerAlign();
      }
    }, [JSON.stringify(popupAlign)]);
    const alignedClassName = React54.useMemo(() => {
      const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
      return clsx(baseClassName, getPopupClassNameFromAlign == null ? void 0 : getPopupClassNameFromAlign(alignInfo));
    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
    React54.useImperativeHandle(ref, () => ({
      nativeElement: externalForwardRef.current,
      popupElement: externalPopupRef.current,
      forceAlign: triggerAlign
    }));
    const [targetWidth, setTargetWidth] = React54.useState(0);
    const [targetHeight, setTargetHeight] = React54.useState(0);
    const syncTargetSize = () => {
      if (stretch && targetEle) {
        const rect = targetEle.getBoundingClientRect();
        setTargetWidth(rect.width);
        setTargetHeight(rect.height);
      }
    };
    const onTargetResize = () => {
      syncTargetSize();
      triggerAlign();
    };
    const onVisibleChanged = (visible) => {
      setInMotion(false);
      onAlign();
      afterOpenChange == null ? void 0 : afterOpenChange(visible);
      afterPopupVisibleChange == null ? void 0 : afterPopupVisibleChange(visible);
    };
    const onPrepare = () => new Promise((resolve) => {
      syncTargetSize();
      setMotionPrepareResolve(() => resolve);
    });
    useLayoutEffect_default(() => {
      if (motionPrepareResolve) {
        onAlign();
        motionPrepareResolve();
        setMotionPrepareResolve(null);
      }
    }, [motionPrepareResolve]);
    function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {
      cloneProps[eventName] = (event, ...args) => {
        var _a;
        if (!ignoreCheck || !ignoreCheck()) {
          callback == null ? void 0 : callback(event);
          triggerOpen(nextOpen, delay);
        }
        (_a = originChildProps[eventName]) == null ? void 0 : _a.call(originChildProps, event, ...args);
      };
    }
    const touchToShow = showActions.has("touch");
    const touchToHide = hideActions.has("touch");
    const touchedRef = React54.useRef(false);
    if (touchToShow || touchToHide) {
      cloneProps.onTouchStart = (...args) => {
        var _a;
        touchedRef.current = true;
        if (openRef.current && touchToHide) {
          triggerOpen(false);
        } else if (!openRef.current && touchToShow) {
          triggerOpen(true);
        }
        (_a = originChildProps.onTouchStart) == null ? void 0 : _a.call(originChildProps, ...args);
      };
    }
    if (clickToShow || clickToHide) {
      cloneProps.onClick = (event, ...args) => {
        var _a;
        if (openRef.current && clickToHide) {
          triggerOpen(false);
        } else if (!openRef.current && clickToShow) {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        (_a = originChildProps.onClick) == null ? void 0 : _a.call(originChildProps, event, ...args);
        touchedRef.current = false;
      };
    }
    const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
    const hoverToShow = showActions.has("hover");
    const hoverToHide = hideActions.has("hover");
    let onPopupMouseEnter;
    let onPopupMouseLeave;
    const ignoreMouseTrigger = () => {
      return touchedRef.current;
    };
    if (hoverToShow) {
      const onMouseEnterCallback = (event) => {
        setMousePosByEvent(event);
      };
      wrapperAction("onMouseEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
      wrapperAction("onPointerEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
      onPopupMouseEnter = (event) => {
        if ((mergedOpen || inMotion) && (popupEle == null ? void 0 : popupEle.contains(event.target))) {
          triggerOpen(true, mouseEnterDelay);
        }
      };
      if (alignPoint) {
        cloneProps.onMouseMove = (event) => {
          var _a;
          (_a = originChildProps.onMouseMove) == null ? void 0 : _a.call(originChildProps, event);
        };
      }
    }
    if (hoverToHide) {
      wrapperAction("onMouseLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
      wrapperAction("onPointerLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
      onPopupMouseLeave = () => {
        triggerOpen(false, mouseLeaveDelay);
      };
    }
    if (showActions.has("focus")) {
      wrapperAction("onFocus", true, focusDelay);
    }
    if (hideActions.has("focus")) {
      wrapperAction("onBlur", false, blurDelay);
    }
    if (showActions.has("contextMenu")) {
      cloneProps.onContextMenu = (event, ...args) => {
        var _a;
        if (openRef.current && hideActions.has("contextMenu")) {
          triggerOpen(false);
        } else {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        event.preventDefault();
        (_a = originChildProps.onContextMenu) == null ? void 0 : _a.call(originChildProps, event, ...args);
      };
    }
    const rendedRef = React54.useRef(false);
    rendedRef.current || (rendedRef.current = forceRender || mergedOpen || inMotion);
    const mergedChildrenProps = {
      ...originChildProps,
      ...cloneProps
    };
    const passedProps = {};
    const passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    passedEventList.forEach((eventName) => {
      if (restProps[eventName]) {
        passedProps[eventName] = (...args) => {
          var _a;
          (_a = mergedChildrenProps[eventName]) == null ? void 0 : _a.call(mergedChildrenProps, ...args);
          restProps[eventName](...args);
        };
      }
    });
    const arrowPos = {
      x: arrowX,
      y: arrowY
    };
    const triggerNode = React54.cloneElement(child, {
      ...mergedChildrenProps,
      ...passedProps
    });
    return React54.createElement(React54.Fragment, null, React54.createElement(es_default, {
      disabled: !mergedOpen,
      ref: setTargetRef,
      onResize: onTargetResize
    }, triggerNode), rendedRef.current && (!uniqueContext || !unique) && React54.createElement(context_default2.Provider, {
      value: context
    }, React54.createElement(Popup_default, {
      portal: PortalComponent,
      ref: setPopupRef,
      prefixCls,
      popup,
      className: clsx(popupClassName, !isMobile2 && alignedClassName),
      style: popupStyle,
      target: targetEle,
      onMouseEnter: onPopupMouseEnter,
      onMouseLeave: onPopupMouseLeave,
      onPointerEnter: onPopupMouseEnter,
      zIndex,
      open: mergedOpen,
      keepDom: inMotion,
      fresh,
      onClick: onPopupClick,
      onPointerDownCapture: onPopupPointerDown,
      mask,
      motion: popupMotion,
      maskMotion,
      onVisibleChanged,
      onPrepare,
      forceRender,
      autoDestroy: mergedAutoDestroy,
      getPopupContainer,
      align: alignInfo,
      arrow: innerArrow,
      arrowPos,
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      onAlign: triggerAlign,
      stretch,
      targetWidth: targetWidth / scaleX,
      targetHeight: targetHeight / scaleY,
      mobile
    })));
  });
  if (true) {
    Trigger.displayName = "Trigger";
  }
  return Trigger;
}
var es_default4 = generateTrigger(es_default3);

// node_modules/antd/es/tooltip/UniqueProvider/MotionContent.js
var import_react30 = __toESM(require_react());
var MotionContent = ({
  children
}) => {
  const {
    getPrefixCls
  } = import_react30.default.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  if (!import_react30.default.isValidElement(children)) {
    return children;
  }
  return import_react30.default.createElement(es_default2, {
    visible: true,
    motionName: `${rootPrefixCls}-fade`,
    motionAppear: true,
    motionEnter: true,
    motionLeave: false,
    removeOnLeave: false
  }, ({
    style: motionStyle,
    className: motionClassName
  }) => {
    const {
      className,
      style: style2
    } = children.props;
    const mergedStyles = {
      ...style2,
      ...motionStyle
    };
    return import_react30.default.cloneElement(children, {
      className: clsx(className, motionClassName),
      style: mergedStyles
    });
  });
};
var MotionContent_default = MotionContent;

// node_modules/antd/es/tooltip/UniqueProvider/index.js
var cachedPlacements = [null, null];
function uniqueBuiltinPlacements(ori) {
  if (cachedPlacements[0] !== ori) {
    const target = {};
    Object.keys(ori).forEach((placement) => {
      target[placement] = {
        ...ori[placement],
        dynamicInset: false
      };
    });
    cachedPlacements[0] = ori;
    cachedPlacements[1] = target;
  }
  return cachedPlacements[1];
}
var UniqueProvider2 = ({
  children
}) => {
  const renderPopup = (options) => {
    const popupEle = typeof options.popup === "function" ? options.popup() : options.popup;
    const {
      id,
      builtinPlacements
    } = options;
    const parsedPlacements = uniqueBuiltinPlacements(builtinPlacements);
    return {
      ...options,
      getPopupContainer: null,
      arrow: false,
      popup: import_react31.default.createElement(MotionContent_default, {
        key: id
      }, popupEle),
      builtinPlacements: parsedPlacements
    };
  };
  return import_react31.default.createElement(UniqueProvider_default, {
    postTriggerProps: renderPopup
  }, children);
};
var UniqueProvider_default2 = UniqueProvider2;

// node_modules/antd/es/config-provider/DisabledContext.js
var React57 = __toESM(require_react());
var DisabledContext = React57.createContext(false);
var DisabledContextProvider = ({
  children,
  disabled
}) => {
  const originDisabled = React57.useContext(DisabledContext);
  return React57.createElement(DisabledContext.Provider, {
    value: disabled ?? originDisabled
  }, children);
};
var DisabledContext_default = DisabledContext;

// node_modules/antd/es/config-provider/hooks/useConfig.js
var import_react32 = __toESM(require_react());

// node_modules/antd/es/config-provider/SizeContext.js
var React58 = __toESM(require_react());
var SizeContext = React58.createContext(void 0);
var SizeContextProvider = ({
  children,
  size
}) => {
  const originSize = React58.useContext(SizeContext);
  return React58.createElement(SizeContext.Provider, {
    value: size || originSize
  }, children);
};
var SizeContext_default = SizeContext;

// node_modules/antd/es/config-provider/hooks/useConfig.js
function useConfig() {
  const componentDisabled = (0, import_react32.useContext)(DisabledContext_default);
  const componentSize = (0, import_react32.useContext)(SizeContext_default);
  return {
    componentDisabled,
    componentSize
  };
}
var useConfig_default = useConfig;

// node_modules/antd/es/config-provider/hooks/useTheme.js
var import_react33 = __toESM(require_react());
function useTheme(theme, parentTheme, config) {
  var _a;
  const warning5 = devUseWarning("ConfigProvider");
  const themeConfig = theme || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
    ...defaultConfig,
    hashed: (parentTheme == null ? void 0 : parentTheme.hashed) ?? defaultConfig.hashed,
    cssVar: parentTheme == null ? void 0 : parentTheme.cssVar
  } : parentTheme;
  const themeKey = (0, import_react33.useId)();
  if (true) {
    const cssVarEnabled = themeConfig.cssVar || parentThemeConfig.cssVar;
    const validKey = !!(typeof themeConfig.cssVar === "object" && ((_a = themeConfig.cssVar) == null ? void 0 : _a.key) || themeKey);
    true ? warning5(!cssVarEnabled || validKey, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.") : void 0;
  }
  return useMemo(() => {
    var _a2;
    if (!theme) {
      return parentTheme;
    }
    const mergedComponents = {
      ...parentThemeConfig.components
    };
    Object.keys(theme.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = {
        ...mergedComponents[componentName],
        ...theme.components[componentName]
      };
    });
    const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
    const mergedCssVar = {
      prefix: config == null ? void 0 : config.prefixCls,
      // Same as prefixCls by default
      ...parentThemeConfig.cssVar,
      ...themeConfig.cssVar,
      key: ((_a2 = themeConfig.cssVar) == null ? void 0 : _a2.key) || cssVarKey
    };
    return {
      ...parentThemeConfig,
      ...themeConfig,
      token: {
        ...parentThemeConfig.token,
        ...themeConfig.token
      },
      components: mergedComponents,
      cssVar: mergedCssVar
    };
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
    const nextTheme = next2[index2];
    return !isEqual_default(prevTheme, nextTheme, true);
  }));
}

// node_modules/antd/es/config-provider/MotionWrapper.js
var React59 = __toESM(require_react());
var MotionCacheContext = React59.createContext(true);
if (true) {
  MotionCacheContext.displayName = "MotionCacheContext";
}
function MotionWrapper(props) {
  const parentMotion = React59.useContext(MotionCacheContext);
  const {
    children
  } = props;
  const [, token2] = useToken();
  const {
    motion: motion2
  } = token2;
  const needWrapMotionProviderRef = React59.useRef(false);
  needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion2);
  if (needWrapMotionProviderRef.current) {
    return React59.createElement(MotionCacheContext.Provider, {
      value: motion2
    }, React59.createElement(MotionProvider, {
      motion: motion2
    }, children));
  }
  return children;
}

// node_modules/antd/es/config-provider/PropWarning.js
var React60 = __toESM(require_react());
var PropWarning = React60.memo(({
  dropdownMatchSelectWidth
}) => {
  const warning5 = devUseWarning("ConfigProvider");
  warning5.deprecated(dropdownMatchSelectWidth === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth");
  return null;
});
if (true) {
  PropWarning.displayName = "PropWarning";
}
var PropWarning_default = true ? PropWarning : () => null;

// node_modules/antd/es/config-provider/index.js
var existThemeConfig = false;
var warnContext = true ? (componentName) => {
  true ? warning_default2(!existThemeConfig, componentName, `Static function can not consume context like dynamic theme. Please use 'App' component instead.`) : void 0;
} : (
  /* istanbul ignore next */
  null
);
var PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
var globalPrefixCls;
var globalIconPrefixCls;
var globalTheme;
var globalHolderRender;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
var setGlobalConfig = (props) => {
  const {
    prefixCls,
    iconPrefixCls,
    theme,
    holderRender
  } = props;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if ("holderRender" in props) {
    globalHolderRender = holderRender;
  }
  if (theme) {
    globalTheme = theme;
  }
};
var globalConfig = () => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalPrefixCls) {
      return globalPrefixCls;
    }
    return getGlobalPrefixCls();
  },
  getTheme: () => globalTheme,
  holderRender: globalHolderRender
});
var ProviderChildren = (props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    alert,
    affix,
    anchor,
    form,
    locale: locale6,
    componentSize,
    direction,
    space,
    splitter,
    virtual,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    popupOverflow,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme,
    componentDisabled,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    masonry,
    menu,
    pagination,
    input,
    textArea,
    otp,
    empty: empty2,
    badge,
    radio,
    rate,
    ribbon,
    switch: SWITCH,
    transfer,
    avatar,
    message: message2,
    tag,
    table,
    card,
    cardMeta,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification: notification2,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    tooltip,
    popover,
    popconfirm,
    qrcode,
    floatButton,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect,
    watermark
  } = props;
  const getPrefixCls = React61.useCallback((suffixCls, customizePrefixCls) => {
    const {
      prefixCls
    } = props;
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
  const csp = customCsp || parentContext.csp;
  useResetIconStyle_default(iconPrefixCls, csp);
  const mergedTheme = useTheme(theme, parentContext.theme, {
    prefixCls: getPrefixCls("")
  });
  if (true) {
    existThemeConfig = existThemeConfig || !!mergedTheme;
  }
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    alert,
    affix,
    anchor,
    locale: locale6 || legacyLocale,
    direction,
    space,
    splitter,
    virtual,
    popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
    popupOverflow,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme,
    segmented,
    statistic: statistic2,
    spin,
    calendar,
    carousel,
    cascader,
    collapse,
    typography,
    checkbox,
    descriptions,
    divider,
    drawer,
    skeleton,
    steps,
    image,
    input,
    textArea,
    otp,
    layout,
    list,
    mentions,
    modal,
    progress,
    result,
    slider,
    breadcrumb,
    masonry,
    menu,
    pagination,
    empty: empty2,
    badge,
    radio,
    rate,
    ribbon,
    switch: SWITCH,
    transfer,
    avatar,
    message: message2,
    tag,
    table,
    card,
    cardMeta,
    tabs,
    timeline,
    timePicker,
    upload: upload2,
    notification: notification2,
    tree,
    colorPicker,
    datePicker,
    rangePicker,
    flex,
    wave,
    dropdown,
    warning: warningConfig,
    tour,
    tooltip,
    popover,
    popconfirm,
    qrcode,
    floatButton,
    floatButtonGroup,
    variant,
    inputNumber,
    treeSelect,
    watermark
  };
  if (true) {
    const warningFn = devUseWarning("ConfigProvider");
    warningFn(!("autoInsertSpaceInButton" in props), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  }
  const config = {
    ...parentContext
  };
  Object.keys(baseConfig).forEach((key) => {
    if (baseConfig[key] !== void 0) {
      config[key] = baseConfig[key];
    }
  });
  PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  if (typeof autoInsertSpaceInButton !== "undefined") {
    config.button = {
      autoInsertSpace: autoInsertSpaceInButton,
      ...config.button
    };
  }
  const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
    const prevKeys = Object.keys(prevConfig);
    const currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
  });
  const {
    layer
  } = React61.useContext(StyleContext_default);
  const memoIconContextValue = React61.useMemo(() => ({
    prefixCls: iconPrefixCls,
    csp,
    layer: layer ? "antd" : void 0
  }), [iconPrefixCls, csp, layer]);
  let childNode = React61.createElement(React61.Fragment, null, React61.createElement(PropWarning_default, {
    dropdownMatchSelectWidth
  }), children);
  const validateMessages = React61.useMemo(() => {
    var _a, _b, _c, _d;
    return merge(((_a = en_US_default6.Form) == null ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) == null ? void 0 : _b.Form) == null ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) == null ? void 0 : _d.validateMessages) || {}, (form == null ? void 0 : form.validateMessages) || {});
  }, [memoedConfig, form == null ? void 0 : form.validateMessages]);
  if (Object.keys(validateMessages).length > 0) {
    childNode = React61.createElement(validateMessagesContext_default.Provider, {
      value: validateMessages
    }, childNode);
  }
  if (locale6) {
    childNode = React61.createElement(locale_default, {
      locale: locale6,
      _ANT_MARK__: ANT_MARK
    }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = React61.createElement(Context_default.Provider, {
      value: memoIconContextValue
    }, childNode);
  }
  if (componentSize) {
    childNode = React61.createElement(SizeContextProvider, {
      size: componentSize
    }, childNode);
  }
  childNode = React61.createElement(MotionWrapper, null, childNode);
  if (tooltip == null ? void 0 : tooltip.unique) {
    childNode = React61.createElement(UniqueProvider_default2, null, childNode);
  }
  const memoTheme = React61.useMemo(() => {
    const {
      algorithm,
      token: token2,
      components: components2,
      cssVar,
      ...rest
    } = mergedTheme || {};
    const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : theme_default;
    const parsedComponents = {};
    Object.entries(components2 || {}).forEach(([componentName, componentToken]) => {
      const parsedToken = {
        ...componentToken
      };
      if ("algorithm" in parsedToken) {
        if (parsedToken.algorithm === true) {
          parsedToken.theme = themeObj;
        } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
          parsedToken.theme = createTheme(parsedToken.algorithm);
        }
        delete parsedToken.algorithm;
      }
      parsedComponents[componentName] = parsedToken;
    });
    const mergedToken = {
      ...seed_default,
      ...token2
    };
    return {
      ...rest,
      theme: themeObj,
      token: mergedToken,
      components: parsedComponents,
      override: {
        override: mergedToken,
        ...parsedComponents
      },
      cssVar
    };
  }, [mergedTheme]);
  if (theme) {
    childNode = React61.createElement(DesignTokenContext.Provider, {
      value: memoTheme
    }, childNode);
  }
  if (memoedConfig.warning) {
    childNode = React61.createElement(WarningContext.Provider, {
      value: memoedConfig.warning
    }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = React61.createElement(DisabledContextProvider, {
      disabled: componentDisabled
    }, childNode);
  }
  return React61.createElement(ConfigContext.Provider, {
    value: memoedConfig
  }, childNode);
};
var ConfigProvider = (props) => {
  const context = React61.useContext(ConfigContext);
  const antLocale = React61.useContext(context_default);
  return React61.createElement(ProviderChildren, {
    parentContext: context,
    legacyLocale: antLocale,
    ...props
  });
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext_default;
ConfigProvider.config = setGlobalConfig;
ConfigProvider.useConfig = useConfig_default;
Object.defineProperty(ConfigProvider, "SizeContext", {
  get: () => {
    true ? warning_default2(false, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead.") : void 0;
    return SizeContext_default;
  }
});
if (true) {
  ConfigProvider.displayName = "ConfigProvider";
}
var config_provider_default = ConfigProvider;

// node_modules/antd/es/anchor/context.js
var React62 = __toESM(require_react());
var AnchorContext = React62.createContext(void 0);
var context_default3 = AnchorContext;

// node_modules/antd/es/anchor/AnchorLink.js
var AnchorLink = (props) => {
  const {
    href,
    title,
    prefixCls: customizePrefixCls,
    children,
    className,
    target,
    replace: replace2
  } = props;
  const context = React63.useContext(context_default3);
  const {
    registerLink,
    unregisterLink,
    scrollTo: scrollTo2,
    onClick,
    activeLink,
    direction,
    classNames: mergedClassNames,
    styles: mergedStyles
  } = context || {};
  React63.useEffect(() => {
    registerLink == null ? void 0 : registerLink(href);
    return () => {
      unregisterLink == null ? void 0 : unregisterLink(href);
    };
  }, [href]);
  const handleClick = (e3) => {
    onClick == null ? void 0 : onClick(e3, {
      title,
      href
    });
    scrollTo2 == null ? void 0 : scrollTo2(href);
    if (e3.defaultPrevented) {
      return;
    }
    const isExternalLink = href.startsWith("http://") || href.startsWith("https://");
    if (isExternalLink) {
      if (replace2) {
        e3.preventDefault();
        window.location.replace(href);
      }
      return;
    }
    e3.preventDefault();
    const historyMethod = replace2 ? "replaceState" : "pushState";
    window.history[historyMethod](null, "", href);
  };
  if (true) {
    const warning5 = devUseWarning("Anchor.Link");
    true ? warning5(!children || direction !== "horizontal", "usage", "`Anchor.Link children` is not supported when `Anchor` direction is horizontal") : void 0;
  }
  const {
    getPrefixCls
  } = React63.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customizePrefixCls);
  const active = activeLink === href;
  const wrapperClassName = clsx(`${prefixCls}-link`, className, mergedClassNames == null ? void 0 : mergedClassNames.item, {
    [`${prefixCls}-link-active`]: active
  });
  const titleClassName = clsx(`${prefixCls}-link-title`, mergedClassNames == null ? void 0 : mergedClassNames.itemTitle, {
    [`${prefixCls}-link-title-active`]: active
  });
  return React63.createElement("div", {
    className: wrapperClassName,
    style: mergedStyles == null ? void 0 : mergedStyles.item
  }, React63.createElement("a", {
    className: titleClassName,
    style: mergedStyles == null ? void 0 : mergedStyles.itemTitle,
    href,
    title: typeof title === "string" ? title : "",
    target,
    onClick: handleClick
  }, title), direction !== "horizontal" ? children : null);
};
var AnchorLink_default = AnchorLink;

// node_modules/antd/es/anchor/style/index.js
var genSharedAnchorStyle = (token2) => {
  const {
    componentCls,
    holderOffsetBlock,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary,
    lineType,
    colorSplit,
    calc
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      marginBlockStart: calc(holderOffsetBlock).mul(-1).equal(),
      paddingBlockStart: holderOffsetBlock,
      // delete overflow: auto
      // overflow: 'auto',
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        paddingInlineStart: lineWidthBold,
        [`${componentCls}-link`]: {
          paddingBlock: token2.linkPaddingBlock,
          paddingInline: `${unit(token2.linkPaddingInlineStart)} 0`,
          "&-title": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            marginBlockEnd: token2.anchorTitleBlock,
            color: token2.colorText,
            transition: `all ${token2.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          },
          [`&-active > ${componentCls}-link-title`]: {
            color: token2.colorPrimary
          },
          // link link
          [`${componentCls}-link`]: {
            paddingBlock: token2.anchorPaddingBlockSecondary
          }
        }
      },
      [`&:not(${componentCls}-wrapper-horizontal)`]: {
        [componentCls]: {
          "&::before": {
            position: "absolute",
            insetInlineStart: 0,
            top: 0,
            height: "100%",
            borderInlineStart: `${unit(lineWidthBold)} ${lineType} ${colorSplit}`,
            content: '" "'
          },
          [`${componentCls}-ink`]: {
            position: "absolute",
            insetInlineStart: 0,
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${motionDurationSlow} ease-in-out`,
            width: lineWidthBold,
            backgroundColor: colorPrimary,
            [`&${componentCls}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${componentCls}-fixed ${componentCls}-ink ${componentCls}-ink`]: {
        display: "none"
      }
    }
  };
};
var genSharedAnchorHorizontalStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    lineWidthBold,
    colorPrimary
  } = token2;
  return {
    [`${componentCls}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: 0
        },
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
        content: '" "'
      },
      [componentCls]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
          /* Safari and Chrome */
        },
        [`${componentCls}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${componentCls}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${motionDurationSlow} ease-in-out, width ${motionDurationSlow} ease-in-out`,
          height: lineWidthBold,
          backgroundColor: colorPrimary
        }
      }
    }
  };
};
var prepareComponentToken3 = (token2) => ({
  linkPaddingBlock: token2.paddingXXS,
  linkPaddingInlineStart: token2.padding
});
var style_default3 = genStyleHooks("Anchor", (token2) => {
  const {
    fontSize,
    fontSizeLG,
    paddingXXS,
    calc
  } = token2;
  const anchorToken = merge2(token2, {
    holderOffsetBlock: paddingXXS,
    anchorPaddingBlockSecondary: calc(paddingXXS).div(2).equal(),
    anchorTitleBlock: calc(fontSize).div(14).mul(3).equal(),
    anchorBallSize: calc(fontSizeLG).div(2).equal()
  });
  return [genSharedAnchorStyle(anchorToken), genSharedAnchorHorizontalStyle(anchorToken)];
}, prepareComponentToken3);

// node_modules/antd/es/anchor/Anchor.js
function getDefaultContainer() {
  return window;
}
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  const rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      return rect.top - element.ownerDocument.documentElement.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
var sharpMatcherRegex = /#([\S ]+)$/;
var Anchor = (props) => {
  const {
    rootClassName,
    prefixCls: customPrefixCls,
    className,
    style: style2,
    offsetTop,
    affix = true,
    showInkInFixed = false,
    children,
    items,
    direction: anchorDirection = "vertical",
    bounds,
    targetOffset: targetOffset4,
    onClick,
    onChange,
    getContainer,
    getCurrentAnchor,
    replace: replace2,
    classNames,
    styles
  } = props;
  if (true) {
    const warning5 = devUseWarning("Anchor");
    warning5.deprecated(!children, "Anchor children", "items");
    true ? warning5(!(anchorDirection === "horizontal" && (items == null ? void 0 : items.some((n2) => "children" in n2))), "usage", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.") : void 0;
  }
  const [links, setLinks] = React64.useState([]);
  const [activeLink, setActiveLink] = React64.useState(null);
  const activeLinkRef = React64.useRef(activeLink);
  const wrapperRef = React64.useRef(null);
  const spanLinkNode = React64.useRef(null);
  const animating = React64.useRef(false);
  const scrollRequestId = React64.useRef(null);
  const {
    direction,
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("anchor");
  const {
    getTargetContainer
  } = React64.useContext(ConfigContext);
  const prefixCls = getPrefixCls("anchor", customPrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default3(prefixCls, rootCls);
  const getCurrentContainer = getContainer ?? getTargetContainer ?? getDefaultContainer;
  const dependencyListItem = JSON.stringify(links);
  const registerLink = useEvent_default((link) => {
    if (!links.includes(link)) {
      setLinks((prev2) => [].concat(_toConsumableArray(prev2), [link]));
    }
  });
  const unregisterLink = useEvent_default((link) => {
    if (links.includes(link)) {
      setLinks((prev2) => prev2.filter((i) => i !== link));
    }
  });
  const updateInk = () => {
    var _a;
    const linkNode = (_a = wrapperRef.current) == null ? void 0 : _a.querySelector(`.${prefixCls}-link-title-active`);
    if (linkNode && spanLinkNode.current) {
      const {
        style: inkStyle
      } = spanLinkNode.current;
      const horizontalAnchor = anchorDirection === "horizontal";
      inkStyle.top = horizontalAnchor ? "" : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;
      inkStyle.height = horizontalAnchor ? "" : `${linkNode.clientHeight}px`;
      inkStyle.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : "";
      inkStyle.width = horizontalAnchor ? `${linkNode.clientWidth}px` : "";
      if (horizontalAnchor) {
        e2(linkNode, {
          scrollMode: "if-needed",
          block: "nearest"
        });
      }
    }
  };
  const getInternalCurrentAnchor = (_links, _offsetTop = 0, _bounds = 5) => {
    const linkSections = [];
    const container = getCurrentContainer();
    _links.forEach((link) => {
      const sharpLinkMatch = sharpMatcherRegex.exec(link == null ? void 0 : link.toString());
      if (!sharpLinkMatch) {
        return;
      }
      const target = document.getElementById(sharpLinkMatch[1]);
      if (target) {
        const top = getOffsetTop(target, container);
        if (top <= _offsetTop + _bounds) {
          linkSections.push({
            link,
            top
          });
        }
      }
    });
    if (linkSections.length) {
      const maxSection = linkSections.reduce((prev2, curr) => curr.top > prev2.top ? curr : prev2);
      return maxSection.link;
    }
    return "";
  };
  const setCurrentActiveLink = useEvent_default((link) => {
    if (activeLinkRef.current === link) {
      return;
    }
    const newLink = typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link;
    setActiveLink(newLink);
    activeLinkRef.current = newLink;
    onChange == null ? void 0 : onChange(link);
  });
  const handleScroll = React64.useCallback(() => {
    if (animating.current) {
      return;
    }
    const currentActiveLink = getInternalCurrentAnchor(links, targetOffset4 !== void 0 ? targetOffset4 : offsetTop || 0, bounds);
    setCurrentActiveLink(currentActiveLink);
  }, [links, targetOffset4, offsetTop, bounds]);
  const handleScrollTo = React64.useCallback((link) => {
    var _a;
    const previousActiveLink = activeLinkRef.current;
    setCurrentActiveLink(link);
    const sharpLinkMatch = sharpMatcherRegex.exec(link);
    if (!sharpLinkMatch) {
      return;
    }
    const targetElement = document.getElementById(sharpLinkMatch[1]);
    if (!targetElement) {
      return;
    }
    if (animating.current) {
      if (previousActiveLink === link) {
        return;
      }
      (_a = scrollRequestId.current) == null ? void 0 : _a.call(scrollRequestId);
    }
    const container = getCurrentContainer();
    const scrollTop = getScroll_default(container);
    const eleOffsetTop = getOffsetTop(targetElement, container);
    let y = scrollTop + eleOffsetTop;
    y -= targetOffset4 !== void 0 ? targetOffset4 : offsetTop || 0;
    animating.current = true;
    scrollRequestId.current = scrollTo(y, {
      getContainer: getCurrentContainer,
      callback() {
        animating.current = false;
      }
    });
  }, [targetOffset4, offsetTop]);
  const mergedProps = {
    ...props,
    direction: anchorDirection
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const wrapperClass = clsx(hashId, cssVarCls, rootCls, rootClassName, `${prefixCls}-wrapper`, {
    [`${prefixCls}-wrapper-horizontal`]: anchorDirection === "horizontal",
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, contextClassName, mergedClassNames.root);
  const anchorClass = clsx(prefixCls, {
    [`${prefixCls}-fixed`]: !affix && !showInkInFixed
  });
  const inkClass = clsx(`${prefixCls}-ink`, mergedClassNames.indicator, {
    [`${prefixCls}-ink-visible`]: activeLink
  });
  const wrapperStyle = {
    maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : "100vh",
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const createNestedLink = (options) => Array.isArray(options) ? options.map((item) => React64.createElement(AnchorLink_default, {
    replace: replace2,
    ...item,
    key: item.key
  }, anchorDirection === "vertical" && createNestedLink(item.children))) : null;
  const anchorContent = React64.createElement("div", {
    ref: wrapperRef,
    className: wrapperClass,
    style: wrapperStyle
  }, React64.createElement("div", {
    className: anchorClass
  }, React64.createElement("span", {
    className: inkClass,
    ref: spanLinkNode,
    style: mergedStyles.indicator
  }), "items" in props ? createNestedLink(items) : children));
  React64.useEffect(() => {
    const scrollContainer = getCurrentContainer();
    handleScroll();
    scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", handleScroll);
    return () => {
      scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", handleScroll);
    };
  }, [dependencyListItem]);
  React64.useEffect(() => {
    if (typeof getCurrentAnchor === "function") {
      setCurrentActiveLink(getCurrentAnchor(activeLinkRef.current || ""));
    }
  }, [getCurrentAnchor]);
  React64.useEffect(() => {
    updateInk();
  }, [anchorDirection, getCurrentAnchor, dependencyListItem, activeLink]);
  const memoizedContextValue = React64.useMemo(() => ({
    registerLink,
    unregisterLink,
    scrollTo: handleScrollTo,
    activeLink,
    onClick,
    direction: anchorDirection,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [activeLink, onClick, handleScrollTo, anchorDirection, mergedStyles, mergedClassNames]);
  const affixProps = affix && typeof affix === "object" ? affix : void 0;
  return React64.createElement(context_default3.Provider, {
    value: memoizedContextValue
  }, affix ? React64.createElement(affix_default, {
    offsetTop,
    target: getCurrentContainer,
    ...affixProps
  }, anchorContent) : anchorContent);
};
if (true) {
  Anchor.displayName = "Anchor";
}
var Anchor_default = Anchor;

// node_modules/antd/es/anchor/index.js
var Anchor2 = Anchor_default;
Anchor2.Link = AnchorLink_default;
var anchor_default = Anchor2;

// node_modules/antd/es/app/App.js
var import_react71 = __toESM(require_react());

// node_modules/antd/es/message/useMessage.js
var React71 = __toESM(require_react());

// node_modules/@rc-component/notification/es/hooks/useNotification.js
var React69 = __toESM(require_react());

// node_modules/@rc-component/notification/es/Notifications.js
var React68 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@rc-component/notification/es/NoticeList.js
var import_react35 = __toESM(require_react());

// node_modules/@rc-component/util/es/KeyCode.js
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e3) {
    const {
      keyCode
    } = e3;
    if (e3.altKey && !e3.ctrlKey || e3.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var KeyCode_default = KeyCode;

// node_modules/@rc-component/notification/es/Notice.js
var React65 = __toESM(require_react());
function _extends6() {
  _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
var Notify = React65.forwardRef((props, ref) => {
  const {
    prefixCls,
    style: style2,
    className,
    duration = 4.5,
    showProgress,
    pauseOnHover = true,
    eventKey,
    content,
    closable,
    props: divProps,
    onClick,
    onNoticeClose,
    times,
    hovering: forcedHovering
  } = props;
  const [hovering, setHovering] = React65.useState(false);
  const [percent, setPercent] = React65.useState(0);
  const [spentTime, setSpentTime] = React65.useState(0);
  const mergedHovering = forcedHovering || hovering;
  const mergedDuration = typeof duration === "number" ? duration : 0;
  const mergedShowProgress = mergedDuration > 0 && showProgress;
  const onInternalClose = () => {
    onNoticeClose(eventKey);
  };
  const onCloseKeyDown = (e3) => {
    if (e3.key === "Enter" || e3.code === "Enter" || e3.keyCode === KeyCode_default.ENTER) {
      onInternalClose();
    }
  };
  React65.useEffect(() => {
    if (!mergedHovering && mergedDuration > 0) {
      const start = Date.now() - spentTime;
      const timeout = setTimeout(() => {
        onInternalClose();
      }, mergedDuration * 1e3 - spentTime);
      return () => {
        if (pauseOnHover) {
          clearTimeout(timeout);
        }
        setSpentTime(Date.now() - start);
      };
    }
  }, [mergedDuration, mergedHovering, times]);
  React65.useEffect(() => {
    if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
      const start = performance.now();
      let animationFrame;
      const calculate = () => {
        cancelAnimationFrame(animationFrame);
        animationFrame = requestAnimationFrame((timestamp) => {
          const runtime = timestamp + spentTime - start;
          const progress = Math.min(runtime / (mergedDuration * 1e3), 1);
          setPercent(progress * 100);
          if (progress < 1) {
            calculate();
          }
        });
      };
      calculate();
      return () => {
        if (pauseOnHover) {
          cancelAnimationFrame(animationFrame);
        }
      };
    }
  }, [mergedDuration, spentTime, mergedHovering, mergedShowProgress, times]);
  const closableObj = React65.useMemo(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    return {};
  }, [closable]);
  const ariaProps = pickAttrs(closableObj, true);
  const validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
  const noticePrefixCls = `${prefixCls}-notice`;
  return React65.createElement("div", _extends6({}, divProps, {
    ref,
    className: clsx(noticePrefixCls, className, {
      [`${noticePrefixCls}-closable`]: closable
    }),
    style: style2,
    onMouseEnter: (e3) => {
      var _a;
      setHovering(true);
      (_a = divProps == null ? void 0 : divProps.onMouseEnter) == null ? void 0 : _a.call(divProps, e3);
    },
    onMouseLeave: (e3) => {
      var _a;
      setHovering(false);
      (_a = divProps == null ? void 0 : divProps.onMouseLeave) == null ? void 0 : _a.call(divProps, e3);
    },
    onClick
  }), React65.createElement("div", {
    className: `${noticePrefixCls}-content`
  }, content), closable && React65.createElement("button", _extends6({
    className: `${noticePrefixCls}-close`,
    onKeyDown: onCloseKeyDown,
    "aria-label": "Close"
  }, ariaProps, {
    onClick: (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      onInternalClose();
    }
  }), closableObj.closeIcon ?? "x"), mergedShowProgress && React65.createElement("progress", {
    className: `${noticePrefixCls}-progress`,
    max: "100",
    value: validPercent
  }, validPercent + "%"));
});
var Notice_default = Notify;

// node_modules/@rc-component/notification/es/NotificationProvider.js
var import_react34 = __toESM(require_react());
var NotificationContext = import_react34.default.createContext({});
var NotificationProvider = ({
  children,
  classNames
}) => {
  return import_react34.default.createElement(NotificationContext.Provider, {
    value: {
      classNames
    }
  }, children);
};
var NotificationProvider_default = NotificationProvider;

// node_modules/@rc-component/notification/es/hooks/useStack.js
var DEFAULT_OFFSET = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = (config) => {
  const result = {
    offset: DEFAULT_OFFSET,
    threshold: DEFAULT_THRESHOLD,
    gap: DEFAULT_GAP
  };
  if (config && typeof config === "object") {
    result.offset = config.offset ?? DEFAULT_OFFSET;
    result.threshold = config.threshold ?? DEFAULT_THRESHOLD;
    result.gap = config.gap ?? DEFAULT_GAP;
  }
  return [!!config, result];
};
var useStack_default = useStack;

// node_modules/@rc-component/notification/es/NoticeList.js
function _extends7() {
  _extends7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
var NoticeList = (props) => {
  const {
    configList,
    placement,
    prefixCls,
    className,
    style: style2,
    motion: motion2,
    onAllNoticeRemoved,
    onNoticeClose,
    stack: stackConfig
  } = props;
  const {
    classNames: ctxCls
  } = (0, import_react35.useContext)(NotificationContext);
  const dictRef = (0, import_react35.useRef)({});
  const [latestNotice, setLatestNotice] = (0, import_react35.useState)(null);
  const [hoverKeys, setHoverKeys] = (0, import_react35.useState)([]);
  const keys2 = configList.map((config) => ({
    config,
    key: String(config.key)
  }));
  const [stack, {
    offset: offset3,
    threshold,
    gap
  }] = useStack_default(stackConfig);
  const expanded = stack && (hoverKeys.length > 0 || keys2.length <= threshold);
  const placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
  (0, import_react35.useEffect)(() => {
    if (stack && hoverKeys.length > 1) {
      setHoverKeys((prev2) => prev2.filter((key) => keys2.some(({
        key: dataKey
      }) => key === dataKey)));
    }
  }, [hoverKeys, keys2, stack]);
  (0, import_react35.useEffect)(() => {
    var _a, _b;
    if (stack && dictRef.current[(_a = keys2[keys2.length - 1]) == null ? void 0 : _a.key]) {
      setLatestNotice(dictRef.current[(_b = keys2[keys2.length - 1]) == null ? void 0 : _b.key]);
    }
  }, [keys2, stack]);
  return import_react35.default.createElement(CSSMotionList_default, _extends7({
    key: placement,
    className: clsx(prefixCls, `${prefixCls}-${placement}`, ctxCls == null ? void 0 : ctxCls.list, className, {
      [`${prefixCls}-stack`]: !!stack,
      [`${prefixCls}-stack-expanded`]: expanded
    }),
    style: style2,
    keys: keys2,
    motionAppear: true
  }, placementMotion, {
    onAllRemoved: () => {
      onAllNoticeRemoved(placement);
    }
  }), ({
    config,
    className: motionClassName,
    style: motionStyle,
    index: motionIndex
  }, nodeRef) => {
    var _a, _b, _c, _d;
    const {
      key,
      times
    } = config;
    const strKey = String(key);
    const {
      className: configClassName,
      style: configStyle,
      classNames: configClassNames,
      styles: configStyles,
      ...restConfig
    } = config;
    const dataIndex = keys2.findIndex((item) => item.key === strKey);
    const stackStyle = {};
    if (stack) {
      const index2 = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
      const transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
      if (index2 > 0) {
        stackStyle.height = expanded ? (_a = dictRef.current[strKey]) == null ? void 0 : _a.offsetHeight : latestNotice == null ? void 0 : latestNotice.offsetHeight;
        let verticalOffset = 0;
        for (let i = 0; i < index2; i++) {
          verticalOffset += ((_b = dictRef.current[keys2[keys2.length - 1 - i].key]) == null ? void 0 : _b.offsetHeight) + gap;
        }
        const transformY = (expanded ? verticalOffset : index2 * offset3) * (placement.startsWith("top") ? 1 : -1);
        const scaleX = !expanded && (latestNotice == null ? void 0 : latestNotice.offsetWidth) && ((_c = dictRef.current[strKey]) == null ? void 0 : _c.offsetWidth) ? ((latestNotice == null ? void 0 : latestNotice.offsetWidth) - offset3 * 2 * (index2 < 3 ? index2 : 3)) / ((_d = dictRef.current[strKey]) == null ? void 0 : _d.offsetWidth) : 1;
        stackStyle.transform = `translate3d(${transformX}, ${transformY}px, 0) scaleX(${scaleX})`;
      } else {
        stackStyle.transform = `translate3d(${transformX}, 0, 0)`;
      }
    }
    return import_react35.default.createElement("div", {
      ref: nodeRef,
      className: clsx(`${prefixCls}-notice-wrapper`, motionClassName, configClassNames == null ? void 0 : configClassNames.wrapper),
      style: {
        ...motionStyle,
        ...stackStyle,
        ...configStyles == null ? void 0 : configStyles.wrapper
      },
      onMouseEnter: () => setHoverKeys((prev2) => prev2.includes(strKey) ? prev2 : [...prev2, strKey]),
      onMouseLeave: () => setHoverKeys((prev2) => prev2.filter((k) => k !== strKey))
    }, import_react35.default.createElement(Notice_default, _extends7({}, restConfig, {
      ref: (node2) => {
        if (dataIndex > -1) {
          dictRef.current[strKey] = node2;
        } else {
          delete dictRef.current[strKey];
        }
      },
      prefixCls,
      classNames: configClassNames,
      styles: configStyles,
      className: clsx(configClassName, ctxCls == null ? void 0 : ctxCls.notice),
      style: configStyle,
      times,
      key,
      eventKey: key,
      onNoticeClose,
      hovering: stack && hoverKeys.length > 0
    })));
  });
};
if (true) {
  NoticeList.displayName = "NoticeList";
}
var NoticeList_default = NoticeList;

// node_modules/@rc-component/notification/es/Notifications.js
var Notifications = React68.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-notification",
    container,
    motion: motion2,
    maxCount,
    className,
    style: style2,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3
  } = props;
  const [configList, setConfigList] = React68.useState([]);
  const onNoticeClose = (key) => {
    var _a;
    const config = configList.find((item) => item.key === key);
    const closable = config == null ? void 0 : config.closable;
    const closableObj = closable && typeof closable === "object" ? closable : {};
    const {
      onClose: closableOnClose
    } = closableObj;
    closableOnClose == null ? void 0 : closableOnClose();
    (_a = config == null ? void 0 : config.onClose) == null ? void 0 : _a.call(config);
    setConfigList((list) => list.filter((item) => item.key !== key));
  };
  React68.useImperativeHandle(ref, () => ({
    open: (config) => {
      setConfigList((list) => {
        var _a;
        let clone = [...list];
        const index2 = clone.findIndex((item) => item.key === config.key);
        const innerConfig = {
          ...config
        };
        if (index2 >= 0) {
          innerConfig.times = (((_a = list[index2]) == null ? void 0 : _a.times) || 0) + 1;
          clone[index2] = innerConfig;
        } else {
          innerConfig.times = 0;
          clone.push(innerConfig);
        }
        if (maxCount > 0 && clone.length > maxCount) {
          clone = clone.slice(-maxCount);
        }
        return clone;
      });
    },
    close: (key) => {
      onNoticeClose(key);
    },
    destroy: () => {
      setConfigList([]);
    }
  }));
  const [placements5, setPlacements] = React68.useState({});
  React68.useEffect(() => {
    const nextPlacements = {};
    configList.forEach((config) => {
      const {
        placement = "topRight"
      } = config;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements5).forEach((placement) => {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  const onAllNoticeRemoved = (placement) => {
    setPlacements((originPlacements) => {
      const clone = {
        ...originPlacements
      };
      const list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  };
  const emptyRef = React68.useRef(false);
  React68.useEffect(() => {
    if (Object.keys(placements5).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved == null ? void 0 : onAllRemoved();
      emptyRef.current = false;
    }
  }, [placements5]);
  if (!container) {
    return null;
  }
  const placementList = Object.keys(placements5);
  return (0, import_react_dom2.createPortal)(React68.createElement(React68.Fragment, null, placementList.map((placement) => {
    const placementConfigList = placements5[placement];
    const list = React68.createElement(NoticeList_default, {
      key: placement,
      configList: placementConfigList,
      placement,
      prefixCls,
      className: className == null ? void 0 : className(placement),
      style: style2 == null ? void 0 : style2(placement),
      motion: motion2,
      onNoticeClose,
      onAllNoticeRemoved,
      stack
    });
    return renderNotifications3 ? renderNotifications3(list, {
      prefixCls,
      key: placement
    }) : list;
  })), container);
});
if (true) {
  Notifications.displayName = "Notifications";
}
var Notifications_default = Notifications;

// node_modules/@rc-component/notification/es/hooks/useNotification.js
var defaultGetContainer = () => document.body;
var uniqueKey = 0;
function mergeConfig(...objList) {
  const clone = {};
  objList.forEach((obj) => {
    if (obj) {
      Object.keys(obj).forEach((key) => {
        const val = obj[key];
        if (val !== void 0) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification(rootConfig = {}) {
  const {
    getContainer = defaultGetContainer,
    motion: motion2,
    prefixCls,
    maxCount,
    className,
    style: style2,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3,
    ...shareConfig
  } = rootConfig;
  const [container, setContainer] = React69.useState();
  const notificationsRef = React69.useRef();
  const contextHolder = React69.createElement(Notifications_default, {
    container,
    ref: notificationsRef,
    prefixCls,
    motion: motion2,
    maxCount,
    className,
    style: style2,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications3
  });
  const [taskQueue3, setTaskQueue] = React69.useState([]);
  const open3 = useEvent_default((config) => {
    const mergedConfig = mergeConfig(shareConfig, config);
    if (mergedConfig.key === null || mergedConfig.key === void 0) {
      mergedConfig.key = `rc-notification-${uniqueKey}`;
      uniqueKey += 1;
    }
    setTaskQueue((queue) => [...queue, {
      type: "open",
      config: mergedConfig
    }]);
  });
  const api = React69.useMemo(() => ({
    open: open3,
    close: (key) => {
      setTaskQueue((queue) => [...queue, {
        type: "close",
        key
      }]);
    },
    destroy: () => {
      setTaskQueue((queue) => [...queue, {
        type: "destroy"
      }]);
    }
  }), []);
  React69.useEffect(() => {
    setContainer(getContainer());
  });
  React69.useEffect(() => {
    if (notificationsRef.current && taskQueue3.length) {
      taskQueue3.forEach((task) => {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      let oriTaskQueue;
      let tgtTaskQueue;
      setTaskQueue((oriQueue) => {
        if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
          oriTaskQueue = oriQueue;
          tgtTaskQueue = oriQueue.filter((task) => !taskQueue3.includes(task));
        }
        return tgtTaskQueue;
      });
    }
  }, [taskQueue3]);
  return [api, contextHolder];
}

// node_modules/antd/es/message/PurePanel.js
var React70 = __toESM(require_react());

// node_modules/antd/es/message/style/index.js
var genMessageStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    boxShadow,
    colorText,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    // Custom token
    contentPadding,
    contentBg
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const messageMoveIn = new Keyframes_default("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframes_default("MessageMoveOut", {
    "0%": {
      maxHeight: token2.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  const noticeStyle = {
    padding: paddingXS,
    textAlign: "center",
    [`${componentCls}-custom-content`]: {
      display: "flex",
      alignItems: "center"
    },
    [`${componentCls}-custom-content > ${iconCls}`]: {
      marginInlineEnd: marginXS,
      // affected by ltr or rtl
      fontSize: fontSizeLG
    },
    [`${noticeCls}-content`]: {
      display: "inline-block",
      padding: contentPadding,
      background: contentBg,
      borderRadius: borderRadiusLG,
      boxShadow,
      pointerEvents: "all"
    },
    [`${componentCls}-success > ${iconCls}`]: {
      color: colorSuccess
    },
    [`${componentCls}-error > ${iconCls}`]: {
      color: colorError
    },
    [`${componentCls}-warning > ${iconCls}`]: {
      color: colorWarning
    },
    [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
      color: colorInfo
    }
  };
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token2),
        color: colorText,
        position: "fixed",
        top: marginXS,
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: {
          ...noticeStyle
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${componentCls}-notice-pure-panel`]: {
        ...noticeStyle,
        padding: 0,
        textAlign: "start"
      }
    }
  ];
};
var prepareComponentToken4 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
  contentBg: token2.colorBgElevated,
  contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
});
var style_default4 = genStyleHooks("Message", (token2) => {
  const combinedToken = merge2(token2, {
    height: 150
  });
  return genMessageStyle(combinedToken);
}, prepareComponentToken4);

// node_modules/antd/es/message/PurePanel.js
var TypeIcon = {
  info: React70.createElement(InfoCircleFilled_default, null),
  success: React70.createElement(CheckCircleFilled_default, null),
  error: React70.createElement(CloseCircleFilled_default, null),
  warning: React70.createElement(ExclamationCircleFilled_default, null),
  loading: React70.createElement(LoadingOutlined_default, null)
};
var PureContent = (props) => {
  const {
    prefixCls,
    type: type5,
    icon,
    children,
    classNames: pureContentClassNames,
    styles
  } = props;
  const iconElement = icon || type5 && TypeIcon[type5];
  const iconNode = cloneElement3(iconElement, (currentProps) => {
    const mergedStyle = {
      ...currentProps == null ? void 0 : currentProps.style,
      ...styles == null ? void 0 : styles.icon
    };
    return {
      className: clsx(currentProps.className, pureContentClassNames == null ? void 0 : pureContentClassNames.icon),
      style: mergedStyle
    };
  });
  return React70.createElement("div", {
    className: clsx(`${prefixCls}-custom-content`, `${prefixCls}-${type5}`)
  }, iconNode, React70.createElement("span", {
    className: pureContentClassNames == null ? void 0 : pureContentClassNames.content,
    style: styles == null ? void 0 : styles.content
  }, children));
};
var PurePanel = (props) => {
  const {
    prefixCls: staticPrefixCls,
    className,
    style: style2,
    type: type5,
    icon,
    content,
    classNames: messageClassNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("message");
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default4(prefixCls, rootCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, messageClassNames], [contextStyles, styles], {
    props
  });
  return React70.createElement(Notice_default, {
    ...restProps,
    prefixCls,
    className: clsx(contextClassName, mergedClassNames.root, className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    eventKey: "pure",
    duration: null,
    content: React70.createElement(PureContent, {
      prefixCls,
      type: type5,
      icon,
      classNames: mergedClassNames,
      styles: mergedStyles
    }, content)
  });
};
var PurePanel_default = PurePanel;

// node_modules/antd/es/message/util.js
function getMotion(prefixCls, transitionName) {
  return {
    motionName: transitionName ?? `${prefixCls}-move-up`
  };
}
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = () => {
    closeFn == null ? void 0 : closeFn();
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}

// node_modules/antd/es/message/useMessage.js
var DEFAULT_OFFSET2 = 8;
var DEFAULT_DURATION = 3;
var Wrapper = ({
  children,
  prefixCls
}) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default4(prefixCls, rootCls);
  return React71.createElement(NotificationProvider_default, {
    classNames: {
      list: clsx(hashId, cssVarCls, rootCls)
    }
  }, children);
};
var renderNotifications = (node2, {
  prefixCls,
  key
}) => React71.createElement(Wrapper, {
  prefixCls,
  key
}, node2);
var Holder = React71.forwardRef((props, ref) => {
  const {
    top,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    duration = DEFAULT_DURATION,
    rtl,
    transitionName,
    onAllRemoved,
    pauseOnHover = true
  } = props;
  const {
    getPrefixCls,
    direction,
    getPopupContainer
  } = useComponentConfig("message");
  const {
    message: message2
  } = React71.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const getStyle3 = () => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: top ?? DEFAULT_OFFSET2
  });
  const getClassName = () => clsx({
    [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
  });
  const getNotificationMotion = () => getMotion(prefixCls, transitionName);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([props == null ? void 0 : props.classNames, message2 == null ? void 0 : message2.classNames], [props == null ? void 0 : props.styles, message2 == null ? void 0 : message2.styles], {
    props
  });
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle3,
    className: getClassName,
    motion: getNotificationMotion,
    // closable=false requires-no closeIcon
    closable: false,
    duration,
    getContainer: () => (staticGetContainer == null ? void 0 : staticGetContainer()) || (getPopupContainer == null ? void 0 : getPopupContainer()) || document.body,
    maxCount,
    onAllRemoved,
    renderNotifications,
    pauseOnHover
  });
  React71.useImperativeHandle(ref, () => ({
    ...api,
    prefixCls,
    message: message2,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = React71.useRef(null);
  const warning5 = devUseWarning("Message");
  const wrapAPI = React71.useMemo(() => {
    const close = (key) => {
      var _a;
      (_a = holderRef.current) == null ? void 0 : _a.close(key);
    };
    const open3 = (config) => {
      if (!holderRef.current) {
        true ? warning5(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        message: message2,
        classNames: originClassNames,
        styles: originStyles
      } = holderRef.current;
      const contextClassName = (message2 == null ? void 0 : message2.className) || {};
      const contextStyle = (message2 == null ? void 0 : message2.style) || {};
      const rawContextClassNames = (message2 == null ? void 0 : message2.classNames) || {};
      const rawContextStyles = (message2 == null ? void 0 : message2.styles) || {};
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type: type5,
        key,
        className,
        style: style2,
        onClose,
        classNames: configClassNames = {},
        styles = {},
        ...restConfig
      } = config;
      let mergedKey = key;
      if (!isNonNullable_default(mergedKey)) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      const contextConfig = {
        ...messageConfig,
        ...config
      };
      const contextClassNames = resolveStyleOrClass(rawContextClassNames, {
        props: contextConfig
      });
      const semanticClassNames = resolveStyleOrClass(configClassNames, {
        props: contextConfig
      });
      const contextStyles = resolveStyleOrClass(rawContextStyles, {
        props: contextConfig
      });
      const semanticStyles = resolveStyleOrClass(styles, {
        props: contextConfig
      });
      const mergedClassNames = mergeClassNames(void 0, contextClassNames, semanticClassNames, originClassNames);
      const mergedStyles = mergeStyles(contextStyles, semanticStyles, originStyles);
      return wrapPromiseFn((resolve) => {
        originOpen({
          ...restConfig,
          key: mergedKey,
          content: React71.createElement(PureContent, {
            prefixCls,
            type: type5,
            icon,
            classNames: mergedClassNames,
            styles: mergedStyles
          }, content),
          placement: "top",
          className: clsx({
            [`${noticePrefixCls}-${type5}`]: type5
          }, className, contextClassName, mergedClassNames.root),
          style: {
            ...mergedStyles.root,
            ...contextStyle,
            ...style2
          },
          onClose: () => {
            onClose == null ? void 0 : onClose();
            resolve();
          }
        });
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy3 = (key) => {
      var _a;
      if (key !== void 0) {
        close(key);
      } else {
        (_a = holderRef.current) == null ? void 0 : _a.destroy();
      }
    };
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys2 = ["info", "success", "warning", "error", "loading"];
    keys2.forEach((type5) => {
      const typeOpen2 = (jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = {
          onClose: mergedOnClose,
          duration: mergedDuration,
          ...config,
          type: type5
        };
        return open3(mergedConfig);
      };
      clone[type5] = typeOpen2;
    });
    return clone;
  }, []);
  return [wrapAPI, React71.createElement(Holder, {
    key: "message-holder",
    ...messageConfig,
    ref: holderRef
  })];
}
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}

// node_modules/antd/es/modal/useModal/index.js
var React138 = __toESM(require_react());

// node_modules/antd/es/modal/confirm.js
var import_react68 = __toESM(require_react());

// node_modules/@rc-component/util/es/React/render.js
var import_client = __toESM(require_client());
var MARK = "__rc_react_root__";
function render(node2, container) {
  const root = container[MARK] || (0, import_client.createRoot)(container);
  root.render(node2);
  container[MARK] = root;
}
async function unmount(container) {
  return Promise.resolve().then(() => {
    var _a;
    (_a = container[MARK]) == null ? void 0 : _a.unmount();
    delete container[MARK];
  });
}

// node_modules/antd/es/modal/ConfirmDialog.js
var React135 = __toESM(require_react());

// node_modules/antd/es/_util/motion.js
var getCollapsedHeight = () => ({
  height: 0,
  opacity: 0
});
var getRealHeight = (node2) => {
  const {
    scrollHeight
  } = node2;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = (node2) => ({
  height: node2 ? node2.offsetHeight : 0
});
var skipOpacityTransition = (_, event) => (event == null ? void 0 : event.deadline) === true || event.propertyName === "height";
var initCollapseMotion = (rootCls = defaultPrefixCls) => ({
  motionName: `${rootCls}-motion-collapse`,
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
});
var getTransitionName2 = (rootPrefixCls, motion2, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion2}`;
};
var motion_default = initCollapseMotion;

// node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var import_react58 = __toESM(require_react());

// node_modules/antd/es/_util/ActionButton.js
var React98 = __toESM(require_react());

// node_modules/antd/es/button/Button.js
var import_react56 = __toESM(require_react());

// node_modules/antd/es/_util/wave/index.js
var import_react36 = __toESM(require_react());

// node_modules/antd/es/_util/wave/style.js
var genWaveStyle = (token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${token2.motionDurationSlow} ${token2.motionEaseInOut}`, `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`].join(",")
        }
      }
    }
  };
};
var style_default5 = genComponentStyleHook("Wave", genWaveStyle);

// node_modules/antd/es/_util/wave/useWave.js
var React73 = __toESM(require_react());

// node_modules/antd/es/_util/wave/interface.js
var TARGET_CLS = `${defaultPrefixCls}-wave-target`;

// node_modules/antd/es/_util/wave/WaveEffect.js
var React72 = __toESM(require_react());

// node_modules/antd/es/_util/wave/util.js
function isValidWaveColor(color) {
  return color && typeof color === "string" && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
  color !== "transparent" && color !== "canvastext";
}
function getTargetWaveColor(node2, colorSource = null) {
  const style2 = getComputedStyle(node2);
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = style2;
  if (colorSource && isValidWaveColor(style2[colorSource])) {
    return style2[colorSource];
  }
  return [borderTopColor, borderColor, backgroundColor].find(isValidWaveColor) ?? null;
}

// node_modules/antd/es/_util/wave/WaveEffect.js
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
var WaveEffect = (props) => {
  const {
    className,
    target,
    component,
    colorSource
  } = props;
  const divRef = React72.useRef(null);
  const [color, setWaveColor] = React72.useState(null);
  const [borderRadius, setBorderRadius] = React72.useState([]);
  const [left, setLeft] = React72.useState(0);
  const [top, setTop] = React72.useState(0);
  const [width, setWidth] = React72.useState(0);
  const [height, setHeight] = React72.useState(0);
  const [enabled, setEnabled] = React72.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
  };
  if (color) {
    waveStyle["--wave-color"] = color;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor(target, colorSource));
    const isStatic = nodeStyle.position === "static";
    const {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-Number.parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum(-Number.parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(Number.parseFloat(radius2))));
  }
  React72.useEffect(() => {
    if (target) {
      const id = raf_default(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(syncPos);
        resizeObserver.observe(target);
      }
      return () => {
        raf_default.cancel(id);
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
      };
    }
  }, [target]);
  if (!enabled) {
    return null;
  }
  const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target == null ? void 0 : target.classList.contains(TARGET_CLS));
  return React72.createElement(es_default2, {
    visible: true,
    motionAppear: true,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (_, event) => {
      var _a;
      if (event.deadline || event.propertyName === "opacity") {
        const holder = (_a = divRef.current) == null ? void 0 : _a.parentElement;
        unmount(holder).then(() => {
          holder == null ? void 0 : holder.remove();
        });
      }
      return false;
    }
  }, ({
    className: motionClassName
  }, ref) => React72.createElement("div", {
    ref: composeRef(divRef, ref),
    className: clsx(className, motionClassName, {
      "wave-quick": isSmallComponent
    }),
    style: waveStyle
  }));
};
var showWaveEffect = (target, info) => {
  var _a;
  const {
    component
  } = info;
  if (component === "Checkbox" && !((_a = target.querySelector("input")) == null ? void 0 : _a.checked)) {
    return;
  }
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = "0px";
  holder.style.top = "0px";
  target == null ? void 0 : target.insertBefore(holder, target == null ? void 0 : target.firstChild);
  render(React72.createElement(WaveEffect, {
    ...info,
    target
  }), holder);
};
var WaveEffect_default = showWaveEffect;

// node_modules/antd/es/_util/wave/useWave.js
var useWave = (nodeRef, className, component, colorSource) => {
  const {
    wave
  } = React73.useContext(ConfigContext);
  const [, token2, hashId] = useToken();
  const showWave = useEvent_default((event) => {
    const node2 = nodeRef.current;
    if ((wave == null ? void 0 : wave.disabled) || !node2) {
      return;
    }
    const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
    const {
      showEffect
    } = wave || {};
    (showEffect || WaveEffect_default)(targetNode, {
      className,
      token: token2,
      component,
      event,
      hashId,
      colorSource
    });
  });
  const rafId = React73.useRef(null);
  React73.useEffect(() => () => {
    raf_default.cancel(rafId.current);
  }, []);
  const showDebounceWave = (event) => {
    raf_default.cancel(rafId.current);
    rafId.current = raf_default(() => {
      showWave(event);
    });
  };
  return showDebounceWave;
};
var useWave_default = useWave;

// node_modules/antd/es/_util/wave/index.js
var Wave = (props) => {
  const {
    children,
    disabled,
    component,
    colorSource
  } = props;
  const {
    getPrefixCls
  } = (0, import_react36.useContext)(ConfigContext);
  const containerRef = (0, import_react36.useRef)(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = style_default5(prefixCls);
  const showWave = useWave_default(containerRef, clsx(prefixCls, hashId), component, colorSource);
  import_react36.default.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== window.Node.ELEMENT_NODE || disabled) {
      return;
    }
    const onClick = (e3) => {
      if (!isVisible_default(e3.target) || // No need wave
      !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") && !node2.className.includes("disabled:") || node2.getAttribute("aria-disabled") === "true" || node2.className.includes("-leave")) {
        return;
      }
      showWave(e3);
    };
    node2.addEventListener("click", onClick, true);
    return () => {
      node2.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!import_react36.default.isValidElement(children)) {
    return children ?? null;
  }
  const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
  return cloneElement3(children, {
    ref
  });
};
if (true) {
  Wave.displayName = "Wave";
}
var wave_default = Wave;

// node_modules/antd/es/config-provider/hooks/useSize.js
var import_react37 = __toESM(require_react());
var useSize = (customSize) => {
  const size = import_react37.default.useContext(SizeContext_default);
  const mergedSize = import_react37.default.useMemo(() => {
    if (!customSize) {
      return size;
    }
    if (typeof customSize === "string") {
      return customSize ?? size;
    }
    if (typeof customSize === "function") {
      return customSize(size);
    }
    return size;
  }, [customSize, size]);
  return mergedSize;
};
var useSize_default = useSize;

// node_modules/antd/es/space/Compact.js
var React76 = __toESM(require_react());

// node_modules/antd/es/space/style/compact.js
var genSpaceCompactStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var compact_default = genStyleHooks(["Space", "Compact"], (token2) => [genSpaceCompactStyle(token2)], () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: false
});

// node_modules/antd/es/space/Compact.js
var SpaceCompactItemContext = React76.createContext(null);
var useCompactItemContext = (prefixCls, direction) => {
  const compactItemContext = React76.useContext(SpaceCompactItemContext);
  const compactItemClassnames = React76.useMemo(() => {
    if (!compactItemContext) {
      return "";
    }
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return clsx(`${prefixCls}-compact${separator}item`, {
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext == null ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext == null ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames
  };
};
var NoCompactStyle = (props) => {
  const {
    children
  } = props;
  return React76.createElement(SpaceCompactItemContext.Provider, {
    value: null
  }, children);
};
var CompactItem = (props) => {
  const {
    children,
    ...others
  } = props;
  return React76.createElement(SpaceCompactItemContext.Provider, {
    value: React76.useMemo(() => others, [others])
  }, children);
};
var Compact = (props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = React76.useContext(ConfigContext);
  const {
    size,
    direction,
    orientation,
    block,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    vertical,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Space.Compact");
    warning5.deprecated(!direction, "direction", "orientation");
  }
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
  const mergedSize = useSize_default((ctx) => size ?? ctx);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [hashId] = compact_default(prefixCls);
  const clx = clsx(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-vertical`]: mergedVertical
  }, className, rootClassName);
  const compactItemContext = React76.useContext(SpaceCompactItemContext);
  const childNodes = toArray(children);
  const nodes = React76.useMemo(() => childNodes.map((child, i) => {
    const key = (child == null ? void 0 : child.key) || `${prefixCls}-item-${i}`;
    return React76.createElement(CompactItem, {
      key,
      compactSize: mergedSize,
      compactDirection: mergedOrientation,
      isFirstItem: i === 0 && (!compactItemContext || (compactItemContext == null ? void 0 : compactItemContext.isFirstItem)),
      isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext == null ? void 0 : compactItemContext.isLastItem))
    }, child);
  }), [childNodes, compactItemContext, mergedOrientation, mergedSize, prefixCls]);
  if (childNodes.length === 0) {
    return null;
  }
  return React76.createElement("div", {
    className: clx,
    ...restProps
  }, nodes);
};
var Compact_default = Compact;

// node_modules/antd/es/button/ButtonGroup.js
var React77 = __toESM(require_react());
var GroupSizeContext = React77.createContext(void 0);
var ButtonGroup = (props) => {
  const {
    getPrefixCls,
    direction
  } = React77.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    size,
    className,
    ...others
  } = props;
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = useToken();
  const sizeCls = React77.useMemo(() => {
    switch (size) {
      case "large":
        return "lg";
      case "small":
        return "sm";
      default:
        return "";
    }
  }, [size]);
  if (true) {
    const warning5 = devUseWarning("Button.Group");
    warning5.deprecated(false, "Button.Group", "Space.Compact");
    true ? warning5(!size || ["large", "small", "middle"].includes(size), "usage", "Invalid prop `size`.") : void 0;
  }
  const classes = clsx(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return React77.createElement(GroupSizeContext.Provider, {
    value: size
  }, React77.createElement("div", {
    ...others,
    className: classes
  }));
};
var ButtonGroup_default = ButtonGroup;

// node_modules/antd/es/button/buttonHelpers.js
var import_react38 = __toESM(require_react());
var rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function convertLegacyProps(type5) {
  if (type5 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type5
  };
}
function isString(str) {
  return typeof str === "string";
}
function isUnBorderedButtonVariant(type5) {
  return type5 === "text" || type5 === "link";
}
function splitCNCharsBySpace(child, needInserted, style2, className) {
  if (!isNonNullable_default(child) || child === "") {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement3(child, (oriProps) => ({
      ...oriProps,
      children: oriProps.children.split("").join(SPACE),
      className,
      style: style2
    }));
  }
  if (isString(child)) {
    return import_react38.default.createElement("span", {
      className,
      style: style2
    }, isTwoCNChar(child) ? child.split("").join(SPACE) : child);
  }
  if (isFragment2(child)) {
    return import_react38.default.createElement("span", {
      className,
      style: style2
    }, child);
  }
  return cloneElement3(child, (oriProps) => ({
    ...oriProps,
    className: clsx(oriProps.className, className) || void 0,
    style: {
      ...oriProps.style,
      ...style2
    }
  }));
}
function spaceChildren(children, needInserted, style2, className) {
  let isPrevChildPure = false;
  const childList = [];
  import_react38.default.Children.forEach(children, (child) => {
    const type5 = typeof child;
    const isCurrentChildPure = type5 === "string" || type5 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return import_react38.default.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted, style2, className));
}
var _ButtonColorTypes = ["default", "primary", "danger"].concat(_toConsumableArray(PresetColors));

// node_modules/antd/es/button/DefaultLoadingIcon.js
var import_react40 = __toESM(require_react());

// node_modules/antd/es/button/IconWrapper.js
var import_react39 = __toESM(require_react());
var IconWrapper = (0, import_react39.forwardRef)((props, ref) => {
  const {
    className,
    style: style2,
    children,
    prefixCls
  } = props;
  const iconWrapperCls = clsx(`${prefixCls}-icon`, className);
  return import_react39.default.createElement("span", {
    ref,
    className: iconWrapperCls,
    style: style2
  }, children);
});
var IconWrapper_default = IconWrapper;

// node_modules/antd/es/button/DefaultLoadingIcon.js
var InnerLoadingIcon = (0, import_react40.forwardRef)((props, ref) => {
  const {
    prefixCls,
    className,
    style: style2,
    iconClassName
  } = props;
  const mergedIconCls = clsx(`${prefixCls}-loading-icon`, className);
  return import_react40.default.createElement(IconWrapper_default, {
    prefixCls,
    className: mergedIconCls,
    style: style2,
    ref
  }, import_react40.default.createElement(LoadingOutlined_default, {
    className: iconClassName
  }));
});
var getCollapsedWidth = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
});
var getRealWidth = (node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
});
var DefaultLoadingIcon = (props) => {
  const {
    prefixCls,
    loading,
    existIcon,
    className,
    style: style2,
    mount
  } = props;
  const visible = !!loading;
  if (existIcon) {
    return import_react40.default.createElement(InnerLoadingIcon, {
      prefixCls,
      className,
      style: style2
    });
  }
  return import_react40.default.createElement(es_default2, {
    visible,
    // Used for minus flex gap style only
    motionName: `${prefixCls}-loading-icon-motion`,
    motionAppear: !mount,
    motionEnter: !mount,
    motionLeave: !mount,
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, ({
    className: motionCls,
    style: motionStyle
  }, ref) => {
    const mergedStyle = {
      ...style2,
      ...motionStyle
    };
    return import_react40.default.createElement(InnerLoadingIcon, {
      prefixCls,
      className: clsx(className, motionCls),
      style: mergedStyle,
      ref
    });
  });
};
var DefaultLoadingIcon_default = DefaultLoadingIcon;

// node_modules/antd/es/button/style/group.js
var genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
  // Border
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
var genGroupStyle = (token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    groupBorderColor,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      // Border Color
      genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
var group_default = genGroupStyle;

// node_modules/@rc-component/color-picker/es/ColorPicker.js
var import_react50 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/color.js
var getRoundNumber = (value) => Math.round(Number(value || 0));
var convertHsb2Hsv = (color) => {
  if (color instanceof FastColor) {
    return color;
  }
  if (color && typeof color === "object" && "h" in color && "b" in color) {
    const {
      b,
      ...resets
    } = color;
    return {
      ...resets,
      v: b
    };
  }
  if (typeof color === "string" && /hsb/.test(color)) {
    return color.replace(/hsb/, "hsv");
  }
  return color;
};
var Color = class extends FastColor {
  constructor(color) {
    super(convertHsb2Hsv(color));
  }
  toHsbString() {
    const hsb = this.toHsb();
    const saturation = getRoundNumber(hsb.s * 100);
    const lightness = getRoundNumber(hsb.b * 100);
    const hue = getRoundNumber(hsb.h);
    const alpha = hsb.a;
    const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
    const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha.toFixed(alpha === 0 ? 0 : 2)})`;
    return alpha === 1 ? hsbString : hsbaString;
  }
  toHsb() {
    const {
      v,
      ...resets
    } = this.toHsv();
    return {
      ...resets,
      b: v,
      a: this.a
    };
  }
};

// node_modules/@rc-component/color-picker/es/util.js
var ColorPickerPrefixCls = "rc-color-picker";
var generateColor = (color) => {
  if (color instanceof Color) {
    return color;
  }
  return new Color(color);
};
var defaultColor = generateColor("#1677ff");
var calculateColor = (props) => {
  const {
    offset: offset3,
    targetRef,
    containerRef,
    color,
    type: type5
  } = props;
  const {
    width,
    height
  } = containerRef.current.getBoundingClientRect();
  const {
    width: targetWidth,
    height: targetHeight
  } = targetRef.current.getBoundingClientRect();
  const centerOffsetX = targetWidth / 2;
  const centerOffsetY = targetHeight / 2;
  const saturation = (offset3.x + centerOffsetX) / width;
  const bright = 1 - (offset3.y + centerOffsetY) / height;
  const hsb = color.toHsb();
  const alphaOffset = saturation;
  const hueOffset = (offset3.x + centerOffsetX) / width * 360;
  if (type5) {
    switch (type5) {
      case "hue":
        return generateColor({
          ...hsb,
          h: hueOffset <= 0 ? 0 : hueOffset
        });
      case "alpha":
        return generateColor({
          ...hsb,
          a: alphaOffset <= 0 ? 0 : alphaOffset
        });
    }
  }
  return generateColor({
    h: hsb.h,
    s: saturation <= 0 ? 0 : saturation,
    b: bright >= 1 ? 1 : bright,
    a: hsb.a
  });
};
var calcOffset = (color, type5) => {
  const hsb = color.toHsb();
  switch (type5) {
    case "hue":
      return {
        x: hsb.h / 360 * 100,
        y: 50
      };
    case "alpha":
      return {
        x: color.a * 100,
        y: 50
      };
    default:
      return {
        x: hsb.s * 100,
        y: (1 - hsb.b) * 100
      };
  }
};

// node_modules/@rc-component/color-picker/es/components/ColorBlock.js
var import_react41 = __toESM(require_react());
var ColorBlock = ({
  color,
  prefixCls,
  className,
  style: style2,
  onClick
}) => {
  const colorBlockCls = `${prefixCls}-color-block`;
  return import_react41.default.createElement("div", {
    className: clsx(colorBlockCls, className),
    style: style2,
    onClick
  }, import_react41.default.createElement("div", {
    className: `${colorBlockCls}-inner`,
    style: {
      background: color
    }
  }));
};
var ColorBlock_default = ColorBlock;

// node_modules/@rc-component/color-picker/es/components/Picker.js
var import_react46 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js
var import_react42 = __toESM(require_react());
function getPosition(e3) {
  const obj = "touches" in e3 ? e3.touches[0] : e3;
  const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
  const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
  return {
    pageX: obj.pageX - scrollXOffset,
    pageY: obj.pageY - scrollYOffset
  };
}
function useColorDrag(props) {
  const {
    targetRef,
    containerRef,
    direction,
    onDragChange,
    onDragChangeComplete,
    calculate,
    color,
    disabledDrag
  } = props;
  const [offsetValue, setOffsetValue] = (0, import_react42.useState)({
    x: 0,
    y: 0
  });
  const mouseMoveRef = (0, import_react42.useRef)(null);
  const mouseUpRef = (0, import_react42.useRef)(null);
  (0, import_react42.useEffect)(() => {
    setOffsetValue(calculate());
  }, [color]);
  (0, import_react42.useEffect)(() => () => {
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    document.removeEventListener("touchmove", mouseMoveRef.current);
    document.removeEventListener("touchend", mouseUpRef.current);
    mouseMoveRef.current = null;
    mouseUpRef.current = null;
  }, []);
  const updateOffset = (e3) => {
    const {
      pageX,
      pageY
    } = getPosition(e3);
    const {
      x: rectX,
      y: rectY,
      width,
      height
    } = containerRef.current.getBoundingClientRect();
    const {
      width: targetWidth,
      height: targetHeight
    } = targetRef.current.getBoundingClientRect();
    const centerOffsetX = targetWidth / 2;
    const centerOffsetY = targetHeight / 2;
    const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
    const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
    const calcOffset2 = {
      x: offsetX,
      y: direction === "x" ? offsetValue.y : offsetY
    };
    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
      return false;
    }
    onDragChange == null ? void 0 : onDragChange(calcOffset2);
  };
  const onDragMove = (e3) => {
    e3.preventDefault();
    updateOffset(e3);
  };
  const onDragStop = (e3) => {
    e3.preventDefault();
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    document.removeEventListener("touchmove", mouseMoveRef.current);
    document.removeEventListener("touchend", mouseUpRef.current);
    mouseMoveRef.current = null;
    mouseUpRef.current = null;
    onDragChangeComplete == null ? void 0 : onDragChangeComplete();
  };
  const onDragStart = (e3) => {
    document.removeEventListener("mousemove", mouseMoveRef.current);
    document.removeEventListener("mouseup", mouseUpRef.current);
    if (disabledDrag) {
      return;
    }
    updateOffset(e3);
    document.addEventListener("mousemove", onDragMove);
    document.addEventListener("mouseup", onDragStop);
    document.addEventListener("touchmove", onDragMove);
    document.addEventListener("touchend", onDragStop);
    mouseMoveRef.current = onDragMove;
    mouseUpRef.current = onDragStop;
  };
  return [offsetValue, onDragStart];
}
var useColorDrag_default = useColorDrag;

// node_modules/@rc-component/color-picker/es/components/Handler.js
var import_react43 = __toESM(require_react());
var Handler = ({
  size = "default",
  color,
  prefixCls
}) => {
  return import_react43.default.createElement("div", {
    className: clsx(`${prefixCls}-handler`, {
      [`${prefixCls}-handler-sm`]: size === "small"
    }),
    style: {
      backgroundColor: color
    }
  });
};
var Handler_default = Handler;

// node_modules/@rc-component/color-picker/es/components/Palette.js
var import_react44 = __toESM(require_react());
var Palette = ({
  children,
  style: style2,
  prefixCls
}) => {
  return import_react44.default.createElement("div", {
    className: `${prefixCls}-palette`,
    style: {
      position: "relative",
      ...style2
    }
  }, children);
};
var Palette_default = Palette;

// node_modules/@rc-component/color-picker/es/components/Transform.js
var import_react45 = __toESM(require_react());
var Transform = (0, import_react45.forwardRef)((props, ref) => {
  const {
    children,
    x,
    y
  } = props;
  return import_react45.default.createElement("div", {
    ref,
    style: {
      position: "absolute",
      left: `${x}%`,
      top: `${y}%`,
      zIndex: 1,
      transform: "translate(-50%, -50%)"
    }
  }, children);
});
var Transform_default = Transform;

// node_modules/@rc-component/color-picker/es/components/Picker.js
var Picker = ({
  color,
  onChange,
  prefixCls,
  onChangeComplete,
  disabled
}) => {
  const pickerRef = (0, import_react46.useRef)();
  const transformRef = (0, import_react46.useRef)();
  const colorRef = (0, import_react46.useRef)(color);
  const onDragChange = useEvent_default((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: pickerRef,
      color
    });
    colorRef.current = calcColor;
    onChange(calcColor);
  });
  const [offset3, dragStartHandle] = useColorDrag_default({
    color,
    containerRef: pickerRef,
    targetRef: transformRef,
    calculate: () => calcOffset(color),
    onDragChange,
    onDragChangeComplete: () => onChangeComplete == null ? void 0 : onChangeComplete(colorRef.current),
    disabledDrag: disabled
  });
  return import_react46.default.createElement("div", {
    ref: pickerRef,
    className: `${prefixCls}-select`,
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, import_react46.default.createElement(Palette_default, {
    prefixCls
  }, import_react46.default.createElement(Transform_default, {
    x: offset3.x,
    y: offset3.y,
    ref: transformRef
  }, import_react46.default.createElement(Handler_default, {
    color: color.toRgbString(),
    prefixCls
  })), import_react46.default.createElement("div", {
    className: `${prefixCls}-saturation`,
    style: {
      backgroundColor: `hsl(${color.toHsb().h},100%, 50%)`,
      backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
    }
  })));
};
var Picker_default = Picker;

// node_modules/@rc-component/color-picker/es/hooks/useColorState.js
var import_react47 = __toESM(require_react());
var useColorState = (defaultValue, value) => {
  const [mergedValue, setValue] = useControlledState(defaultValue, value);
  const color = (0, import_react47.useMemo)(() => generateColor(mergedValue), [mergedValue]);
  return [color, setValue];
};
var useColorState_default = useColorState;

// node_modules/@rc-component/color-picker/es/hooks/useComponent.js
var React88 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/components/Slider.js
var import_react49 = __toESM(require_react());

// node_modules/@rc-component/color-picker/es/components/Gradient.js
var import_react48 = __toESM(require_react());
var Gradient = ({
  colors,
  children,
  direction = "to right",
  type: type5,
  prefixCls
}) => {
  const gradientColors = (0, import_react48.useMemo)(() => colors.map((color, idx) => {
    let result = generateColor(color);
    if (type5 === "alpha" && idx === colors.length - 1) {
      result = new Color(result.setA(1));
    }
    return result.toRgbString();
  }).join(","), [colors, type5]);
  return import_react48.default.createElement("div", {
    className: `${prefixCls}-gradient`,
    style: {
      position: "absolute",
      inset: 0,
      background: `linear-gradient(${direction}, ${gradientColors})`
    }
  }, children);
};
var Gradient_default = Gradient;

// node_modules/@rc-component/color-picker/es/components/Slider.js
var Slider = (props) => {
  const {
    prefixCls,
    colors,
    disabled,
    onChange,
    onChangeComplete,
    color,
    type: type5
  } = props;
  const sliderRef = (0, import_react49.useRef)(null);
  const transformRef = (0, import_react49.useRef)(null);
  const colorRef = (0, import_react49.useRef)(color);
  const getValue2 = (c) => {
    return type5 === "hue" ? c.getHue() : c.a * 100;
  };
  const onDragChange = useEvent_default((offsetValue) => {
    const calcColor = calculateColor({
      offset: offsetValue,
      targetRef: transformRef,
      containerRef: sliderRef,
      color,
      type: type5
    });
    colorRef.current = calcColor;
    onChange(getValue2(calcColor));
  });
  const [offset3, dragStartHandle] = useColorDrag_default({
    color,
    targetRef: transformRef,
    containerRef: sliderRef,
    calculate: () => calcOffset(color, type5),
    onDragChange,
    onDragChangeComplete() {
      onChangeComplete(getValue2(colorRef.current));
    },
    direction: "x",
    disabledDrag: disabled
  });
  const handleColor = import_react49.default.useMemo(() => {
    if (type5 === "hue") {
      const hsb = color.toHsb();
      hsb.s = 1;
      hsb.b = 1;
      hsb.a = 1;
      const lightColor = new Color(hsb);
      return lightColor;
    }
    return color;
  }, [color, type5]);
  const gradientList = import_react49.default.useMemo(() => colors.map((info) => `${info.color} ${info.percent}%`), [colors]);
  return import_react49.default.createElement("div", {
    ref: sliderRef,
    className: clsx(`${prefixCls}-slider`, `${prefixCls}-slider-${type5}`),
    onMouseDown: dragStartHandle,
    onTouchStart: dragStartHandle
  }, import_react49.default.createElement(Palette_default, {
    prefixCls
  }, import_react49.default.createElement(Transform_default, {
    x: offset3.x,
    y: offset3.y,
    ref: transformRef
  }, import_react49.default.createElement(Handler_default, {
    size: "small",
    color: handleColor.toHexString(),
    prefixCls
  })), import_react49.default.createElement(Gradient_default, {
    colors: gradientList,
    type: type5,
    prefixCls
  })));
};
var Slider_default = Slider;

// node_modules/@rc-component/color-picker/es/hooks/useComponent.js
function useComponent(components2) {
  return React88.useMemo(() => {
    const {
      slider
    } = components2 || {};
    return [slider || Slider_default];
  }, [components2]);
}

// node_modules/@rc-component/color-picker/es/ColorPicker.js
function _extends8() {
  _extends8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
var HUE_COLORS = [{
  color: "rgb(255, 0, 0)",
  percent: 0
}, {
  color: "rgb(255, 255, 0)",
  percent: 17
}, {
  color: "rgb(0, 255, 0)",
  percent: 33
}, {
  color: "rgb(0, 255, 255)",
  percent: 50
}, {
  color: "rgb(0, 0, 255)",
  percent: 67
}, {
  color: "rgb(255, 0, 255)",
  percent: 83
}, {
  color: "rgb(255, 0, 0)",
  percent: 100
}];
var ColorPicker = (0, import_react50.forwardRef)((props, ref) => {
  const {
    value,
    defaultValue,
    prefixCls = ColorPickerPrefixCls,
    onChange,
    onChangeComplete,
    className,
    style: style2,
    panelRender,
    disabledAlpha = false,
    disabled = false,
    components: components2
  } = props;
  const [Slider5] = useComponent(components2);
  const [colorValue, setColorValue] = useColorState_default(defaultValue || defaultColor, value);
  const alphaColor = (0, import_react50.useMemo)(() => colorValue.setA(1).toRgbString(), [colorValue]);
  const handleChange = (data, type5) => {
    if (!value) {
      setColorValue(data);
    }
    onChange == null ? void 0 : onChange(data, type5);
  };
  const getHueColor = (hue) => new Color(colorValue.setHue(hue));
  const getAlphaColor4 = (alpha) => new Color(colorValue.setA(alpha / 100));
  const onHueChange = (hue) => {
    handleChange(getHueColor(hue), {
      type: "hue",
      value: hue
    });
  };
  const onAlphaChange = (alpha) => {
    handleChange(getAlphaColor4(alpha), {
      type: "alpha",
      value: alpha
    });
  };
  const onHueChangeComplete = (hue) => {
    if (onChangeComplete) {
      onChangeComplete(getHueColor(hue));
    }
  };
  const onAlphaChangeComplete = (alpha) => {
    if (onChangeComplete) {
      onChangeComplete(getAlphaColor4(alpha));
    }
  };
  const mergeCls = clsx(`${prefixCls}-panel`, className, {
    [`${prefixCls}-panel-disabled`]: disabled
  });
  const sharedSliderProps = {
    prefixCls,
    disabled,
    color: colorValue
  };
  const defaultPanel = import_react50.default.createElement(import_react50.default.Fragment, null, import_react50.default.createElement(Picker_default, _extends8({
    onChange: handleChange
  }, sharedSliderProps, {
    onChangeComplete
  })), import_react50.default.createElement("div", {
    className: `${prefixCls}-slider-container`
  }, import_react50.default.createElement("div", {
    className: clsx(`${prefixCls}-slider-group`, {
      [`${prefixCls}-slider-group-disabled-alpha`]: disabledAlpha
    })
  }, import_react50.default.createElement(Slider5, _extends8({}, sharedSliderProps, {
    type: "hue",
    colors: HUE_COLORS,
    min: 0,
    max: 359,
    value: colorValue.getHue(),
    onChange: onHueChange,
    onChangeComplete: onHueChangeComplete
  })), !disabledAlpha && import_react50.default.createElement(Slider5, _extends8({}, sharedSliderProps, {
    type: "alpha",
    colors: [{
      percent: 0,
      color: "rgba(255, 0, 4, 0)"
    }, {
      percent: 100,
      color: alphaColor
    }],
    min: 0,
    max: 100,
    value: colorValue.a * 100,
    onChange: onAlphaChange,
    onChangeComplete: onAlphaChangeComplete
  }))), import_react50.default.createElement(ColorBlock_default, {
    color: colorValue.toRgbString(),
    prefixCls
  })));
  return import_react50.default.createElement("div", {
    className: mergeCls,
    style: style2,
    ref
  }, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
});
if (true) {
  ColorPicker.displayName = "ColorPicker";
}
var ColorPicker_default = ColorPicker;

// node_modules/@rc-component/color-picker/es/index.js
var es_default5 = ColorPicker_default;

// node_modules/antd/es/color-picker/color.js
var toHexFormat = (value, alpha) => (value == null ? void 0 : value.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6)) || "";
var getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
var AggregationColor = function() {
  function AggregationColor2(color) {
    var _a;
    _classCallCheck(this, AggregationColor2);
    this.cleared = false;
    if (color instanceof AggregationColor2) {
      this.metaColor = color.metaColor.clone();
      this.colors = (_a = color.colors) == null ? void 0 : _a.map((info) => ({
        color: new AggregationColor2(info.color),
        percent: info.percent
      }));
      this.cleared = color.cleared;
      return;
    }
    const isArray = Array.isArray(color);
    if (isArray && color.length) {
      this.colors = color.map(({
        color: c,
        percent
      }) => ({
        color: new AggregationColor2(c),
        percent
      }));
      this.metaColor = new Color(this.colors[0].color.metaColor);
    } else {
      this.metaColor = new Color(isArray ? "" : color);
    }
    if (!color || isArray && !this.colors) {
      this.metaColor = this.metaColor.setA(0);
      this.cleared = true;
    }
  }
  return _createClass(AggregationColor2, [{
    key: "toHsb",
    value: function toHsb() {
      return this.metaColor.toHsb();
    }
  }, {
    key: "toHsbString",
    value: function toHsbString() {
      return this.metaColor.toHsbString();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return getHex(this.toHexString(), this.metaColor.a < 1);
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      return this.metaColor.toHexString();
    }
  }, {
    key: "toRgb",
    value: function toRgb() {
      return this.metaColor.toRgb();
    }
  }, {
    key: "toRgbString",
    value: function toRgbString() {
      return this.metaColor.toRgbString();
    }
  }, {
    key: "isGradient",
    value: function isGradient() {
      return !!this.colors && !this.cleared;
    }
  }, {
    key: "getColors",
    value: function getColors() {
      return this.colors || [{
        color: this,
        percent: 0
      }];
    }
  }, {
    key: "toCssString",
    value: function toCssString() {
      const {
        colors
      } = this;
      if (colors) {
        const colorsStr = colors.map((c) => `${c.color.toRgbString()} ${c.percent}%`).join(", ");
        return `linear-gradient(90deg, ${colorsStr})`;
      }
      return this.metaColor.toRgbString();
    }
  }, {
    key: "equals",
    value: function equals(color) {
      if (!color || this.isGradient() !== color.isGradient()) {
        return false;
      }
      if (!this.isGradient()) {
        return this.toHexString() === color.toHexString();
      }
      return this.colors.length === color.colors.length && this.colors.every((c, i) => {
        const target = color.colors[i];
        return c.percent === target.percent && c.color.equals(target.color);
      });
    }
  }]);
}();

// node_modules/antd/es/color-picker/components/ColorPresets.js
var import_react55 = __toESM(require_react());

// node_modules/antd/es/collapse/Collapse.js
var React95 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends9() {
  return _extends9 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t2 = arguments[e3];
      for (var r2 in t2)
        ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends9.apply(null, arguments);
}

// node_modules/@rc-component/collapse/es/Collapse.js
var import_react54 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/hooks/useItems.js
var import_react53 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/Panel.js
var import_react52 = __toESM(require_react());

// node_modules/@rc-component/collapse/es/PanelContent.js
var import_react51 = __toESM(require_react());
var PanelContent = import_react51.default.forwardRef((props, ref) => {
  const {
    prefixCls,
    forceRender,
    className,
    style: style2,
    children,
    isActive: isActive2,
    role,
    classNames: customizeClassNames,
    styles
  } = props;
  const [rendered, setRendered] = import_react51.default.useState(isActive2 || forceRender);
  import_react51.default.useEffect(() => {
    if (forceRender || isActive2) {
      setRendered(true);
    }
  }, [forceRender, isActive2]);
  if (!rendered) {
    return null;
  }
  return import_react51.default.createElement("div", {
    ref,
    className: clsx(`${prefixCls}-panel`, {
      [`${prefixCls}-panel-active`]: isActive2,
      [`${prefixCls}-panel-inactive`]: !isActive2
    }, className),
    style: style2,
    role
  }, import_react51.default.createElement("div", {
    className: clsx(`${prefixCls}-body`, customizeClassNames == null ? void 0 : customizeClassNames.body),
    style: styles == null ? void 0 : styles.body
  }, children));
});
if (true) {
  PanelContent.displayName = "PanelContent";
}
var PanelContent_default = PanelContent;

// node_modules/@rc-component/collapse/es/Panel.js
var CollapsePanel = import_react52.default.forwardRef((props, ref) => {
  const {
    showArrow = true,
    headerClass,
    isActive: isActive2,
    onItemClick,
    forceRender,
    className,
    classNames: customizeClassNames = {},
    styles = {},
    prefixCls,
    collapsible,
    accordion,
    panelKey,
    extra,
    header,
    expandIcon,
    openMotion,
    destroyOnHidden,
    children,
    ...resetProps
  } = props;
  const disabled = collapsible === "disabled";
  const ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
  const collapsibleProps = {
    onClick: () => {
      onItemClick == null ? void 0 : onItemClick(panelKey);
    },
    onKeyDown: (e3) => {
      if (e3.key === "Enter" || e3.keyCode === KeyCode_default.ENTER || e3.which === KeyCode_default.ENTER) {
        onItemClick == null ? void 0 : onItemClick(panelKey);
      }
    },
    role: accordion ? "tab" : "button",
    ["aria-expanded"]: isActive2,
    ["aria-disabled"]: disabled,
    tabIndex: disabled ? -1 : 0
  };
  const iconNodeInner = typeof expandIcon === "function" ? expandIcon(props) : import_react52.default.createElement("i", {
    className: "arrow"
  });
  const iconNode = iconNodeInner && import_react52.default.createElement("div", _extends9({
    className: clsx(`${prefixCls}-expand-icon`, customizeClassNames == null ? void 0 : customizeClassNames.icon),
    style: styles == null ? void 0 : styles.icon
  }, ["header", "icon"].includes(collapsible) ? collapsibleProps : {}), iconNodeInner);
  const collapsePanelClassNames = clsx(`${prefixCls}-item`, {
    [`${prefixCls}-item-active`]: isActive2,
    [`${prefixCls}-item-disabled`]: disabled
  }, className);
  const headerClassName = clsx(headerClass, `${prefixCls}-header`, {
    [`${prefixCls}-collapsible-${collapsible}`]: !!collapsible
  }, customizeClassNames == null ? void 0 : customizeClassNames.header);
  const headerProps = {
    className: headerClassName,
    style: styles == null ? void 0 : styles.header,
    ...["header", "icon"].includes(collapsible) ? {} : collapsibleProps
  };
  return import_react52.default.createElement("div", _extends9({}, resetProps, {
    ref,
    className: collapsePanelClassNames
  }), import_react52.default.createElement("div", headerProps, showArrow && iconNode, import_react52.default.createElement("span", _extends9({
    className: clsx(`${prefixCls}-title`, customizeClassNames == null ? void 0 : customizeClassNames.title),
    style: styles == null ? void 0 : styles.title
  }, collapsible === "header" ? collapsibleProps : {}), header), ifExtraExist && import_react52.default.createElement("div", {
    className: `${prefixCls}-extra`
  }, extra)), import_react52.default.createElement(es_default2, _extends9({
    visible: isActive2,
    leavedClassName: `${prefixCls}-panel-hidden`
  }, openMotion, {
    forceRender,
    removeOnLeave: destroyOnHidden
  }), ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => {
    return import_react52.default.createElement(PanelContent_default, {
      ref: motionRef,
      prefixCls,
      className: motionClassName,
      classNames: customizeClassNames,
      style: motionStyle,
      styles,
      isActive: isActive2,
      forceRender,
      role: accordion ? "tabpanel" : void 0
    }, children);
  }));
});
var Panel_default = CollapsePanel;

// node_modules/@rc-component/collapse/es/hooks/useItems.js
var convertItemsToNodes = (items, props) => {
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon,
    classNames: collapseClassNames,
    styles
  } = props;
  return items.map((item, index2) => {
    const {
      children,
      label,
      key: rawKey,
      collapsible: rawCollapsible,
      onItemClick: rawOnItemClick,
      destroyOnHidden: rawDestroyOnHidden,
      ...restProps
    } = item;
    const key = String(rawKey ?? index2);
    const mergeCollapsible = rawCollapsible ?? collapsible;
    const mergedDestroyOnHidden = rawDestroyOnHidden ?? destroyOnHidden;
    const handleItemClick = (value) => {
      if (mergeCollapsible === "disabled") {
        return;
      }
      onItemClick(value);
      rawOnItemClick == null ? void 0 : rawOnItemClick(value);
    };
    let isActive2 = false;
    if (accordion) {
      isActive2 = activeKey[0] === key;
    } else {
      isActive2 = activeKey.indexOf(key) > -1;
    }
    return import_react53.default.createElement(Panel_default, _extends9({}, restProps, {
      classNames: collapseClassNames,
      styles,
      prefixCls,
      key,
      panelKey: key,
      isActive: isActive2,
      accordion,
      openMotion,
      expandIcon,
      header: label,
      collapsible: mergeCollapsible,
      onItemClick: handleItemClick,
      destroyOnHidden: mergedDestroyOnHidden
    }), children);
  });
};
var getNewChild = (child, index2, props) => {
  if (!child) {
    return null;
  }
  const {
    prefixCls,
    accordion,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    openMotion,
    expandIcon,
    classNames: collapseClassNames,
    styles
  } = props;
  const key = child.key || String(index2);
  const {
    header,
    headerClass,
    destroyOnHidden: childDestroyOnHidden,
    collapsible: childCollapsible,
    onItemClick: childOnItemClick
  } = child.props;
  let isActive2 = false;
  if (accordion) {
    isActive2 = activeKey[0] === key;
  } else {
    isActive2 = activeKey.indexOf(key) > -1;
  }
  const mergeCollapsible = childCollapsible ?? collapsible;
  const handleItemClick = (value) => {
    if (mergeCollapsible === "disabled") {
      return;
    }
    onItemClick(value);
    childOnItemClick == null ? void 0 : childOnItemClick(value);
  };
  const childProps = {
    key,
    panelKey: key,
    header,
    headerClass,
    classNames: collapseClassNames,
    styles,
    isActive: isActive2,
    prefixCls,
    destroyOnHidden: childDestroyOnHidden ?? destroyOnHidden,
    openMotion,
    accordion,
    children: child.props.children,
    onItemClick: handleItemClick,
    expandIcon,
    collapsible: mergeCollapsible
  };
  if (typeof child.type === "string") {
    return child;
  }
  Object.keys(childProps).forEach((propName) => {
    if (typeof childProps[propName] === "undefined") {
      delete childProps[propName];
    }
  });
  return import_react53.default.cloneElement(child, childProps);
};
function useItems(items, rawChildren, props) {
  if (Array.isArray(items)) {
    return convertItemsToNodes(items, props);
  }
  return toArray(rawChildren).map((child, index2) => getNewChild(child, index2, props));
}
var useItems_default = useItems;

// node_modules/@rc-component/collapse/es/Collapse.js
function getActiveKeysArray(activeKey) {
  let currentActiveKey = activeKey;
  if (!Array.isArray(currentActiveKey)) {
    const activeKeyType = typeof currentActiveKey;
    currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
  }
  return currentActiveKey.map((key) => String(key));
}
var Collapse = import_react54.default.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-collapse",
    destroyOnHidden = false,
    style: style2,
    accordion,
    className,
    children,
    collapsible,
    openMotion,
    expandIcon,
    activeKey: rawActiveKey,
    defaultActiveKey,
    onChange,
    items,
    classNames: customizeClassNames,
    styles
  } = props;
  const collapseClassName = clsx(prefixCls, className);
  const [internalActiveKey, setActiveKey] = useControlledState(defaultActiveKey, rawActiveKey);
  const activeKey = getActiveKeysArray(internalActiveKey);
  const triggerActiveKey = useEvent_default((next2) => {
    const nextKeys = getActiveKeysArray(next2);
    setActiveKey(nextKeys);
    onChange == null ? void 0 : onChange(nextKeys);
  });
  const onItemClick = (key) => {
    if (accordion) {
      triggerActiveKey(activeKey[0] === key ? [] : [key]);
    } else {
      triggerActiveKey(activeKey.includes(key) ? activeKey.filter((item) => item !== key) : [...activeKey, key]);
    }
  };
  warning_default(!children, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
  const mergedChildren = useItems_default(items, children, {
    prefixCls,
    accordion,
    openMotion,
    expandIcon,
    collapsible,
    destroyOnHidden,
    onItemClick,
    activeKey,
    classNames: customizeClassNames,
    styles
  });
  return import_react54.default.createElement("div", _extends9({
    ref,
    className: collapseClassName,
    style: style2,
    role: accordion ? "tablist" : void 0
  }, pickAttrs(props, {
    aria: true,
    data: true
  })), mergedChildren);
});
var Collapse_default = Object.assign(Collapse, {
  /**
   * @deprecated use `items` instead, will be removed in `v4.0.0`
   */
  Panel: Panel_default
});

// node_modules/@rc-component/collapse/es/index.js
var es_default6 = Collapse_default;
var {
  Panel
} = Collapse_default;

// node_modules/antd/es/collapse/CollapsePanel.js
var React94 = __toESM(require_react());
var CollapsePanel2 = React94.forwardRef((props, ref) => {
  if (true) {
    const warning5 = devUseWarning("Collapse.Panel");
    warning5.deprecated(!("disabled" in props), "disabled", 'collapsible="disabled"');
  }
  const {
    getPrefixCls
  } = React94.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showArrow = true
  } = props;
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const collapsePanelClassName = clsx({
    [`${prefixCls}-no-arrow`]: !showArrow
  }, className);
  return React94.createElement(es_default6.Panel, {
    ref,
    ...props,
    prefixCls,
    className: collapsePanelClassName
  });
});
var CollapsePanel_default = CollapsePanel2;

// node_modules/antd/es/style/motion/collapse.js
var genCollapseMotion = (token2) => ({
  [token2.componentCls]: {
    // For common/openAnimation
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
});
var collapse_default = genCollapseMotion;

// node_modules/antd/es/style/motion/motion.js
var initMotionCommon = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
var initMotionCommonLeave = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
var initMotion = (motionCls, inKeyframes, outKeyframes, duration, sameLevel = false) => {
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: {
      ...initMotionCommon(duration),
      animationPlayState: "paused"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      ...initMotionCommonLeave(duration),
      animationPlayState: "paused"
    },
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
};

// node_modules/antd/es/style/motion/fade.js
var fadeIn = new Keyframes_default("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var fadeOut = new Keyframes_default("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
var initFadeMotion = (token2, sameLevel = false) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
};

// node_modules/antd/es/style/motion/move.js
var moveDownIn = new Keyframes_default("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveDownOut = new Keyframes_default("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveLeftIn = new Keyframes_default("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveLeftOut = new Keyframes_default("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveRightIn = new Keyframes_default("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveRightOut = new Keyframes_default("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveUpIn = new Keyframes_default("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
var moveUpOut = new Keyframes_default("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
var moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
var initMoveMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};

// node_modules/antd/es/style/motion/slide.js
var slideUpIn = new Keyframes_default("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideUpOut = new Keyframes_default("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideDownIn = new Keyframes_default("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
var slideDownOut = new Keyframes_default("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
var slideLeftIn = new Keyframes_default("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
var slideLeftOut = new Keyframes_default("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
var slideRightIn = new Keyframes_default("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
var slideRightOut = new Keyframes_default("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
var slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
var initSlideMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
};

// node_modules/antd/es/style/motion/zoom.js
var zoomIn = new Keyframes_default("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomOut = new Keyframes_default("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
var zoomBigIn = new Keyframes_default("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
var zoomBigOut = new Keyframes_default("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
var zoomUpIn = new Keyframes_default("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
var zoomUpOut = new Keyframes_default("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
var zoomLeftIn = new Keyframes_default("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
var zoomLeftOut = new Keyframes_default("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
var zoomRightIn = new Keyframes_default("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
var zoomRightOut = new Keyframes_default("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
var zoomDownIn = new Keyframes_default("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
var zoomDownOut = new Keyframes_default("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
var zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
var initZoomMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};

// node_modules/antd/es/collapse/style/index.js
var genBaseStyle2 = (token2) => {
  const {
    componentCls,
    contentBg,
    padding,
    headerBg,
    headerPadding,
    collapseHeaderPaddingSM,
    collapseHeaderPaddingLG,
    collapsePanelBorderRadius,
    lineWidth,
    lineType,
    colorBorder,
    colorText,
    colorTextHeading,
    colorTextDisabled,
    fontSizeLG,
    lineHeight,
    lineHeightLG,
    marginSM,
    paddingSM,
    paddingLG,
    paddingXS,
    motionDurationSlow,
    fontSizeIcon,
    contentPadding,
    fontHeight,
    fontHeightLG
  } = token2;
  const borderBase = `${unit(lineWidth)} ${lineType} ${colorBorder}`;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      backgroundColor: headerBg,
      border: borderBase,
      borderRadius: collapsePanelBorderRadius,
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${componentCls}-item`]: {
        borderBottom: borderBase,
        "&:first-child": {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)} 0 0`
          }
        },
        "&:last-child": {
          [`
            &,
            & > ${componentCls}-header`]: {
            borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}`
          }
        },
        [`> ${componentCls}-header`]: {
          position: "relative",
          // Compatible with old version of antd, should remove in next version
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: headerPadding,
          color: colorTextHeading,
          lineHeight,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}, visibility 0s`,
          ...genFocusStyle(token2),
          [`> ${componentCls}-title`]: {
            flex: "auto"
          },
          // >>>>> Arrow
          [`${componentCls}-expand-icon`]: {
            height: fontHeight,
            display: "flex",
            alignItems: "center",
            marginInlineEnd: marginSM
          },
          [`${componentCls}-arrow`]: {
            ...resetIcon(),
            fontSize: fontSizeIcon,
            // when `transform: rotate()` is applied to icon's root element
            transition: `transform ${motionDurationSlow}`,
            // when `transform: rotate()` is applied to icon's child element
            svg: {
              transition: `transform ${motionDurationSlow}`
            }
          },
          // >>>>> Text
          [`${componentCls}-title`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${componentCls}-collapsible-header`]: {
          cursor: "default",
          [`${componentCls}-title`]: {
            flex: "none",
            cursor: "pointer"
          },
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`${componentCls}-collapsible-icon`]: {
          cursor: "unset",
          [`${componentCls}-expand-icon`]: {
            cursor: "pointer"
          }
        }
      },
      [`${componentCls}-panel`]: {
        color: colorText,
        backgroundColor: contentBg,
        borderTop: borderBase,
        [`& > ${componentCls}-body`]: {
          padding: contentPadding
        },
        "&-hidden": {
          display: "none"
        }
      },
      "&-small": {
        [`> ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingSM,
            paddingInlineStart: paddingXS,
            [`> ${componentCls}-expand-icon`]: {
              // Arrow offset
              marginInlineStart: token2.calc(paddingSM).sub(paddingXS).equal()
            }
          },
          [`> ${componentCls}-panel > ${componentCls}-body`]: {
            padding: paddingSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-item`]: {
          fontSize: fontSizeLG,
          lineHeight: lineHeightLG,
          [`> ${componentCls}-header`]: {
            padding: collapseHeaderPaddingLG,
            paddingInlineStart: padding,
            [`> ${componentCls}-expand-icon`]: {
              height: fontHeightLG,
              // Arrow offset
              marginInlineStart: token2.calc(paddingLG).sub(padding).equal()
            }
          },
          [`> ${componentCls}-panel > ${componentCls}-body`]: {
            padding: paddingLG
          }
        }
      },
      [`${componentCls}-item:last-child`]: {
        borderBottom: 0,
        [`> ${componentCls}-panel`]: {
          borderRadius: `0 0 ${unit(collapsePanelBorderRadius)} ${unit(collapsePanelBorderRadius)}`
        }
      },
      [`& ${componentCls}-item-disabled > ${componentCls}-header`]: {
        [`
          &,
          & > .arrow
        `]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Placement ==========================
      [`&${componentCls}-icon-placement-end`]: {
        [`& > ${componentCls}-item`]: {
          [`> ${componentCls}-header`]: {
            [`${componentCls}-expand-icon`]: {
              order: 1,
              marginInlineEnd: 0,
              marginInlineStart: marginSM
            }
          }
        }
      }
    }
  };
};
var genArrowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
  return {
    [`${componentCls}-rtl`]: {
      [fixedSelector]: {
        transform: `rotate(180deg)`
      }
    }
  };
};
var genBorderlessStyle = (token2) => {
  const {
    componentCls,
    headerBg,
    borderlessContentPadding,
    borderlessContentBg,
    colorBorder
  } = token2;
  return {
    [`${componentCls}-borderless`]: {
      backgroundColor: headerBg,
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: `1px solid ${colorBorder}`
      },
      [`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: {
        borderRadius: 0
      },
      [`> ${componentCls}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${componentCls}-item > ${componentCls}-panel`]: {
        backgroundColor: borderlessContentBg,
        borderTop: 0
      },
      [`> ${componentCls}-item > ${componentCls}-panel > ${componentCls}-body`]: {
        padding: borderlessContentPadding
      }
    }
  };
};
var genGhostStyle = (token2) => {
  const {
    componentCls,
    paddingSM
  } = token2;
  return {
    [`${componentCls}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${componentCls}-item`]: {
        borderBottom: 0,
        [`> ${componentCls}-panel`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${componentCls}-body`]: {
            paddingBlock: paddingSM
          }
        }
      }
    }
  };
};
var prepareComponentToken5 = (token2) => ({
  headerPadding: `${token2.paddingSM}px ${token2.padding}px`,
  headerBg: token2.colorFillAlter,
  contentPadding: `${token2.padding}px 16px`,
  // Fixed Value
  contentBg: token2.colorBgContainer,
  borderlessContentPadding: `${token2.paddingXXS}px 16px ${token2.padding}px`,
  borderlessContentBg: "transparent"
});
var style_default6 = genStyleHooks("Collapse", (token2) => {
  const collapseToken = merge2(token2, {
    collapseHeaderPaddingSM: `${unit(token2.paddingXS)} ${unit(token2.paddingSM)}`,
    collapseHeaderPaddingLG: `${unit(token2.padding)} ${unit(token2.paddingLG)}`,
    collapsePanelBorderRadius: token2.borderRadiusLG
  });
  return [genBaseStyle2(collapseToken), genBorderlessStyle(collapseToken), genGhostStyle(collapseToken), genArrowStyle(collapseToken), collapse_default(collapseToken)];
}, prepareComponentToken5);

// node_modules/antd/es/collapse/Collapse.js
var Collapse2 = React95.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction,
    expandIcon: contextExpandIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("collapse");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    bordered = true,
    ghost,
    size: customizeSize,
    expandIconPlacement,
    expandIconPosition,
    children,
    destroyInactivePanel,
    destroyOnHidden,
    expandIcon,
    classNames,
    styles
  } = props;
  const mergedSize = useSize_default((ctx) => customizeSize ?? ctx ?? "middle");
  const prefixCls = getPrefixCls("collapse", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [hashId, cssVarCls] = style_default6(prefixCls);
  const mergedPlacement = expandIconPlacement ?? expandIconPosition ?? "start";
  const mergedProps = {
    ...props,
    size: mergedSize,
    bordered,
    expandIconPlacement: mergedPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedExpandIcon = expandIcon ?? contextExpandIcon;
  if (true) {
    const warning5 = devUseWarning("Collapse");
    [["destroyInactivePanel", "destroyOnHidden"], ["expandIconPosition", "expandIconPlacement"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const renderExpandIcon3 = React95.useCallback((panelProps = {}) => {
    const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : React95.createElement(RightOutlined_default, {
      rotate: panelProps.isActive ? direction === "rtl" ? -90 : 90 : void 0,
      "aria-label": panelProps.isActive ? "expanded" : "collapsed"
    });
    return cloneElement3(icon, () => {
      var _a;
      return {
        className: clsx((_a = icon == null ? void 0 : icon.props) == null ? void 0 : _a.className, `${prefixCls}-arrow`)
      };
    });
  }, [mergedExpandIcon, prefixCls, direction]);
  const collapseClassName = clsx(`${prefixCls}-icon-placement-${mergedPlacement}`, {
    [`${prefixCls}-borderless`]: !bordered,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-ghost`]: !!ghost,
    [`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
  }, contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const openMotion = React95.useMemo(() => ({
    ...motion_default(rootPrefixCls),
    motionAppear: false,
    leavedClassName: `${prefixCls}-panel-hidden`
  }), [rootPrefixCls, prefixCls]);
  const items = React95.useMemo(() => {
    if (children) {
      return toArray(children).map((child) => child);
    }
    return null;
  }, [children]);
  return (
    // @ts-ignore
    React95.createElement(es_default6, {
      ref,
      openMotion,
      ...omit(props, ["rootClassName"]),
      expandIcon: renderExpandIcon3,
      prefixCls,
      className: collapseClassName,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      classNames: mergedClassNames,
      styles: mergedStyles,
      destroyOnHidden: destroyOnHidden ?? destroyInactivePanel
    }, items)
  );
});
if (true) {
  Collapse2.displayName = "Collapse";
}
var Collapse_default2 = Object.assign(Collapse2, {
  Panel: CollapsePanel_default
});

// node_modules/antd/es/collapse/index.js
var collapse_default2 = Collapse_default2;

// node_modules/antd/es/color-picker/util.js
var generateColor2 = (color) => {
  if (color instanceof AggregationColor) {
    return color;
  }
  return new AggregationColor(color);
};
var getRoundNumber2 = (value) => Math.round(Number(value || 0));
var getColorAlpha = (color) => getRoundNumber2(color.toHsb().a * 100);
var genAlphaColor = (color, alpha) => {
  const rgba = color.toRgb();
  if (!rgba.r && !rgba.g && !rgba.b) {
    const hsba = color.toHsb();
    hsba.a = alpha || 1;
    return generateColor2(hsba);
  }
  rgba.a = alpha || 1;
  return generateColor2(rgba);
};
var getGradientPercentColor = (colors, percent) => {
  const filledColors = [{
    percent: 0,
    color: colors[0].color
  }].concat(_toConsumableArray(colors), [{
    percent: 100,
    color: colors[colors.length - 1].color
  }]);
  for (let i = 0; i < filledColors.length - 1; i += 1) {
    const startPtg = filledColors[i].percent;
    const endPtg = filledColors[i + 1].percent;
    const startColor = filledColors[i].color;
    const endColor = filledColors[i + 1].color;
    if (startPtg <= percent && percent <= endPtg) {
      const dist = endPtg - startPtg;
      if (dist === 0) {
        return startColor;
      }
      const ratio = (percent - startPtg) / dist * 100;
      const startRcColor = new Color(startColor);
      const endRcColor = new Color(endColor);
      return startRcColor.mix(endRcColor, ratio).toRgbString();
    }
  }
  return "";
};

// node_modules/antd/es/color-picker/components/ColorPresets.js
var genPresetColor2 = (list) => list.map((value) => {
  value.colors = value.colors.map(generateColor2);
  return value;
});
var isBright = (value, bgColorToken) => {
  const {
    r: r2,
    g,
    b,
    a
  } = value.toRgb();
  const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
  if (a <= 0.5) {
    return hsv.v > 0.5;
  }
  return r2 * 0.299 + g * 0.587 + b * 0.114 > 192;
};
var genCollapsePanelKey = (preset, index2) => {
  const mergedKey = preset.key ?? index2;
  return `panel-${mergedKey}`;
};
var ColorPresets = ({
  prefixCls,
  presets,
  value: color,
  onChange
}) => {
  const [locale6] = useLocale_default("ColorPicker");
  const [, token2] = useToken();
  const presetsValue = (0, import_react55.useMemo)(() => genPresetColor2(presets), [presets]);
  const colorPresetsPrefixCls = `${prefixCls}-presets`;
  const activeKeys = (0, import_react55.useMemo)(() => presetsValue.reduce((acc, preset, index2) => {
    const {
      defaultOpen = true
    } = preset;
    if (defaultOpen) {
      acc.push(genCollapsePanelKey(preset, index2));
    }
    return acc;
  }, []), [presetsValue]);
  const handleClick = (colorValue) => {
    onChange == null ? void 0 : onChange(colorValue);
  };
  const items = presetsValue.map((preset, index2) => {
    var _a;
    return {
      key: genCollapsePanelKey(preset, index2),
      label: import_react55.default.createElement("div", {
        className: `${colorPresetsPrefixCls}-label`
      }, preset == null ? void 0 : preset.label),
      children: import_react55.default.createElement("div", {
        className: `${colorPresetsPrefixCls}-items`
      }, Array.isArray(preset == null ? void 0 : preset.colors) && ((_a = preset.colors) == null ? void 0 : _a.length) > 0 ? preset.colors.map((presetColor, index3) => {
        const colorInst = generateColor2(presetColor);
        return import_react55.default.createElement(
          ColorBlock_default,
          {
            // eslint-disable-next-line react/no-array-index-key
            key: `preset-${index3}-${presetColor.toHexString()}`,
            color: colorInst.toCssString(),
            prefixCls,
            className: clsx(`${colorPresetsPrefixCls}-color`, {
              [`${colorPresetsPrefixCls}-color-checked`]: presetColor.toCssString() === (color == null ? void 0 : color.toCssString()),
              [`${colorPresetsPrefixCls}-color-bright`]: isBright(presetColor, token2.colorBgElevated)
            }),
            onClick: () => handleClick(presetColor)
          }
        );
      }) : import_react55.default.createElement("span", {
        className: `${colorPresetsPrefixCls}-empty`
      }, locale6.presetEmpty))
    };
  });
  return import_react55.default.createElement("div", {
    className: colorPresetsPrefixCls
  }, import_react55.default.createElement(collapse_default2, {
    defaultActiveKey: activeKeys,
    ghost: true,
    items
  }));
};
var ColorPresets_default = ColorPresets;

// node_modules/antd/es/button/style/token.js
var prepareToken = (token2) => {
  const {
    paddingInline,
    onlyIconSize,
    borderColorDisabled
  } = token2;
  const buttonToken = merge2(token2, {
    buttonPaddingHorizontal: paddingInline,
    buttonPaddingVertical: 0,
    buttonIconOnlyFontSize: onlyIconSize,
    colorBorderDisabled: borderColorDisabled
  });
  return buttonToken;
};
var prepareComponentToken6 = (token2) => {
  const contentFontSize = token2.contentFontSize ?? token2.fontSize;
  const contentFontSizeSM = token2.contentFontSizeSM ?? token2.fontSize;
  const contentFontSizeLG = token2.contentFontSizeLG ?? token2.fontSizeLG;
  const contentLineHeight = token2.contentLineHeight ?? getLineHeight(contentFontSize);
  const contentLineHeightSM = token2.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
  const contentLineHeightLG = token2.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
  const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
  const shadowColorTokens = PresetColors.reduce((prev2, colorKey) => ({
    ...prev2,
    [`${colorKey}ShadowColor`]: `0 ${unit(token2.controlOutlineWidth)} 0 ${getAlphaColor_default(token2[`${colorKey}1`], token2.colorBgContainer)}`
  }), {});
  const defaultBgDisabled = token2.colorBgContainerDisabled;
  const dashedBgDisabled = token2.colorBgContainerDisabled;
  return {
    ...shadowColorTokens,
    fontWeight: 400,
    iconGap: token2.marginXS,
    defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
    primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
    dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
    primaryColor: token2.colorTextLightSolid,
    dangerColor: token2.colorTextLightSolid,
    borderColorDisabled: token2.colorBorderDisabled,
    defaultGhostColor: token2.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: token2.colorBgContainer,
    paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
    paddingInlineSM: 8 - token2.lineWidth,
    onlyIconSize: "inherit",
    onlyIconSizeSM: "inherit",
    onlyIconSizeLG: "inherit",
    groupBorderColor: token2.colorPrimaryHover,
    linkHoverBg: "transparent",
    textTextColor: token2.colorText,
    textTextHoverColor: token2.colorText,
    textTextActiveColor: token2.colorText,
    textHoverBg: token2.colorFillTertiary,
    defaultColor: token2.colorText,
    defaultBg: token2.colorBgContainer,
    defaultBorderColor: token2.colorBorder,
    defaultBorderColorDisabled: token2.colorBorder,
    defaultHoverBg: token2.colorBgContainer,
    defaultHoverColor: token2.colorPrimaryHover,
    defaultHoverBorderColor: token2.colorPrimaryHover,
    defaultActiveBg: token2.colorBgContainer,
    defaultActiveColor: token2.colorPrimaryActive,
    defaultActiveBorderColor: token2.colorPrimaryActive,
    solidTextColor,
    contentFontSize,
    contentFontSizeSM,
    contentFontSizeLG,
    contentLineHeight,
    contentLineHeightSM,
    contentLineHeightLG,
    paddingBlock: Math.max((token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth, 0),
    paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth, 0),
    paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth, 0),
    defaultBgDisabled,
    dashedBgDisabled
  };
};

// node_modules/antd/es/button/style/variant.js
var genVariantStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const getCssVar = genCssVar(antCls, "btn");
  return {
    [componentCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        // Border
        [getCssVar("border-width")]: "1px",
        [getCssVar("border-color")]: "#000",
        [getCssVar("border-color-hover")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-color-active")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-color-disabled")]: `var(${getCssVar("border-color")})`,
        [getCssVar("border-style")]: "solid",
        // Text
        [getCssVar("text-color")]: "#000",
        [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
        [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`,
        [getCssVar("text-color-disabled")]: `var(${getCssVar("text-color")})`,
        // Background
        [getCssVar("bg-color")]: "#ddd",
        [getCssVar("bg-color-hover")]: `var(${getCssVar("bg-color")})`,
        [getCssVar("bg-color-active")]: `var(${getCssVar("bg-color")})`,
        [getCssVar("bg-color-disabled")]: token2.colorBgContainerDisabled,
        [getCssVar("bg-color-container")]: token2.colorBgContainer,
        // Shadow
        [getCssVar("shadow")]: "none"
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        // Basic
        border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color")})`,
        color: `var(${getCssVar("text-color")})`,
        backgroundColor: `var(${getCssVar("bg-color")})`,
        // Status
        [`&:not(:disabled):not(${componentCls}-disabled)`]: {
          // Hover
          "&:hover": {
            border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-hover")})`,
            color: `var(${getCssVar("text-color-hover")})`,
            backgroundColor: `var(${getCssVar("bg-color-hover")})`
          },
          // Active
          "&:active": {
            border: `var(${getCssVar("border-width")}) var(${getCssVar("border-style")}) var(${getCssVar("border-color-active")})`,
            color: `var(${getCssVar("text-color-active")})`,
            backgroundColor: `var(${getCssVar("bg-color-active")})`
          }
        }
      },
      // ==============================================================
      // ==                         Variants                         ==
      // ==============================================================
      {
        // >>>>> Solid
        [`&${componentCls}-variant-solid`]: {
          // Solid Variables
          [getCssVar("solid-bg-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("solid-bg-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("solid-bg-color-active")]: `var(${getCssVar("color-active")})`,
          // Variables
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: token2.colorTextLightSolid,
          [getCssVar("bg-color")]: `var(${getCssVar("solid-bg-color")})`,
          [getCssVar("bg-color-hover")]: `var(${getCssVar("solid-bg-color-hover")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("solid-bg-color-active")})`,
          // Box Shadow
          boxShadow: `var(${getCssVar("shadow")})`
        },
        // >>>>> Outlined & Dashed
        [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
          [getCssVar("border-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("border-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("border-color-active")]: `var(${getCssVar("color-active")})`,
          [getCssVar("bg-color")]: `var(${getCssVar("bg-color-container")})`,
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
          // Box Shadow
          boxShadow: `var(${getCssVar("shadow")})`
        },
        // >>>>> Dashed
        [`&${componentCls}-variant-dashed`]: {
          [getCssVar("border-style")]: "dashed",
          [getCssVar("bg-color-disabled")]: token2.dashedBgDisabled
        },
        // >>>>> Filled
        [`&${componentCls}-variant-filled`]: {
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("bg-color")]: `var(${getCssVar("color-light")})`,
          [getCssVar("bg-color-hover")]: `var(${getCssVar("color-light-hover")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
        },
        // >>>>> Text & Link
        [`&${componentCls}-variant-text, &${componentCls}-variant-link`]: {
          [getCssVar("border-color")]: "transparent",
          [getCssVar("text-color")]: `var(${getCssVar("color-base")})`,
          [getCssVar("text-color-hover")]: `var(${getCssVar("color-hover")})`,
          [getCssVar("text-color-active")]: `var(${getCssVar("color-active")})`,
          [getCssVar("bg-color")]: "transparent",
          [getCssVar("bg-color-hover")]: "transparent",
          [getCssVar("bg-color-active")]: "transparent",
          [`&:disabled, &${token2.componentCls}-disabled`]: {
            background: "transparent",
            borderColor: "transparent"
          }
        },
        // >>>>> Text
        [`&${componentCls}-variant-text`]: {
          [getCssVar("bg-color-hover")]: `var(${getCssVar("color-light")})`,
          [getCssVar("bg-color-active")]: `var(${getCssVar("color-light-active")})`
        }
      },
      // ==============================================================
      // ==                          Colors                          ==
      // ==============================================================
      {
        // ======================== By Default ========================
        // >>>>> Link
        [`&${componentCls}-variant-link`]: {
          [getCssVar("color-base")]: token2.colorLink,
          [getCssVar("color-hover")]: token2.colorLinkHover,
          [getCssVar("color-active")]: token2.colorLinkActive
        },
        // ======================== Compatible ========================
        // >>>>> Primary
        [`&${componentCls}-color-primary`]: {
          [getCssVar("color-base")]: token2.colorPrimary,
          [getCssVar("color-hover")]: token2.colorPrimaryHover,
          [getCssVar("color-active")]: token2.colorPrimaryActive,
          [getCssVar("color-light")]: token2.colorPrimaryBg,
          [getCssVar("color-light-hover")]: token2.colorPrimaryBgHover,
          [getCssVar("color-light-active")]: token2.colorPrimaryBorder,
          [getCssVar("shadow")]: token2.primaryShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token2.primaryColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          }
        },
        // >>>>> Danger
        [`&${componentCls}-color-dangerous`]: {
          [getCssVar("color-base")]: token2.colorError,
          [getCssVar("color-hover")]: token2.colorErrorHover,
          [getCssVar("color-active")]: token2.colorErrorActive,
          [getCssVar("color-light")]: token2.colorErrorBg,
          [getCssVar("color-light-hover")]: token2.colorErrorBgFilledHover,
          [getCssVar("color-light-active")]: token2.colorErrorBgActive,
          [getCssVar("shadow")]: token2.dangerShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token2.dangerColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          }
        },
        // >>>>> Default
        [`&${componentCls}-color-default`]: {
          [getCssVar("solid-bg-color")]: token2.colorBgSolid,
          [getCssVar("solid-bg-color-hover")]: token2.colorBgSolidHover,
          [getCssVar("solid-bg-color-active")]: token2.colorBgSolidActive,
          [getCssVar("color-base")]: token2.defaultBorderColor,
          [getCssVar("color-hover")]: token2.defaultHoverBorderColor,
          [getCssVar("color-active")]: token2.defaultActiveBorderColor,
          [getCssVar("color-light")]: token2.colorFillTertiary,
          [getCssVar("color-light-hover")]: token2.colorFillSecondary,
          [getCssVar("color-light-active")]: token2.colorFill,
          [getCssVar("text-color")]: token2.colorText,
          [getCssVar("text-color-hover")]: token2.defaultHoverBorderColor,
          [getCssVar("text-color-active")]: token2.defaultActiveBorderColor,
          [getCssVar("shadow")]: token2.defaultShadow,
          [`&${componentCls}-variant-solid`]: {
            [getCssVar("text-color")]: token2.solidTextColor,
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          },
          [`&${componentCls}-variant-filled, &${componentCls}-variant-text`]: {
            [getCssVar("text-color-hover")]: `var(${getCssVar("text-color")})`,
            [getCssVar("text-color-active")]: `var(${getCssVar("text-color")})`
          },
          [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
            [getCssVar("bg-color-hover")]: token2.defaultHoverBg,
            [getCssVar("bg-color-active")]: token2.defaultActiveBg
          },
          [`&${componentCls}-background-ghost`]: {
            [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
              [getCssVar("text-color")]: token2.defaultGhostColor,
              [getCssVar("border-color")]: token2.defaultGhostBorderColor
            }
          }
        }
      },
      // >>>>> Preset Colors
      PresetColors.map((colorKey) => {
        const darkColor = token2[`${colorKey}6`];
        const lightColor = token2[`${colorKey}1`];
        const hoverColor = token2[`${colorKey}5`];
        const lightHoverColor = token2[`${colorKey}2`];
        const lightActiveColor = token2[`${colorKey}3`];
        const activeColor = token2[`${colorKey}7`];
        const shadowColor = token2[`${colorKey}ShadowColor`];
        return {
          [`&${componentCls}-color-${colorKey}`]: {
            [getCssVar("color-base")]: darkColor,
            [getCssVar("color-hover")]: hoverColor,
            [getCssVar("color-active")]: activeColor,
            [getCssVar("color-light")]: lightColor,
            [getCssVar("color-light-hover")]: lightHoverColor,
            [getCssVar("color-light-active")]: lightActiveColor,
            [getCssVar("shadow")]: shadowColor
          }
        };
      }),
      // ==============================================================
      // ==                         Disabled                         ==
      // ==============================================================
      {
        // Disabled
        [`&:disabled, &${token2.componentCls}-disabled`]: {
          cursor: "not-allowed",
          borderColor: token2.colorBorderDisabled,
          background: `var(${getCssVar("bg-color-disabled")})`,
          color: token2.colorTextDisabled,
          boxShadow: "none"
        }
      },
      // ==============================================================
      // ==                          Ghost                           ==
      // ==============================================================
      {
        // Ghost
        [`&${componentCls}-background-ghost`]: {
          [getCssVar("bg-color")]: "transparent",
          [getCssVar("shadow")]: "none"
        }
      }
    ]
  };
};
var variant_default = genVariantStyle;

// node_modules/antd/es/button/style/index.js
var genSharedButtonStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    fontWeight,
    opacityLoading,
    motionDurationSlow,
    motionEaseInOut,
    iconGap,
    calc
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: iconGap,
      alignItems: "center",
      justifyContent: "center",
      fontWeight,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      "&:disabled > *": {
        pointerEvents: "none"
      },
      // https://github.com/ant-design/ant-design/issues/51380
      [`${componentCls}-icon > svg`]: resetIcon(),
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": genFocusStyle(token2),
      [`&${componentCls}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      [`&${componentCls}-icon-only`]: {
        paddingInline: 0,
        // make `btn-icon-only` not too narrow
        [`&${componentCls}-compact-item`]: {
          flex: "none"
        }
      },
      // Loading
      [`&${componentCls}-loading`]: {
        opacity: opacityLoading,
        cursor: "default"
      },
      [`${componentCls}-loading-icon`]: {
        transition: ["width", "opacity", "margin"].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
      },
      // iconPlacement
      [`&:not(${componentCls}-icon-end)`]: {
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineEnd: calc(iconGap).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineEnd: 0
          },
          "&-leave-start": {
            marginInlineEnd: 0
          },
          "&-leave-active": {
            marginInlineEnd: calc(iconGap).mul(-1).equal()
          }
        }
      },
      "&-icon-end": {
        flexDirection: "row-reverse",
        [`${componentCls}-loading-icon-motion`]: {
          "&-appear-start, &-enter-start": {
            marginInlineStart: calc(iconGap).mul(-1).equal()
          },
          "&-appear-active, &-enter-active": {
            marginInlineStart: 0
          },
          "&-leave-start": {
            marginInlineStart: 0
          },
          "&-leave-active": {
            marginInlineStart: calc(iconGap).mul(-1).equal()
          }
        }
      }
    }
  };
};
var genCircleButtonStyle = (token2) => ({
  minWidth: token2.controlHeight,
  paddingInline: 0,
  borderRadius: "50%"
});
var genButtonStyle = (token2, prefixCls = "") => {
  const {
    componentCls,
    controlHeight,
    fontSize,
    borderRadius,
    buttonPaddingHorizontal,
    iconCls,
    buttonPaddingVertical,
    buttonIconOnlyFontSize
  } = token2;
  return [
    {
      [prefixCls]: {
        fontSize,
        height: controlHeight,
        padding: `${unit(buttonPaddingVertical)} ${unit(buttonPaddingHorizontal)}`,
        borderRadius,
        [`&${componentCls}-icon-only`]: {
          width: controlHeight,
          [iconCls]: {
            fontSize: buttonIconOnlyFontSize
          }
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${prefixCls}`]: {
        borderRadius: token2.controlHeight,
        [`&:not(${componentCls}-icon-only)`]: {
          paddingInline: token2.buttonPaddingHorizontal
        }
      }
    }
  ];
};
var genSizeBaseButtonStyle = (token2) => {
  const baseToken = merge2(token2, {
    fontSize: token2.contentFontSize
  });
  return genButtonStyle(baseToken, token2.componentCls);
};
var genSizeSmallButtonStyle = (token2) => {
  const smallToken = merge2(token2, {
    controlHeight: token2.controlHeightSM,
    fontSize: token2.contentFontSizeSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: token2.paddingInlineSM,
    buttonPaddingVertical: 0,
    borderRadius: token2.borderRadiusSM,
    buttonIconOnlyFontSize: token2.onlyIconSizeSM
  });
  return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
};
var genSizeLargeButtonStyle = (token2) => {
  const largeToken = merge2(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.contentFontSizeLG,
    buttonPaddingHorizontal: token2.paddingInlineLG,
    buttonPaddingVertical: 0,
    borderRadius: token2.borderRadiusLG,
    buttonIconOnlyFontSize: token2.onlyIconSizeLG
  });
  return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
};
var genBlockButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
var style_default7 = genStyleHooks("Button", (token2) => {
  const buttonToken = prepareToken(token2);
  return [
    // Shared
    genSharedButtonStyle(buttonToken),
    // Size
    genSizeBaseButtonStyle(buttonToken),
    genSizeSmallButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    // Block
    genBlockButtonStyle(buttonToken),
    // Variant
    variant_default(buttonToken),
    // Button Group
    group_default(buttonToken)
  ];
}, prepareComponentToken6, {
  unitless: {
    fontWeight: true,
    contentLineHeight: true,
    contentLineHeightSM: true,
    contentLineHeightLG: true
  }
});

// node_modules/antd/es/style/compact-item.js
function compactItemBorder(token2, parentCls, options, prefixCls) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    [`&-item:not(${prefixCls}-status-success)`]: {
      zIndex: 2
    },
    "&-item": {
      [hoverEffects]: {
        zIndex: 3
      },
      ...focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 3
        }
      } : {},
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle(token2, options = {
  focus: true
}) {
  const {
    componentCls
  } = token2;
  const {
    componentCls: customizePrefixCls
  } = options;
  const mergedComponentCls = customizePrefixCls || componentCls;
  const compactCls = `${mergedComponentCls}-compact`;
  return {
    [compactCls]: {
      ...compactItemBorder(token2, compactCls, options, mergedComponentCls),
      ...compactItemBorderRadius(mergedComponentCls, compactCls, options)
    }
  };
}

// node_modules/antd/es/style/compact-item-vertical.js
function compactItemVerticalBorder(token2, parentCls, prefixCls) {
  return {
    // border collapse
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
    },
    [`&-item:not(${prefixCls}-status-success)`]: {
      zIndex: 2
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 3
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: {
      ...compactItemVerticalBorder(token2, compactCls, token2.componentCls),
      ...compactItemBorderVerticalRadius(token2.componentCls, compactCls)
    }
  };
}

// node_modules/antd/es/button/style/compact.js
var genButtonCompactStyle = (token2) => {
  const {
    componentCls,
    colorPrimaryHover,
    lineWidth,
    calc
  } = token2;
  const insetOffset = calc(lineWidth).mul(-1).equal();
  const getCompactBorderStyle = (vertical) => {
    const itemCls = `${componentCls}-compact${vertical ? "-vertical" : ""}-item`;
    const selector = `${itemCls}${componentCls}-primary:not([disabled])`;
    return {
      // TODO: Border color transition should be not cover when has color.
      [itemCls]: {
        transition: `none`
      },
      [`${selector} + ${selector}::before`]: {
        position: "absolute",
        top: vertical ? insetOffset : 0,
        insetInlineStart: vertical ? 0 : insetOffset,
        backgroundColor: colorPrimaryHover,
        content: '""',
        width: vertical ? "100%" : lineWidth,
        height: vertical ? lineWidth : "100%"
      }
    };
  };
  return {
    ...getCompactBorderStyle(),
    ...getCompactBorderStyle(true)
  };
};
var compact_default2 = genSubStyleComponent(["Button", "compact"], (token2) => {
  const buttonToken = prepareToken(token2);
  return [
    // Space Compact
    genCompactItemStyle(buttonToken),
    genCompactItemVerticalStyle(buttonToken),
    genButtonCompactStyle(buttonToken)
  ];
}, prepareComponentToken6);

// node_modules/antd/es/button/Button.js
function getLoadingConfig(loading) {
  if (typeof loading === "object" && loading) {
    let delay = loading == null ? void 0 : loading.delay;
    delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
    return {
      loading: delay <= 0,
      delay
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
var ButtonTypeMap = {
  default: ["default", "outlined"],
  primary: ["primary", "solid"],
  dashed: ["default", "dashed"],
  // `link` is not a real color but we should compatible with it
  link: ["link", "link"],
  text: ["default", "text"]
};
var InternalCompoundedButton = import_react56.default.forwardRef((props, ref) => {
  const {
    _skipSemantic,
    loading = false,
    prefixCls: customizePrefixCls,
    color,
    variant,
    type: type5,
    danger = false,
    shape: customizeShape,
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    iconPosition,
    iconPlacement,
    ghost = false,
    block = false,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType = "button",
    classNames,
    styles,
    style: style2,
    autoInsertSpace,
    autoFocus,
    ...rest
  } = props;
  const childNodes = toArray(children);
  const mergedType = type5 || "default";
  const {
    button
  } = import_react56.default.useContext(ConfigContext);
  const shape = customizeShape || (button == null ? void 0 : button.shape) || "default";
  const [parsedColor, parsedVariant] = (0, import_react56.useMemo)(() => {
    if (color && variant) {
      return [color, variant];
    }
    if (type5 || danger) {
      const colorVariantPair = ButtonTypeMap[mergedType] || [];
      if (danger) {
        return ["danger", colorVariantPair[1]];
      }
      return colorVariantPair;
    }
    if ((button == null ? void 0 : button.color) && (button == null ? void 0 : button.variant)) {
      return [button.color, button.variant];
    }
    return ["default", "outlined"];
  }, [color, variant, type5, danger, button == null ? void 0 : button.color, button == null ? void 0 : button.variant, mergedType]);
  const [mergedColor, mergedVariant] = (0, import_react56.useMemo)(() => {
    if (ghost && parsedVariant === "solid") {
      return [parsedColor, "outlined"];
    }
    return [parsedColor, parsedVariant];
  }, [parsedColor, parsedVariant, ghost]);
  const isDanger = mergedColor === "danger";
  const mergedColorText = isDanger ? "dangerous" : mergedColor;
  const {
    getPrefixCls,
    direction,
    autoInsertSpace: contextAutoInsertSpace,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("button");
  const mergedInsertSpace = autoInsertSpace ?? contextAutoInsertSpace ?? true;
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [hashId, cssVarCls] = style_default7(prefixCls);
  const disabled = (0, import_react56.useContext)(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const groupSize = (0, import_react56.useContext)(GroupSizeContext);
  const loadingOrDelay = (0, import_react56.useMemo)(() => getLoadingConfig(loading), [loading]);
  const [innerLoading, setLoading] = (0, import_react56.useState)(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = (0, import_react56.useState)(false);
  const buttonRef = (0, import_react56.useRef)(null);
  const mergedRef = useComposeRef(ref, buttonRef);
  const needInserted = childNodes.length === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
  const isMountRef = (0, import_react56.useRef)(true);
  import_react56.default.useEffect(() => {
    isMountRef.current = false;
    return () => {
      isMountRef.current = true;
    };
  }, []);
  useLayoutEffect_default(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    return cleanupTimer;
  }, [loadingOrDelay.delay, loadingOrDelay.loading]);
  (0, import_react56.useEffect)(() => {
    if (!buttonRef.current || !mergedInsertSpace) {
      return;
    }
    const buttonText = buttonRef.current.textContent || "";
    if (needInserted && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  });
  (0, import_react56.useEffect)(() => {
    if (autoFocus && buttonRef.current) {
      buttonRef.current.focus();
    }
  }, []);
  const handleClick = import_react56.default.useCallback((e3) => {
    var _a;
    if (innerLoading || mergedDisabled) {
      e3.preventDefault();
      return;
    }
    (_a = props.onClick) == null ? void 0 : _a.call(props, "href" in props ? e3 : e3);
  }, [props.onClick, innerLoading, mergedDisabled]);
  if (true) {
    const warning5 = devUseWarning("Button");
    true ? warning5(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
    true ? warning5(!(ghost && isUnBorderedButtonVariant(mergedVariant)), "usage", "`link` or `text` button can't be a `ghost` button.") : void 0;
    warning5.deprecated(!iconPosition, "iconPosition", "iconPlacement");
  }
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const sizeClassNameMap2 = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  const sizeFullName = useSize_default((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
  const sizeCls = sizeFullName ? sizeClassNameMap2[sizeFullName] ?? "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const mergedIconPlacement = iconPlacement ?? iconPosition ?? "start";
  const linkButtonRestProps = omit(rest, ["navigate"]);
  const mergedProps = {
    ...props,
    type: mergedType,
    color: mergedColor,
    variant: mergedVariant,
    danger: isDanger,
    shape,
    size: sizeFullName,
    disabled: mergedDisabled,
    loading: innerLoading,
    iconPlacement: mergedIconPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([_skipSemantic ? void 0 : contextClassNames, classNames], [_skipSemantic ? void 0 : contextStyles, styles], {
    props: mergedProps
  });
  const classes = clsx(prefixCls, hashId, cssVarCls, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape !== "square" && shape,
    // Compatible with versions earlier than 5.21.0
    [`${prefixCls}-${mergedType}`]: mergedType,
    [`${prefixCls}-dangerous`]: danger,
    [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
    [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-icon-end`]: mergedIconPlacement === "end"
  }, compactItemClassnames, className, rootClassName, contextClassName, mergedClassNames.root);
  const fullStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const iconSharedProps = {
    className: mergedClassNames.icon,
    style: mergedStyles.icon
  };
  const iconWrapperElement = (child) => import_react56.default.createElement(IconWrapper_default, {
    prefixCls,
    ...iconSharedProps
  }, child);
  const defaultLoadingIconElement = import_react56.default.createElement(DefaultLoadingIcon_default, {
    existIcon: !!icon,
    prefixCls,
    loading: innerLoading,
    mount: isMountRef.current,
    ...iconSharedProps
  });
  let iconNode;
  if (icon && !innerLoading) {
    iconNode = iconWrapperElement(icon);
  } else if (loading && typeof loading === "object" && loading.icon) {
    iconNode = iconWrapperElement(loading.icon);
  } else {
    iconNode = defaultLoadingIconElement;
  }
  const contentNode = isNonNullable_default(children) ? spaceChildren(children, needInserted && mergedInsertSpace, mergedStyles.content, mergedClassNames.content) : null;
  if (linkButtonRestProps.href !== void 0) {
    return import_react56.default.createElement("a", {
      ...linkButtonRestProps,
      className: clsx(classes, {
        [`${prefixCls}-disabled`]: mergedDisabled
      }),
      href: mergedDisabled ? void 0 : linkButtonRestProps.href,
      style: fullStyle,
      onClick: handleClick,
      ref: mergedRef,
      tabIndex: mergedDisabled ? -1 : 0,
      "aria-disabled": mergedDisabled
    }, iconNode, contentNode);
  }
  let buttonNode = import_react56.default.createElement("button", {
    ...rest,
    type: htmlType,
    className: classes,
    style: fullStyle,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: mergedRef
  }, iconNode, contentNode, compactItemClassnames && import_react56.default.createElement(compact_default2, {
    prefixCls
  }));
  if (!isUnBorderedButtonVariant(mergedVariant)) {
    buttonNode = import_react56.default.createElement(wave_default, {
      component: "Button",
      disabled: innerLoading
    }, buttonNode);
  }
  return buttonNode;
});
var Button = InternalCompoundedButton;
Button.Group = ButtonGroup_default;
Button.__ANT_BUTTON = true;
if (true) {
  Button.displayName = "Button";
}
var Button_default = Button;

// node_modules/antd/es/_util/ActionButton.js
var isThenable = (thing) => {
  return typeof (thing == null ? void 0 : thing.then) === "function";
};
var ActionButton = (props) => {
  const {
    type: type5,
    children,
    prefixCls,
    buttonProps,
    close,
    autoFocus,
    emitEvent,
    isSilent,
    quitOnNullishReturnValue,
    actionFn
  } = props;
  const clickedRef = React98.useRef(false);
  const buttonRef = React98.useRef(null);
  const [loading, setLoading] = useSafeState(false);
  const onInternalClose = (...args) => {
    close == null ? void 0 : close(...args);
  };
  React98.useEffect(() => {
    let timeoutId = null;
    if (autoFocus) {
      timeoutId = setTimeout(() => {
        var _a;
        (_a = buttonRef.current) == null ? void 0 : _a.focus({
          preventScroll: true
        });
      });
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [autoFocus]);
  const handlePromiseOnOk = (returnValueOfOnOk) => {
    if (!isThenable(returnValueOfOnOk)) {
      return;
    }
    setLoading(true);
    returnValueOfOnOk.then((...args) => {
      setLoading(false, true);
      onInternalClose.apply(void 0, args);
      clickedRef.current = false;
    }, (e3) => {
      setLoading(false, true);
      clickedRef.current = false;
      if (isSilent == null ? void 0 : isSilent()) {
        return;
      }
      return Promise.reject(e3);
    });
  };
  const onClick = (e3) => {
    if (clickedRef.current) {
      return;
    }
    clickedRef.current = true;
    if (!actionFn) {
      onInternalClose();
      return;
    }
    let returnValueOfOnOk;
    if (emitEvent) {
      returnValueOfOnOk = actionFn(e3);
      if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
        clickedRef.current = false;
        onInternalClose(e3);
        return;
      }
    } else if (actionFn.length) {
      returnValueOfOnOk = actionFn(close);
      clickedRef.current = false;
    } else {
      returnValueOfOnOk = actionFn();
      if (!isThenable(returnValueOfOnOk)) {
        onInternalClose();
        return;
      }
    }
    handlePromiseOnOk(returnValueOfOnOk);
  };
  return React98.createElement(Button_default, {
    ...convertLegacyProps(type5),
    onClick,
    loading,
    prefixCls,
    ...buttonProps,
    ref: buttonRef
  }, children);
};
var ActionButton_default = ActionButton;

// node_modules/antd/es/modal/context.js
var import_react57 = __toESM(require_react());
var ModalContext = import_react57.default.createContext({});
var {
  Provider: ModalContextProvider
} = ModalContext;

// node_modules/antd/es/modal/components/ConfirmCancelBtn.js
var ConfirmCancelBtn = () => {
  const {
    autoFocusButton,
    cancelButtonProps,
    cancelTextLocale,
    isSilent,
    mergedOkCancel,
    rootPrefixCls,
    close,
    onCancel,
    onConfirm,
    onClose
  } = (0, import_react58.useContext)(ModalContext);
  return mergedOkCancel ? import_react58.default.createElement(ActionButton_default, {
    isSilent,
    actionFn: onCancel,
    close: (...args) => {
      close == null ? void 0 : close(...args);
      onConfirm == null ? void 0 : onConfirm(false);
      onClose == null ? void 0 : onClose();
    },
    autoFocus: autoFocusButton === "cancel",
    buttonProps: cancelButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, cancelTextLocale) : null;
};
var ConfirmCancelBtn_default = ConfirmCancelBtn;

// node_modules/antd/es/modal/components/ConfirmOkBtn.js
var import_react59 = __toESM(require_react());
var ConfirmOkBtn = () => {
  const {
    autoFocusButton,
    close,
    isSilent,
    okButtonProps,
    rootPrefixCls,
    okTextLocale,
    okType,
    onConfirm,
    onOk,
    onClose
  } = (0, import_react59.useContext)(ModalContext);
  return import_react59.default.createElement(ActionButton_default, {
    isSilent,
    type: okType || "primary",
    actionFn: onOk,
    close: (...args) => {
      close == null ? void 0 : close(...args);
      onConfirm == null ? void 0 : onConfirm(true);
      onClose == null ? void 0 : onClose();
    },
    autoFocus: autoFocusButton === "ok",
    buttonProps: okButtonProps,
    prefixCls: `${rootPrefixCls}-btn`
  }, okTextLocale);
};
var ConfirmOkBtn_default = ConfirmOkBtn;

// node_modules/antd/es/modal/Modal.js
var React134 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/DialogWrap.js
var React108 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/context.js
var React102 = __toESM(require_react());
var RefContext = React102.createContext({});

// node_modules/@rc-component/dialog/es/Dialog/index.js
var React107 = __toESM(require_react());
var import_react62 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/util.js
function getMotionName(prefixCls, transitionName, animationName) {
  let motionName = transitionName;
  if (!motionName && animationName) {
    motionName = `${prefixCls}-${animationName}`;
  }
  return motionName;
}
function getScroll2(w, top) {
  let ret = w[`page${top ? "Y" : "X"}Offset`];
  const method4 = `scroll${top ? "Top" : "Left"}`;
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d.body[method4];
    }
  }
  return ret;
}
function offset(el) {
  const rect = el.getBoundingClientRect();
  const pos = {
    left: rect.left,
    top: rect.top
  };
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll2(w);
  pos.top += getScroll2(w, true);
  return pos;
}

// node_modules/@rc-component/dialog/es/Dialog/Content/index.js
var React105 = __toESM(require_react());
var import_react61 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/Dialog/Content/Panel.js
var import_react60 = __toESM(require_react());

// node_modules/@rc-component/dialog/es/Dialog/Content/MemoChildren.js
var React103 = __toESM(require_react());
var MemoChildren_default = React103.memo(({
  children
}) => children, (_, {
  shouldUpdate
}) => !shouldUpdate);

// node_modules/@rc-component/dialog/es/Dialog/Content/Panel.js
function _extends10() {
  _extends10 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends10.apply(this, arguments);
}
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var entityStyle = {
  outline: "none"
};
var Panel2 = import_react60.default.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style: style2,
    title,
    ariaId,
    footer,
    closable,
    closeIcon,
    onClose,
    children,
    bodyStyle,
    bodyProps,
    modalRender,
    onMouseDown,
    onMouseUp,
    holderRef,
    visible,
    forceRender,
    width,
    height,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  const {
    panel: panelRef
  } = import_react60.default.useContext(RefContext);
  const mergedRef = useComposeRef(holderRef, panelRef);
  const sentinelStartRef = (0, import_react60.useRef)(null);
  const sentinelEndRef = (0, import_react60.useRef)(null);
  import_react60.default.useImperativeHandle(ref, () => ({
    focus: () => {
      var _a;
      (_a = sentinelStartRef.current) == null ? void 0 : _a.focus({
        preventScroll: true
      });
    },
    changeActive: (next2) => {
      const {
        activeElement
      } = document;
      if (next2 && activeElement === sentinelEndRef.current) {
        sentinelStartRef.current.focus({
          preventScroll: true
        });
      } else if (!next2 && activeElement === sentinelStartRef.current) {
        sentinelEndRef.current.focus({
          preventScroll: true
        });
      }
    }
  }));
  const contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  const footerNode = footer ? import_react60.default.createElement("div", {
    className: clsx(`${prefixCls}-footer`, modalClassNames == null ? void 0 : modalClassNames.footer),
    style: {
      ...modalStyles == null ? void 0 : modalStyles.footer
    }
  }, footer) : null;
  const headerNode = title ? import_react60.default.createElement("div", {
    className: clsx(`${prefixCls}-header`, modalClassNames == null ? void 0 : modalClassNames.header),
    style: {
      ...modalStyles == null ? void 0 : modalStyles.header
    }
  }, import_react60.default.createElement("div", {
    className: clsx(`${prefixCls}-title`, modalClassNames == null ? void 0 : modalClassNames.title),
    id: ariaId,
    style: {
      ...modalStyles == null ? void 0 : modalStyles.title
    }
  }, title)) : null;
  const closableObj = (0, import_react60.useMemo)(() => {
    if (typeof closable === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return {
        closeIcon: closeIcon ?? import_react60.default.createElement("span", {
          className: `${prefixCls}-close-x`
        })
      };
    }
    return {};
  }, [closable, closeIcon, prefixCls]);
  const ariaProps = pickAttrs(closableObj, true);
  const closeBtnIsDisabled = typeof closable === "object" && closable.disabled;
  const closerNode = closable ? import_react60.default.createElement("button", _extends10({
    type: "button",
    onClick: onClose,
    "aria-label": "Close"
  }, ariaProps, {
    className: `${prefixCls}-close`,
    disabled: closeBtnIsDisabled
  }), closableObj.closeIcon) : null;
  const content = import_react60.default.createElement("div", {
    className: clsx(`${prefixCls}-container`, modalClassNames == null ? void 0 : modalClassNames.container),
    style: modalStyles == null ? void 0 : modalStyles.container
  }, closerNode, headerNode, import_react60.default.createElement("div", _extends10({
    className: clsx(`${prefixCls}-body`, modalClassNames == null ? void 0 : modalClassNames.body),
    style: {
      ...bodyStyle,
      ...modalStyles == null ? void 0 : modalStyles.body
    }
  }, bodyProps), children), footerNode);
  return import_react60.default.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": title ? ariaId : null,
    "aria-modal": "true",
    ref: mergedRef,
    style: {
      ...style2,
      ...contentStyle
    },
    className: clsx(prefixCls, className),
    onMouseDown,
    onMouseUp
  }, import_react60.default.createElement("div", {
    ref: sentinelStartRef,
    tabIndex: 0,
    style: entityStyle
  }, import_react60.default.createElement(MemoChildren_default, {
    shouldUpdate: visible || forceRender
  }, modalRender ? modalRender(content) : content)), import_react60.default.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle
  }));
});
if (true) {
  Panel2.displayName = "Panel";
}
var Panel_default2 = Panel2;

// node_modules/@rc-component/dialog/es/Dialog/Content/index.js
function _extends11() {
  _extends11 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends11.apply(this, arguments);
}
var Content = React105.forwardRef((props, ref) => {
  const {
    prefixCls,
    title,
    style: style2,
    className,
    visible,
    forceRender,
    destroyOnHidden,
    motionName,
    ariaId,
    onVisibleChanged,
    mousePosition: mousePosition2
  } = props;
  const dialogRef = (0, import_react61.useRef)(null);
  const panelRef = (0, import_react61.useRef)(null);
  React105.useImperativeHandle(ref, () => ({
    ...panelRef.current,
    inMotion: dialogRef.current.inMotion,
    enableMotion: dialogRef.current.enableMotion
  }));
  const [transformOrigin, setTransformOrigin] = React105.useState();
  const contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    const elementOffset = offset(dialogRef.current.nativeElement);
    setTransformOrigin(mousePosition2 && (mousePosition2.x || mousePosition2.y) ? `${mousePosition2.x - elementOffset.left}px ${mousePosition2.y - elementOffset.top}px` : "");
  }
  return React105.createElement(es_default2, {
    visible,
    onVisibleChanged,
    onAppearPrepare: onPrepare,
    onEnterPrepare: onPrepare,
    forceRender,
    motionName,
    removeOnLeave: destroyOnHidden,
    ref: dialogRef
  }, ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => React105.createElement(Panel_default2, _extends11({}, props, {
    ref: panelRef,
    title,
    ariaId,
    prefixCls,
    holderRef: motionRef,
    style: {
      ...motionStyle,
      ...style2,
      ...contentStyle
    },
    className: clsx(className, motionClassName)
  })));
});
if (true) {
  Content.displayName = "Content";
}
var Content_default = Content;

// node_modules/@rc-component/dialog/es/Dialog/Mask.js
var React106 = __toESM(require_react());
function _extends12() {
  _extends12 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends12.apply(this, arguments);
}
var Mask2 = (props) => {
  const {
    prefixCls,
    style: style2,
    visible,
    maskProps,
    motionName,
    className
  } = props;
  return React106.createElement(es_default2, {
    key: "mask",
    visible,
    motionName,
    leavedClassName: `${prefixCls}-mask-hidden`
  }, ({
    className: motionClassName,
    style: motionStyle
  }, ref) => React106.createElement("div", _extends12({
    ref,
    style: {
      ...motionStyle,
      ...style2
    },
    className: clsx(`${prefixCls}-mask`, motionClassName, className)
  }, maskProps)));
};
var Mask_default = Mask2;

// node_modules/@rc-component/dialog/es/Dialog/index.js
function _extends13() {
  _extends13 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends13.apply(this, arguments);
}
var Dialog = (props) => {
  const {
    prefixCls = "rc-dialog",
    zIndex,
    visible = false,
    keyboard = true,
    focusTriggerAfterClose = true,
    // scrollLocker,
    // Wrapper
    wrapStyle,
    wrapClassName,
    wrapProps,
    onClose,
    afterOpenChange,
    afterClose,
    // Dialog
    transitionName,
    animation,
    closable = true,
    // Mask
    mask = true,
    maskTransitionName,
    maskAnimation,
    maskClosable = true,
    maskStyle,
    maskProps,
    rootClassName,
    rootStyle,
    classNames: modalClassNames,
    styles: modalStyles
  } = props;
  if (true) {
    ["wrapStyle", "bodyStyle", "maskStyle"].forEach((prop) => {
      warning(!(prop in props), `${prop} is deprecated, please use styles instead.`);
    });
    if ("wrapClassName" in props) {
      warning(false, `wrapClassName is deprecated, please use classNames instead.`);
    }
  }
  const lastOutSideActiveElementRef = (0, import_react62.useRef)(null);
  const wrapperRef = (0, import_react62.useRef)(null);
  const contentRef = (0, import_react62.useRef)(null);
  const [animatedVisible, setAnimatedVisible] = React107.useState(visible);
  const ariaId = useId_default();
  function saveLastOutSideActiveElementRef() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  function focusDialogContent() {
    var _a;
    if (!contains(wrapperRef.current, document.activeElement)) {
      (_a = contentRef.current) == null ? void 0 : _a.focus();
    }
  }
  function doClose() {
    setAnimatedVisible(false);
    if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
      try {
        lastOutSideActiveElementRef.current.focus({
          preventScroll: true
        });
      } catch (e3) {
      }
      lastOutSideActiveElementRef.current = null;
    }
    if (animatedVisible) {
      afterClose == null ? void 0 : afterClose();
    }
  }
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      focusDialogContent();
    } else {
      doClose();
    }
    afterOpenChange == null ? void 0 : afterOpenChange(newVisible);
  }
  function onInternalClose(e3) {
    onClose == null ? void 0 : onClose(e3);
  }
  const contentClickRef = (0, import_react62.useRef)(false);
  const contentTimeoutRef = (0, import_react62.useRef)(null);
  const onContentMouseDown = () => {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  const onContentMouseUp = () => {
    contentTimeoutRef.current = setTimeout(() => {
      contentClickRef.current = false;
    });
  };
  let onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = (e3) => {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e3.target) {
        onInternalClose(e3);
      }
    };
  }
  function onWrapperKeyDown(e3) {
    if (keyboard && e3.keyCode === KeyCode_default.ESC) {
      e3.stopPropagation();
      onInternalClose(e3);
      return;
    }
    if (visible && e3.keyCode === KeyCode_default.TAB) {
      contentRef.current.changeActive(!e3.shiftKey);
    }
  }
  (0, import_react62.useEffect)(() => {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    } else if (animatedVisible && contentRef.current.enableMotion() && !contentRef.current.inMotion()) {
      doClose();
    }
  }, [visible]);
  (0, import_react62.useEffect)(() => () => {
    clearTimeout(contentTimeoutRef.current);
  }, []);
  const mergedStyle = {
    zIndex,
    ...wrapStyle,
    ...modalStyles == null ? void 0 : modalStyles.wrapper,
    display: !animatedVisible ? "none" : null
  };
  return React107.createElement("div", _extends13({
    className: clsx(`${prefixCls}-root`, rootClassName),
    style: rootStyle
  }, pickAttrs(props, {
    data: true
  })), React107.createElement(Mask_default, {
    prefixCls,
    visible: mask && visible,
    motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
    style: {
      zIndex,
      ...maskStyle,
      ...modalStyles == null ? void 0 : modalStyles.mask
    },
    maskProps,
    className: modalClassNames == null ? void 0 : modalClassNames.mask
  }), React107.createElement("div", _extends13({
    tabIndex: -1,
    onKeyDown: onWrapperKeyDown,
    className: clsx(`${prefixCls}-wrap`, wrapClassName, modalClassNames == null ? void 0 : modalClassNames.wrapper),
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: mergedStyle
  }, wrapProps), React107.createElement(Content_default, _extends13({}, props, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    ref: contentRef,
    closable,
    ariaId,
    prefixCls,
    visible: visible && animatedVisible,
    onClose: onInternalClose,
    onVisibleChanged: onDialogVisibleChanged,
    motionName: getMotionName(prefixCls, transitionName, animation)
  }))));
};
var Dialog_default = Dialog;

// node_modules/@rc-component/dialog/es/DialogWrap.js
function _extends14() {
  _extends14 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends14.apply(this, arguments);
}
var DialogWrap = (props) => {
  const {
    visible,
    getContainer,
    forceRender,
    destroyOnHidden = false,
    afterClose,
    closable,
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React108.useState(visible);
  const refContext = React108.useMemo(() => ({
    panel: panelRef
  }), [panelRef]);
  React108.useEffect(() => {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (!forceRender && destroyOnHidden && !animatedVisible) {
    return null;
  }
  return React108.createElement(RefContext.Provider, {
    value: refContext
  }, React108.createElement(es_default3, {
    open: visible || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer,
    autoLock: visible || animatedVisible
  }, React108.createElement(Dialog_default, _extends14({}, props, {
    destroyOnHidden,
    afterClose: () => {
      const closableObj = closable && typeof closable === "object" ? closable : {};
      const {
        afterClose: closableAfterClose
      } = closableObj || {};
      closableAfterClose == null ? void 0 : closableAfterClose();
      afterClose == null ? void 0 : afterClose();
      setAnimatedVisible(false);
    }
  }))));
};
if (true) {
  DialogWrap.displayName = "Dialog";
}
var DialogWrap_default = DialogWrap;

// node_modules/@rc-component/dialog/es/index.js
var es_default7 = DialogWrap_default;

// node_modules/antd/es/_util/ContextIsolator.js
var import_react64 = __toESM(require_react());

// node_modules/antd/es/form/context.js
var React119 = __toESM(require_react());

// node_modules/@rc-component/form/es/index.js
var React118 = __toESM(require_react());

// node_modules/@rc-component/form/es/Field.js
var React112 = __toESM(require_react());

// node_modules/@rc-component/form/es/FieldContext.js
var React109 = __toESM(require_react());
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = () => {
  warning_default(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context2 = React109.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: () => {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc,
      setBatchUpdate: warningFunc
    };
  }
});
var FieldContext_default = Context2;

// node_modules/@rc-component/form/es/ListContext.js
var React110 = __toESM(require_react());
var ListContext = React110.createContext(null);
var ListContext_default = ListContext;

// node_modules/@rc-component/form/es/utils/typeUtil.js
function toArray3(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function isFormInstance(form) {
  return form && !!form._init;
}

// node_modules/@rc-component/async-validator/es/messages.js
function newMessages() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t2) {
  try {
    return -1 !== Function.toString.call(t2).indexOf("[native code]");
  } catch (n2) {
    return "function" == typeof t2;
  }
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t2, e3, r2) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o3 = [null];
  o3.push.apply(o3, e3);
  var p = new (t2.bind.apply(t2, o3))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t2) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
    if (null === t3 || !_isNativeFunction(t3))
      return t3;
    if ("function" != typeof t3)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t3))
        return r2.get(t3);
      r2.set(t3, Wrapper3);
    }
    function Wrapper3() {
      return _construct(t3, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper3.prototype = Object.create(t3.prototype, {
      constructor: {
        value: Wrapper3,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper3, t3);
  }, _wrapNativeSuper(t2);
}

// node_modules/@rc-component/async-validator/es/util.js
var formatRegExp = /%[sdj%]/g;
var warning3 = function warning4() {
};
if (typeof process !== "undefined" && process.env && true && typeof window !== "undefined" && typeof document !== "undefined") {
  warning3 = function warning5(type5, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e3) {
        return typeof e3 === "string";
      })) {
        console.warn(type5, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type5) {
  return type5 === "string" || type5 === "url" || type5 === "hex" || type5 === "email" || type5 === "date" || type5 === "pattern";
}
function isEmptyValue(value, type5) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type5 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type5) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, _toConsumableArray(errors || []));
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
  });
  return ret;
}
var AsyncValidationError = function(_Error) {
  _inherits(AsyncValidationError2, _Error);
  var _super = _createSuper(AsyncValidationError2);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _classCallCheck(this, AsyncValidationError2);
    _this = _super.call(this, "Async Validation Error");
    _defineProperty(_assertThisInitialized(_this), "errors", void 0);
    _defineProperty(_assertThisInitialized(_this), "fields", void 0);
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return _createClass(AsyncValidationError2);
}(_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending.catch(function(e3) {
      return e3;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending.catch(function(e3) {
    return e3;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path2) {
  var v = value;
  for (var i = 0; i < path2.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path2[i]];
  }
  return v;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (_typeof(value) === "object" && _typeof(target[s]) === "object") {
          target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}

// node_modules/@rc-component/async-validator/es/rule/enum.js
var ENUM = "enum";
var enumerable = function enumerable2(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(", ")));
  }
};
var enum_default = enumerable;

// node_modules/@rc-component/async-validator/es/rule/pattern.js
var pattern = function pattern2(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var pattern_default = pattern;

// node_modules/@rc-component/async-validator/es/rule/range.js
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var range_default = range;

// node_modules/@rc-component/async-validator/es/rule/required.js
var required = function required2(rule, value, source, errors, options, type5) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type5 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var required_default = required;

// node_modules/@rc-component/async-validator/es/rule/url.js
var urlReg;
var url_default = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b = function b2(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6List = [
    "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ];
  var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
  var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
  var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
  var v4exact = new RegExp("^".concat(v4, "$"));
  var v6exact = new RegExp("^".concat(v6, "$"));
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path2);
  urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
  return urlReg;
};

// node_modules/@rc-component/async-validator/es/rule/type.js
var pattern3 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  float: function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp3(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e3) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return _typeof(value) === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern3.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(url_default());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern3.hex);
  }
};
var type = function type2(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required_default(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && _typeof(value) !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var type_default = type;

// node_modules/@rc-component/async-validator/es/rule/whitespace.js
var whitespace2 = function whitespace3(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var whitespace_default = whitespace2;

// node_modules/@rc-component/async-validator/es/rule/index.js
var rule_default = {
  required: required_default,
  whitespace: whitespace_default,
  type: type_default,
  range: range_default,
  enum: enum_default,
  pattern: pattern_default
};

// node_modules/@rc-component/async-validator/es/validator/any.js
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var any_default = any;

// node_modules/@rc-component/async-validator/es/validator/array.js
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array_default = array2;

// node_modules/@rc-component/async-validator/es/validator/boolean.js
var boolean = function boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var boolean_default = boolean;

// node_modules/@rc-component/async-validator/es/validator/date.js
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rule_default.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rule_default.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var date_default = date2;

// node_modules/@rc-component/async-validator/es/validator/enum.js
var ENUM2 = "enum";
var enumerable3 = function enumerable4(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default[ENUM2](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var enum_default2 = enumerable3;

// node_modules/@rc-component/async-validator/es/validator/float.js
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var float_default = floatFn;

// node_modules/@rc-component/async-validator/es/validator/integer.js
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer_default = integer2;

// node_modules/@rc-component/async-validator/es/validator/method.js
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var method_default = method2;

// node_modules/@rc-component/async-validator/es/validator/number.js
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number_default = number2;

// node_modules/@rc-component/async-validator/es/validator/object.js
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object_default = object2;

// node_modules/@rc-component/async-validator/es/validator/pattern.js
var pattern4 = function pattern5(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rule_default.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern_default2 = pattern4;

// node_modules/@rc-component/async-validator/es/validator/regexp.js
var regexp4 = function regexp5(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp_default = regexp4;

// node_modules/@rc-component/async-validator/es/validator/required.js
var required3 = function required4(rule, value, callback, source, options) {
  var errors = [];
  var type5 = Array.isArray(value) ? "array" : _typeof(value);
  rule_default.required(rule, value, source, errors, options, type5);
  callback(errors);
};
var required_default2 = required3;

// node_modules/@rc-component/async-validator/es/validator/string.js
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rule_default.type(rule, value, source, errors, options);
      rule_default.range(rule, value, source, errors, options);
      rule_default.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rule_default.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var string_default = string;

// node_modules/@rc-component/async-validator/es/validator/type.js
var type3 = function type4(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rule_default.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rule_default.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var type_default2 = type3;

// node_modules/@rc-component/async-validator/es/validator/index.js
var validator_default = {
  string: string_default,
  method: method_default,
  number: number_default,
  boolean: boolean_default,
  regexp: regexp_default,
  integer: integer_default,
  float: float_default,
  array: array_default,
  object: object_default,
  enum: enum_default2,
  pattern: pattern_default2,
  date: date_default,
  url: type_default2,
  hex: type_default2,
  email: type_default2,
  required: required_default2,
  any: any_default
};

// node_modules/@rc-component/async-validator/es/index.js
var Schema = function() {
  function Schema2(descriptor) {
    _classCallCheck(this, Schema2);
    _defineProperty(this, "rules", null);
    _defineProperty(this, "_messages", messages);
    this.define(descriptor);
  }
  _createClass(Schema2, [{
    key: "define",
    value: function define2(rules) {
      var _this = this;
      if (!rules) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (_typeof(rules) !== "object" || Array.isArray(rules)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules).forEach(function(name) {
        var item = rules[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    }
  }, {
    key: "messages",
    value: function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    }
  }, {
    key: "validate",
    value: function validate(source_) {
      var _this2 = this;
      var o3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      };
      var source = source_;
      var options = o3;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e3) {
          if (Array.isArray(e3)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e3));
          } else {
            errors.push(e3);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages2 = this.messages();
        if (messages2 === messages) {
          messages2 = newMessages();
        }
        deepMerge(messages2, options.messages);
        options.messages = messages2;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _objectSpread2({}, source);
            }
            value = source[z] = rule.transform(value);
            if (value !== void 0 && value !== null) {
              rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof(value));
            }
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _objectSpread2({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (_typeof(rule.fields) === "object" || _typeof(rule.defaultField) === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _objectSpread2(_objectSpread2({}, schema), {}, {
            fullField: "".concat(rule.fullField, ".").concat(key),
            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
          });
        }
        function cb() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var errorList = Array.isArray(e3) ? e3 : [e3];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            var _console$error, _console;
            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e3) {
            return cb(e3);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    }
  }, {
    key: "getType",
    value: function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validator_default.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validator_default.required;
      }
      return validator_default[this.getType(rule)] || void 0;
    }
  }]);
  return Schema2;
}();
_defineProperty(Schema, "register", function register(type5, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validator_default[type5] = validator;
});
_defineProperty(Schema, "warning", warning3);
_defineProperty(Schema, "messages", messages);
_defineProperty(Schema, "validators", validator_default);
var es_default8 = Schema;

// node_modules/@rc-component/form/es/utils/validateUtil.js
var React111 = __toESM(require_react());

// node_modules/@rc-component/form/es/utils/messages.js
var typeTemplate2 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate2,
    method: typeTemplate2,
    array: typeTemplate2,
    object: typeTemplate2,
    number: typeTemplate2,
    date: typeTemplate2,
    boolean: typeTemplate2,
    integer: typeTemplate2,
    float: typeTemplate2,
    regexp: typeTemplate2,
    email: typeTemplate2,
    url: typeTemplate2,
    hex: typeTemplate2
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};

// node_modules/@rc-component/form/es/utils/validateUtil.js
var AsyncValidator = es_default8;
function replaceMessage(template, kv) {
  return template.replace(/\\?\$\{\w+\}/g, (str) => {
    if (str.startsWith("\\")) {
      return str.slice(1);
    }
    const key = str.slice(2, -1);
    return kv[key];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
async function validateRule(name, value, rule, options, messageVariables) {
  const cloneRule = {
    ...rule
  };
  delete cloneRule.ruleIndex;
  AsyncValidator.warning = () => void 0;
  if (cloneRule.validator) {
    const originValidator = cloneRule.validator;
    cloneRule.validator = (...args) => {
      try {
        return originValidator(...args);
      } catch (error) {
        console.error(error);
        return Promise.reject(CODE_LOGIC_ERROR);
      }
    };
  }
  let subRuleField = null;
  if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
    subRuleField = cloneRule.defaultField;
    delete cloneRule.defaultField;
  }
  const validator = new AsyncValidator({
    [name]: [cloneRule]
  });
  const messages2 = merge(defaultValidateMessages, options.validateMessages);
  validator.messages(messages2);
  let result = [];
  try {
    await Promise.resolve(validator.validate({
      [name]: value
    }, {
      ...options
    }));
  } catch (errObj) {
    if (errObj.errors) {
      result = errObj.errors.map(({
        message: message2
      }, index2) => {
        const mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
        return React111.isValidElement(mergedMessage) ? (
          // Wrap ReactNode with `key`
          React111.cloneElement(mergedMessage, {
            key: `error_${index2}`
          })
        ) : mergedMessage;
      });
    }
  }
  if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {
    const subResults = await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)));
    return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
  }
  const kv = {
    ...rule,
    name,
    enum: (rule.enum || []).join(", "),
    ...messageVariables
  };
  const fillVariableResult = result.map((error) => {
    if (typeof error === "string") {
      return replaceMessage(error, kv);
    }
    return error;
  });
  return fillVariableResult;
}
function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
  const name = namePath.join(".");
  const filledRules = rules.map((currentRule, ruleIndex) => {
    const originValidatorFunc = currentRule.validator;
    const cloneRule = {
      ...currentRule,
      ruleIndex
    };
    if (originValidatorFunc) {
      cloneRule.validator = (rule, val, callback) => {
        let hasPromise = false;
        const wrappedCallback = (...args) => {
          Promise.resolve().then(() => {
            warning_default(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback(...args);
            }
          });
        };
        const promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warning_default(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(() => {
            callback();
          }).catch((err) => {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(({
    warningOnly: w1,
    ruleIndex: i1
  }, {
    warningOnly: w2,
    ruleIndex: i2
  }) => {
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  let summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(async (resolve, reject) => {
      for (let i = 0; i < filledRules.length; i += 1) {
        const rule = filledRules[i];
        const errors = await validateRule(name, value, rule, options, messageVariables);
        if (errors.length) {
          reject([{
            errors,
            rule
          }]);
          return;
        }
      }
      resolve([]);
    });
  } else {
    const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
      errors,
      rule
    })));
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch((e3) => e3);
  return summaryPromise;
}
async function finishOnAllFailed(rulePromises) {
  return Promise.all(rulePromises).then((errorsList) => {
    const errors = [].concat(...errorsList);
    return errors;
  });
}
async function finishOnFirstFailed(rulePromises) {
  let count = 0;
  return new Promise((resolve) => {
    rulePromises.forEach((promise) => {
      promise.then((ruleError) => {
        if (ruleError.errors.length) {
          resolve([ruleError]);
        }
        count += 1;
        if (count === rulePromises.length) {
          resolve([]);
        }
      });
    });
  });
}

// node_modules/@rc-component/form/es/utils/valueUtil.js
function getNamePath(path2) {
  return toArray3(path2);
}
function cloneByNamePathList(store, namePathList) {
  let newStore = {};
  namePathList.forEach((namePath) => {
    const value = get(store, namePath);
    newStore = set(newStore, namePath, value);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath, partialMatch = false) {
  return namePathList && namePathList.some((path2) => matchNamePath(namePath, path2, partialMatch));
}
function matchNamePath(namePath, subNamePath, partialMatch = false) {
  if (!namePath || !subNamePath) {
    return false;
  }
  if (!partialMatch && namePath.length !== subNamePath.length) {
    return false;
  }
  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || typeof source !== "object" || typeof target !== "object") {
    return false;
  }
  const sourceKeys = Object.keys(source);
  const targetKeys = Object.keys(target);
  const keys2 = /* @__PURE__ */ new Set([...sourceKeys, ...targetKeys]);
  return [...keys2].every((key) => {
    const sourceValue = source[key];
    const targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName, ...args) {
  const event = args[0];
  if (event && event.target && typeof event.target === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  const {
    length: length2
  } = array4;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  const item = array4[moveIndex];
  const diff = moveIndex - toIndex;
  if (diff > 0) {
    return [...array4.slice(0, toIndex), item, ...array4.slice(toIndex, moveIndex), ...array4.slice(moveIndex + 1, length2)];
  }
  if (diff < 0) {
    return [...array4.slice(0, moveIndex), ...array4.slice(moveIndex + 1, toIndex + 1), item, ...array4.slice(toIndex + 1, length2)];
  }
  return array4;
}

// node_modules/@rc-component/form/es/Field.js
function _extends15() {
  _extends15 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends15.apply(this, arguments);
}
var EMPTY_ERRORS = [];
var EMPTY_WARNINGS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev2, next2, "source" in info ? {
      source: info.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = class extends React112.Component {
  // ============================== Subscriptions ==============================
  constructor(props) {
    super(props);
    __publicField(this, "state", {
      resetCount: 0
    });
    __publicField(this, "cancelRegisterFunc", null);
    __publicField(this, "mounted", false);
    /**
     * Follow state should not management in State since it will async update by React.
     * This makes first render of form can not get correct state value.
     */
    __publicField(this, "touched", false);
    /**
     * Mark when touched & validated. Currently only used for `dependencies`.
     * Note that we do not think field with `initialValue` is dirty
     * but this will be by `isFieldDirty` func.
     */
    __publicField(this, "dirty", false);
    __publicField(this, "validatePromise");
    __publicField(this, "prevValidating");
    __publicField(this, "errors", EMPTY_ERRORS);
    __publicField(this, "warnings", EMPTY_WARNINGS);
    __publicField(this, "cancelRegister", () => {
      const {
        preserve: preserve2,
        isListField,
        name
      } = this.props;
      if (this.cancelRegisterFunc) {
        this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
      }
      this.cancelRegisterFunc = null;
    });
    // ================================== Utils ==================================
    __publicField(this, "getNamePath", () => {
      const {
        name,
        fieldContext
      } = this.props;
      const {
        prefixName = []
      } = fieldContext;
      return name !== void 0 ? [...prefixName, ...name] : [];
    });
    __publicField(this, "getRules", () => {
      const {
        rules = [],
        fieldContext
      } = this.props;
      return rules.map((rule) => {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    });
    __publicField(this, "refresh", () => {
      if (!this.mounted)
        return;
      this.setState(({
        resetCount
      }) => ({
        resetCount: resetCount + 1
      }));
    });
    // Event should only trigger when meta changed
    __publicField(this, "metaCache", null);
    __publicField(this, "triggerMetaEvent", (destroy3) => {
      const {
        onMetaChange
      } = this.props;
      if (onMetaChange) {
        const meta = {
          ...this.getMeta(),
          destroy: destroy3
        };
        if (!isEqual_default(this.metaCache, meta)) {
          onMetaChange(meta);
        }
        this.metaCache = meta;
      } else {
        this.metaCache = null;
      }
    });
    // ========================= Field Entity Interfaces =========================
    // Trigger by store update. Check if need update the component
    __publicField(this, "onStoreChange", (prevStore, namePathList, info) => {
      const {
        shouldUpdate,
        dependencies = [],
        onReset
      } = this.props;
      const {
        store
      } = info;
      const namePath = this.getNamePath();
      const prevValue = this.getValue(prevStore);
      const curValue = this.getValue(store);
      const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      if (info.type === "valueUpdate" && info.source === "external" && !isEqual_default(prevValue, curValue)) {
        this.touched = true;
        this.dirty = true;
        this.validatePromise = null;
        this.errors = EMPTY_ERRORS;
        this.warnings = EMPTY_WARNINGS;
        this.triggerMetaEvent();
      }
      switch (info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            this.touched = false;
            this.dirty = false;
            this.validatePromise = void 0;
            this.errors = EMPTY_ERRORS;
            this.warnings = EMPTY_WARNINGS;
            this.triggerMetaEvent();
            onReset == null ? void 0 : onReset();
            this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          const {
            data
          } = info;
          if (namePathMatch) {
            if ("touched" in data) {
              this.touched = data.touched;
            }
            if ("validating" in data && !("originRCField" in data)) {
              this.validatePromise = data.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data) {
              this.errors = data.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data) {
              this.warnings = data.warnings || EMPTY_WARNINGS;
            }
            this.dirty = true;
            this.triggerMetaEvent();
            this.reRender();
            return;
          } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
            this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          const dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some((dependency) => containsNamePath(info.relatedFields, dependency))) {
            this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    });
    __publicField(this, "validateRules", (options) => {
      const namePath = this.getNamePath();
      const currentValue = this.getValue();
      const {
        triggerName,
        validateOnly = false
      } = options || {};
      const rootPromise = Promise.resolve().then(async () => {
        if (!this.mounted) {
          return [];
        }
        const {
          validateFirst = false,
          messageVariables,
          validateDebounce
        } = this.props;
        let filteredRules = this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
            const {
              validateTrigger
            } = rule;
            if (!validateTrigger) {
              return true;
            }
            const triggerList = toArray3(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        if (validateDebounce && triggerName) {
          await new Promise((resolve) => {
            setTimeout(resolve, validateDebounce);
          });
          if (this.validatePromise !== rootPromise) {
            return [];
          }
        }
        const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise.catch((e3) => e3).then((ruleErrors = EMPTY_ERRORS) => {
          var _a;
          if (this.validatePromise === rootPromise) {
            this.validatePromise = null;
            const nextErrors = [];
            const nextWarnings = [];
            (_a = ruleErrors.forEach) == null ? void 0 : _a.call(ruleErrors, ({
              rule: {
                warningOnly
              },
              errors = EMPTY_ERRORS
            }) => {
              if (warningOnly) {
                nextWarnings.push(...errors);
              } else {
                nextErrors.push(...errors);
              }
            });
            this.errors = nextErrors;
            this.warnings = nextWarnings;
            this.triggerMetaEvent();
            this.reRender();
          }
        });
        return promise;
      });
      if (validateOnly) {
        return rootPromise;
      }
      this.validatePromise = rootPromise;
      this.dirty = true;
      this.errors = EMPTY_ERRORS;
      this.warnings = EMPTY_WARNINGS;
      this.triggerMetaEvent();
      this.reRender();
      return rootPromise;
    });
    __publicField(this, "isFieldValidating", () => !!this.validatePromise);
    __publicField(this, "isFieldTouched", () => this.touched);
    __publicField(this, "isFieldDirty", () => {
      if (this.dirty || this.props.initialValue !== void 0) {
        return true;
      }
      const {
        fieldContext
      } = this.props;
      const {
        getInitialValue
      } = fieldContext.getInternalHooks(HOOK_MARK);
      if (getInitialValue(this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    });
    __publicField(this, "getErrors", () => this.errors);
    __publicField(this, "getWarnings", () => this.warnings);
    __publicField(this, "isListField", () => this.props.isListField);
    __publicField(this, "isList", () => this.props.isList);
    __publicField(this, "isPreserve", () => this.props.preserve);
    // ============================= Child Component =============================
    __publicField(this, "getMeta", () => {
      this.prevValidating = this.isFieldValidating();
      const meta = {
        touched: this.isFieldTouched(),
        validating: this.prevValidating,
        errors: this.errors,
        warnings: this.warnings,
        name: this.getNamePath(),
        validated: this.validatePromise === null
      };
      return meta;
    });
    // Only return validate child node. If invalidate, will do nothing about field.
    __publicField(this, "getOnlyChild", (children) => {
      if (typeof children === "function") {
        const meta = this.getMeta();
        return {
          ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
          isFunction: true
        };
      }
      const childList = toArray(children);
      if (childList.length !== 1 || !React112.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    });
    // ============================== Field Control ==============================
    __publicField(this, "getValue", (store) => {
      const {
        getFieldsValue
      } = this.props.fieldContext;
      const namePath = this.getNamePath();
      return get(store || getFieldsValue(true), namePath);
    });
    __publicField(this, "getControlled", (childProps = {}) => {
      const {
        name,
        trigger = "onChange",
        validateTrigger,
        getValueFromEvent,
        normalize: normalize2,
        valuePropName = "value",
        getValueProps,
        fieldContext
      } = this.props;
      const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      const namePath = this.getNamePath();
      const {
        getInternalHooks,
        getFieldsValue
      } = fieldContext;
      const {
        dispatch
      } = getInternalHooks(HOOK_MARK);
      const value = this.getValue();
      const mergedGetValueProps = getValueProps || ((val) => ({
        [valuePropName]: val
      }));
      const originTriggerFunc = childProps[trigger];
      const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
      if (valueProps) {
        Object.keys(valueProps).forEach((key) => {
          warning_default(typeof valueProps[key] !== "function", `It's not recommended to generate dynamic function prop by \`getValueProps\`. Please pass it to child component directly (prop: ${key})`);
        });
      }
      const control = {
        ...childProps,
        ...valueProps
      };
      control[trigger] = (...args) => {
        this.touched = true;
        this.dirty = true;
        this.triggerMetaEvent();
        let newValue;
        if (getValueFromEvent) {
          newValue = getValueFromEvent(...args);
        } else {
          newValue = defaultGetValueFromEvent(valuePropName, ...args);
        }
        if (normalize2) {
          newValue = normalize2(newValue, value, getFieldsValue(true));
        }
        if (newValue !== value) {
          dispatch({
            type: "updateValue",
            namePath,
            value: newValue
          });
        }
        if (originTriggerFunc) {
          originTriggerFunc(...args);
        }
      };
      const validateTriggerList = toArray3(mergedValidateTrigger || []);
      validateTriggerList.forEach((triggerName) => {
        const originTrigger = control[triggerName];
        control[triggerName] = (...args) => {
          if (originTrigger) {
            originTrigger(...args);
          }
          const {
            rules
          } = this.props;
          if (rules && rules.length) {
            dispatch({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    });
    if (props.fieldContext) {
      const {
        getInternalHooks
      } = props.fieldContext;
      const {
        initEntityValue
      } = getInternalHooks(HOOK_MARK);
      initEntityValue(this);
    }
  }
  componentDidMount() {
    const {
      shouldUpdate,
      fieldContext
    } = this.props;
    this.mounted = true;
    if (fieldContext) {
      const {
        getInternalHooks
      } = fieldContext;
      const {
        registerField
      } = getInternalHooks(HOOK_MARK);
      this.cancelRegisterFunc = registerField(this);
    }
    if (shouldUpdate === true) {
      this.reRender();
    }
  }
  componentWillUnmount() {
    this.cancelRegister();
    this.triggerMetaEvent(true);
    this.mounted = false;
  }
  reRender() {
    if (!this.mounted)
      return;
    this.forceUpdate();
  }
  render() {
    const {
      resetCount
    } = this.state;
    const {
      children
    } = this.props;
    const {
      child,
      isFunction
    } = this.getOnlyChild(children);
    let returnChildNode;
    if (isFunction) {
      returnChildNode = child;
    } else if (React112.isValidElement(child)) {
      returnChildNode = React112.cloneElement(child, this.getControlled(child.props));
    } else {
      warning_default(!child, "`children` of Field is not validate ReactElement.");
      returnChildNode = child;
    }
    return React112.createElement(React112.Fragment, {
      key: resetCount
    }, returnChildNode);
  }
};
__publicField(Field, "contextType", FieldContext_default);
function WrapperField({
  name,
  ...restProps
}) {
  const fieldContext = React112.useContext(FieldContext_default);
  const listContext = React112.useContext(ListContext_default);
  const namePath = name !== void 0 ? getNamePath(name) : void 0;
  const isMergedListField = restProps.isListField ?? !!listContext;
  let key = "keep";
  if (!isMergedListField) {
    key = `_${(namePath || []).join("_")}`;
  }
  if (restProps.preserve === false && isMergedListField && namePath.length <= 1) {
    warning_default(false, "`preserve` should not apply on Form.List fields.");
  }
  return React112.createElement(Field, _extends15({
    key,
    name: namePath,
    isListField: isMergedListField
  }, restProps, {
    fieldContext
  }));
}
var Field_default = WrapperField;

// node_modules/@rc-component/form/es/List.js
var React113 = __toESM(require_react());
function List({
  name,
  initialValue,
  children,
  rules,
  validateTrigger,
  isListField
}) {
  const context = React113.useContext(FieldContext_default);
  const wrapperListContext = React113.useContext(ListContext_default);
  const keyRef = React113.useRef({
    keys: [],
    id: 0
  });
  const keyManager = keyRef.current;
  const prefixName = React113.useMemo(() => {
    const parentPrefixName = getNamePath(context.prefixName) || [];
    return [...parentPrefixName, ...getNamePath(name)];
  }, [context.prefixName, name]);
  const fieldContext = React113.useMemo(() => ({
    ...context,
    prefixName
  }), [context, prefixName]);
  const listContext = React113.useMemo(() => ({
    getKey: (namePath) => {
      const len = prefixName.length;
      const pathName = namePath[len];
      return [keyManager.keys[pathName], namePath.slice(len + 1)];
    }
  }), [keyManager, prefixName]);
  if (typeof children !== "function") {
    warning_default(false, "Form.List only accepts function as children.");
    return null;
  }
  const shouldUpdate = (prevValue, nextValue, {
    source
  }) => {
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return React113.createElement(ListContext_default.Provider, {
    value: listContext
  }, React113.createElement(FieldContext_default.Provider, {
    value: fieldContext
  }, React113.createElement(Field_default, {
    name: [],
    shouldUpdate,
    rules,
    validateTrigger,
    initialValue,
    isList: true,
    isListField: isListField ?? !!wrapperListContext
  }, ({
    value = [],
    onChange
  }, meta) => {
    const {
      getFieldValue
    } = context;
    const getNewValue = () => {
      const values = getFieldValue(prefixName || []);
      return values || [];
    };
    const operations = {
      add: (defaultValue, index2) => {
        const newValue = getNewValue();
        if (index2 >= 0 && index2 <= newValue.length) {
          keyManager.keys = [...keyManager.keys.slice(0, index2), keyManager.id, ...keyManager.keys.slice(index2)];
          onChange([...newValue.slice(0, index2), defaultValue, ...newValue.slice(index2)]);
        } else {
          if (index2 < 0 || index2 > newValue.length) {
            warning_default(false, "The second parameter of the add function should be a valid positive number.");
          }
          keyManager.keys = [...keyManager.keys, keyManager.id];
          onChange([...newValue, defaultValue]);
        }
        keyManager.id += 1;
      },
      remove: (index2) => {
        const newValue = getNewValue();
        const indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
        if (indexSet.size <= 0) {
          return;
        }
        keyManager.keys = keyManager.keys.filter((_, keysIndex) => !indexSet.has(keysIndex));
        onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));
      },
      move(from2, to) {
        if (from2 === to) {
          return;
        }
        const newValue = getNewValue();
        if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
          return;
        }
        keyManager.keys = move(keyManager.keys, from2, to);
        onChange(move(newValue, from2, to));
      }
    };
    let listValue = value || [];
    if (!Array.isArray(listValue)) {
      listValue = [];
      if (true) {
        warning_default(false, `Current value of '${prefixName.join(" > ")}' is not an array type.`);
      }
    }
    return children(listValue.map((__, index2) => {
      let key = keyManager.keys[index2];
      if (key === void 0) {
        keyManager.keys[index2] = keyManager.id;
        key = keyManager.keys[index2];
        keyManager.id += 1;
      }
      return {
        name: index2,
        key,
        isListField: true
      };
    }), operations, meta);
  })));
}
var List_default = List;

// node_modules/@rc-component/form/es/useForm.js
var React114 = __toESM(require_react());

// node_modules/@rc-component/form/es/utils/asyncUtil.js
function allPromiseFinish(promiseList) {
  let hasError = false;
  let count = promiseList.length;
  const results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise((resolve, reject) => {
    promiseList.forEach((promise, index2) => {
      promise.catch((e3) => {
        hasError = true;
        return e3;
      }).then((result) => {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}

// node_modules/@rc-component/form/es/utils/NameMap.js
var SPLIT2 = "__@field_split__";
function normalize(namePath) {
  return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT2);
}
var NameMap = class {
  constructor() {
    __publicField(this, "kvs", /* @__PURE__ */ new Map());
  }
  set(key, value) {
    this.kvs.set(normalize(key), value);
  }
  get(key) {
    return this.kvs.get(normalize(key));
  }
  update(key, updater) {
    const origin = this.get(key);
    const next2 = updater(origin);
    if (!next2) {
      this.delete(key);
    } else {
      this.set(key, next2);
    }
  }
  delete(key) {
    this.kvs.delete(normalize(key));
  }
  // Since we only use this in test, let simply realize this
  map(callback) {
    return [...this.kvs.entries()].map(([key, value]) => {
      const cells = key.split(SPLIT2);
      return callback({
        key: cells.map((cell) => {
          const [, type5, unit3] = cell.match(/^([^:]*):(.*)$/);
          return type5 === "number" ? Number(unit3) : unit3;
        }),
        value
      });
    });
  }
  toJSON() {
    const json = {};
    this.map(({
      key,
      value
    }) => {
      json[key.join(".")] = value;
      return null;
    });
    return json;
  }
};
var NameMap_default = NameMap;

// node_modules/@rc-component/form/es/useForm.js
var FormStore = class {
  constructor(forceRootUpdate) {
    __publicField(this, "formHooked", false);
    __publicField(this, "forceRootUpdate");
    __publicField(this, "subscribable", true);
    __publicField(this, "store", {});
    __publicField(this, "fieldEntities", []);
    __publicField(this, "initialValues", {});
    __publicField(this, "callbacks", {});
    __publicField(this, "validateMessages", null);
    __publicField(this, "preserve", null);
    __publicField(this, "lastValidatePromise", null);
    __publicField(this, "getForm", () => ({
      getFieldValue: this.getFieldValue,
      getFieldsValue: this.getFieldsValue,
      getFieldError: this.getFieldError,
      getFieldWarning: this.getFieldWarning,
      getFieldsError: this.getFieldsError,
      isFieldsTouched: this.isFieldsTouched,
      isFieldTouched: this.isFieldTouched,
      isFieldValidating: this.isFieldValidating,
      isFieldsValidating: this.isFieldsValidating,
      resetFields: this.resetFields,
      setFields: this.setFields,
      setFieldValue: this.setFieldValue,
      setFieldsValue: this.setFieldsValue,
      validateFields: this.validateFields,
      submit: this.submit,
      _init: true,
      getInternalHooks: this.getInternalHooks
    }));
    // ======================== Internal Hooks ========================
    __publicField(this, "getInternalHooks", (key) => {
      if (key === HOOK_MARK) {
        this.formHooked = true;
        return {
          dispatch: this.dispatch,
          initEntityValue: this.initEntityValue,
          registerField: this.registerField,
          useSubscribe: this.useSubscribe,
          setInitialValues: this.setInitialValues,
          destroyForm: this.destroyForm,
          setCallbacks: this.setCallbacks,
          setValidateMessages: this.setValidateMessages,
          getFields: this.getFields,
          setPreserve: this.setPreserve,
          getInitialValue: this.getInitialValue,
          registerWatch: this.registerWatch,
          setBatchUpdate: this.setBatchUpdate
        };
      }
      warning_default(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    });
    __publicField(this, "useSubscribe", (subscribable) => {
      this.subscribable = subscribable;
    });
    /**
     * Record prev Form unmount fieldEntities which config preserve false.
     * This need to be refill with initialValues instead of store value.
     */
    __publicField(this, "prevWithoutPreserves", null);
    /**
     * First time `setInitialValues` should update store with initial value
     */
    __publicField(this, "setInitialValues", (initialValues, init) => {
      var _a;
      this.initialValues = initialValues || {};
      if (init) {
        let nextStore = merge(initialValues, this.store);
        (_a = this.prevWithoutPreserves) == null ? void 0 : _a.map(({
          key: namePath
        }) => {
          nextStore = set(nextStore, namePath, get(initialValues, namePath));
        });
        this.prevWithoutPreserves = null;
        this.updateStore(nextStore);
      }
    });
    __publicField(this, "destroyForm", (clearOnDestroy) => {
      if (clearOnDestroy) {
        this.updateStore({});
      } else {
        const prevWithoutPreserves = new NameMap_default();
        this.getFieldEntities(true).forEach((entity) => {
          if (!this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        this.prevWithoutPreserves = prevWithoutPreserves;
      }
    });
    __publicField(this, "getInitialValue", (namePath) => {
      const initValue = get(this.initialValues, namePath);
      return namePath.length ? merge(initValue) : initValue;
    });
    __publicField(this, "setCallbacks", (callbacks) => {
      this.callbacks = callbacks;
    });
    __publicField(this, "setValidateMessages", (validateMessages) => {
      this.validateMessages = validateMessages;
    });
    __publicField(this, "setPreserve", (preserve2) => {
      this.preserve = preserve2;
    });
    // ============================= Watch ============================
    __publicField(this, "watchList", []);
    __publicField(this, "registerWatch", (callback) => {
      this.watchList.push(callback);
      return () => {
        this.watchList = this.watchList.filter((fn) => fn !== callback);
      };
    });
    __publicField(this, "notifyWatch", (namePath = []) => {
      if (this.watchList.length) {
        const values = this.getFieldsValue();
        const allValues = this.getFieldsValue(true);
        this.watchList.forEach((callback) => {
          callback(values, allValues, namePath);
        });
      }
    });
    __publicField(this, "notifyWatchNamePathList", []);
    __publicField(this, "batchNotifyWatch", (namePath) => {
      this.notifyWatchNamePathList.push(namePath);
      this.batch("notifyWatch", () => {
        this.notifyWatch(this.notifyWatchNamePathList);
        this.notifyWatchNamePathList = [];
      });
    });
    // ============================= Batch ============================
    __publicField(this, "batchUpdate");
    __publicField(this, "setBatchUpdate", (batchUpdate) => {
      this.batchUpdate = batchUpdate;
    });
    // Batch call the task, only last will be called
    __publicField(this, "batch", (key, callback) => {
      this.batchUpdate(key, callback);
    });
    // ========================== Dev Warning =========================
    __publicField(this, "timeoutId", null);
    __publicField(this, "warningUnhooked", () => {
      if (!this.timeoutId && typeof window !== "undefined") {
        this.timeoutId = setTimeout(() => {
          this.timeoutId = null;
          if (!this.formHooked) {
            warning_default(false, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
          }
        });
      }
    });
    // ============================ Store =============================
    __publicField(this, "updateStore", (nextStore) => {
      this.store = nextStore;
    });
    // ============================ Fields ============================
    /**
     * Get registered field entities.
     * @param pure Only return field which has a `name`. Default: false
     */
    __publicField(this, "getFieldEntities", (pure = false) => {
      if (!pure) {
        return this.fieldEntities;
      }
      return this.fieldEntities.filter((field) => field.getNamePath().length);
    });
    __publicField(this, "getFieldsMap", (pure = false) => {
      const cache = new NameMap_default();
      this.getFieldEntities(pure).forEach((field) => {
        const namePath = field.getNamePath();
        cache.set(namePath, field);
      });
      return cache;
    });
    __publicField(this, "getFieldEntitiesForNamePathList", (nameList) => {
      if (!nameList) {
        return this.getFieldEntities(true);
      }
      const cache = this.getFieldsMap(true);
      return nameList.map((name) => {
        const namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    });
    __publicField(this, "getFieldsValue", (nameList, filterFunc) => {
      this.warningUnhooked();
      let mergedNameList;
      let mergedFilterFunc;
      if (nameList === true || Array.isArray(nameList)) {
        mergedNameList = nameList;
        mergedFilterFunc = filterFunc;
      } else if (nameList && typeof nameList === "object") {
        mergedFilterFunc = nameList.filter;
      }
      if (mergedNameList === true && !mergedFilterFunc) {
        return this.store;
      }
      const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
      const filteredNameList = [];
      const listNamePaths = [];
      fieldEntities.forEach((entity) => {
        var _a;
        const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();
        if ((_a = entity.isList) == null ? void 0 : _a.call(entity)) {
          listNamePaths.push(namePath);
          return;
        }
        if (!mergedFilterFunc) {
          filteredNameList.push(namePath);
        } else {
          const meta = "getMeta" in entity ? entity.getMeta() : null;
          if (mergedFilterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));
      listNamePaths.forEach((namePath) => {
        if (!get(mergedValues, namePath)) {
          mergedValues = set(mergedValues, namePath, []);
        }
      });
      return mergedValues;
    });
    __publicField(this, "getFieldValue", (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      return get(this.store, namePath);
    });
    __publicField(this, "getFieldsError", (nameList) => {
      this.warningUnhooked();
      const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map((entity, index2) => {
        if (entity && !entity.INVALIDATE_NAME_PATH) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index2]),
          errors: [],
          warnings: []
        };
      });
    });
    __publicField(this, "getFieldError", (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      const fieldError = this.getFieldsError([namePath])[0];
      return fieldError.errors;
    });
    __publicField(this, "getFieldWarning", (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      const fieldError = this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    });
    __publicField(this, "isFieldsTouched", (...args) => {
      this.warningUnhooked();
      const [arg0, arg1] = args;
      let namePathList;
      let isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      const fieldEntities = this.getFieldEntities(true);
      const isFieldTouched = (field) => field.isFieldTouched();
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
      }
      const map = new NameMap_default();
      namePathList.forEach((shortNamePath) => {
        map.set(shortNamePath, []);
      });
      fieldEntities.forEach((field) => {
        const fieldNamePath = field.getNamePath();
        namePathList.forEach((shortNamePath) => {
          if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {
            map.update(shortNamePath, (list) => [...list, field]);
          }
        });
      });
      const isNamePathListTouched = (entities) => entities.some(isFieldTouched);
      const namePathListEntities = map.map(({
        value
      }) => value);
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    });
    __publicField(this, "isFieldTouched", (name) => {
      this.warningUnhooked();
      return this.isFieldsTouched([name]);
    });
    __publicField(this, "isFieldsValidating", (nameList) => {
      this.warningUnhooked();
      const fieldEntities = this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some((testField) => testField.isFieldValidating());
      }
      const namePathList = nameList.map(getNamePath);
      return fieldEntities.some((testField) => {
        const fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    });
    __publicField(this, "isFieldValidating", (name) => {
      this.warningUnhooked();
      return this.isFieldsValidating([name]);
    });
    /**
     * Reset Field with field `initialValue` prop.
     * Can pass `entities` or `namePathList` or just nothing.
     */
    __publicField(this, "resetWithFieldInitialValue", (info = {}) => {
      const cache = new NameMap_default();
      const fieldEntities = this.getFieldEntities(true);
      fieldEntities.forEach((field) => {
        const {
          initialValue
        } = field.props;
        const namePath = field.getNamePath();
        if (initialValue !== void 0) {
          const records = cache.get(namePath) || /* @__PURE__ */ new Set();
          records.add({
            entity: field,
            value: initialValue
          });
          cache.set(namePath, records);
        }
      });
      const resetWithFields = (entities) => {
        entities.forEach((field) => {
          const {
            initialValue
          } = field.props;
          if (initialValue !== void 0) {
            const namePath = field.getNamePath();
            const formInitialValue = this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warning_default(false, `Form already set 'initialValues' with path '${namePath.join(".")}'. Field can not overwrite it.`);
            } else {
              const records = cache.get(namePath);
              if (records && records.size > 1) {
                warning_default(false, `Multiple Field with path '${namePath.join(".")}' set 'initialValue'. Can not decide which one to pick.`);
              } else if (records) {
                const originValue = this.getFieldValue(namePath);
                const isListField = field.isListField();
                if (!isListField && (!info.skipExist || originValue === void 0)) {
                  this.updateStore(set(this.store, namePath, [...records][0].value));
                }
              }
            }
          }
        });
      };
      let requiredFieldEntities;
      if (info.entities) {
        requiredFieldEntities = info.entities;
      } else if (info.namePathList) {
        requiredFieldEntities = [];
        info.namePathList.forEach((namePath) => {
          const records = cache.get(namePath);
          if (records) {
            requiredFieldEntities.push(...[...records].map((r2) => r2.entity));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    });
    __publicField(this, "resetFields", (nameList) => {
      this.warningUnhooked();
      const prevStore = this.store;
      if (!nameList) {
        this.updateStore(merge(this.initialValues));
        this.resetWithFieldInitialValue();
        this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        this.notifyWatch();
        return;
      }
      const namePathList = nameList.map(getNamePath);
      namePathList.forEach((namePath) => {
        const initialValue = this.getInitialValue(namePath);
        this.updateStore(set(this.store, namePath, initialValue));
      });
      this.resetWithFieldInitialValue({
        namePathList
      });
      this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      this.notifyWatch(namePathList);
    });
    __publicField(this, "setFields", (fields) => {
      this.warningUnhooked();
      const prevStore = this.store;
      const namePathList = [];
      fields.forEach((fieldData) => {
        const {
          name,
          ...data
        } = fieldData;
        const namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data) {
          this.updateStore(set(this.store, namePath, data.value));
        }
        this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      this.notifyWatch(namePathList);
    });
    __publicField(this, "getFields", () => {
      const entities = this.getFieldEntities(true);
      const fields = entities.map((field) => {
        const namePath = field.getNamePath();
        const meta = field.getMeta();
        const fieldData = {
          ...meta,
          name: namePath,
          value: this.getFieldValue(namePath)
        };
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    });
    // =========================== Observer ===========================
    /**
     * This only trigger when a field is on constructor to avoid we get initialValue too late
     */
    __publicField(this, "initEntityValue", (entity) => {
      const {
        initialValue
      } = entity.props;
      if (initialValue !== void 0) {
        const namePath = entity.getNamePath();
        const prevValue = get(this.store, namePath);
        if (prevValue === void 0) {
          this.updateStore(set(this.store, namePath, initialValue));
        }
      }
    });
    __publicField(this, "isMergedPreserve", (fieldPreserve) => {
      const mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : this.preserve;
      return mergedPreserve ?? true;
    });
    __publicField(this, "registerField", (entity) => {
      this.fieldEntities.push(entity);
      const namePath = entity.getNamePath();
      this.batchNotifyWatch(namePath);
      if (entity.props.initialValue !== void 0) {
        const prevStore = this.store;
        this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return (isListField, preserve2, subNamePath = []) => {
        this.fieldEntities = this.fieldEntities.filter((item) => item !== entity);
        if (!this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
          const defaultValue = isListField ? void 0 : this.getInitialValue(namePath);
          if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every((field) => (
            // Only reset when no namePath exist
            !matchNamePath(field.getNamePath(), namePath)
          ))) {
            const prevStore = this.store;
            this.updateStore(set(prevStore, namePath, defaultValue, true));
            this.notifyObservers(prevStore, [namePath], {
              type: "remove"
            });
            this.triggerDependenciesUpdate(prevStore, namePath);
          }
        }
        this.batchNotifyWatch(namePath);
      };
    });
    __publicField(this, "dispatch", (action) => {
      switch (action.type) {
        case "updateValue": {
          const {
            namePath,
            value
          } = action;
          this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          const {
            namePath,
            triggerName
          } = action;
          this.validateFields([namePath], {
            triggerName
          });
          break;
        }
        default:
      }
    });
    __publicField(this, "notifyObservers", (prevStore, namePathList, info) => {
      if (this.subscribable) {
        const mergedInfo = {
          ...info,
          store: this.getFieldsValue(true)
        };
        this.getFieldEntities().forEach(({
          onStoreChange
        }) => {
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        this.forceRootUpdate();
      }
    });
    /**
     * Notify dependencies children with parent update
     * We need delay to trigger validate in case Field is under render props
     */
    __publicField(this, "triggerDependenciesUpdate", (prevStore, namePath) => {
      const childrenFields = this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        this.validateFields(childrenFields);
      }
      this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath, ...childrenFields]
      });
      return childrenFields;
    });
    __publicField(this, "updateValue", (name, value) => {
      const namePath = getNamePath(name);
      const prevStore = this.store;
      this.updateStore(set(this.store, namePath, value));
      this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      this.notifyWatch([namePath]);
      const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);
      const {
        onValuesChange
      } = this.callbacks;
      if (onValuesChange) {
        const changedValues = cloneByNamePathList(this.store, [namePath]);
        const allValues = this.getFieldsValue();
        const mergedAllValues = merge(allValues, changedValues);
        onValuesChange(changedValues, mergedAllValues);
      }
      this.triggerOnFieldsChange([namePath, ...childrenFields]);
    });
    // Let all child Field get update.
    __publicField(this, "setFieldsValue", (store) => {
      this.warningUnhooked();
      const prevStore = this.store;
      if (store) {
        const nextStore = merge(this.store, store);
        this.updateStore(nextStore);
      }
      this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      this.notifyWatch();
    });
    __publicField(this, "setFieldValue", (name, value) => {
      this.setFields([{
        name,
        value,
        errors: [],
        warnings: [],
        touched: true
      }]);
    });
    __publicField(this, "getDependencyChildrenFields", (rootNamePath) => {
      const children = /* @__PURE__ */ new Set();
      const childrenFields = [];
      const dependencies2fields = new NameMap_default();
      this.getFieldEntities().forEach((field) => {
        const {
          dependencies
        } = field.props;
        (dependencies || []).forEach((dependency) => {
          const dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, (fields = /* @__PURE__ */ new Set()) => {
            fields.add(field);
            return fields;
          });
        });
      });
      const fillChildren = (namePath) => {
        const fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
        fields.forEach((field) => {
          if (!children.has(field)) {
            children.add(field);
            const fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    });
    __publicField(this, "triggerOnFieldsChange", (namePathList, filedErrors) => {
      const {
        onFieldsChange
      } = this.callbacks;
      if (onFieldsChange) {
        const fields = this.getFields();
        if (filedErrors) {
          const cache = new NameMap_default();
          filedErrors.forEach(({
            name,
            errors
          }) => {
            cache.set(name, errors);
          });
          fields.forEach((field) => {
            field.errors = cache.get(field.name) || field.errors;
          });
        }
        const changedFields = fields.filter(({
          name: fieldName
        }) => containsNamePath(namePathList, fieldName));
        if (changedFields.length) {
          onFieldsChange(changedFields, fields);
        }
      }
    });
    // =========================== Validate ===========================
    __publicField(this, "validateFields", (arg1, arg2) => {
      this.warningUnhooked();
      let nameList;
      let options;
      if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
        nameList = arg1;
        options = arg2;
      } else {
        options = arg1;
      }
      const provideNameList = !!nameList;
      const namePathList = provideNameList ? nameList.map(getNamePath) : [];
      const finalValueNamePathList = [...namePathList];
      const promiseList = [];
      const TMP_SPLIT = String(Date.now());
      const validateNamePathList = /* @__PURE__ */ new Set();
      const {
        recursive,
        dirty
      } = options || {};
      this.getFieldEntities(true).forEach((field) => {
        const fieldNamePath = field.getNamePath();
        if (!provideNameList) {
          if (
            // If is field, pass directly
            !field.isList() || // If is list, do not add if already exist sub field in the namePathList
            !namePathList.some((name) => matchNamePath(name, fieldNamePath, true))
          ) {
            finalValueNamePathList.push(fieldNamePath);
          }
          namePathList.push(fieldNamePath);
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        if (dirty && !field.isFieldDirty()) {
          return;
        }
        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
          const promise = field.validateRules({
            validateMessages: {
              ...defaultValidateMessages,
              ...this.validateMessages
            },
            ...options
          });
          promiseList.push(promise.then(() => ({
            name: fieldNamePath,
            errors: [],
            warnings: []
          })).catch((ruleErrors) => {
            var _a;
            const mergedErrors = [];
            const mergedWarnings = [];
            (_a = ruleErrors.forEach) == null ? void 0 : _a.call(ruleErrors, ({
              rule: {
                warningOnly
              },
              errors
            }) => {
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      const summaryPromise = allPromiseFinish(promiseList);
      this.lastValidatePromise = summaryPromise;
      summaryPromise.catch((results) => results).then((results) => {
        const resultNamePathList = results.map(({
          name
        }) => name);
        this.notifyObservers(this.store, resultNamePathList, {
          type: "validateFinish"
        });
        this.triggerOnFieldsChange(resultNamePathList, results);
      });
      const returnPromise = summaryPromise.then(() => {
        if (this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(this.getFieldsValue(finalValueNamePathList));
        }
        return Promise.reject([]);
      }).catch((results) => {
        var _a, _b;
        const errorList = results.filter((result) => result && result.errors.length);
        const errorMessage = (_b = (_a = errorList[0]) == null ? void 0 : _a.errors) == null ? void 0 : _b[0];
        return Promise.reject({
          message: errorMessage,
          values: this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch((e3) => e3);
      const triggerNamePathList = namePathList.filter((namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT)));
      this.triggerOnFieldsChange(triggerNamePathList);
      return returnPromise;
    });
    // ============================ Submit ============================
    __publicField(this, "submit", () => {
      this.warningUnhooked();
      this.validateFields().then((values) => {
        const {
          onFinish
        } = this.callbacks;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch((e3) => {
        const {
          onFinishFailed
        } = this.callbacks;
        if (onFinishFailed) {
          onFinishFailed(e3);
        }
      });
    });
    this.forceRootUpdate = forceRootUpdate;
  }
};
function useForm(form) {
  const formRef = React114.useRef(null);
  const [, forceUpdate] = React114.useState({});
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      const forceReRender = () => {
        forceUpdate({});
      };
      const formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var useForm_default = useForm;

// node_modules/@rc-component/form/es/Form.js
var React117 = __toESM(require_react());

// node_modules/@rc-component/form/es/FormContext.js
var React115 = __toESM(require_react());
var FormContext = React115.createContext({
  triggerFormChange: () => {
  },
  triggerFormFinish: () => {
  },
  registerForm: () => {
  },
  unregisterForm: () => {
  }
});
var FormProvider = ({
  validateMessages,
  onFormChange,
  onFormFinish,
  children
}) => {
  const formContext = React115.useContext(FormContext);
  const formsRef = React115.useRef({});
  return React115.createElement(FormContext.Provider, {
    value: {
      ...formContext,
      validateMessages: {
        ...formContext.validateMessages,
        ...validateMessages
      },
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: (name, changedFields) => {
        if (onFormChange) {
          onFormChange(name, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name, changedFields);
      },
      triggerFormFinish: (name, values) => {
        if (onFormFinish) {
          onFormFinish(name, {
            values,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name, values);
      },
      registerForm: (name, form) => {
        if (name) {
          formsRef.current = {
            ...formsRef.current,
            [name]: form
          };
        }
        formContext.registerForm(name, form);
      },
      unregisterForm: (name) => {
        const newForms = {
          ...formsRef.current
        };
        delete newForms[name];
        formsRef.current = newForms;
        formContext.unregisterForm(name);
      }
    }
  }, children);
};
var FormContext_default = FormContext;

// node_modules/@rc-component/form/es/BatchUpdate.js
var React116 = __toESM(require_react());
var BatchUpdate = React116.forwardRef((_, ref) => {
  const [batchInfo, setBatchInfo] = React116.useState({});
  React116.useLayoutEffect(() => {
    const keys2 = Object.keys(batchInfo);
    if (keys2.length) {
      keys2.forEach((key) => {
        var _a;
        (_a = batchInfo[key]) == null ? void 0 : _a.call(batchInfo);
      });
      setBatchInfo({});
    }
  }, [batchInfo]);
  React116.useImperativeHandle(ref, () => ({
    batch: (key, callback) => {
      setBatchInfo((ori) => ({
        ...ori,
        [key]: callback
      }));
    }
  }));
  return null;
});
var BatchUpdate_default = BatchUpdate;

// node_modules/@rc-component/form/es/Form.js
function _extends16() {
  _extends16 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends16.apply(this, arguments);
}
var Form = ({
  name,
  initialValues,
  fields,
  form,
  preserve: preserve2,
  children,
  component: Component8 = "form",
  validateMessages,
  validateTrigger = "onChange",
  onValuesChange,
  onFieldsChange,
  onFinish,
  onFinishFailed,
  clearOnDestroy,
  ...restProps
}, ref) => {
  const nativeElementRef = React117.useRef(null);
  const formContext = React117.useContext(FormContext_default);
  const [formInstance] = useForm_default(form);
  const {
    useSubscribe,
    setInitialValues,
    setCallbacks,
    setValidateMessages,
    setPreserve,
    destroyForm,
    setBatchUpdate
  } = formInstance.getInternalHooks(HOOK_MARK);
  React117.useImperativeHandle(ref, () => ({
    ...formInstance,
    nativeElement: nativeElementRef.current
  }));
  React117.useEffect(() => {
    formContext.registerForm(name, formInstance);
    return () => {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]);
  setValidateMessages({
    ...formContext.validateMessages,
    ...validateMessages
  });
  setCallbacks({
    onValuesChange,
    onFieldsChange: (changedFields, ...rest) => {
      formContext.triggerFormChange(name, changedFields);
      if (onFieldsChange) {
        onFieldsChange(changedFields, ...rest);
      }
    },
    onFinish: (values) => {
      formContext.triggerFormFinish(name, values);
      if (onFinish) {
        onFinish(values);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve2);
  const mountRef = React117.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  const batchUpdateRef = React117.useRef(null);
  const batchUpdateTasksRef = React117.useRef([]);
  const tryFlushBatch = () => {
    if (batchUpdateRef.current) {
      batchUpdateTasksRef.current.forEach(([key, fn]) => {
        batchUpdateRef.current.batch(key, fn);
      });
      batchUpdateTasksRef.current = [];
    }
  };
  const setBatchUpdateRef = React117.useCallback((batchUpdate2) => {
    batchUpdateRef.current = batchUpdate2;
    tryFlushBatch();
  }, []);
  const batchUpdate = (key, callback) => {
    batchUpdateTasksRef.current.push([key, callback]);
    tryFlushBatch();
  };
  setBatchUpdate(batchUpdate);
  React117.useEffect(
    () => () => destroyForm(clearOnDestroy),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  let childrenNode;
  const childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    const values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  const prevFieldsRef = React117.useRef(null);
  React117.useEffect(() => {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  const formContextValue = React117.useMemo(() => ({
    ...formInstance,
    validateTrigger
  }), [formInstance, validateTrigger]);
  const wrapperNode = React117.createElement(ListContext_default.Provider, {
    value: null
  }, React117.createElement(FieldContext_default.Provider, {
    value: formContextValue
  }, childrenNode), React117.createElement(BatchUpdate_default, {
    ref: setBatchUpdateRef
  }));
  if (Component8 === false) {
    return wrapperNode;
  }
  return React117.createElement(Component8, _extends16({}, restProps, {
    ref: nativeElementRef,
    onSubmit: (event) => {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: (event) => {
      var _a;
      event.preventDefault();
      formInstance.resetFields();
      (_a = restProps.onReset) == null ? void 0 : _a.call(restProps, event);
    }
  }), wrapperNode);
};
var Form_default = Form;

// node_modules/@rc-component/form/es/useWatch.js
var import_react63 = __toESM(require_react());
function stringify2(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Math.random();
  }
}
function useWatch2(...args) {
  const [dependencies, _form = {}] = args;
  const options = isFormInstance(_form) ? {
    form: _form
  } : _form;
  const form = options.form;
  const [value, setValue] = (0, import_react63.useState)(() => typeof dependencies === "function" ? dependencies({}) : void 0);
  const valueStr = (0, import_react63.useMemo)(() => stringify2(value), [value]);
  const valueStrRef = (0, import_react63.useRef)(valueStr);
  valueStrRef.current = valueStr;
  const fieldContext = (0, import_react63.useContext)(FieldContext_default);
  const formInstance = form || fieldContext;
  const isValidForm = formInstance && formInstance._init;
  if (true) {
    warning_default(args.length === 2 ? form ? isValidForm : true : isValidForm, "useWatch requires a form instance since it can not auto detect from context.");
  }
  const {
    getFieldsValue,
    getInternalHooks
  } = formInstance;
  const {
    registerWatch
  } = getInternalHooks(HOOK_MARK);
  const triggerUpdate = useEvent_default((values, allValues) => {
    const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();
    const nextValue = typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, getNamePath(dependencies));
    if (stringify2(value) !== stringify2(nextValue)) {
      setValue(nextValue);
    }
  });
  const flattenDeps = typeof dependencies === "function" ? dependencies : JSON.stringify(dependencies);
  (0, import_react63.useEffect)(() => {
    if (!isValidForm) {
      return;
    }
    triggerUpdate();
  }, [isValidForm, flattenDeps]);
  (0, import_react63.useEffect)(() => {
    if (!isValidForm) {
      return;
    }
    const cancelRegister = registerWatch((values, allValues) => {
      triggerUpdate(values, allValues);
    });
    return cancelRegister;
  }, [isValidForm]);
  return value;
}
var useWatch_default = useWatch2;

// node_modules/@rc-component/form/es/index.js
var InternalForm = React118.forwardRef(Form_default);
var RefForm = InternalForm;
RefForm.FormProvider = FormProvider;
RefForm.Field = Field_default;
RefForm.List = List_default;
RefForm.useForm = useForm_default;
RefForm.useWatch = useWatch_default;
var es_default9 = RefForm;

// node_modules/antd/es/form/context.js
var FormContext2 = React119.createContext({
  labelAlign: "right",
  layout: "horizontal",
  itemRef: () => {
  }
});
var NoStyleItemContext = React119.createContext(null);
var FormProvider2 = (props) => {
  const providerProps = omit(props, ["prefixCls"]);
  return React119.createElement(FormProvider, {
    ...providerProps
  });
};
var FormItemPrefixContext = React119.createContext({
  prefixCls: ""
});
var FormItemInputContext = React119.createContext({});
if (true) {
  FormItemInputContext.displayName = "FormItemInputContext";
}
var NoFormStyle = ({
  children,
  status,
  override
}) => {
  const formItemInputContext = React119.useContext(FormItemInputContext);
  const newFormItemInputContext = React119.useMemo(() => {
    const newContext = {
      ...formItemInputContext
    };
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return React119.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
};
var VariantContext = React119.createContext(void 0);

// node_modules/antd/es/_util/ContextIsolator.js
var ContextIsolator = (props) => {
  const {
    space,
    form,
    children
  } = props;
  if (!isNonNullable_default(children)) {
    return null;
  }
  let result = children;
  if (form) {
    result = import_react64.default.createElement(NoFormStyle, {
      override: true,
      status: true
    }, result);
  }
  if (space) {
    result = import_react64.default.createElement(NoCompactStyle, null, result);
  }
  return result;
};
var ContextIsolator_default = ContextIsolator;

// node_modules/@rc-component/util/es/Dom/styleChecker.js
var isStyleNameSupport = (styleName) => {
  if (canUseDom() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const {
      documentElement
    } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
};
var isStyleValueSupport = (styleName, value) => {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}

// node_modules/antd/es/_util/styleChecker.js
var canUseDocElement = () => canUseDom() && window.document.documentElement;

// node_modules/antd/es/skeleton/Skeleton.js
var React129 = __toESM(require_react());

// node_modules/antd/es/skeleton/Avatar.js
var React122 = __toESM(require_react());

// node_modules/antd/es/skeleton/Element.js
var React121 = __toESM(require_react());
var Element2 = (props) => {
  const {
    prefixCls,
    className,
    style: style2,
    size,
    shape
  } = props;
  const sizeCls = clsx({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = clsx({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = React121.useMemo(() => typeof size === "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return React121.createElement("span", {
    className: clsx(prefixCls, sizeCls, shapeCls, className),
    style: {
      ...sizeStyle,
      ...style2
    }
  });
};
var Element_default = Element2;

// node_modules/antd/es/skeleton/style/index.js
var skeletonClsLoading = new Keyframes_default(`ant-skeleton-loading`, {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
});
var genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: unit(size)
});
var genSkeletonElementSize = (size) => ({
  width: size,
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonColor = (token2) => ({
  background: token2.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token2.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
});
var genSkeletonElementInputSize = (size, calc) => ({
  width: calc(size).mul(5).equal(),
  minWidth: calc(size).mul(5).equal(),
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonElementAvatar = (token2) => {
  const {
    skeletonAvatarCls,
    gradientFromColor,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token2;
  return {
    [skeletonAvatarCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      ...genSkeletonElementSize(controlHeight)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: {
      ...genSkeletonElementSize(controlHeightLG)
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: {
      ...genSkeletonElementSize(controlHeightSM)
    }
  };
};
var genSkeletonElementInput = (token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return {
    [skeletonInputCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      ...genSkeletonElementInputSize(controlHeight, calc)
    },
    [`${skeletonInputCls}-lg`]: {
      ...genSkeletonElementInputSize(controlHeightLG, calc)
    },
    [`${skeletonInputCls}-sm`]: {
      ...genSkeletonElementInputSize(controlHeightSM, calc)
    }
  };
};
var genSkeletonElementShape = (token2) => {
  const {
    gradientFromColor,
    borderRadiusSM,
    imageSizeBase,
    calc
  } = token2;
  return {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "middle",
    background: gradientFromColor,
    borderRadius: borderRadiusSM,
    ...genSkeletonElementSize(calc(imageSizeBase).mul(2).equal())
  };
};
var genSkeletonElementNode = (token2) => {
  return {
    [token2.skeletonNodeCls]: {
      ...genSkeletonElementShape(token2)
    }
  };
};
var genSkeletonElementImage = (token2) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    calc
  } = token2;
  return {
    [skeletonImageCls]: {
      ...genSkeletonElementShape(token2),
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: {
        ...genSkeletonElementSize(imageSizeBase),
        maxWidth: calc(imageSizeBase).mul(4).equal(),
        maxHeight: calc(imageSizeBase).mul(4).equal()
      },
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    },
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
var genSkeletonElementButtonShape = (token2, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
var genSkeletonElementButtonSize = (size, calc) => ({
  width: calc(size).mul(2).equal(),
  minWidth: calc(size).mul(2).equal(),
  ...genSkeletonElementCommonSize(size)
});
var genSkeletonElementButton = (token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token2;
  return {
    [skeletonButtonCls]: {
      display: "inline-block",
      verticalAlign: "top",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      width: calc(controlHeight).mul(2).equal(),
      minWidth: calc(controlHeight).mul(2).equal(),
      ...genSkeletonElementButtonSize(controlHeight, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls),
    [`${skeletonButtonCls}-lg`]: {
      ...genSkeletonElementButtonSize(controlHeightLG, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`),
    [`${skeletonButtonCls}-sm`]: {
      ...genSkeletonElementButtonSize(controlHeightSM, calc)
    },
    ...genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`)
  };
};
var genBaseStyle3 = (token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonNodeCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    padding,
    marginSM,
    borderRadius,
    titleHeight,
    blockRadius,
    paragraphLiHeight,
    controlHeightXS,
    paragraphMarginTop
  } = token2;
  return {
    [componentCls]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [skeletonAvatarCls]: {
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor,
          ...genSkeletonElementSize(controlHeight)
        },
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: {
          ...genSkeletonElementSize(controlHeightLG)
        },
        [`${skeletonAvatarCls}-sm`]: {
          ...genSkeletonElementSize(controlHeightSM)
        }
      },
      [`${componentCls}-section`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [skeletonTitleCls]: {
          width: "100%",
          height: titleHeight,
          background: gradientFromColor,
          borderRadius: blockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [skeletonParagraphCls]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: paragraphLiHeight,
            listStyle: "none",
            background: gradientFromColor,
            borderRadius: blockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-section`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-section`]: {
      // Title
      [skeletonTitleCls]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: paragraphMarginTop
        }
      }
    },
    // Skeleton with element
    [`${componentCls}${componentCls}-element`]: {
      display: "inline-block",
      width: "auto",
      ...genSkeletonElementButton(token2),
      ...genSkeletonElementAvatar(token2),
      ...genSkeletonElementInput(token2),
      ...genSkeletonElementNode(token2),
      ...genSkeletonElementImage(token2)
    },
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [skeletonButtonCls]: {
        width: "100%"
      },
      [skeletonInputCls]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonNodeCls},
        ${skeletonImageCls}
      `]: {
        ...genSkeletonColor(token2)
      }
    }
  };
};
var prepareComponentToken7 = (token2) => {
  const {
    colorFillContent,
    colorFill
  } = token2;
  const gradientFromColor = colorFillContent;
  const gradientToColor = colorFill;
  return {
    color: gradientFromColor,
    colorGradientEnd: gradientToColor,
    gradientFromColor,
    gradientToColor,
    titleHeight: token2.controlHeight / 2,
    blockRadius: token2.borderRadiusSM,
    paragraphMarginTop: token2.marginLG + token2.marginXXS,
    paragraphLiHeight: token2.controlHeight / 2
  };
};
var style_default8 = genStyleHooks("Skeleton", (token2) => {
  const {
    componentCls,
    calc
  } = token2;
  const skeletonToken = merge2(token2, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonNodeCls: `${componentCls}-node`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return genBaseStyle3(skeletonToken);
}, prepareComponentToken7, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
});

// node_modules/antd/es/skeleton/Avatar.js
var SkeletonAvatar = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    active,
    style: style2,
    styles,
    shape = "circle",
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React122.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, classNames == null ? void 0 : classNames.root, className, rootClassName, hashId, cssVarCls);
  return React122.createElement("div", {
    className: cls,
    style: styles == null ? void 0 : styles.root
  }, React122.createElement(Element_default, {
    prefixCls: `${prefixCls}-avatar`,
    className: classNames == null ? void 0 : classNames.content,
    style: {
      ...styles == null ? void 0 : styles.content,
      ...style2
    },
    shape,
    size,
    ...rest
  }));
};
var Avatar_default = SkeletonAvatar;

// node_modules/antd/es/skeleton/Button.js
var React123 = __toESM(require_react());
var SkeletonButton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    active,
    style: style2,
    styles,
    block = false,
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React123.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, classNames == null ? void 0 : classNames.root, className, rootClassName, hashId, cssVarCls);
  return React123.createElement("div", {
    className: cls,
    style: styles == null ? void 0 : styles.root
  }, React123.createElement(Element_default, {
    prefixCls: `${prefixCls}-button`,
    className: classNames == null ? void 0 : classNames.content,
    style: {
      ...styles == null ? void 0 : styles.content,
      ...style2
    },
    size,
    ...rest
  }));
};
var Button_default2 = SkeletonButton;

// node_modules/antd/es/skeleton/Image.js
var React125 = __toESM(require_react());

// node_modules/antd/es/skeleton/Node.js
var React124 = __toESM(require_react());
var SkeletonNode = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    internalClassName,
    style: style2,
    styles,
    active,
    children
  } = props;
  const {
    getPrefixCls
  } = React124.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, classNames == null ? void 0 : classNames.root, className, rootClassName, cssVarCls);
  return React124.createElement("div", {
    className: cls,
    style: styles == null ? void 0 : styles.root
  }, React124.createElement("div", {
    className: clsx(classNames == null ? void 0 : classNames.content, internalClassName || `${prefixCls}-node`),
    style: {
      ...styles == null ? void 0 : styles.content,
      ...style2
    }
  }, children));
};
var Node_default = SkeletonNode;

// node_modules/antd/es/skeleton/Image.js
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = (props) => {
  const {
    getPrefixCls
  } = React125.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", props.prefixCls);
  return React125.createElement(Node_default, {
    ...props,
    internalClassName: `${prefixCls}-image`
  }, React125.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${prefixCls}-image-svg`
  }, React125.createElement("title", null, "Image placeholder"), React125.createElement("path", {
    d: path,
    className: `${prefixCls}-image-path`
  })));
};
var Image_default = SkeletonImage;

// node_modules/antd/es/skeleton/Input.js
var React126 = __toESM(require_react());
var SkeletonInput = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    rootClassName,
    active,
    block,
    style: style2,
    styles,
    size = "default",
    ...rest
  } = props;
  const {
    getPrefixCls
  } = React126.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, classNames == null ? void 0 : classNames.root, className, rootClassName, hashId, cssVarCls);
  return React126.createElement("div", {
    className: cls,
    style: styles == null ? void 0 : styles.root
  }, React126.createElement(Element_default, {
    prefixCls: `${prefixCls}-input`,
    className: classNames == null ? void 0 : classNames.content,
    style: {
      ...styles == null ? void 0 : styles.content,
      ...style2
    },
    size,
    ...rest
  }));
};
var Input_default = SkeletonInput;

// node_modules/antd/es/skeleton/Paragraph.js
var React127 = __toESM(require_react());
var getWidth = (index2, props) => {
  const {
    width,
    rows = 2
  } = props;
  if (Array.isArray(width)) {
    return width[index2];
  }
  if (rows - 1 === index2) {
    return width;
  }
  return void 0;
};
var Paragraph = (props) => {
  const {
    prefixCls,
    className,
    style: style2,
    rows = 0
  } = props;
  const rowList = Array.from({
    length: rows
  }).map((_, index2) => (
    // eslint-disable-next-line react/no-array-index-key
    React127.createElement("li", {
      key: index2,
      style: {
        width: getWidth(index2, props)
      }
    })
  ));
  return React127.createElement("ul", {
    className: clsx(prefixCls, className),
    style: style2
  }, rowList);
};
var Paragraph_default = Paragraph;

// node_modules/antd/es/skeleton/Title.js
var React128 = __toESM(require_react());
var Title = ({
  prefixCls,
  className,
  width,
  style: style2
}) => (
  // biome-ignore lint/a11y/useHeadingContent: HOC here
  React128.createElement("h3", {
    className: clsx(prefixCls, className),
    style: {
      width,
      ...style2
    }
  })
);
var Title_default = Title;

// node_modules/antd/es/skeleton/Skeleton.js
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  if (!hasAvatar || !hasTitle) {
    basicProps.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
var Skeleton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    classNames,
    style: style2,
    styles,
    children,
    avatar = false,
    title = true,
    paragraph = true,
    active,
    round
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("skeleton");
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [hashId, cssVarCls] = style_default8(prefixCls);
  const mergedProps = {
    ...props,
    avatar,
    title,
    paragraph
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = {
        className: mergedClassNames.avatar,
        prefixCls: `${prefixCls}-avatar`,
        ...getAvatarBasicProps(hasTitle, hasParagraph),
        ...getComponentProps(avatar),
        style: mergedStyles.avatar
      };
      avatarNode = React129.createElement("div", {
        className: clsx(mergedClassNames.header, `${prefixCls}-header`),
        style: mergedStyles.header
      }, React129.createElement(Element_default, {
        ...avatarProps
      }));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = {
          className: mergedClassNames.title,
          prefixCls: `${prefixCls}-title`,
          ...getTitleBasicProps(hasAvatar, hasParagraph),
          ...getComponentProps(title),
          style: mergedStyles.title
        };
        $title = React129.createElement(Title_default, {
          ...titleProps
        });
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = {
          className: mergedClassNames.paragraph,
          prefixCls: `${prefixCls}-paragraph`,
          ...getParagraphBasicProps(hasAvatar, hasTitle),
          ...getComponentProps(paragraph),
          style: mergedStyles.paragraph
        };
        paragraphNode = React129.createElement(Paragraph_default, {
          ...paragraphProps
        });
      }
      contentNode = React129.createElement("div", {
        className: clsx(mergedClassNames.section, `${prefixCls}-section`),
        style: mergedStyles.section
      }, $title, paragraphNode);
    }
    const cls = clsx(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-round`]: round
    }, mergedClassNames.root, contextClassName, className, rootClassName, hashId, cssVarCls);
    return React129.createElement("div", {
      className: cls,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      }
    }, avatarNode, contentNode);
  }
  return children ?? null;
};
Skeleton.Button = Button_default2;
Skeleton.Avatar = Avatar_default;
Skeleton.Input = Input_default;
Skeleton.Image = Image_default;
Skeleton.Node = Node_default;
if (true) {
  Skeleton.displayName = "Skeleton";
}
var Skeleton_default = Skeleton;

// node_modules/antd/es/skeleton/index.js
var skeleton_default = Skeleton_default;

// node_modules/antd/es/watermark/context.js
var React130 = __toESM(require_react());
function voidFunc() {
}
var WatermarkContext = React130.createContext({
  add: voidFunc,
  remove: voidFunc
});
function usePanelRef(panelSelector) {
  const watermark = React130.useContext(WatermarkContext);
  const panelEleRef = React130.useRef(null);
  const panelRef = useEvent_default((ele) => {
    if (ele) {
      const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
      if (innerContentEle) {
        watermark.add(innerContentEle);
        panelEleRef.current = innerContentEle;
      }
    } else {
      watermark.remove(panelEleRef.current);
    }
  });
  return panelRef;
}
var context_default4 = WatermarkContext;

// node_modules/antd/es/modal/shared.js
var import_react67 = __toESM(require_react());

// node_modules/antd/es/modal/components/NormalCancelBtn.js
var import_react65 = __toESM(require_react());
var NormalCancelBtn = () => {
  const {
    cancelButtonProps,
    cancelTextLocale,
    onCancel
  } = (0, import_react65.useContext)(ModalContext);
  return import_react65.default.createElement(Button_default, {
    onClick: onCancel,
    ...cancelButtonProps
  }, cancelTextLocale);
};
var NormalCancelBtn_default = NormalCancelBtn;

// node_modules/antd/es/modal/components/NormalOkBtn.js
var import_react66 = __toESM(require_react());
var NormalOkBtn = () => {
  const {
    confirmLoading,
    okButtonProps,
    okType,
    okTextLocale,
    onOk
  } = (0, import_react66.useContext)(ModalContext);
  return import_react66.default.createElement(Button_default, {
    ...convertLegacyProps(okType),
    loading: confirmLoading,
    onClick: onOk,
    ...okButtonProps
  }, okTextLocale);
};
var NormalOkBtn_default = NormalOkBtn;

// node_modules/antd/es/modal/shared.js
function renderCloseIcon(prefixCls, closeIcon) {
  return import_react67.default.createElement("span", {
    className: `${prefixCls}-close-x`
  }, closeIcon || import_react67.default.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  }));
}
var Footer = (props) => {
  const {
    okText,
    okType = "primary",
    cancelText,
    confirmLoading,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps,
    footer
  } = props;
  const [locale6] = useLocale_default("Modal", getConfirmLocale());
  const okTextLocale = okText || (locale6 == null ? void 0 : locale6.okText);
  const cancelTextLocale = cancelText || (locale6 == null ? void 0 : locale6.cancelText);
  const memoizedValue = import_react67.default.useMemo(() => {
    return {
      confirmLoading,
      okButtonProps,
      cancelButtonProps,
      okTextLocale,
      cancelTextLocale,
      okType,
      onOk,
      onCancel
    };
  }, [confirmLoading, okButtonProps, cancelButtonProps, okTextLocale, cancelTextLocale, okType, onOk, onCancel]);
  let footerNode;
  if (typeof footer === "function" || typeof footer === "undefined") {
    footerNode = import_react67.default.createElement(import_react67.default.Fragment, null, import_react67.default.createElement(NormalCancelBtn_default, null), import_react67.default.createElement(NormalOkBtn_default, null));
    if (typeof footer === "function") {
      footerNode = footer(footerNode, {
        OkBtn: NormalOkBtn_default,
        CancelBtn: NormalCancelBtn_default
      });
    }
    footerNode = import_react67.default.createElement(ModalContextProvider, {
      value: memoizedValue
    }, footerNode);
  } else {
    footerNode = footer;
  }
  return import_react67.default.createElement(DisabledContextProvider, {
    disabled: false
  }, footerNode);
};

// node_modules/antd/es/grid/style/index.js
var genGridRowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
};
var genGridColStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
};
var genLoopGridColumnsStyle = (token2, sizeCls) => {
  const {
    prefixCls,
    componentCls,
    gridColumns
  } = token2;
  const gridColumnsStyle = {};
  for (let i = gridColumns; i >= 0; i--) {
    if (i === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
        // https://github.com/ant-design/ant-design/issues/44456
        // Form set `display: flex` on Col which will override `display: block`.
        // Let's get it from css variable to support override.
        {
          ["--ant-display"]: "block",
          // Fallback to display if variable not support
          display: "block"
        },
        {
          display: "var(--ant-display)",
          flex: `0 0 ${i / gridColumns * 100}%`,
          maxWidth: `${i / gridColumns * 100}%`
        }
      ];
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
        insetInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
        insetInlineEnd: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
        marginInlineStart: `${i / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
        order: i
      };
    }
  }
  gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
    flex: `var(--${prefixCls}${sizeCls}-flex)`
  };
  return gridColumnsStyle;
};
var genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
var genGridMediaStyle = (token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${unit(screenSize)})`]: {
    ...genGridStyle(token2, sizeCls)
  }
});
var prepareRowComponentToken = () => ({});
var prepareColComponentToken = () => ({});
var useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
var getMediaSize = (token2) => {
  const mediaSizesMap = {
    xs: token2.screenXSMin,
    sm: token2.screenSMMin,
    md: token2.screenMDMin,
    lg: token2.screenLGMin,
    xl: token2.screenXLMin,
    xxl: token2.screenXXLMin
  };
  return mediaSizesMap;
};
var useColStyle = genStyleHooks("Grid", (token2) => {
  const gridToken = merge2(token2, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  });
  const gridMediaSizesMap = getMediaSize(gridToken);
  delete gridMediaSizesMap.xs;
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => ({
    ...pre,
    ...cur
  }), {})];
}, prepareColComponentToken);

// node_modules/antd/es/modal/style/index.js
function box(position3) {
  return {
    position: position3,
    inset: 0
  };
}
var genModalMaskStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return [{
    [`${componentCls}-root`]: {
      [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: token2.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      // https://github.com/ant-design/ant-design/issues/37329
      // https://github.com/ant-design/ant-design/issues/40272
      [`${componentCls}${antCls}-zoom-leave ${componentCls}-container`]: {
        pointerEvents: "none"
      },
      [`${componentCls}-mask`]: {
        ...box("fixed"),
        zIndex: token2.zIndexPopupBase,
        height: "100%",
        backgroundColor: token2.colorBgMask,
        pointerEvents: "none",
        [`&${componentCls}-mask-blur`]: {
          backdropFilter: "blur(4px)"
        },
        [`${componentCls}-hidden`]: {
          display: "none"
        }
      },
      [`${componentCls}-wrap`]: {
        ...box("fixed"),
        zIndex: token2.zIndexPopupBase,
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      }
    }
  }, {
    [`${componentCls}-root`]: initFadeMotion(token2)
  }];
};
var genModalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    // ======================== Root =========================
    {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [componentCls]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${token2.screenSMMax}px)`]: {
          [componentCls]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${unit(token2.marginXS)} auto`
          },
          [`${componentCls}-centered`]: {
            [componentCls]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [componentCls]: {
        ...resetComponent(token2),
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${unit(token2.calc(token2.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: token2.paddingLG,
        [`${componentCls}-title`]: {
          margin: 0,
          color: token2.titleColor,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.titleFontSize,
          lineHeight: token2.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-container`]: {
          position: "relative",
          backgroundColor: token2.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: token2.borderRadiusLG,
          boxShadow: token2.boxShadow,
          pointerEvents: "auto",
          padding: token2.contentPadding
        },
        [`${componentCls}-close`]: {
          position: "absolute",
          top: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
          zIndex: token2.calc(token2.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: token2.modalCloseIconColor,
          fontWeight: token2.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: token2.borderRadiusSM,
          width: token2.modalCloseBtnSize,
          height: token2.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: token2.fontSizeLG,
            fontStyle: "normal",
            lineHeight: unit(token2.modalCloseBtnSize),
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:disabled": {
            pointerEvents: "none"
          },
          "&:hover": {
            color: token2.modalCloseIconHoverColor,
            backgroundColor: token2.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          },
          ...genFocusStyle(token2)
        },
        [`${componentCls}-header`]: {
          color: token2.colorText,
          background: token2.headerBg,
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
          marginBottom: token2.headerMarginBottom,
          padding: token2.headerPadding,
          borderBottom: token2.headerBorderBottom
        },
        [`${componentCls}-body`]: {
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          wordWrap: "break-word",
          padding: token2.bodyPadding,
          [`${componentCls}-body-skeleton`]: {
            width: "100%",
            height: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            margin: `${unit(token2.margin)} auto`
          }
        },
        [`${componentCls}-footer`]: {
          textAlign: "end",
          background: token2.footerBg,
          marginTop: token2.footerMarginTop,
          padding: token2.footerPadding,
          borderTop: token2.footerBorderTop,
          borderRadius: token2.footerBorderRadius,
          [`> ${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginInlineStart: token2.marginXS
          }
        },
        [`${componentCls}-open`]: {
          overflow: "hidden"
        }
      }
    },
    // ======================== Pure =========================
    {
      [`${componentCls}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${componentCls}-container,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${componentCls}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
};
var genRTLStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-root`]: {
      [`${componentCls}-wrap-rtl`]: {
        direction: "rtl",
        [`${componentCls}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
};
var genResponsiveWidthStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const oriGridMediaSizesMap = getMediaSize(token2);
  const gridMediaSizesMap = {
    ...oriGridMediaSizesMap
  };
  delete gridMediaSizesMap.xs;
  const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
  const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({
    [`@media (min-width: ${unit(gridMediaSizesMap[key])})`]: {
      width: `var(${cssVarPrefix}${key}-width)`
    }
  }));
  return {
    [`${componentCls}-root`]: {
      [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index2) => {
        const previousKey = Object.keys(oriGridMediaSizesMap)[index2 - 1];
        return previousKey ? {
          [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)`
        } : null;
      })), [{
        width: `var(${cssVarPrefix}xs-width)`
      }], _toConsumableArray(responsiveStyles))
    }
  };
};
var prepareToken2 = (token2) => {
  const headerPaddingVertical = token2.padding;
  const headerFontSize = token2.fontSizeHeading5;
  const headerLineHeight = token2.lineHeightHeading5;
  const modalToken = merge2(token2, {
    modalHeaderHeight: token2.calc(token2.calc(headerLineHeight).mul(headerFontSize).equal()).add(token2.calc(headerPaddingVertical).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: token2.colorSplit,
    modalFooterBorderStyle: token2.lineType,
    modalFooterBorderWidth: token2.lineWidth,
    modalCloseIconColor: token2.colorIcon,
    modalCloseIconHoverColor: token2.colorIconHover,
    modalCloseBtnSize: token2.controlHeight,
    modalConfirmIconSize: token2.fontHeight,
    modalTitleHeight: token2.calc(token2.titleFontSize).mul(token2.titleLineHeight).equal()
  });
  return modalToken;
};
var prepareComponentToken8 = (token2) => ({
  footerBg: "transparent",
  headerBg: "transparent",
  titleLineHeight: token2.lineHeightHeading5,
  titleFontSize: token2.fontSizeHeading5,
  contentBg: token2.colorBgElevated,
  titleColor: token2.colorTextHeading,
  // internal
  contentPadding: token2.wireframe ? 0 : `${unit(token2.paddingMD)} ${unit(token2.paddingContentHorizontalLG)}`,
  headerPadding: token2.wireframe ? `${unit(token2.padding)} ${unit(token2.paddingLG)}` : 0,
  headerBorderBottom: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
  headerMarginBottom: token2.wireframe ? 0 : token2.marginXS,
  bodyPadding: token2.wireframe ? token2.paddingLG : 0,
  footerPadding: token2.wireframe ? `${unit(token2.paddingXS)} ${unit(token2.padding)}` : 0,
  footerBorderTop: token2.wireframe ? `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
  footerBorderRadius: token2.wireframe ? `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}` : 0,
  footerMarginTop: token2.wireframe ? 0 : token2.marginSM,
  confirmBodyPadding: token2.wireframe ? `${unit(token2.padding * 2)} ${unit(token2.padding * 2)} ${unit(token2.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: token2.wireframe ? token2.margin : token2.marginSM,
  confirmBtnsMarginTop: token2.wireframe ? token2.marginLG : token2.marginSM,
  mask: true
});
var style_default9 = genStyleHooks("Modal", (token2) => {
  const modalToken = prepareToken2(token2);
  return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), initZoomMotion(modalToken, "zoom"), genResponsiveWidthStyle(modalToken)];
}, prepareComponentToken8, {
  unitless: {
    titleLineHeight: true
  }
});

// node_modules/antd/es/modal/Modal.js
var mousePosition;
var getClickPosition = (e3) => {
  mousePosition = {
    x: e3.pageX,
    y: e3.pageY
  };
  setTimeout(() => {
    mousePosition = null;
  }, 100);
};
if (canUseDocElement()) {
  document.documentElement.addEventListener("click", getClickPosition, true);
}
var Modal = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    open: open3,
    wrapClassName,
    centered,
    getContainer,
    focusTriggerAfterClose = true,
    style: style2,
    width = 520,
    footer,
    classNames,
    styles,
    children,
    loading,
    confirmLoading,
    zIndex: customizeZIndex,
    mousePosition: customizeMousePosition,
    onOk,
    onCancel,
    okButtonProps,
    cancelButtonProps,
    destroyOnHidden,
    destroyOnClose,
    panelRef = null,
    closable,
    mask: modalMask,
    modalRender,
    ...restProps
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    centered: contextCentered,
    cancelButtonProps: contextCancelButtonProps,
    okButtonProps: contextOkButtonProps,
    mask: contextMask
  } = useComponentConfig("modal");
  const {
    modal: modalContext
  } = React134.useContext(ConfigContext);
  const [closableAfterclose, onClose] = React134.useMemo(() => {
    if (typeof closable === "boolean") {
      return [void 0, void 0];
    }
    return [closable == null ? void 0 : closable.afterClose, closable == null ? void 0 : closable.onClose];
  }, [closable]);
  const prefixCls = getPrefixCls("modal", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [mergedMask, maskBlurClassName] = useMergedMask(modalMask, contextMask, prefixCls);
  const handleCancel = (e3) => {
    if (confirmLoading) {
      return;
    }
    onCancel == null ? void 0 : onCancel(e3);
    onClose == null ? void 0 : onClose();
  };
  const handleOk = (e3) => {
    onOk == null ? void 0 : onOk(e3);
    onClose == null ? void 0 : onClose();
  };
  if (true) {
    const warning5 = devUseWarning("Modal");
    [["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"], ["destroyOnClose", "destroyOnHidden"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls, rootCls);
  const wrapClassNameExtended = clsx(wrapClassName, {
    [`${prefixCls}-centered`]: centered ?? contextCentered,
    [`${prefixCls}-wrap-rtl`]: direction === "rtl"
  });
  const dialogFooter = footer !== null && !loading ? React134.createElement(Footer, {
    ...props,
    okButtonProps: {
      ...contextOkButtonProps,
      ...okButtonProps
    },
    onOk: handleOk,
    cancelButtonProps: {
      ...contextCancelButtonProps,
      ...cancelButtonProps
    },
    onCancel: handleCancel
  }) : null;
  const [rawClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
    closable: true,
    closeIcon: React134.createElement(CloseOutlined_default, {
      className: `${prefixCls}-close-icon`
    }),
    closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
  });
  const mergedClosable = rawClosable ? {
    disabled: closeBtnIsDisabled,
    closeIcon: mergedCloseIcon,
    afterClose: closableAfterclose,
    ...ariaProps
  } : false;
  const mergedModalRender = modalRender ? (node2) => React134.createElement("div", {
    className: `${prefixCls}-render`
  }, modalRender(node2)) : void 0;
  const panelClassName = `.${prefixCls}-${modalRender ? "render" : "container"}`;
  const innerPanelRef = usePanelRef(panelClassName);
  const mergedPanelRef = composeRef(panelRef, innerPanelRef);
  const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
  const mergedProps = {
    ...props,
    width,
    panelRef,
    focusTriggerAfterClose,
    mask: mergedMask,
    zIndex
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames, maskBlurClassName], [contextStyles, styles], {
    props: mergedProps
  });
  const [numWidth, responsiveWidth] = React134.useMemo(() => {
    if (width && typeof width === "object") {
      return [void 0, width];
    }
    return [width, void 0];
  }, [width]);
  const responsiveWidthVars = React134.useMemo(() => {
    const vars = {};
    if (responsiveWidth) {
      Object.keys(responsiveWidth).forEach((breakpoint) => {
        const breakpointWidth = responsiveWidth[breakpoint];
        if (breakpointWidth !== void 0) {
          vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
        }
      });
    }
    return vars;
  }, [prefixCls, responsiveWidth]);
  return React134.createElement(ContextIsolator_default, {
    form: true,
    space: true
  }, React134.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, React134.createElement(es_default7, {
    width: numWidth,
    ...restProps,
    zIndex,
    getContainer: getContainer === void 0 ? getContextPopupContainer : getContainer,
    prefixCls,
    rootClassName: clsx(hashId, rootClassName, cssVarCls, rootCls, mergedClassNames.root),
    rootStyle: mergedStyles.root,
    footer: dialogFooter,
    visible: open3,
    mousePosition: customizeMousePosition ?? mousePosition,
    onClose: handleCancel,
    closable: mergedClosable,
    closeIcon: mergedCloseIcon,
    focusTriggerAfterClose,
    transitionName: getTransitionName2(rootPrefixCls, "zoom", props.transitionName),
    maskTransitionName: getTransitionName2(rootPrefixCls, "fade", props.maskTransitionName),
    mask: mergedMask,
    className: clsx(hashId, className, contextClassName),
    style: {
      ...contextStyle,
      ...style2,
      ...responsiveWidthVars
    },
    classNames: {
      ...mergedClassNames,
      wrapper: clsx(mergedClassNames.wrapper, wrapClassNameExtended)
    },
    styles: mergedStyles,
    panelRef: mergedPanelRef,
    destroyOnHidden: destroyOnHidden ?? destroyOnClose,
    modalRender: mergedModalRender
  }, loading ? React134.createElement(skeleton_default, {
    active: true,
    title: false,
    paragraph: {
      rows: 4
    },
    className: `${prefixCls}-body-skeleton`
  }) : children)));
};
var Modal_default = Modal;

// node_modules/antd/es/modal/style/confirm.js
var genModalConfirmStyle = (token2) => {
  const {
    componentCls,
    titleFontSize,
    titleLineHeight,
    modalConfirmIconSize,
    fontSize,
    lineHeight,
    modalTitleHeight,
    fontHeight,
    confirmBodyPadding
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [confirmComponentCls]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${token2.antCls}-modal-header`]: {
        display: "none"
      },
      [`${confirmComponentCls}-body-wrapper`]: {
        ...clearFix()
      },
      [`&${componentCls} ${componentCls}-body`]: {
        padding: confirmBodyPadding
      },
      // ====================== Body ======================
      [`${confirmComponentCls}-body`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${token2.iconCls}`]: {
          flex: "none",
          fontSize: modalConfirmIconSize,
          marginInlineEnd: token2.confirmIconMarginInlineEnd,
          marginTop: token2.calc(token2.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        },
        [`&-has-title > ${token2.iconCls}`]: {
          marginTop: token2.calc(token2.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
        }
      },
      [`${confirmComponentCls}-paragraph`]: {
        display: "flex",
        flexDirection: "column",
        flex: "auto",
        rowGap: token2.marginXS,
        // https://github.com/ant-design/ant-design/issues/51912
        maxWidth: `calc(100% - ${unit(token2.marginSM)})`
      },
      // https://github.com/ant-design/ant-design/issues/48159
      [`${token2.iconCls} + ${confirmComponentCls}-paragraph`]: {
        maxWidth: `calc(100% - ${unit(token2.calc(token2.modalConfirmIconSize).add(token2.marginSM).equal())})`
      },
      [`${confirmComponentCls}-title`]: {
        color: token2.colorTextHeading,
        fontWeight: token2.fontWeightStrong,
        fontSize: titleFontSize,
        lineHeight: titleLineHeight
      },
      [`${confirmComponentCls}-container`]: {
        color: token2.colorText,
        fontSize,
        lineHeight
      },
      // ===================== Footer =====================
      [`${confirmComponentCls}-btns`]: {
        textAlign: "end",
        marginTop: token2.confirmBtnsMarginTop,
        [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorError
    },
    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorWarning
    },
    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorInfo
    },
    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorSuccess
    }
  };
};
var confirm_default = genSubStyleComponent(["Modal", "confirm"], (token2) => {
  const modalToken = prepareToken2(token2);
  return genModalConfirmStyle(modalToken);
}, prepareComponentToken8, {
  // confirm is weak than modal since no conflict here
  order: -1e3
});

// node_modules/antd/es/modal/ConfirmDialog.js
var ConfirmContent = (props) => {
  const {
    prefixCls,
    icon,
    okText,
    cancelText,
    confirmPrefixCls,
    type: type5,
    okCancel,
    footer,
    // Legacy for static function usage
    locale: staticLocale,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Modal");
    true ? warning5(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  let mergedIcon = icon;
  if (!icon && icon !== null) {
    switch (type5) {
      case "info":
        mergedIcon = React135.createElement(InfoCircleFilled_default, null);
        break;
      case "success":
        mergedIcon = React135.createElement(CheckCircleFilled_default, null);
        break;
      case "error":
        mergedIcon = React135.createElement(CloseCircleFilled_default, null);
        break;
      default:
        mergedIcon = React135.createElement(ExclamationCircleFilled_default, null);
    }
  }
  const mergedOkCancel = okCancel ?? type5 === "confirm";
  const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
  const [locale6] = useLocale_default("Modal");
  const mergedLocale = staticLocale || locale6;
  const okTextLocale = okText || (mergedOkCancel ? mergedLocale == null ? void 0 : mergedLocale.okText : mergedLocale == null ? void 0 : mergedLocale.justOkText);
  const cancelTextLocale = cancelText || (mergedLocale == null ? void 0 : mergedLocale.cancelText);
  const {
    closable
  } = restProps;
  const {
    onClose
  } = closable && typeof closable === "object" ? closable : {};
  const memoizedValue = React135.useMemo(() => {
    return {
      autoFocusButton,
      cancelTextLocale,
      okTextLocale,
      mergedOkCancel,
      onClose,
      ...restProps
    };
  }, [autoFocusButton, cancelTextLocale, okTextLocale, mergedOkCancel, onClose, restProps]);
  const footerOriginNode = React135.createElement(React135.Fragment, null, React135.createElement(ConfirmCancelBtn_default, null), React135.createElement(ConfirmOkBtn_default, null));
  const hasTitle = props.title !== void 0 && props.title !== null;
  const bodyCls = `${confirmPrefixCls}-body`;
  return React135.createElement("div", {
    className: `${confirmPrefixCls}-body-wrapper`
  }, React135.createElement("div", {
    className: clsx(bodyCls, {
      [`${bodyCls}-has-title`]: hasTitle
    })
  }, mergedIcon, React135.createElement("div", {
    className: `${confirmPrefixCls}-paragraph`
  }, hasTitle && React135.createElement("span", {
    className: `${confirmPrefixCls}-title`
  }, props.title), React135.createElement("div", {
    className: `${confirmPrefixCls}-content`
  }, props.content))), footer === void 0 || typeof footer === "function" ? React135.createElement(ModalContextProvider, {
    value: memoizedValue
  }, React135.createElement("div", {
    className: `${confirmPrefixCls}-btns`
  }, typeof footer === "function" ? footer(footerOriginNode, {
    OkBtn: ConfirmOkBtn_default,
    CancelBtn: ConfirmCancelBtn_default
  }) : footerOriginNode)) : footer, React135.createElement(confirm_default, {
    prefixCls
  }));
};
var ConfirmDialog = (props) => {
  const {
    close,
    zIndex,
    maskStyle,
    direction,
    prefixCls,
    wrapClassName,
    rootPrefixCls,
    bodyStyle,
    closable = false,
    onConfirm,
    styles,
    title,
    okButtonProps,
    cancelButtonProps
  } = props;
  const {
    cancelButtonProps: contextCancelButtonProps,
    okButtonProps: contextOkButtonProps
  } = useComponentConfig("modal");
  if (true) {
    const warning5 = devUseWarning("Modal");
    [["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const confirmPrefixCls = `${prefixCls}-confirm`;
  const width = props.width || 416;
  const style2 = props.style || {};
  const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
  const classString = clsx(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
    [`${confirmPrefixCls}-rtl`]: direction === "rtl"
  }, props.className);
  const [, token2] = useToken();
  const mergedZIndex = React135.useMemo(() => {
    if (zIndex !== void 0) {
      return zIndex;
    }
    return token2.zIndexPopupBase + CONTAINER_MAX_OFFSET;
  }, [zIndex, token2]);
  return React135.createElement(Modal_default, {
    ...props,
    className: classString,
    wrapClassName: clsx({
      [`${confirmPrefixCls}-centered`]: !!props.centered
    }, wrapClassName),
    onCancel: () => {
      close == null ? void 0 : close({
        triggerCancel: true
      });
      onConfirm == null ? void 0 : onConfirm(false);
    },
    title,
    footer: null,
    transitionName: getTransitionName2(rootPrefixCls || "", "zoom", props.transitionName),
    maskTransitionName: getTransitionName2(rootPrefixCls || "", "fade", props.maskTransitionName),
    maskClosable,
    style: style2,
    styles: {
      body: bodyStyle,
      mask: maskStyle,
      ...styles
    },
    width,
    zIndex: mergedZIndex,
    closable
  }, React135.createElement(ConfirmContent, {
    ...props,
    confirmPrefixCls,
    okButtonProps: {
      ...contextOkButtonProps,
      ...okButtonProps
    },
    cancelButtonProps: {
      ...contextCancelButtonProps,
      ...cancelButtonProps
    }
  }));
};
var ConfirmDialogWrapper = (props) => {
  const {
    rootPrefixCls,
    iconPrefixCls,
    direction,
    theme
  } = props;
  return React135.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls,
    direction,
    theme
  }, React135.createElement(ConfirmDialog, {
    ...props
  }));
};
if (true) {
  ConfirmDialog.displayName = "ConfirmDialog";
  ConfirmDialogWrapper.displayName = "ConfirmDialogWrapper";
}
var ConfirmDialog_default = ConfirmDialogWrapper;

// node_modules/antd/es/modal/destroyFns.js
var destroyFns = [];
var destroyFns_default = destroyFns;

// node_modules/antd/es/modal/confirm.js
var defaultRootPrefixCls = "";
function getRootPrefixCls() {
  return defaultRootPrefixCls;
}
var ConfirmDialogWrapper2 = (props) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    getContainer,
    direction
  } = props;
  const runtimeLocale2 = getConfirmLocale();
  const config = (0, import_react68.useContext)(ConfigContext);
  const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
  const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
  let mergedGetContainer = getContainer;
  if (mergedGetContainer === false) {
    mergedGetContainer = void 0;
    if (true) {
      true ? warning_default2(false, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.") : void 0;
    }
  }
  return import_react68.default.createElement(ConfirmDialog_default, {
    ...props,
    rootPrefixCls,
    prefixCls,
    iconPrefixCls: config.iconPrefixCls,
    theme: config.theme,
    direction: direction ?? config.direction,
    locale: ((_a = config.locale) == null ? void 0 : _a.Modal) ?? runtimeLocale2,
    getContainer: mergedGetContainer
  });
};
function confirm(config) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("Modal");
  }
  const container = document.createDocumentFragment();
  let currentConfig = {
    ...config,
    close,
    open: true
  };
  let timeoutId;
  function destroy3(...args) {
    var _a;
    const triggerCancel = args.some((param) => param == null ? void 0 : param.triggerCancel);
    if (triggerCancel) {
      (_a = config.onCancel) == null ? void 0 : _a.call(config, () => {
      }, ...args.slice(1));
    }
    for (let i = 0; i < destroyFns_default.length; i++) {
      const fn = destroyFns_default[i];
      if (fn === close) {
        destroyFns_default.splice(i, 1);
        break;
      }
    }
    unmount(container).then(() => {
    });
  }
  const scheduleRender = (props) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      const rootPrefixCls = global.getPrefixCls(void 0, getRootPrefixCls());
      const iconPrefixCls = global.getIconPrefixCls();
      const theme = global.getTheme();
      const dom = import_react68.default.createElement(ConfirmDialogWrapper2, {
        ...props
      });
      render(import_react68.default.createElement(config_provider_default, {
        prefixCls: rootPrefixCls,
        iconPrefixCls,
        theme
      }, typeof global.holderRender === "function" ? global.holderRender(dom) : dom), container);
    });
  };
  function close(...args) {
    currentConfig = {
      ...currentConfig,
      open: false,
      afterClose: () => {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy3.apply(this, args);
      }
    };
    scheduleRender(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = {
        ...currentConfig,
        ...configUpdate
      };
    }
    scheduleRender(currentConfig);
  }
  scheduleRender(currentConfig);
  destroyFns_default.push(close);
  return {
    destroy: close,
    update
  };
}
function withWarn(props) {
  return {
    ...props,
    type: "warning"
  };
}
function withInfo(props) {
  return {
    ...props,
    type: "info"
  };
}
function withSuccess(props) {
  return {
    ...props,
    type: "success"
  };
}
function withError(props) {
  return {
    ...props,
    type: "error"
  };
}
function withConfirm(props) {
  return {
    ...props,
    type: "confirm"
  };
}
function modalGlobalConfig({
  rootPrefixCls
}) {
  true ? warning_default2(false, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead.") : void 0;
  defaultRootPrefixCls = rootPrefixCls;
}

// node_modules/antd/es/modal/useModal/HookModal.js
var React137 = __toESM(require_react());
var HookModal = ({
  afterClose: hookAfterClose,
  config,
  ...restProps
}, ref) => {
  const [open3, setOpen] = React137.useState(true);
  const [innerConfig, setInnerConfig] = React137.useState(config);
  const {
    direction,
    getPrefixCls
  } = React137.useContext(ConfigContext);
  const prefixCls = getPrefixCls("modal");
  const rootPrefixCls = getPrefixCls();
  const afterClose = () => {
    var _a;
    hookAfterClose();
    (_a = innerConfig.afterClose) == null ? void 0 : _a.call(innerConfig);
  };
  const close = (...args) => {
    var _a;
    setOpen(false);
    const triggerCancel = args.some((param) => param == null ? void 0 : param.triggerCancel);
    if (triggerCancel) {
      (_a = innerConfig.onCancel) == null ? void 0 : _a.call(innerConfig, () => {
      }, ...args.slice(1));
    }
  };
  React137.useImperativeHandle(ref, () => ({
    destroy: close,
    update: (newConfig) => {
      setInnerConfig((originConfig) => {
        const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
        return {
          ...originConfig,
          ...nextConfig
        };
      });
    }
  }));
  const mergedOkCancel = innerConfig.okCancel ?? innerConfig.type === "confirm";
  const [contextLocale] = useLocale_default("Modal", en_US_default6.Modal);
  return React137.createElement(ConfirmDialog_default, {
    prefixCls,
    rootPrefixCls,
    ...innerConfig,
    close,
    open: open3,
    afterClose,
    okText: innerConfig.okText || (mergedOkCancel ? contextLocale == null ? void 0 : contextLocale.okText : contextLocale == null ? void 0 : contextLocale.justOkText),
    direction: innerConfig.direction || direction,
    cancelText: innerConfig.cancelText || (contextLocale == null ? void 0 : contextLocale.cancelText),
    ...restProps
  });
};
var HookModal_default = React137.forwardRef(HookModal);

// node_modules/antd/es/modal/useModal/index.js
var uuid4 = 0;
var ElementsHolder = React138.memo(React138.forwardRef((_props, ref) => {
  const [elements, patchElement] = usePatchElement();
  React138.useImperativeHandle(ref, () => ({
    patchElement
  }), [patchElement]);
  return React138.createElement(React138.Fragment, null, elements);
}));
function useModal() {
  const holderRef = React138.useRef(null);
  const [actionQueue, setActionQueue] = React138.useState([]);
  React138.useEffect(() => {
    if (actionQueue.length) {
      const cloneQueue = _toConsumableArray(actionQueue);
      cloneQueue.forEach((action) => {
        action();
      });
      setActionQueue([]);
    }
  }, [actionQueue]);
  const getConfirmFunc = React138.useCallback((withFunc) => function hookConfirm(config) {
    var _a;
    uuid4 += 1;
    const modalRef = React138.createRef();
    let resolvePromise;
    const promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    let silent = false;
    let closeFunc;
    const modal = React138.createElement(HookModal_default, {
      key: `modal-${uuid4}`,
      config: withFunc(config),
      ref: modalRef,
      afterClose: () => {
        closeFunc == null ? void 0 : closeFunc();
      },
      isSilent: () => silent,
      onConfirm: (confirmed) => {
        resolvePromise(confirmed);
      }
    });
    closeFunc = (_a = holderRef.current) == null ? void 0 : _a.patchElement(modal);
    if (closeFunc) {
      destroyFns_default.push(closeFunc);
    }
    const instance = {
      destroy: () => {
        function destroyAction() {
          var _a2;
          (_a2 = modalRef.current) == null ? void 0 : _a2.destroy();
        }
        if (modalRef.current) {
          destroyAction();
        } else {
          setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
        }
      },
      update: (newConfig) => {
        function updateAction() {
          var _a2;
          (_a2 = modalRef.current) == null ? void 0 : _a2.update(newConfig);
        }
        if (modalRef.current) {
          updateAction();
        } else {
          setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
        }
      },
      then: (resolve) => {
        silent = true;
        return promise.then(resolve);
      }
    };
    return instance;
  }, []);
  const fns = React138.useMemo(() => ({
    info: getConfirmFunc(withInfo),
    success: getConfirmFunc(withSuccess),
    error: getConfirmFunc(withError),
    warning: getConfirmFunc(withWarn),
    confirm: getConfirmFunc(withConfirm)
  }), [getConfirmFunc]);
  return [fns, React138.createElement(ElementsHolder, {
    key: "modal-holder",
    ref: holderRef
  })];
}
var useModal_default = useModal;

// node_modules/antd/es/notification/useNotification.js
var import_react69 = __toESM(require_react());

// node_modules/antd/es/notification/PurePanel.js
var React139 = __toESM(require_react());

// node_modules/antd/es/notification/style/placement.js
var genNotificationPlacementStyle = (token2) => {
  const {
    componentCls,
    notificationMarginEdge,
    animationMaxHeight
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const rightFadeIn = new Keyframes_default("antNotificationFadeIn", {
    "0%": {
      transform: `translate3d(100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  const topFadeIn = new Keyframes_default("antNotificationTopFadeIn", {
    "0%": {
      top: -animationMaxHeight,
      opacity: 0
    },
    "100%": {
      top: 0,
      opacity: 1
    }
  });
  const bottomFadeIn = new Keyframes_default("antNotificationBottomFadeIn", {
    "0%": {
      bottom: token2.calc(animationMaxHeight).mul(-1).equal(),
      opacity: 0
    },
    "100%": {
      bottom: 0,
      opacity: 1
    }
  });
  const leftFadeIn = new Keyframes_default("antNotificationLeftFadeIn", {
    "0%": {
      transform: `translate3d(-100%, 0, 0)`,
      opacity: 0
    },
    "100%": {
      transform: `translate3d(0, 0, 0)`,
      opacity: 1
    }
  });
  return {
    [componentCls]: {
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        marginInline: 0,
        [noticeCls]: {
          marginInline: "auto auto"
        }
      },
      [`&${componentCls}-top`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: topFadeIn
        }
      },
      [`&${componentCls}-bottom`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: bottomFadeIn
        }
      },
      [`&${componentCls}-topRight, &${componentCls}-bottomRight`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: rightFadeIn
        }
      },
      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
        marginRight: {
          value: 0,
          _skip_check_: true
        },
        marginLeft: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [noticeCls]: {
          marginInlineEnd: "auto",
          marginInlineStart: 0
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: leftFadeIn
        }
      }
    }
  };
};
var placement_default = genNotificationPlacementStyle;

// node_modules/antd/es/notification/interface.js
var NotificationPlacements = ["top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"];

// node_modules/antd/es/notification/style/stack.js
var placementAlignProperty = {
  topLeft: "left",
  topRight: "right",
  bottomLeft: "left",
  bottomRight: "right",
  top: "left",
  bottom: "left"
};
var genPlacementStackStyle = (token2, placement) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-${placement}`]: {
      [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
        [placement.startsWith("top") ? "top" : "bottom"]: 0,
        [placementAlignProperty[placement]]: {
          value: 0,
          _skip_check_: true
        }
      }
    }
  };
};
var genStackChildrenStyle = (token2) => {
  const childrenStyle = {};
  for (let i = 1; i < token2.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      overflow: "hidden",
      [`& > ${token2.componentCls}-notice`]: {
        opacity: 0,
        transition: `opacity ${token2.motionDurationMid}`
      }
    };
  }
  return {
    [`&:not(:nth-last-child(-n+${token2.notificationStackLayer}))`]: {
      opacity: 0,
      overflow: "hidden",
      color: "transparent",
      pointerEvents: "none"
    },
    ...childrenStyle
  };
};
var genStackedNoticeStyle = (token2) => {
  const childrenStyle = {};
  for (let i = 1; i < token2.notificationStackLayer; i++) {
    childrenStyle[`&:nth-last-child(${i + 1})`] = {
      background: token2.colorBgBlur,
      backdropFilter: "blur(10px)",
      "-webkit-backdrop-filter": "blur(10px)"
    };
  }
  return {
    ...childrenStyle
  };
};
var genStackStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-stack`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        transition: `transform ${token2.motionDurationSlow}, backdrop-filter 0s`,
        willChange: "transform, opacity",
        position: "absolute",
        ...genStackChildrenStyle(token2)
      }
    },
    [`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        ...genStackedNoticeStyle(token2)
      }
    },
    [`${componentCls}-stack${componentCls}-stack-expanded`]: {
      [`& > ${componentCls}-notice-wrapper`]: {
        "&:not(:nth-last-child(-n + 1))": {
          opacity: 1,
          overflow: "unset",
          color: "inherit",
          pointerEvents: "auto",
          [`& > ${token2.componentCls}-notice`]: {
            opacity: 1
          }
        },
        "&:after": {
          content: '""',
          position: "absolute",
          height: token2.margin,
          width: "100%",
          insetInline: 0,
          bottom: token2.calc(token2.margin).mul(-1).equal(),
          background: "transparent",
          pointerEvents: "auto"
        }
      }
    },
    ...NotificationPlacements.map((placement) => genPlacementStackStyle(token2, placement)).reduce((acc, cur) => ({
      ...acc,
      ...cur
    }), {})
  };
};
var stack_default = genStackStyle;

// node_modules/antd/es/notification/style/index.js
var genNoticeStyle = (token2) => {
  const {
    iconCls,
    componentCls,
    // .ant-notification
    boxShadow,
    fontSizeLG,
    notificationMarginBottom,
    borderRadiusLG,
    colorSuccess,
    colorInfo,
    colorWarning,
    colorError,
    colorTextHeading,
    notificationBg,
    notificationPadding,
    notificationMarginEdge,
    progressBg,
    notificationProgressHeight,
    fontSize,
    lineHeight,
    width,
    notificationIconSize,
    colorText,
    colorSuccessBg,
    colorErrorBg,
    colorInfoBg,
    colorWarningBg
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  return {
    position: "relative",
    marginBottom: notificationMarginBottom,
    marginInlineStart: "auto",
    background: notificationBg,
    borderRadius: borderRadiusLG,
    boxShadow,
    [noticeCls]: {
      padding: notificationPadding,
      width,
      maxWidth: `calc(100vw - ${unit(token2.calc(notificationMarginEdge).mul(2).equal())})`,
      lineHeight,
      wordWrap: "break-word",
      borderRadius: borderRadiusLG,
      overflow: "hidden",
      // Type-specific background colors
      "&-success": colorSuccessBg ? {
        background: colorSuccessBg
      } : {},
      "&-error": colorErrorBg ? {
        background: colorErrorBg
      } : {},
      "&-info": colorInfoBg ? {
        background: colorInfoBg
      } : {},
      "&-warning": colorWarningBg ? {
        background: colorWarningBg
      } : {}
    },
    [`${noticeCls}-title`]: {
      marginBottom: token2.marginXS,
      color: colorTextHeading,
      fontSize: fontSizeLG,
      lineHeight: token2.lineHeightLG
    },
    [`${noticeCls}-description`]: {
      fontSize,
      color: colorText,
      marginTop: token2.marginXS
    },
    [`${noticeCls}-closable ${noticeCls}-title`]: {
      paddingInlineEnd: token2.paddingLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-title`]: {
      marginBottom: token2.marginXS,
      marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
      fontSize: fontSizeLG
    },
    [`${noticeCls}-with-icon ${noticeCls}-description`]: {
      marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
      fontSize
    },
    // Icon & color style in different selector level
    // https://github.com/ant-design/ant-design/issues/16503
    // https://github.com/ant-design/ant-design/issues/15512
    [`${noticeCls}-icon`]: {
      position: "absolute",
      fontSize: notificationIconSize,
      lineHeight: 1,
      // icon-font
      [`&-success${iconCls}`]: {
        color: colorSuccess
      },
      [`&-info${iconCls}`]: {
        color: colorInfo
      },
      [`&-warning${iconCls}`]: {
        color: colorWarning
      },
      [`&-error${iconCls}`]: {
        color: colorError
      }
    },
    [`${noticeCls}-close`]: {
      position: "absolute",
      top: token2.notificationPaddingVertical,
      insetInlineEnd: token2.notificationPaddingHorizontal,
      color: token2.colorIcon,
      outline: "none",
      width: token2.notificationCloseButtonSize,
      height: token2.notificationCloseButtonSize,
      borderRadius: token2.borderRadiusSM,
      transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "none",
      border: "none",
      "&:hover": {
        color: token2.colorIconHover,
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      },
      ...genFocusStyle(token2)
    },
    [`${noticeCls}-progress`]: {
      position: "absolute",
      display: "block",
      appearance: "none",
      inlineSize: `calc(100% - ${unit(borderRadiusLG)} * 2)`,
      left: {
        _skip_check_: true,
        value: borderRadiusLG
      },
      right: {
        _skip_check_: true,
        value: borderRadiusLG
      },
      bottom: 0,
      blockSize: notificationProgressHeight,
      border: 0,
      "&, &::-webkit-progress-bar": {
        borderRadius: borderRadiusLG,
        backgroundColor: `rgba(0, 0, 0, 0.04)`
      },
      "&::-moz-progress-bar": {
        background: progressBg
      },
      "&::-webkit-progress-value": {
        borderRadius: borderRadiusLG,
        background: progressBg
      }
    },
    [`${noticeCls}-actions`]: {
      float: "right",
      marginTop: token2.marginSM
    }
  };
};
var genNotificationStyle = (token2) => {
  const {
    componentCls,
    // .ant-notification
    notificationMarginBottom,
    notificationMarginEdge,
    motionDurationMid,
    motionEaseInOut
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const fadeOut2 = new Keyframes_default("antNotificationFadeOut", {
    "0%": {
      maxHeight: token2.animationMaxHeight,
      marginBottom: notificationMarginBottom
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "fixed",
        zIndex: token2.zIndexPopup,
        marginRight: {
          value: notificationMarginEdge,
          _skip_check_: true
        },
        [`${componentCls}-hook-holder`]: {
          position: "relative"
        },
        //  animation
        [`${componentCls}-fade-appear-prepare`]: {
          opacity: "0 !important"
        },
        [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-leave`]: {
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          animationDuration: motionDurationMid,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationPlayState: "running"
        },
        [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
          animationName: fadeOut2,
          animationPlayState: "running"
        },
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${noticeCls}-actions`]: {
            float: "left"
          }
        }
      }
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: genNoticeStyle(token2)
      }
    }
  ];
};
var prepareComponentToken9 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
  width: 384,
  progressBg: `linear-gradient(90deg, ${token2.colorPrimaryBorderHover}, ${token2.colorPrimary})`,
  colorSuccessBg: token2.colorSuccessBg,
  colorErrorBg: token2.colorErrorBg,
  colorInfoBg: token2.colorInfoBg,
  colorWarningBg: token2.colorWarningBg
});
var prepareNotificationToken = (token2) => {
  const notificationPaddingVertical = token2.paddingMD;
  const notificationPaddingHorizontal = token2.paddingLG;
  const notificationToken = merge2(token2, {
    notificationBg: token2.colorBgElevated,
    notificationPaddingVertical,
    notificationPaddingHorizontal,
    notificationIconSize: token2.calc(token2.fontSizeLG).mul(token2.lineHeightLG).equal(),
    notificationCloseButtonSize: token2.calc(token2.controlHeightLG).mul(0.55).equal(),
    notificationMarginBottom: token2.margin,
    notificationPadding: `${unit(token2.paddingMD)} ${unit(token2.paddingContentHorizontalLG)}`,
    notificationMarginEdge: token2.marginLG,
    animationMaxHeight: 150,
    notificationStackLayer: 3,
    notificationProgressHeight: 2
  });
  return notificationToken;
};
var style_default10 = genStyleHooks("Notification", (token2) => {
  const notificationToken = prepareNotificationToken(token2);
  return [genNotificationStyle(notificationToken), placement_default(notificationToken), stack_default(notificationToken)];
}, prepareComponentToken9);

// node_modules/antd/es/notification/style/pure-panel.js
var pure_panel_default = genSubStyleComponent(["Notification", "PurePanel"], (token2) => {
  const noticeCls = `${token2.componentCls}-notice`;
  const notificationToken = prepareNotificationToken(token2);
  return {
    [`${noticeCls}-pure-panel`]: {
      ...genNoticeStyle(notificationToken),
      width: notificationToken.width,
      maxWidth: `calc(100vw - ${unit(token2.calc(notificationToken.notificationMarginEdge).mul(2).equal())})`,
      margin: 0
    }
  };
}, prepareComponentToken9);

// node_modules/antd/es/notification/PurePanel.js
var TypeIcon2 = {
  info: React139.createElement(InfoCircleFilled_default, null),
  success: React139.createElement(CheckCircleFilled_default, null),
  error: React139.createElement(CloseCircleFilled_default, null),
  warning: React139.createElement(ExclamationCircleFilled_default, null),
  loading: React139.createElement(LoadingOutlined_default, null)
};
function getCloseIcon(prefixCls, closeIcon) {
  if (closeIcon === null || closeIcon === false) {
    return null;
  }
  return closeIcon || React139.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  });
}
var typeToIcon = {
  success: CheckCircleFilled_default,
  info: InfoCircleFilled_default,
  error: CloseCircleFilled_default,
  warning: ExclamationCircleFilled_default
};
var PureContent2 = (props) => {
  const {
    prefixCls,
    icon,
    type: type5,
    title,
    description,
    actions,
    role = "alert",
    styles,
    classNames: pureContentCls
  } = props;
  let iconNode = null;
  if (icon) {
    iconNode = React139.createElement("span", {
      className: clsx(`${prefixCls}-icon`, pureContentCls.icon),
      style: styles.icon
    }, icon);
  } else if (type5) {
    iconNode = React139.createElement(typeToIcon[type5] || null, {
      className: clsx(`${prefixCls}-icon`, pureContentCls.icon, `${prefixCls}-icon-${type5}`),
      style: styles.icon
    });
  }
  return React139.createElement("div", {
    className: clsx({
      [`${prefixCls}-with-icon`]: iconNode
    }),
    role
  }, iconNode, React139.createElement("div", {
    className: clsx(`${prefixCls}-title`, pureContentCls.title),
    style: styles.title
  }, title), description && React139.createElement("div", {
    className: clsx(`${prefixCls}-description`, pureContentCls.description),
    style: styles.description
  }, description), actions && React139.createElement("div", {
    className: clsx(`${prefixCls}-actions`, pureContentCls.actions),
    style: styles.actions
  }, actions));
};
var PurePanel2 = (props) => {
  const {
    prefixCls: staticPrefixCls,
    icon,
    type: type5,
    message: message2,
    title,
    description,
    btn,
    actions,
    closeIcon: _closeIcon,
    className: notificationClassName,
    style: style2,
    styles,
    classNames: notificationClassNames,
    closable,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("notification");
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, notificationClassNames], [contextStyles, styles], {
    props
  });
  const {
    notification: notificationContext
  } = React139.useContext(ConfigContext);
  const mergedActions = actions ?? btn;
  if (true) {
    const warning5 = devUseWarning("Notification");
    [["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const mergedTitle = title ?? message2;
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const noticePrefixCls = `${prefixCls}-notice`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default10(prefixCls, rootCls);
  const [rawClosable, mergedCloseIcon, , ariaProps] = useClosable(pickClosable(props), pickClosable(notificationContext), {
    closable: true,
    closeIcon: React139.createElement(CloseOutlined_default, {
      className: `${prefixCls}-close-icon`
    }),
    closeIconRender: (icon2) => getCloseIcon(prefixCls, icon2)
  });
  const mergedClosable = rawClosable ? {
    onClose: closable && typeof closable === "object" ? closable == null ? void 0 : closable.onClose : void 0,
    closeIcon: mergedCloseIcon,
    ...ariaProps
  } : false;
  return React139.createElement("div", {
    className: clsx(`${noticePrefixCls}-pure-panel`, hashId, notificationClassName, cssVarCls, rootCls, mergedClassNames.root),
    style: mergedStyles.root
  }, React139.createElement(pure_panel_default, {
    prefixCls
  }), React139.createElement(Notice_default, {
    style: {
      ...contextStyle,
      ...style2
    },
    ...restProps,
    prefixCls,
    eventKey: "pure",
    duration: null,
    closable: mergedClosable,
    className: clsx(notificationClassName, contextClassName),
    content: React139.createElement(PureContent2, {
      classNames: mergedClassNames,
      styles: mergedStyles,
      prefixCls: noticePrefixCls,
      icon,
      type: type5,
      title: mergedTitle,
      description,
      actions: mergedActions
    })
  }));
};
var PurePanel_default2 = PurePanel2;

// node_modules/antd/es/notification/util.js
function getPlacementStyle(placement, top, bottom) {
  let style2;
  switch (placement) {
    case "top":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style2 = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style2 = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
function getMotion2(prefixCls) {
  return {
    motionName: `${prefixCls}-fade`
  };
}
function getCloseIconConfig(closeIcon, notificationConfig, notification2) {
  if (typeof closeIcon !== "undefined") {
    return closeIcon;
  }
  if (typeof (notificationConfig == null ? void 0 : notificationConfig.closeIcon) !== "undefined") {
    return notificationConfig.closeIcon;
  }
  return notification2 == null ? void 0 : notification2.closeIcon;
}

// node_modules/antd/es/notification/useNotification.js
var DEFAULT_OFFSET3 = 24;
var DEFAULT_DURATION2 = 4.5;
var DEFAULT_PLACEMENT = "topRight";
var Wrapper2 = ({
  children,
  prefixCls
}) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default10(prefixCls, rootCls);
  return import_react69.default.createElement(NotificationProvider_default, {
    classNames: {
      list: clsx(hashId, cssVarCls, rootCls)
    }
  }, children);
};
var renderNotifications2 = (node2, {
  prefixCls,
  key
}) => import_react69.default.createElement(Wrapper2, {
  prefixCls,
  key
}, node2);
var Holder2 = import_react69.default.forwardRef((props, ref) => {
  const {
    top,
    bottom,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    rtl,
    onAllRemoved,
    stack,
    duration = DEFAULT_DURATION2,
    pauseOnHover = true,
    showProgress
  } = props;
  const {
    getPrefixCls,
    getPopupContainer,
    direction
  } = useComponentConfig("notification");
  const {
    notification: notification2
  } = (0, import_react69.useContext)(ConfigContext);
  const [, token2] = useToken();
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const mergedDuration = (0, import_react69.useMemo)(() => typeof duration === "number" && duration > 0 ? duration : false, [duration]);
  const getStyle3 = (placement) => getPlacementStyle(placement, top ?? DEFAULT_OFFSET3, bottom ?? DEFAULT_OFFSET3);
  const getClassName = () => clsx({
    [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
  });
  const getNotificationMotion = () => getMotion2(prefixCls);
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle3,
    className: getClassName,
    motion: getNotificationMotion,
    closable: {
      closeIcon: getCloseIcon(prefixCls)
    },
    duration: mergedDuration,
    getContainer: () => (staticGetContainer == null ? void 0 : staticGetContainer()) || (getPopupContainer == null ? void 0 : getPopupContainer()) || document.body,
    maxCount,
    pauseOnHover,
    showProgress,
    onAllRemoved,
    renderNotifications: renderNotifications2,
    stack: stack === false ? false : {
      threshold: typeof stack === "object" ? stack == null ? void 0 : stack.threshold : void 0,
      offset: 8,
      gap: token2.margin
    }
  });
  const [mergedClassNames, mergedStyles] = useMergeSemantic([notification2 == null ? void 0 : notification2.classNames, props == null ? void 0 : props.classNames], [notification2 == null ? void 0 : notification2.styles, props == null ? void 0 : props.styles], {
    props
  });
  import_react69.default.useImperativeHandle(ref, () => ({
    ...api,
    prefixCls,
    notification: notification2,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  return holder;
});
function useInternalNotification(notificationConfig) {
  const holderRef = import_react69.default.useRef(null);
  const warning5 = devUseWarning("Notification");
  const {
    notification: notificationContext
  } = import_react69.default.useContext(ConfigContext);
  const wrapAPI = import_react69.default.useMemo(() => {
    const open3 = (config) => {
      if (!holderRef.current) {
        true ? warning5(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
        return;
      }
      const {
        open: originOpen,
        prefixCls,
        notification: notification2,
        classNames: originClassNames,
        styles: originStyles
      } = holderRef.current;
      const contextClassName = (notification2 == null ? void 0 : notification2.className) || {};
      const contextStyle = (notification2 == null ? void 0 : notification2.style) || {};
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        title,
        message: message2,
        description,
        icon,
        type: type5,
        btn,
        actions,
        className,
        style: style2,
        role = "alert",
        closeIcon,
        closable,
        classNames: configClassNames = {},
        styles = {},
        ...restConfig
      } = config;
      if (true) {
        [["btn", "actions"], ["message", "title"]].forEach(([deprecatedName, newName]) => {
          warning5.deprecated(!(deprecatedName in config), deprecatedName, newName);
        });
      }
      const mergedTitle = title ?? message2;
      const mergedActions = actions ?? btn;
      const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification2));
      const [rawClosable, mergedCloseIcon, , ariaProps] = computeClosable(pickClosable({
        ...notificationConfig || {},
        ...config
      }), pickClosable(notificationContext), {
        closable: true,
        closeIcon: realCloseIcon
      });
      const mergedClosable = rawClosable ? {
        onClose: closable && typeof closable === "object" ? closable.onClose : void 0,
        closeIcon: mergedCloseIcon,
        ...ariaProps
      } : false;
      const semanticClassNames = resolveStyleOrClass(configClassNames, {
        props: config
      });
      const semanticStyles = resolveStyleOrClass(styles, {
        props: config
      });
      const mergedClassNames = mergeClassNames(void 0, originClassNames, semanticClassNames);
      const mergedStyles = mergeStyles(originStyles, semanticStyles);
      return originOpen({
        // use placement from props instead of hard-coding "topRight"
        placement: (notificationConfig == null ? void 0 : notificationConfig.placement) ?? DEFAULT_PLACEMENT,
        ...restConfig,
        content: import_react69.default.createElement(PureContent2, {
          prefixCls: noticePrefixCls,
          icon,
          type: type5,
          title: mergedTitle,
          description,
          actions: mergedActions,
          role,
          classNames: mergedClassNames,
          styles: mergedStyles
        }),
        className: clsx({
          [`${noticePrefixCls}-${type5}`]: type5
        }, className, contextClassName, mergedClassNames.root),
        style: {
          ...contextStyle,
          ...mergedStyles.root,
          ...style2
        },
        closable: mergedClosable
      });
    };
    const destroy3 = (key) => {
      var _a, _b;
      if (key !== void 0) {
        (_a = holderRef.current) == null ? void 0 : _a.close(key);
      } else {
        (_b = holderRef.current) == null ? void 0 : _b.destroy();
      }
    };
    const clone = {
      open: open3,
      destroy: destroy3
    };
    const keys2 = ["success", "info", "warning", "error"];
    keys2.forEach((type5) => {
      clone[type5] = (config) => open3({
        ...config,
        type: type5
      });
    });
    return clone;
  }, [notificationConfig, notificationContext]);
  return [wrapAPI, import_react69.default.createElement(Holder2, {
    key: "notification-holder",
    ...notificationConfig,
    ref: holderRef
  })];
}
function useNotification2(notificationConfig) {
  return useInternalNotification(notificationConfig);
}

// node_modules/antd/es/app/context.js
var import_react70 = __toESM(require_react());
var AppConfigContext = import_react70.default.createContext({});
var AppContext = import_react70.default.createContext({
  message: {},
  notification: {},
  modal: {}
});
var context_default5 = AppContext;

// node_modules/antd/es/app/style/index.js
var genBaseStyle4 = (token2) => {
  const {
    componentCls,
    colorText,
    fontSize,
    lineHeight,
    fontFamily
  } = token2;
  return {
    [componentCls]: {
      color: colorText,
      fontSize,
      lineHeight,
      fontFamily,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken10 = () => ({});
var style_default11 = genStyleHooks("App", genBaseStyle4, prepareComponentToken10);

// node_modules/antd/es/app/App.js
var App = (props) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    className,
    rootClassName,
    message: message2,
    notification: notification2,
    style: style2,
    component = "div"
  } = props;
  const {
    direction,
    getPrefixCls
  } = (0, import_react71.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("app", customizePrefixCls);
  const [hashId, cssVarCls] = style_default11(prefixCls);
  const customClassName = clsx(hashId, prefixCls, className, rootClassName, cssVarCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const appConfig = (0, import_react71.useContext)(AppConfigContext);
  const mergedAppConfig = import_react71.default.useMemo(() => ({
    message: {
      ...appConfig.message,
      ...message2
    },
    notification: {
      ...appConfig.notification,
      ...notification2
    }
  }), [message2, notification2, appConfig.message, appConfig.notification]);
  const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
  const [notificationApi, notificationContextHolder] = useNotification2(mergedAppConfig.notification);
  const [ModalApi, ModalContextHolder] = useModal_default();
  const memoizedContextValue = import_react71.default.useMemo(() => ({
    message: messageApi,
    notification: notificationApi,
    modal: ModalApi
  }), [messageApi, notificationApi, ModalApi]);
  devUseWarning("App")(!(cssVarCls && component === false), "usage", "When using cssVar, ensure `component` is assigned a valid React component string.");
  const Component8 = component === false ? import_react71.default.Fragment : component;
  const rootProps = {
    className: customClassName,
    style: style2
  };
  return import_react71.default.createElement(context_default5.Provider, {
    value: memoizedContextValue
  }, import_react71.default.createElement(AppConfigContext.Provider, {
    value: mergedAppConfig
  }, import_react71.default.createElement(Component8, {
    ...component === false ? void 0 : rootProps
  }, ModalContextHolder, messageContextHolder, notificationContextHolder, children)));
};
if (true) {
  App.displayName = "App";
}
var App_default = App;

// node_modules/antd/es/app/useApp.js
var import_react72 = __toESM(require_react());
var useApp = () => import_react72.default.useContext(context_default5);
var useApp_default = useApp;

// node_modules/antd/es/app/index.js
var App2 = App_default;
App2.useApp = useApp_default;
var app_default = App2;

// node_modules/antd/es/_util/PurePanel.js
var React144 = __toESM(require_react());
function withPureRenderTheme(Component8) {
  return (props) => React144.createElement(config_provider_default, {
    theme: {
      token: {
        motion: false,
        zIndexPopupBase: 0
      }
    }
  }, React144.createElement(Component8, {
    ...props
  }));
}
var genPurePanel = (Component8, alignPropName, postProps, defaultPrefixCls2, getDropdownCls) => {
  const PurePanel19 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2
    } = props;
    const holderRef = React144.useRef(null);
    const [popupHeight, setPopupHeight] = React144.useState(0);
    const [popupWidth, setPopupWidth] = React144.useState(0);
    const [open3, setOpen] = useControlledState(false, props.open);
    const {
      getPrefixCls
    } = React144.useContext(ConfigContext);
    const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
    React144.useEffect(() => {
      setOpen(true);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver = new ResizeObserver((entries) => {
          const element = entries[0].target;
          setPopupHeight(element.offsetHeight + 8);
          setPopupWidth(element.offsetWidth);
        });
        const interval = setInterval(() => {
          var _a;
          const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
          const popup = (_a = holderRef.current) == null ? void 0 : _a.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver.observe(popup);
          }
        }, 10);
        return () => {
          clearInterval(interval);
          resizeObserver.disconnect();
        };
      }
    }, [prefixCls]);
    let mergedProps = {
      ...props,
      style: {
        ...style2,
        margin: 0
      },
      open: open3,
      getPopupContainer: () => holderRef.current
    };
    if (postProps) {
      mergedProps = postProps(mergedProps);
    }
    if (alignPropName) {
      Object.assign(mergedProps, {
        [alignPropName]: {
          overflow: {
            adjustX: false,
            adjustY: false
          }
        }
      });
    }
    const mergedStyle = {
      paddingBottom: popupHeight,
      position: "relative",
      minWidth: popupWidth
    };
    return React144.createElement("div", {
      ref: holderRef,
      style: mergedStyle
    }, React144.createElement(Component8, {
      ...mergedProps
    }));
  };
  return withPureRenderTheme(PurePanel19);
};
var PurePanel_default3 = genPurePanel;

// node_modules/antd/es/select/index.js
var React193 = __toESM(require_react());

// node_modules/@rc-component/select/es/Select.js
var React185 = __toESM(require_react());

// node_modules/@rc-component/select/es/BaseSelect/index.js
var React166 = __toESM(require_react());

// node_modules/@rc-component/select/es/hooks/useAllowClear.js
var import_react73 = __toESM(require_react());
var useAllowClear = (prefixCls, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode) => {
  const allowClearConfig = (0, import_react73.useMemo)(() => {
    if (typeof allowClear === "boolean") {
      return {
        allowClear
      };
    }
    if (allowClear && typeof allowClear === "object") {
      return allowClear;
    }
    return {
      allowClear: false
    };
  }, [allowClear]);
  return (0, import_react73.useMemo)(() => {
    const mergedAllowClear = !disabled && allowClearConfig.allowClear !== false && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "");
    return {
      allowClear: mergedAllowClear,
      clearIcon: mergedAllowClear ? allowClearConfig.clearIcon || clearIcon || "" : null
    };
  }, [allowClearConfig, clearIcon, disabled, displayValues.length, mergedSearchValue, mode]);
};

// node_modules/@rc-component/select/es/hooks/useBaseProps.js
var React145 = __toESM(require_react());
var BaseSelectContext = React145.createContext(null);
function useBaseProps() {
  return React145.useContext(BaseSelectContext);
}

// node_modules/@rc-component/select/es/hooks/useLock.js
var React146 = __toESM(require_react());
function useLock(duration = 250) {
  const lockRef = React146.useRef(null);
  const timeoutRef = React146.useRef(null);
  React146.useEffect(() => () => {
    window.clearTimeout(timeoutRef.current);
  }, []);
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(() => {
      lockRef.current = null;
    }, duration);
  }
  return [() => lockRef.current, doLock];
}

// node_modules/@rc-component/select/es/hooks/useSelectTriggerControl.js
var React147 = __toESM(require_react());
function isInside(elements, target) {
  return elements.filter((element) => element).some((element) => element.contains(target) || element === target);
}
function useSelectTriggerControl(elements, open3, triggerOpen, customizedTrigger) {
  const onGlobalMouseDown = useEvent_default((event) => {
    if (customizedTrigger) {
      return;
    }
    let target = event.target;
    if (target.shadowRoot && event.composed) {
      target = event.composedPath()[0] || target;
    }
    if (event._ori_target) {
      target = event._ori_target;
    }
    if (open3 && // Marked by SelectInput mouseDown event
    !isInside(elements(), target)) {
      triggerOpen(false);
    }
  });
  React147.useEffect(() => {
    window.addEventListener("mousedown", onGlobalMouseDown);
    return () => window.removeEventListener("mousedown", onGlobalMouseDown);
  }, [onGlobalMouseDown]);
}

// node_modules/@rc-component/select/es/SelectTrigger.js
var React148 = __toESM(require_react());
function _extends17() {
  _extends17 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends17.apply(this, arguments);
}
var getBuiltInPlacements = (popupMatchSelectWidth) => {
  const adjustX = popupMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
};
var SelectTrigger = (props, ref) => {
  const {
    prefixCls,
    disabled,
    visible,
    children,
    popupElement,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    direction = "ltr",
    placement,
    builtinPlacements,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    getPopupContainer,
    empty: empty2,
    onPopupVisibleChange,
    onPopupMouseEnter,
    onPopupMouseDown,
    onPopupBlur,
    ...restProps
  } = props;
  const popupPrefixCls = `${prefixCls}-dropdown`;
  let popupNode = popupElement;
  if (popupRender) {
    popupNode = popupRender(popupElement);
  }
  const mergedBuiltinPlacements2 = React148.useMemo(() => builtinPlacements || getBuiltInPlacements(popupMatchSelectWidth), [builtinPlacements, popupMatchSelectWidth]);
  const mergedTransitionName = animation ? `${popupPrefixCls}-${animation}` : transitionName;
  const isNumberPopupWidth = typeof popupMatchSelectWidth === "number";
  const stretch = React148.useMemo(() => {
    if (isNumberPopupWidth) {
      return null;
    }
    return popupMatchSelectWidth === false ? "minWidth" : "width";
  }, [popupMatchSelectWidth, isNumberPopupWidth]);
  let mergedPopupStyle = popupStyle;
  if (isNumberPopupWidth) {
    mergedPopupStyle = {
      ...popupStyle,
      width: popupMatchSelectWidth
    };
  }
  const triggerPopupRef = React148.useRef(null);
  React148.useImperativeHandle(ref, () => ({
    getPopupElement: () => {
      var _a;
      return (_a = triggerPopupRef.current) == null ? void 0 : _a.popupElement;
    }
  }));
  return React148.createElement(es_default4, _extends17({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: mergedBuiltinPlacements2,
    prefixCls: popupPrefixCls,
    popupMotion: {
      motionName: mergedTransitionName
    },
    popup: React148.createElement("div", {
      onMouseEnter: onPopupMouseEnter,
      onMouseDown: onPopupMouseDown,
      onBlur: onPopupBlur
    }, popupNode),
    ref: triggerPopupRef,
    stretch,
    popupAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: clsx(popupClassName, {
      [`${popupPrefixCls}-empty`]: empty2
    }),
    popupStyle: mergedPopupStyle,
    onPopupVisibleChange
  }), children);
};
var RefSelectTrigger = React148.forwardRef(SelectTrigger);
if (true) {
  RefSelectTrigger.displayName = "SelectTrigger";
}
var SelectTrigger_default = RefSelectTrigger;

// node_modules/@rc-component/select/es/utils/valueUtil.js
function getKey(data, index2) {
  const {
    key
  } = data;
  let value;
  if ("value" in data) {
    ({
      value
    } = data);
  }
  if (key !== null && key !== void 0) {
    return key;
  }
  if (value !== void 0) {
    return value;
  }
  return `rc-index-key-${index2}`;
}
function isValidCount(value) {
  return typeof value !== "undefined" && !Number.isNaN(value);
}
function fillFieldNames(fieldNames, childrenAsData) {
  const {
    label,
    value,
    options,
    groupLabel
  } = fieldNames || {};
  const mergedLabel = label || (childrenAsData ? "children" : "label");
  return {
    label: mergedLabel,
    value: value || "value",
    options: options || "options",
    groupLabel: groupLabel || mergedLabel
  };
}
function flattenOptions(options, {
  fieldNames,
  childrenAsData
} = {}) {
  const flattenList = [];
  const {
    label: fieldLabel,
    value: fieldValue,
    options: fieldOptions,
    groupLabel
  } = fillFieldNames(fieldNames, false);
  function dig(list, isGroupOption) {
    if (!Array.isArray(list)) {
      return;
    }
    list.forEach((data) => {
      if (isGroupOption || !(fieldOptions in data)) {
        const value = data[fieldValue];
        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label: data[fieldLabel],
          value
        });
      } else {
        let grpLabel = data[groupLabel];
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data.label;
        }
        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  const newOption = {
    ...option
  };
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get() {
        warning_default(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
        return newOption;
      }
    });
  }
  return newOption;
}
var getSeparatedContent = (text, tokens, end) => {
  if (!tokens || !tokens.length) {
    return null;
  }
  let match3 = false;
  const separate = (str, [token2, ...restTokens]) => {
    if (!token2) {
      return [str];
    }
    const list2 = str.split(token2);
    match3 = match3 || list2.length > 1;
    return list2.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);
  };
  const list = separate(text, tokens);
  if (match3) {
    return typeof end !== "undefined" ? list.slice(0, end) : list;
  } else {
    return null;
  }
};

// node_modules/@rc-component/select/es/BaseSelect/Polite.js
var React149 = __toESM(require_react());
function Polite(props) {
  const {
    visible,
    values
  } = props;
  if (!visible) {
    return null;
  }
  const MAX_COUNT = 50;
  return React149.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, `${values.slice(0, MAX_COUNT).map(({
    label,
    value
  }) => ["number", "string"].includes(typeof label) ? label : value).join(", ")}`, values.length > MAX_COUNT ? ", ..." : null);
}

// node_modules/@rc-component/select/es/hooks/useOpen.js
var import_react74 = __toESM(require_react());
var internalMacroTask = (fn) => {
  const channel = new MessageChannel();
  channel.port1.onmessage = fn;
  channel.port2.postMessage(null);
};
var macroTask = (fn, times = 1) => {
  if (times <= 0) {
    fn();
    return;
  }
  internalMacroTask(() => {
    macroTask(fn, times - 1);
  });
};
function useOpen(propOpen, onOpen, postOpen) {
  const [rendered, setRendered] = (0, import_react74.useState)(false);
  (0, import_react74.useEffect)(() => {
    setRendered(true);
  }, []);
  const [stateOpen, internalSetOpen] = useControlledState(false, propOpen);
  const ssrSafeOpen = rendered ? stateOpen : false;
  const mergedOpen = postOpen(ssrSafeOpen);
  const taskIdRef = (0, import_react74.useRef)(0);
  const triggerEvent = useEvent_default((nextOpen) => {
    if (onOpen && mergedOpen !== nextOpen) {
      onOpen(nextOpen);
    }
    internalSetOpen(nextOpen);
  });
  const toggleOpen = useEvent_default((nextOpen, config = {}) => {
    const {
      cancelFun
    } = config;
    taskIdRef.current += 1;
    const id = taskIdRef.current;
    const nextOpenVal = typeof nextOpen === "boolean" ? nextOpen : !mergedOpen;
    function triggerUpdate() {
      if (
        // Always check if id is match
        id === taskIdRef.current && // Check if need to cancel
        !(cancelFun == null ? void 0 : cancelFun())
      ) {
        triggerEvent(nextOpenVal);
      }
    }
    if (nextOpenVal) {
      triggerUpdate();
    } else {
      macroTask(() => {
        triggerUpdate();
      });
    }
  });
  return [mergedOpen, toggleOpen];
}

// node_modules/@rc-component/select/es/SelectInput/index.js
var React164 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Affix.js
var React150 = __toESM(require_react());
function Affix2(props) {
  const {
    children,
    ...restProps
  } = props;
  if (!children) {
    return null;
  }
  return React150.createElement("div", restProps, children);
}

// node_modules/@rc-component/select/es/SelectInput/Content/index.js
var React163 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Content/SingleContent.js
var React155 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/Input.js
var React152 = __toESM(require_react());

// node_modules/@rc-component/select/es/SelectInput/context.js
var React151 = __toESM(require_react());
var SelectInputContext = React151.createContext(null);
function useSelectInputContext() {
  return React151.useContext(SelectInputContext);
}
var context_default6 = SelectInputContext;

// node_modules/@rc-component/select/es/SelectInput/Input.js
var Input = React152.forwardRef((props, ref) => {
  const {
    onChange,
    onKeyDown: onKeyDown2,
    onBlur,
    style: style2,
    syncWidth,
    value,
    className,
    autoComplete,
    ...restProps
  } = props;
  const {
    prefixCls,
    mode,
    onSearch,
    onSearchSubmit,
    onInputBlur,
    autoFocus,
    tokenWithEnter,
    placeholder,
    components: {
      input: InputComponent = "input"
    }
  } = useSelectInputContext();
  const {
    id,
    classNames,
    styles,
    open: open3,
    activeDescendantId,
    role,
    disabled
  } = useBaseProps() || {};
  const inputCls = clsx(`${prefixCls}-input`, classNames == null ? void 0 : classNames.input, className);
  const compositionStatusRef = React152.useRef(false);
  const pastedTextRef = React152.useRef(null);
  const inputRef = React152.useRef(null);
  React152.useImperativeHandle(ref, () => inputRef.current);
  const handleChange = (event) => {
    let {
      value: nextVal
    } = event.target;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      nextVal = nextVal.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    if (onSearch) {
      onSearch(nextVal, true, compositionStatusRef.current);
    }
    onChange == null ? void 0 : onChange(event);
  };
  const handleKeyDown = (event) => {
    const {
      key
    } = event;
    const {
      value: nextVal
    } = event.currentTarget;
    if (key === "Enter" && mode === "tags" && !compositionStatusRef.current && onSearchSubmit) {
      onSearchSubmit(nextVal);
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(event);
  };
  const handleBlur = (event) => {
    onInputBlur == null ? void 0 : onInputBlur();
    onBlur == null ? void 0 : onBlur(event);
  };
  const handleCompositionStart = () => {
    compositionStatusRef.current = true;
  };
  const handleCompositionEnd = (event) => {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      const {
        value: nextVal
      } = event.currentTarget;
      onSearch == null ? void 0 : onSearch(nextVal, true, false);
    }
  };
  const handlePaste = (event) => {
    const {
      clipboardData
    } = event;
    const pastedValue = clipboardData == null ? void 0 : clipboardData.getData("text");
    pastedTextRef.current = pastedValue || "";
  };
  const [widthCssVar, setWidthCssVar] = React152.useState(void 0);
  useLayoutEffect_default(() => {
    const input = inputRef.current;
    if (syncWidth && input) {
      input.style.width = "0px";
      const scrollWidth = input.scrollWidth;
      setWidthCssVar(scrollWidth);
      input.style.width = "";
    }
  }, [syncWidth, value]);
  const sharedInputProps = {
    id,
    type: mode === "combobox" ? "text" : "search",
    ...restProps,
    ref: inputRef,
    style: {
      ...styles == null ? void 0 : styles.input,
      ...style2,
      "--select-input-width": widthCssVar
    },
    autoFocus,
    autoComplete: autoComplete || "off",
    className: inputCls,
    disabled,
    value: value || "",
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur,
    onPaste: handlePaste,
    onCompositionStart: handleCompositionStart,
    onCompositionEnd: handleCompositionEnd,
    // Accessibility attributes
    role: role || "combobox",
    "aria-expanded": open3 || false,
    "aria-haspopup": "listbox",
    "aria-owns": open3 ? `${id}_list` : void 0,
    "aria-autocomplete": "list",
    "aria-controls": open3 ? `${id}_list` : void 0,
    "aria-activedescendant": open3 ? activeDescendantId : void 0
  };
  if (React152.isValidElement(InputComponent)) {
    const existingProps = InputComponent.props || {};
    const mergedProps = {
      placeholder: props.placeholder || placeholder,
      ...sharedInputProps,
      ...existingProps
    };
    Object.keys(existingProps).forEach((key) => {
      const existingValue = existingProps[key];
      if (typeof existingValue === "function") {
        mergedProps[key] = (...args) => {
          var _a;
          existingValue(...args);
          (_a = sharedInputProps[key]) == null ? void 0 : _a.call(sharedInputProps, ...args);
        };
      }
    });
    mergedProps.ref = composeRef(InputComponent.ref, sharedInputProps.ref);
    return React152.cloneElement(InputComponent, mergedProps);
  }
  const Component8 = InputComponent;
  return React152.createElement(Component8, sharedInputProps);
});
var Input_default2 = Input;

// node_modules/@rc-component/select/es/SelectInput/Content/Placeholder.js
var React153 = __toESM(require_react());
function Placeholder(props) {
  const {
    prefixCls,
    placeholder,
    displayValues
  } = useSelectInputContext();
  const {
    classNames,
    styles
  } = useBaseProps();
  const {
    show = true
  } = props;
  if (displayValues.length) {
    return null;
  }
  return React153.createElement("div", {
    className: clsx(`${prefixCls}-placeholder`, classNames == null ? void 0 : classNames.placeholder),
    style: {
      visibility: show ? "visible" : "hidden",
      ...styles == null ? void 0 : styles.placeholder
    }
  }, placeholder);
}

// node_modules/@rc-component/select/es/SelectContext.js
var React154 = __toESM(require_react());
var SelectContext = React154.createContext(null);
var SelectContext_default = SelectContext;

// node_modules/@rc-component/select/es/utils/commonUtil.js
function toArray4(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
function hasValue(value) {
  return value !== void 0 && value !== null;
}
function isComboNoValue(value) {
  return !value && value !== 0;
}
function isTitleType(title) {
  return ["string", "number"].includes(typeof title);
}
function getTitle(item) {
  let title = void 0;
  if (item) {
    if (isTitleType(item.title)) {
      title = item.title.toString();
    } else if (isTitleType(item.label)) {
      title = item.label.toString();
    }
  }
  return title;
}

// node_modules/@rc-component/select/es/SelectInput/Content/SingleContent.js
function _extends18() {
  _extends18 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends18.apply(this, arguments);
}
var SingleContent = React155.forwardRef(({
  inputProps
}, ref) => {
  const {
    prefixCls,
    searchValue,
    activeValue,
    displayValues,
    maxLength,
    mode
  } = useSelectInputContext();
  const {
    triggerOpen,
    title: rootTitle,
    showSearch,
    classNames,
    styles
  } = useBaseProps();
  const selectContext = React155.useContext(SelectContext_default);
  const [inputChanged, setInputChanged] = React155.useState(false);
  const combobox = mode === "combobox";
  const displayValue = displayValues[0];
  const mergedSearchValue = React155.useMemo(() => {
    if (combobox && activeValue && !inputChanged && triggerOpen) {
      return activeValue;
    }
    return showSearch ? searchValue : "";
  }, [combobox, activeValue, inputChanged, triggerOpen, searchValue, showSearch]);
  const optionProps = React155.useMemo(() => {
    let restProps = {
      className: `${prefixCls}-content-value`,
      style: {
        visibility: mergedSearchValue ? "hidden" : "visible"
      }
    };
    if (displayValue && (selectContext == null ? void 0 : selectContext.flattenOptions)) {
      const option = selectContext.flattenOptions.find((opt) => opt.value === displayValue.value);
      if (option == null ? void 0 : option.data) {
        const {
          label,
          value,
          className,
          style: style2,
          key,
          ...rest
        } = option.data;
        restProps = {
          ...restProps,
          ...rest,
          title: getTitle(option.data),
          className: clsx(restProps.className, className),
          style: {
            ...restProps.style,
            ...style2
          }
        };
      }
    }
    if (displayValue && !restProps.title) {
      restProps.title = getTitle(displayValue);
    }
    if (rootTitle !== void 0) {
      restProps.title = rootTitle;
    }
    return restProps;
  }, [displayValue, selectContext == null ? void 0 : selectContext.flattenOptions, prefixCls, mergedSearchValue, rootTitle]);
  React155.useEffect(() => {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  return React155.createElement("div", {
    className: clsx(`${prefixCls}-content`, classNames == null ? void 0 : classNames.content),
    style: styles == null ? void 0 : styles.content
  }, displayValue ? React155.createElement("div", optionProps, displayValue.label) : React155.createElement(Placeholder, {
    show: !mergedSearchValue
  }), React155.createElement(Input_default2, _extends18({
    ref
  }, inputProps, {
    value: mergedSearchValue,
    maxLength: mode === "combobox" ? maxLength : void 0,
    onChange: (e3) => {
      var _a;
      setInputChanged(true);
      (_a = inputProps.onChange) == null ? void 0 : _a.call(inputProps, e3);
    }
  })));
});
var SingleContent_default = SingleContent;

// node_modules/@rc-component/select/es/SelectInput/Content/MultipleContent.js
var React162 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/Overflow.js
var React160 = __toESM(require_react());
var import_react76 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/Item.js
var React156 = __toESM(require_react());
var UNDEFINED = void 0;
function InternalItem(props, ref) {
  const {
    prefixCls,
    invalidate,
    item,
    renderItem: renderItem2,
    responsive,
    responsiveDisabled,
    registerSize,
    itemKey: itemKey3,
    className,
    style: style2,
    children,
    display,
    order,
    component: Component8 = "div",
    ...restProps
  } = props;
  const mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey3, width);
  }
  React156.useEffect(() => () => {
    internalRegisterSize(null);
  }, []);
  const childNode = renderItem2 && item !== UNDEFINED ? renderItem2(item, {
    index: order
  }) : children;
  let overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  const overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  let itemNode = React156.createElement(Component8, _extends9({
    className: clsx(!invalidate && prefixCls, className),
    style: {
      ...overflowStyle,
      ...style2
    }
  }, overflowProps, restProps, {
    ref
  }), childNode);
  if (responsive) {
    itemNode = React156.createElement(es_default, {
      onResize: ({
        offsetWidth
      }) => {
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item = React156.forwardRef(InternalItem);
if (true) {
  Item.displayName = "Item";
}
var Item_default = Item;

// node_modules/@rc-component/overflow/es/hooks/useEffectState.js
var React157 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/@rc-component/overflow/es/hooks/channelUpdate.js
function channelUpdate(callback) {
  if (typeof MessageChannel === "undefined") {
    raf_default(callback);
  } else {
    const channel = new MessageChannel();
    channel.port1.onmessage = () => callback();
    channel.port2.postMessage(void 0);
  }
}

// node_modules/@rc-component/overflow/es/hooks/useEffectState.js
function useBatcher() {
  const updateFuncRef = React157.useRef(null);
  const notifyEffectUpdate = (callback) => {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate(() => {
        (0, import_react_dom3.unstable_batchedUpdates)(() => {
          updateFuncRef.current.forEach((fn) => {
            fn();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  };
  return notifyEffectUpdate;
}
function useEffectState(notifyEffectUpdate, defaultValue) {
  const [stateValue, setStateValue] = React157.useState(defaultValue);
  const setEffectVal = useEvent_default((nextValue) => {
    notifyEffectUpdate(() => {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}

// node_modules/@rc-component/overflow/es/RawItem.js
var React159 = __toESM(require_react());

// node_modules/@rc-component/overflow/es/context.js
var import_react75 = __toESM(require_react());
var OverflowContext = import_react75.default.createContext(null);

// node_modules/@rc-component/overflow/es/RawItem.js
var InternalRawItem = (props, ref) => {
  const context = React159.useContext(OverflowContext);
  if (!context) {
    const {
      component: Component8 = "div",
      ...restProps2
    } = props;
    return React159.createElement(Component8, _extends9({}, restProps2, {
      ref
    }));
  }
  const {
    className: contextClassName,
    ...restContext
  } = context;
  const {
    className,
    ...restProps
  } = props;
  return React159.createElement(OverflowContext.Provider, {
    value: null
  }, React159.createElement(Item_default, _extends9({
    ref,
    className: clsx(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = React159.forwardRef(InternalRawItem);
if (true) {
  RawItem.displayName = "RawItem";
}
var RawItem_default = RawItem;

// node_modules/@rc-component/overflow/es/Overflow.js
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return `+ ${omittedItems.length} ...`;
}
function Overflow(props, ref) {
  const {
    prefixCls = "rc-overflow",
    data = [],
    renderItem: renderItem2,
    renderRawItem,
    itemKey: itemKey3,
    itemWidth = 10,
    ssr,
    style: style2,
    className,
    maxCount,
    renderRest,
    renderRawRest,
    prefix: prefix2,
    suffix,
    component: Component8 = "div",
    itemComponent,
    onVisibleChange,
    ...restProps
  } = props;
  const fullySSR = ssr === "full";
  const notifyEffectUpdate = useBatcher();
  const [containerWidth, setContainerWidth] = useEffectState(notifyEffectUpdate, null);
  const mergedContainerWidth = containerWidth || 0;
  const [itemWidths, setItemWidths] = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map());
  const [prevRestWidth, setPrevRestWidth] = useEffectState(notifyEffectUpdate, 0);
  const [restWidth, setRestWidth] = useEffectState(notifyEffectUpdate, 0);
  const [prefixWidth, setPrefixWidth] = useEffectState(notifyEffectUpdate, 0);
  const [suffixWidth, setSuffixWidth] = useEffectState(notifyEffectUpdate, 0);
  const [suffixFixedStart, setSuffixFixedStart] = (0, import_react76.useState)(null);
  const [displayCount, setDisplayCount] = (0, import_react76.useState)(null);
  const mergedDisplayCount = React160.useMemo(() => {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  const [restReady, setRestReady] = (0, import_react76.useState)(false);
  const itemPrefixCls = `${prefixCls}-item`;
  const mergedRestWidth = Math.max(prevRestWidth, restWidth);
  const isResponsive = maxCount === RESPONSIVE;
  const shouldResponsive = data.length && isResponsive;
  const invalidate = maxCount === INVALIDATE;
  const showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
  const mergedData = (0, import_react76.useMemo)(() => {
    let items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  const omittedItems = (0, import_react76.useMemo)(() => {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
  const getKey5 = (0, import_react76.useCallback)((item, index2) => {
    if (typeof itemKey3 === "function") {
      return itemKey3(item);
    }
    return (itemKey3 && (item == null ? void 0 : item[itemKey3])) ?? index2;
  }, [itemKey3]);
  const mergedRenderItem = (0, import_react76.useCallback)(renderItem2 || ((item) => item), [renderItem2]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange == null ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths((origin) => {
      const clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  }
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerPrefixSize(_, width) {
    setPrefixWidth(width);
  }
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey5(mergedData[index2], index2));
  }
  useLayoutEffect_default(() => {
    if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
      let totalWidth = prefixWidth + suffixWidth;
      const len = mergedData.length;
      const lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (let i = 0; i < len; i += 1) {
        let currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (
          // Only one means `totalWidth` is the final width
          lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
          i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
        ) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, prefixWidth, suffixWidth, getKey5, mergedData]);
  const displayRest = restReady && !!omittedItems.length;
  let suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  const itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  const internalRenderItemNode = renderRawItem ? (item, index2) => {
    const key = getKey5(item, index2);
    return React160.createElement(OverflowContext.Provider, {
      key,
      value: {
        ...itemSharedProps,
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      }
    }, renderRawItem(item, index2));
  } : (item, index2) => {
    const key = getKey5(item, index2);
    return React160.createElement(Item_default, _extends9({}, itemSharedProps, {
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  const restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: `${itemPrefixCls}-rest`,
    registerSize: registerOverflowSize,
    display: displayRest
  };
  const mergedRenderRest = renderRest || defaultRenderRest;
  const restNode = renderRawRest ? React160.createElement(OverflowContext.Provider, {
    value: {
      ...itemSharedProps,
      ...restContextProps
    }
  }, renderRawRest(omittedItems)) : React160.createElement(Item_default, _extends9({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  const overflowNode = React160.createElement(Component8, _extends9({
    className: clsx(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), prefix2 && React160.createElement(Item_default, _extends9({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: -1,
    className: `${itemPrefixCls}-prefix`,
    registerSize: registerPrefixSize,
    display: true
  }), prefix2), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && React160.createElement(Item_default, _extends9({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: `${itemPrefixCls}-suffix`,
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  return isResponsive ? React160.createElement(es_default, {
    onResize: onOverflowResize,
    disabled: !shouldResponsive
  }, overflowNode) : overflowNode;
}
var ForwardOverflow = React160.forwardRef(Overflow);
ForwardOverflow.Item = RawItem_default;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
if (true) {
  ForwardOverflow.displayName = "Overflow";
}
var Overflow_default = ForwardOverflow;

// node_modules/@rc-component/overflow/es/index.js
var es_default10 = Overflow_default;

// node_modules/@rc-component/select/es/TransBtn.js
var React161 = __toESM(require_react());
var TransBtn = (props) => {
  const {
    className,
    style: style2,
    customizeIcon,
    customizeIconProps,
    children,
    onMouseDown,
    onClick
  } = props;
  const icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
  return React161.createElement("span", {
    className,
    onMouseDown: (event) => {
      event.preventDefault();
      onMouseDown == null ? void 0 : onMouseDown(event);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none",
      ...style2
    },
    unselectable: "on",
    onClick,
    "aria-hidden": true
  }, icon !== void 0 ? icon : React161.createElement("span", {
    className: clsx(className.split(/\s+/).map((cls) => `${cls}-icon`))
  }, children));
};
var TransBtn_default = TransBtn;

// node_modules/@rc-component/select/es/SelectInput/Content/MultipleContent.js
function _extends19() {
  _extends19 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends19.apply(this, arguments);
}
function itemKey(value) {
  return value.key ?? value.value;
}
var onPreventMouseDown = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var MultipleContent_default = React162.forwardRef(function MultipleContent({
  inputProps
}, ref) {
  const {
    prefixCls,
    displayValues,
    searchValue,
    mode,
    onSelectorRemove,
    removeIcon: removeIconFromContext
  } = useSelectInputContext();
  const {
    disabled,
    showSearch,
    triggerOpen,
    toggleOpen,
    autoClearSearchValue,
    tagRender: tagRenderFromContext,
    maxTagPlaceholder: maxTagPlaceholderFromContext,
    maxTagTextLength,
    maxTagCount,
    classNames,
    styles
  } = useBaseProps();
  const selectionItemPrefixCls = `${prefixCls}-selection-item`;
  let computedSearchValue = searchValue;
  if (!triggerOpen && mode === "multiple" && autoClearSearchValue !== false) {
    computedSearchValue = "";
  }
  const inputValue = showSearch ? computedSearchValue || "" : "";
  const inputEditable = showSearch && !disabled;
  const removeIcon = removeIconFromContext ?? "";
  const maxTagPlaceholder = maxTagPlaceholderFromContext ?? ((omittedValues) => `+ ${omittedValues.length} ...`);
  const tagRender = tagRenderFromContext;
  const onToggleOpen = (newOpen) => {
    toggleOpen(newOpen);
  };
  const onRemove = (value) => {
    onSelectorRemove == null ? void 0 : onSelectorRemove(value);
  };
  const defaultRenderSelector = (item, content, itemDisabled, closable, onClose) => React162.createElement("span", {
    title: getTitle(item),
    className: clsx(selectionItemPrefixCls, {
      [`${selectionItemPrefixCls}-disabled`]: itemDisabled
    }, classNames == null ? void 0 : classNames.item),
    style: styles == null ? void 0 : styles.item
  }, React162.createElement("span", {
    className: clsx(`${selectionItemPrefixCls}-content`, classNames == null ? void 0 : classNames.itemContent),
    style: styles == null ? void 0 : styles.itemContent
  }, content), closable && React162.createElement(TransBtn_default, {
    className: clsx(`${selectionItemPrefixCls}-remove`, classNames == null ? void 0 : classNames.itemRemove),
    style: styles == null ? void 0 : styles.itemRemove,
    onMouseDown: onPreventMouseDown,
    onClick: onClose,
    customizeIcon: removeIcon
  }, ""));
  const customizeRenderSelector = (value, content, itemDisabled, closable, onClose, isMaxTag, info) => {
    const onMouseDown = (e3) => {
      onPreventMouseDown(e3);
      onToggleOpen(!triggerOpen);
    };
    return React162.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content,
      value,
      index: info == null ? void 0 : info.index,
      disabled: itemDisabled,
      closable,
      onClose,
      isMaxTag: !!isMaxTag
    }));
  };
  const renderItem2 = (valueItem, info) => {
    const {
      disabled: itemDisabled,
      label,
      value
    } = valueItem;
    const closable = !disabled && !itemDisabled;
    let displayLabel = label;
    if (typeof maxTagTextLength === "number") {
      if (typeof label === "string" || typeof label === "number") {
        const strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
        }
      }
    }
    const onClose = (event) => {
      if (event) {
        event.stopPropagation();
      }
      onRemove(valueItem);
    };
    return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, void 0, info) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  };
  const renderRest = (omittedValues) => {
    if (!displayValues.length) {
      return null;
    }
    const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({
      title: content
    }, content, false);
  };
  return React162.createElement(es_default10, {
    prefixCls: `${prefixCls}-content`,
    className: classNames == null ? void 0 : classNames.content,
    style: styles == null ? void 0 : styles.content,
    prefix: !displayValues.length && (!searchValue || !triggerOpen) ? React162.createElement(Placeholder, null) : null,
    data: displayValues,
    renderItem: renderItem2,
    renderRest,
    suffix: React162.createElement(Input_default2, _extends19({
      ref,
      disabled,
      readOnly: !inputEditable
    }, inputProps, {
      value: inputValue || "",
      syncWidth: true
    })),
    itemKey,
    maxCount: maxTagCount
  });
});

// node_modules/@rc-component/select/es/SelectInput/Content/index.js
var SelectContent = React163.forwardRef(function SelectContent2(_, ref) {
  const {
    multiple,
    onInputKeyDown,
    tabIndex
  } = useSelectInputContext();
  const baseProps = useBaseProps();
  const {
    showSearch
  } = baseProps;
  const ariaProps = pickAttrs(baseProps, {
    aria: true
  });
  const sharedInputProps = {
    ...ariaProps,
    onKeyDown: onInputKeyDown,
    readOnly: !showSearch,
    tabIndex
  };
  if (multiple) {
    return React163.createElement(MultipleContent_default, {
      ref,
      inputProps: sharedInputProps
    });
  }
  return React163.createElement(SingleContent_default, {
    ref,
    inputProps: sharedInputProps
  });
});
var Content_default2 = SelectContent;

// node_modules/@rc-component/select/es/utils/keyUtil.js
function isValidateOpenKey(currentKeyCode) {
  return (
    // Undefined for Edge bug:
    // https://github.com/ant-design/ant-design/issues/51292
    currentKeyCode && // Other keys
    ![
      // System function button
      KeyCode_default.ESC,
      KeyCode_default.SHIFT,
      KeyCode_default.BACKSPACE,
      KeyCode_default.TAB,
      KeyCode_default.WIN_KEY,
      KeyCode_default.ALT,
      KeyCode_default.META,
      KeyCode_default.WIN_KEY_RIGHT,
      KeyCode_default.CTRL,
      KeyCode_default.SEMICOLON,
      KeyCode_default.EQUALS,
      KeyCode_default.CAPS_LOCK,
      KeyCode_default.CONTEXT_MENU,
      // Arrow keys - should not trigger open when navigating in input
      KeyCode_default.UP,
      // KeyCode.DOWN,
      KeyCode_default.LEFT,
      KeyCode_default.RIGHT,
      // F1-F12
      KeyCode_default.F1,
      KeyCode_default.F2,
      KeyCode_default.F3,
      KeyCode_default.F4,
      KeyCode_default.F5,
      KeyCode_default.F6,
      KeyCode_default.F7,
      KeyCode_default.F8,
      KeyCode_default.F9,
      KeyCode_default.F10,
      KeyCode_default.F11,
      KeyCode_default.F12
    ].includes(currentKeyCode)
  );
}

// node_modules/@rc-component/select/es/SelectInput/index.js
function _extends20() {
  _extends20 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends20.apply(this, arguments);
}
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex", "activeValue", "onSelectorRemove", "focused"];
var SelectInput_default = React164.forwardRef(function SelectInput(props, ref) {
  const {
    // Style
    prefixCls,
    className,
    style: style2,
    // UI
    prefix: prefix2,
    suffix,
    clearIcon,
    children,
    // Data
    multiple,
    displayValues,
    placeholder,
    mode,
    // Search
    searchValue,
    onSearch,
    onSearchSubmit,
    onInputBlur,
    // Input
    maxLength,
    autoFocus,
    // Events
    onMouseDown,
    onClearMouseDown,
    onInputKeyDown,
    onSelectorRemove,
    // Token handling
    tokenWithEnter,
    // Components
    components: components2,
    ...restProps
  } = props;
  const {
    triggerOpen,
    toggleOpen,
    showSearch,
    disabled,
    loading,
    classNames,
    styles
  } = useBaseProps();
  const rootRef = React164.useRef(null);
  const inputRef = React164.useRef(null);
  const onInternalInputKeyDown = useEvent_default((event) => {
    const {
      which
    } = event;
    const isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
    if (!isTextAreaElement && triggerOpen && (which === KeyCode_default.UP || which === KeyCode_default.DOWN)) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (isTextAreaElement && !triggerOpen && ~[KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.LEFT, KeyCode_default.RIGHT].indexOf(which)) {
      return;
    }
    if (isValidateOpenKey(which)) {
      toggleOpen(true);
    }
  });
  React164.useImperativeHandle(ref, () => {
    return {
      focus: (options) => {
        var _a, _b;
        (_b = (_a = inputRef.current || rootRef.current).focus) == null ? void 0 : _b.call(_a, options);
      },
      blur: () => {
        var _a, _b;
        (_b = (_a = inputRef.current || rootRef.current).blur) == null ? void 0 : _b.call(_a);
      },
      nativeElement: rootRef.current
    };
  });
  const onInternalMouseDown = useEvent_default((event) => {
    var _a;
    if (!disabled) {
      const inputDOM = getDOM(inputRef.current);
      event.nativeEvent._ori_target = inputDOM;
      if (inputDOM && event.target !== inputDOM && !inputDOM.contains(event.target)) {
        event.preventDefault();
      }
      const shouldPreventClose = triggerOpen && !multiple && (mode === "combobox" || showSearch);
      if (!event.nativeEvent._select_lazy) {
        (_a = inputRef.current) == null ? void 0 : _a.focus();
        if (!shouldPreventClose) {
          toggleOpen();
        }
      } else if (triggerOpen) {
        toggleOpen(false);
      }
    }
    onMouseDown == null ? void 0 : onMouseDown(event);
  });
  const {
    root: RootComponent
  } = components2;
  const domProps = omit(restProps, DEFAULT_OMIT_PROPS);
  const contextValue = {
    ...props,
    onInputKeyDown: onInternalInputKeyDown
  };
  if (RootComponent) {
    if (React164.isValidElement(RootComponent)) {
      return React164.cloneElement(RootComponent, {
        ...domProps,
        ref: composeRef(RootComponent.ref, rootRef)
      });
    }
    return React164.createElement(RootComponent, _extends20({}, domProps, {
      ref: rootRef
    }));
  }
  return React164.createElement(context_default6.Provider, {
    value: contextValue
  }, React164.createElement("div", _extends20({}, domProps, {
    // Style
    ref: rootRef,
    className,
    style: style2,
    onMouseDown: onInternalMouseDown
  }), React164.createElement(Affix2, {
    className: clsx(`${prefixCls}-prefix`, classNames == null ? void 0 : classNames.prefix),
    style: styles == null ? void 0 : styles.prefix
  }, prefix2), React164.createElement(Content_default2, {
    ref: inputRef
  }), React164.createElement(Affix2, {
    className: clsx(`${prefixCls}-suffix`, {
      [`${prefixCls}-suffix-loading`]: loading
    }, classNames == null ? void 0 : classNames.suffix),
    style: styles == null ? void 0 : styles.suffix
  }, suffix), clearIcon && React164.createElement(Affix2, {
    className: clsx(`${prefixCls}-clear`, classNames == null ? void 0 : classNames.clear),
    style: styles == null ? void 0 : styles.clear,
    onMouseDown: (e3) => {
      e3.nativeEvent._select_lazy = true;
      onClearMouseDown == null ? void 0 : onClearMouseDown(e3);
    }
  }, clearIcon), children));
});

// node_modules/@rc-component/select/es/hooks/useComponents.js
var React165 = __toESM(require_react());
function useComponents(components2, getInputElement, getRawInputElement) {
  return React165.useMemo(() => {
    let {
      root,
      input
    } = components2 || {};
    if (getRawInputElement) {
      root = getRawInputElement();
    }
    if (getInputElement) {
      input = getInputElement();
    }
    return {
      root,
      input
    };
  }, [components2, getInputElement, getRawInputElement]);
}

// node_modules/@rc-component/select/es/BaseSelect/index.js
function _extends21() {
  _extends21 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends21.apply(this, arguments);
}
var isMultiple = (mode) => mode === "tags" || mode === "multiple";
var BaseSelect = React166.forwardRef((props, ref) => {
  const {
    id,
    prefixCls,
    className,
    styles,
    classNames,
    showSearch,
    tagRender,
    showScrollBar = "optional",
    direction,
    omitDomProps,
    // Value
    displayValues,
    onDisplayValuesChange,
    emptyOptions,
    notFoundContent = "Not Found",
    onClear,
    maxCount,
    placeholder,
    // Mode
    mode,
    // Status
    disabled,
    loading,
    // Customize Input
    getInputElement,
    getRawInputElement,
    // Open
    open: open3,
    defaultOpen,
    onPopupVisibleChange,
    // Active
    activeValue,
    onActiveValueChange,
    activeDescendantId,
    // Search
    searchValue,
    autoClearSearchValue,
    onSearch,
    onSearchSplit,
    tokenSeparators,
    // Icons
    allowClear,
    prefix: prefix2,
    suffix,
    suffixIcon,
    clearIcon,
    // Dropdown
    OptionList: OptionList3,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    // Focus
    showAction = [],
    onFocus,
    onBlur,
    // Rest Events
    onKeyUp,
    onKeyDown: onKeyDown2,
    onMouseDown,
    // Components
    components: components2,
    // Rest Props
    ...restProps
  } = props;
  const multiple = isMultiple(mode);
  const containerRef = React166.useRef(null);
  const triggerRef = React166.useRef(null);
  const listRef = React166.useRef(null);
  const [focused, setFocused] = React166.useState(false);
  React166.useImperativeHandle(ref, () => {
    var _a, _b;
    return {
      focus: (_a = containerRef.current) == null ? void 0 : _a.focus,
      blur: (_b = containerRef.current) == null ? void 0 : _b.blur,
      scrollTo: (arg) => {
        var _a2;
        return (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo(arg);
      },
      nativeElement: getDOM(containerRef.current)
    };
  });
  const mergedComponents = useComponents(components2, getInputElement, getRawInputElement);
  const mergedSearchValue = React166.useMemo(() => {
    var _a;
    if (mode !== "combobox") {
      return searchValue;
    }
    const val = (_a = displayValues[0]) == null ? void 0 : _a.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  const customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
  const emptyListContent = !notFoundContent && emptyOptions;
  const [mergedOpen, triggerOpen] = useOpen(open3, onPopupVisibleChange, (nextOpen) => disabled || emptyListContent ? false : nextOpen);
  const tokenWithEnter = React166.useMemo(() => (tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)), [tokenSeparators]);
  const onInternalSearch = (searchText, fromTyping, isCompositing) => {
    if (multiple && isValidCount(maxCount) && displayValues.length >= maxCount) {
      return;
    }
    let ret = true;
    let newSearchText = searchText;
    onActiveValueChange == null ? void 0 : onActiveValueChange(null);
    const separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - displayValues.length : void 0);
    const patchLabels = isCompositing ? null : separatedList;
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit == null ? void 0 : onSearchSplit(patchLabels);
      triggerOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    if (searchText && fromTyping && ret) {
      triggerOpen(true);
    }
    return ret;
  };
  const onInternalSearchSubmit = (searchText) => {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: "submit"
    });
  };
  React166.useEffect(() => {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  React166.useEffect(() => {
    if (disabled) {
      triggerOpen(false);
      setFocused(false);
    }
  }, [disabled, mergedOpen]);
  const [getClearLock, setClearLock] = useLock();
  const keyLockRef = React166.useRef(false);
  const onInternalKeyDown = (event) => {
    var _a;
    const clearLock = getClearLock();
    const {
      key
    } = event;
    const isEnterKey = key === "Enter";
    if (isEnterKey) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        triggerOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      const cloneDisplayValues = [...displayValues];
      let removedDisplayValue = null;
      for (let i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        const current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
      if (isEnterKey) {
        keyLockRef.current = true;
      }
      (_a = listRef.current) == null ? void 0 : _a.onKeyDown(event);
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(event);
  };
  const onInternalKeyUp = (event, ...rest) => {
    var _a;
    if (mergedOpen) {
      (_a = listRef.current) == null ? void 0 : _a.onKeyUp(event, ...rest);
    }
    if (event.key === "Enter") {
      keyLockRef.current = false;
    }
    onKeyUp == null ? void 0 : onKeyUp(event, ...rest);
  };
  const onSelectorRemove = useEvent_default((val) => {
    const newValues = displayValues.filter((i) => i !== val);
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  });
  const onInputBlur = () => {
    keyLockRef.current = false;
  };
  const getSelectElements = () => {
    var _a;
    return [getDOM(containerRef.current), (_a = triggerRef.current) == null ? void 0 : _a.getPopupElement()];
  };
  useSelectTriggerControl(getSelectElements, mergedOpen, triggerOpen, !!mergedComponents.root);
  const internalMouseDownRef = React166.useRef(false);
  const onInternalFocus = (event) => {
    setFocused(true);
    if (!disabled) {
      if (showAction.includes("focus")) {
        triggerOpen(true);
      }
      onFocus == null ? void 0 : onFocus(event);
    }
  };
  const onRootBlur = () => {
    if (mergedOpen && !internalMouseDownRef.current) {
      triggerOpen(false, {
        cancelFun: () => isInside(getSelectElements(), document.activeElement)
      });
    }
  };
  const onInternalBlur = (event) => {
    setFocused(false);
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, {
          source: "submit"
        });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    onRootBlur();
    if (!disabled) {
      onBlur == null ? void 0 : onBlur(event);
    }
  };
  const onRootMouseDown = (event, ...restArgs) => {
    var _a;
    const {
      target
    } = event;
    const popupElement = (_a = triggerRef.current) == null ? void 0 : _a.getPopupElement();
    if ((popupElement == null ? void 0 : popupElement.contains(target)) && triggerOpen) {
      triggerOpen(true);
    }
    onMouseDown == null ? void 0 : onMouseDown(event, ...restArgs);
    internalMouseDownRef.current = true;
    macroTask(() => {
      internalMouseDownRef.current = false;
    });
  };
  const [, forceUpdate] = React166.useState({});
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  let onTriggerVisibleChange;
  if (!!mergedComponents.root) {
    onTriggerVisibleChange = (newOpen) => {
      triggerOpen(newOpen);
    };
  }
  const baseSelectContext = React166.useMemo(() => ({
    ...props,
    notFoundContent,
    open: mergedOpen,
    triggerOpen: mergedOpen,
    id,
    showSearch,
    multiple,
    toggleOpen: triggerOpen,
    showScrollBar,
    styles,
    classNames
  }), [props, notFoundContent, triggerOpen, id, showSearch, multiple, mergedOpen, showScrollBar, styles, classNames]);
  const mergedSuffixIcon = React166.useMemo(() => {
    const nextSuffix = suffix ?? suffixIcon;
    if (typeof nextSuffix === "function") {
      return nextSuffix({
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused,
        showSearch,
        loading
      });
    }
    return nextSuffix;
  }, [suffix, suffixIcon, mergedSearchValue, mergedOpen, focused, showSearch, loading]);
  const onClearMouseDown = () => {
    var _a;
    onClear == null ? void 0 : onClear();
    (_a = containerRef.current) == null ? void 0 : _a.focus();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  };
  const {
    allowClear: mergedAllowClear,
    clearIcon: clearNode
  } = useAllowClear(prefixCls, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode);
  const optionList = React166.createElement(OptionList3, {
    ref: listRef
  });
  const mergedClassName = clsx(prefixCls, className, {
    [`${prefixCls}-focused`]: focused,
    [`${prefixCls}-multiple`]: multiple,
    [`${prefixCls}-single`]: !multiple,
    [`${prefixCls}-allow-clear`]: mergedAllowClear,
    [`${prefixCls}-show-arrow`]: mergedSuffixIcon !== void 0 && mergedSuffixIcon !== null,
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-open`]: mergedOpen,
    [`${prefixCls}-customize-input`]: customizeInputElement,
    [`${prefixCls}-show-search`]: showSearch
  });
  let renderNode = React166.createElement(SelectInput_default, _extends21({}, restProps, {
    // Ref
    ref: containerRef,
    prefixCls,
    className: mergedClassName,
    focused,
    prefix: prefix2,
    suffix: mergedSuffixIcon,
    clearIcon: clearNode,
    multiple,
    mode,
    displayValues,
    placeholder,
    searchValue: mergedSearchValue,
    activeValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onInputBlur,
    onFocus: onInternalFocus,
    onBlur: onInternalBlur,
    onClearMouseDown,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onSelectorRemove,
    tokenWithEnter,
    onMouseDown: onRootMouseDown,
    components: mergedComponents
  }));
  renderNode = React166.createElement(SelectTrigger_default, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: mergedOpen,
    popupElement: optionList,
    animation,
    transitionName,
    popupStyle,
    popupClassName,
    direction,
    popupMatchSelectWidth,
    popupRender,
    popupAlign,
    placement,
    builtinPlacements,
    getPopupContainer,
    empty: emptyOptions,
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter,
    onPopupMouseDown: onRootMouseDown,
    onPopupBlur: onRootBlur
  }, renderNode);
  return React166.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, React166.createElement(Polite, {
    visible: focused && !mergedOpen,
    values: displayValues
  }), renderNode);
});
if (true) {
  BaseSelect.displayName = "BaseSelect";
}
var BaseSelect_default = BaseSelect;

// node_modules/@rc-component/select/es/OptGroup.js
var OptGroup = () => null;
OptGroup.isSelectOptGroup = true;
var OptGroup_default = OptGroup;

// node_modules/@rc-component/select/es/Option.js
var Option = () => null;
Option.isSelectOption = true;
var Option_default = Option;

// node_modules/@rc-component/virtual-list/es/List.js
var React176 = __toESM(require_react());
var import_react81 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());

// node_modules/@rc-component/virtual-list/es/Filler.js
var React167 = __toESM(require_react());
var Filler = React167.forwardRef(({
  height,
  offsetY,
  offsetX,
  children,
  prefixCls,
  onInnerResize,
  innerProps,
  rtl,
  extra
}, ref) => {
  let outerStyle = {};
  let innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offsetY !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = {
      ...innerStyle,
      transform: `translateY(${offsetY}px)`,
      [rtl ? "marginRight" : "marginLeft"]: -offsetX,
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    };
  }
  return React167.createElement("div", {
    style: outerStyle
  }, React167.createElement(es_default, {
    onResize: ({
      offsetHeight
    }) => {
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, React167.createElement("div", _extends9({
    style: innerStyle,
    className: clsx({
      [`${prefixCls}-holder-inner`]: prefixCls
    }),
    ref
  }, innerProps), children, extra)));
});
Filler.displayName = "Filler";
var Filler_default = Filler;

// node_modules/@rc-component/virtual-list/es/hooks/useChildren.js
var React169 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/Item.js
var React168 = __toESM(require_react());
function Item2({
  children,
  setRef
}) {
  const refFunc = React168.useCallback((node2) => {
    setRef(node2);
  }, []);
  return React168.cloneElement(children, {
    ref: refFunc
  });
}

// node_modules/@rc-component/virtual-list/es/hooks/useChildren.js
function useChildren(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, {
  getKey: getKey5
}) {
  return list.slice(startIndex, endIndex + 1).map((item, index2) => {
    const eleIndex = startIndex + index2;
    const node2 = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth
      },
      offsetX
    });
    const key = getKey5(item);
    return React169.createElement(Item2, {
      key,
      setRef: (ele) => setNodeRef(item, ele)
    }, node2);
  });
}

// node_modules/@rc-component/virtual-list/es/hooks/useDiffItem.js
var React170 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/algorithmUtil.js
function findListDiffIndex(originList, targetList, getKey5) {
  const originLen = originList.length;
  const targetLen = targetList.length;
  let shortList;
  let longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  const notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey5(item);
    }
    return notExistKey;
  }
  let diffIndex = null;
  let multiple = Math.abs(originLen - targetLen) !== 1;
  for (let i = 0; i < longList.length; i += 1) {
    const shortKey = getItemKey(shortList[i]);
    const longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}

// node_modules/@rc-component/virtual-list/es/hooks/useDiffItem.js
function useDiffItem(data, getKey5, onDiff) {
  const [prevData, setPrevData] = React170.useState(data);
  const [diffItem, setDiffItem] = React170.useState(null);
  React170.useEffect(() => {
    const diff = findListDiffIndex(prevData || [], data || [], getKey5);
    if ((diff == null ? void 0 : diff.index) !== void 0) {
      onDiff == null ? void 0 : onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}

// node_modules/@rc-component/virtual-list/es/hooks/useFrameWheel.js
var import_react78 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/isFirefox.js
var isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
var isFirefox_default = isFF;

// node_modules/@rc-component/virtual-list/es/hooks/useOriginScroll.js
var import_react77 = __toESM(require_react());
var useOriginScroll_default = (isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) => {
  const lockRef = (0, import_react77.useRef)(false);
  const lockTimeoutRef = (0, import_react77.useRef)(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(() => {
      lockRef.current = false;
    }, 50);
  }
  const scrollPingRef = (0, import_react77.useRef)({
    top: isScrollAtTop,
    bottom: isScrollAtBottom,
    left: isScrollAtLeft,
    right: isScrollAtRight
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  scrollPingRef.current.left = isScrollAtLeft;
  scrollPingRef.current.right = isScrollAtRight;
  return (isHorizontal, delta, smoothOffset = false) => {
    const originScroll = isHorizontal ? (
      // Pass origin wheel when on the left
      delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
      delta > 0 && scrollPingRef.current.right
    ) : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
    delta > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
};

// node_modules/@rc-component/virtual-list/es/hooks/useFrameWheel.js
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
  const offsetRef = (0, import_react78.useRef)(0);
  const nextFrameRef = (0, import_react78.useRef)(null);
  const wheelValueRef = (0, import_react78.useRef)(null);
  const isMouseScrollRef = (0, import_react78.useRef)(false);
  const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  function onWheelY(e3, deltaY) {
    raf_default.cancel(nextFrameRef.current);
    if (originScroll(false, deltaY))
      return;
    const event = e3;
    if (!event._virtualHandled) {
      event._virtualHandled = true;
    } else {
      return;
    }
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (!isFirefox_default) {
      event.preventDefault();
    }
    nextFrameRef.current = raf_default(() => {
      const patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple, false);
      offsetRef.current = 0;
    });
  }
  function onWheelX(event, deltaX) {
    onWheelDelta(deltaX, true);
    if (!isFirefox_default) {
      event.preventDefault();
    }
  }
  const wheelDirectionRef = (0, import_react78.useRef)(null);
  const wheelDirectionCleanRef = (0, import_react78.useRef)(null);
  function onWheel(event) {
    if (!inVirtual)
      return;
    raf_default.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = raf_default(() => {
      wheelDirectionRef.current = null;
    }, 2);
    const {
      deltaX,
      deltaY,
      shiftKey
    } = event;
    let mergedDeltaX = deltaX;
    let mergedDeltaY = deltaY;
    if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;
      wheelDirectionRef.current = "sx";
    }
    const absX = Math.abs(mergedDeltaX);
    const absY = Math.abs(mergedDeltaY);
    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
    }
    if (wheelDirectionRef.current === "y") {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}

// node_modules/@rc-component/virtual-list/es/hooks/useGetSize.js
var React171 = __toESM(require_react());
function useGetSize(mergedData, getKey5, heights, itemHeight) {
  const [key2Index, bottomList] = React171.useMemo(() => [/* @__PURE__ */ new Map(), []], [mergedData, heights.id, itemHeight]);
  const getSize3 = (startKey, endKey = startKey) => {
    let startIndex = key2Index.get(startKey);
    let endIndex = key2Index.get(endKey);
    if (startIndex === void 0 || endIndex === void 0) {
      const dataLen = mergedData.length;
      for (let i = bottomList.length; i < dataLen; i += 1) {
        const item = mergedData[i];
        const key = getKey5(item);
        key2Index.set(key, i);
        const cacheHeight = heights.get(key) ?? itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }
        if (startIndex !== void 0 && endIndex !== void 0) {
          break;
        }
      }
    }
    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex]
    };
  };
  return getSize3;
}

// node_modules/@rc-component/virtual-list/es/hooks/useHeights.js
var React172 = __toESM(require_react());
var import_react79 = __toESM(require_react());

// node_modules/@rc-component/virtual-list/es/utils/CacheMap.js
var CacheMap = class {
  constructor() {
    __publicField(this, "maps");
    // Used for cache key
    // `useMemo` no need to update if `id` not change
    __publicField(this, "id", 0);
    __publicField(this, "diffRecords", /* @__PURE__ */ new Map());
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  set(key, value) {
    this.diffRecords.set(key, this.maps[key]);
    this.maps[key] = value;
    this.id += 1;
  }
  get(key) {
    return this.maps[key];
  }
  /**
   * CacheMap will record the key changed.
   * To help to know what's update in the next render.
   */
  resetRecord() {
    this.diffRecords.clear();
  }
  getRecord() {
    return this.diffRecords;
  }
};
var CacheMap_default = CacheMap;

// node_modules/@rc-component/virtual-list/es/hooks/useHeights.js
function parseNumber(value) {
  const num = parseFloat(value);
  return isNaN(num) ? 0 : num;
}
function useHeights(getKey5, onItemAdd, onItemRemove) {
  const [updatedMark, setUpdatedMark] = React172.useState(0);
  const instanceRef = (0, import_react79.useRef)(/* @__PURE__ */ new Map());
  const heightsRef = (0, import_react79.useRef)(new CacheMap_default());
  const promiseIdRef = (0, import_react79.useRef)(0);
  function cancelRaf() {
    promiseIdRef.current += 1;
  }
  function collectHeight(sync = false) {
    cancelRaf();
    const doCollect = () => {
      let changed = false;
      instanceRef.current.forEach((element, key) => {
        if (element && element.offsetParent) {
          const {
            offsetHeight
          } = element;
          const {
            marginTop,
            marginBottom
          } = getComputedStyle(element);
          const marginTopNum = parseNumber(marginTop);
          const marginBottomNum = parseNumber(marginBottom);
          const totalHeight = offsetHeight + marginTopNum + marginBottomNum;
          if (heightsRef.current.get(key) !== totalHeight) {
            heightsRef.current.set(key, totalHeight);
            changed = true;
          }
        }
      });
      if (changed) {
        setUpdatedMark((c) => c + 1);
      }
    };
    if (sync) {
      doCollect();
    } else {
      promiseIdRef.current += 1;
      const id = promiseIdRef.current;
      Promise.resolve().then(() => {
        if (id === promiseIdRef.current) {
          doCollect();
        }
      });
    }
  }
  function setInstanceRef(item, instance) {
    const key = getKey5(item);
    const origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd == null ? void 0 : onItemAdd(item);
      } else {
        onItemRemove == null ? void 0 : onItemRemove(item);
      }
    }
  }
  (0, import_react79.useEffect)(() => {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}

// node_modules/@rc-component/virtual-list/es/hooks/useMobileTouchMove.js
var import_react80 = __toESM(require_react());
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  const touchedRef = (0, import_react80.useRef)(false);
  const touchXRef = (0, import_react80.useRef)(0);
  const touchYRef = (0, import_react80.useRef)(0);
  const elementRef = (0, import_react80.useRef)(null);
  const intervalRef = (0, import_react80.useRef)(null);
  let cleanUpEvents;
  const onTouchMove = (e3) => {
    if (touchedRef.current) {
      const currentX = Math.ceil(e3.touches[0].pageX);
      const currentY = Math.ceil(e3.touches[0].pageY);
      let offsetX = touchXRef.current - currentX;
      let offsetY = touchYRef.current - currentY;
      const isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
      if (isHorizontal) {
        touchXRef.current = currentX;
      } else {
        touchYRef.current = currentY;
      }
      const scrollHandled = callback(isHorizontal, isHorizontal ? offsetX : offsetY, false, e3);
      if (scrollHandled) {
        e3.preventDefault();
      }
      clearInterval(intervalRef.current);
      if (scrollHandled) {
        intervalRef.current = setInterval(() => {
          if (isHorizontal) {
            offsetX *= SMOOTH_PTG;
          } else {
            offsetY *= SMOOTH_PTG;
          }
          const offset3 = Math.floor(isHorizontal ? offsetX : offsetY);
          if (!callback(isHorizontal, offset3, true) || Math.abs(offset3) <= 0.1) {
            clearInterval(intervalRef.current);
          }
        }, 16);
      }
    }
  };
  const onTouchEnd = () => {
    touchedRef.current = false;
    cleanUpEvents();
  };
  const onTouchStart = (e3) => {
    cleanUpEvents();
    if (e3.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchXRef.current = Math.ceil(e3.touches[0].pageX);
      touchYRef.current = Math.ceil(e3.touches[0].pageY);
      elementRef.current = e3.target;
      elementRef.current.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      elementRef.current.addEventListener("touchend", onTouchEnd, {
        passive: true
      });
    }
  };
  cleanUpEvents = () => {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect_default(() => {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart, {
        passive: true
      });
    }
    return () => {
      var _a;
      (_a = listRef.current) == null ? void 0 : _a.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}

// node_modules/@rc-component/virtual-list/es/hooks/useScrollDrag.js
var React173 = __toESM(require_react());
function smoothScrollOffset(offset3) {
  return Math.floor(offset3 ** 0.5);
}
function getPageXY(e3, horizontal) {
  const obj = "touches" in e3 ? e3.touches[0] : e3;
  return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
  React173.useEffect(() => {
    const ele = componentRef.current;
    if (inVirtual && ele) {
      let mouseDownLock = false;
      let rafId;
      let offset3;
      const stopScroll = () => {
        raf_default.cancel(rafId);
      };
      const continueScroll = () => {
        stopScroll();
        rafId = raf_default(() => {
          onScrollOffset(offset3);
          continueScroll();
        });
      };
      const clearDragState = () => {
        mouseDownLock = false;
        stopScroll();
      };
      const onMouseDown = (e3) => {
        if (e3.target.draggable || e3.button !== 0) {
          return;
        }
        const event = e3;
        if (!event._virtualHandled) {
          event._virtualHandled = true;
          mouseDownLock = true;
        }
      };
      const onMouseMove = (e3) => {
        if (mouseDownLock) {
          const mouseY = getPageXY(e3, false);
          const {
            top,
            bottom
          } = ele.getBoundingClientRect();
          if (mouseY <= top) {
            const diff = top - mouseY;
            offset3 = -smoothScrollOffset(diff);
            continueScroll();
          } else if (mouseY >= bottom) {
            const diff = mouseY - bottom;
            offset3 = smoothScrollOffset(diff);
            continueScroll();
          } else {
            stopScroll();
          }
        }
      };
      ele.addEventListener("mousedown", onMouseDown);
      ele.ownerDocument.addEventListener("mouseup", clearDragState);
      ele.ownerDocument.addEventListener("mousemove", onMouseMove);
      ele.ownerDocument.addEventListener("dragend", clearDragState);
      return () => {
        ele.removeEventListener("mousedown", onMouseDown);
        ele.ownerDocument.removeEventListener("mouseup", clearDragState);
        ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
        ele.ownerDocument.removeEventListener("dragend", clearDragState);
        stopScroll();
      };
    }
  }, [inVirtual]);
}

// node_modules/@rc-component/virtual-list/es/hooks/useScrollTo.js
var React174 = __toESM(require_react());
var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey5, collectHeight, syncScrollTop, triggerFlash) {
  const scrollRef = React174.useRef();
  const [syncState, setSyncState] = React174.useState(null);
  useLayoutEffect_default(() => {
    if (syncState && syncState.times < MAX_TIMES) {
      if (!containerRef.current) {
        setSyncState((ori) => ({
          ...ori
        }));
        return;
      }
      collectHeight();
      const {
        targetAlign,
        originAlign,
        index: index2,
        offset: offset3
      } = syncState;
      const height = containerRef.current.clientHeight;
      let needCollectHeight = false;
      let newTargetAlign = targetAlign;
      let targetTop = null;
      if (height) {
        const mergedAlign = targetAlign || originAlign;
        let stackTop = 0;
        let itemTop = 0;
        let itemBottom = 0;
        const maxLen = Math.min(data.length - 1, index2);
        for (let i = 0; i <= maxLen; i += 1) {
          const key = getKey5(data[i]);
          itemTop = stackTop;
          const cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          stackTop = itemBottom;
        }
        let leftHeight = mergedAlign === "top" ? offset3 : height - offset3;
        for (let i = maxLen; i >= 0; i -= 1) {
          const key = getKey5(data[i]);
          const cacheHeight = heights.get(key);
          if (cacheHeight === void 0) {
            needCollectHeight = true;
            break;
          }
          leftHeight -= cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }
        switch (mergedAlign) {
          case "top":
            targetTop = itemTop - offset3;
            break;
          case "bottom":
            targetTop = itemBottom - height + offset3;
            break;
          default: {
            const {
              scrollTop
            } = containerRef.current;
            const scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = "top";
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = "bottom";
            }
          }
        }
        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }
      if (needCollectHeight) {
        setSyncState({
          ...syncState,
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop
        });
      }
    } else if ((syncState == null ? void 0 : syncState.times) === MAX_TIMES) {
      warning_default(false, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
    }
  }, [syncState, containerRef.current]);
  return (arg) => {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    raf_default.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && typeof arg === "object") {
      let index2;
      const {
        align
      } = arg;
      if ("index" in arg) {
        ({
          index: index2
        } = arg);
      } else {
        index2 = data.findIndex((item) => getKey5(item) === arg.key);
      }
      const {
        offset: offset3 = 0
      } = arg;
      setSyncState({
        times: 0,
        index: index2,
        offset: offset3,
        originAlign: align
      });
    }
  };
}

// node_modules/@rc-component/virtual-list/es/ScrollBar.js
var React175 = __toESM(require_react());
var ScrollBar = React175.forwardRef((props, ref) => {
  const {
    prefixCls,
    rtl,
    scrollOffset,
    scrollRange,
    onStartMove,
    onStopMove,
    onScroll,
    horizontal,
    spinSize,
    containerSize,
    style: style2,
    thumbStyle: propsThumbStyle,
    showScrollBar
  } = props;
  const [dragging, setDragging] = React175.useState(false);
  const [pageXY, setPageXY] = React175.useState(null);
  const [startTop, setStartTop] = React175.useState(null);
  const isLTR = !rtl;
  const scrollbarRef = React175.useRef();
  const thumbRef = React175.useRef();
  const [visible, setVisible] = React175.useState(showScrollBar);
  const visibleTimeoutRef = React175.useRef();
  const delayHidden = () => {
    if (showScrollBar === true || showScrollBar === false)
      return;
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);
    visibleTimeoutRef.current = setTimeout(() => {
      setVisible(false);
    }, 3e3);
  };
  const enableScrollRange = scrollRange - containerSize || 0;
  const enableOffsetRange = containerSize - spinSize || 0;
  const top = React175.useMemo(() => {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    const ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);
  const onContainerMouseDown = (e3) => {
    e3.stopPropagation();
    e3.preventDefault();
  };
  const stateRef = React175.useRef({
    top,
    dragging,
    pageY: pageXY,
    startTop
  });
  stateRef.current = {
    top,
    dragging,
    pageY: pageXY,
    startTop
  };
  const onThumbMouseDown = (e3) => {
    setDragging(true);
    setPageXY(getPageXY(e3, horizontal));
    setStartTop(stateRef.current.top);
    onStartMove();
    e3.stopPropagation();
    e3.preventDefault();
  };
  React175.useEffect(() => {
    const onScrollbarTouchStart = (e3) => {
      e3.preventDefault();
    };
    const scrollbarEle = scrollbarRef.current;
    const thumbEle = thumbRef.current;
    scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
      passive: false
    });
    thumbEle.addEventListener("touchstart", onThumbMouseDown, {
      passive: false
    });
    return () => {
      scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
      thumbEle.removeEventListener("touchstart", onThumbMouseDown);
    };
  }, []);
  const enableScrollRangeRef = React175.useRef();
  enableScrollRangeRef.current = enableScrollRange;
  const enableOffsetRangeRef = React175.useRef();
  enableOffsetRangeRef.current = enableOffsetRange;
  React175.useEffect(() => {
    if (dragging) {
      let moveRafId;
      const onMouseMove = (e3) => {
        const {
          dragging: stateDragging,
          pageY: statePageY,
          startTop: stateStartTop
        } = stateRef.current;
        raf_default.cancel(moveRafId);
        const rect = scrollbarRef.current.getBoundingClientRect();
        const scale = containerSize / (horizontal ? rect.width : rect.height);
        if (stateDragging) {
          const offset3 = (getPageXY(e3, horizontal) - statePageY) * scale;
          let newTop = stateStartTop;
          if (!isLTR && horizontal) {
            newTop -= offset3;
          } else {
            newTop += offset3;
          }
          const tmpEnableScrollRange = enableScrollRangeRef.current;
          const tmpEnableOffsetRange = enableOffsetRangeRef.current;
          const ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
          let newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
          moveRafId = raf_default(() => {
            onScroll(newScrollTop, horizontal);
          });
        }
      };
      const onMouseUp = () => {
        setDragging(false);
        onStopMove();
      };
      window.addEventListener("mousemove", onMouseMove, {
        passive: true
      });
      window.addEventListener("touchmove", onMouseMove, {
        passive: true
      });
      window.addEventListener("mouseup", onMouseUp, {
        passive: true
      });
      window.addEventListener("touchend", onMouseUp, {
        passive: true
      });
      return () => {
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("touchmove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
        window.removeEventListener("touchend", onMouseUp);
        raf_default.cancel(moveRafId);
      };
    }
  }, [dragging]);
  React175.useEffect(() => {
    delayHidden();
    return () => {
      clearTimeout(visibleTimeoutRef.current);
    };
  }, [scrollOffset]);
  React175.useImperativeHandle(ref, () => ({
    delayHidden
  }));
  const scrollbarPrefixCls = `${prefixCls}-scrollbar`;
  const containerStyle = {
    position: "absolute",
    visibility: visible ? null : "hidden"
  };
  const thumbStyle = {
    position: "absolute",
    borderRadius: 99,
    background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
    cursor: "pointer",
    userSelect: "none"
  };
  if (horizontal) {
    Object.assign(containerStyle, {
      height: 8,
      left: 0,
      right: 0,
      bottom: 0
    });
    Object.assign(thumbStyle, {
      height: "100%",
      width: spinSize,
      [isLTR ? "left" : "right"]: top
    });
  } else {
    Object.assign(containerStyle, {
      width: 8,
      top: 0,
      bottom: 0,
      [isLTR ? "right" : "left"]: 0
    });
    Object.assign(thumbStyle, {
      width: "100%",
      height: spinSize,
      top
    });
  }
  return React175.createElement("div", {
    ref: scrollbarRef,
    className: clsx(scrollbarPrefixCls, {
      [`${scrollbarPrefixCls}-horizontal`]: horizontal,
      [`${scrollbarPrefixCls}-vertical`]: !horizontal,
      [`${scrollbarPrefixCls}-visible`]: visible
    }),
    style: {
      ...containerStyle,
      ...style2
    },
    onMouseDown: onContainerMouseDown,
    onMouseMove: delayHidden
  }, React175.createElement("div", {
    ref: thumbRef,
    className: clsx(`${scrollbarPrefixCls}-thumb`, {
      [`${scrollbarPrefixCls}-thumb-moving`]: dragging
    }),
    style: {
      ...thumbStyle,
      ...propsThumbStyle
    },
    onMouseDown: onThumbMouseDown
  }));
});
if (true) {
  ScrollBar.displayName = "ScrollBar";
}
var ScrollBar_default = ScrollBar;

// node_modules/@rc-component/virtual-list/es/utils/scrollbarUtil.js
var MIN_SIZE = 20;
function getSpinSize(containerSize = 0, scrollRange = 0) {
  let baseSize = containerSize / scrollRange * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  return Math.floor(baseSize);
}

// node_modules/@rc-component/virtual-list/es/List.js
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  const {
    prefixCls = "rc-virtual-list",
    className,
    height,
    itemHeight,
    fullHeight = true,
    style: style2,
    data,
    children,
    itemKey: itemKey3,
    virtual,
    direction,
    scrollWidth,
    component: Component8 = "div",
    onScroll,
    onVirtualScroll,
    onVisibleChange,
    innerProps,
    extraRender,
    styles,
    showScrollBar = "optional",
    ...restProps
  } = props;
  const getKey5 = React176.useCallback((item) => {
    if (typeof itemKey3 === "function") {
      return itemKey3(item);
    }
    return item == null ? void 0 : item[itemKey3];
  }, [itemKey3]);
  const [setInstanceRef, collectHeight, heights, heightUpdatedMark] = useHeights(getKey5, null, null);
  const useVirtual = !!(virtual !== false && height && itemHeight);
  const containerHeight = React176.useMemo(() => Object.values(heights.maps).reduce((total, curr) => total + curr, 0), [heights.id, heights.maps]);
  const inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  const isRTL = direction === "rtl";
  const mergedClassName = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: isRTL
  }, className);
  const mergedData = data || EMPTY_DATA;
  const componentRef = (0, import_react81.useRef)();
  const fillerInnerRef = (0, import_react81.useRef)();
  const containerRef = (0, import_react81.useRef)();
  const [offsetTop, setOffsetTop] = (0, import_react81.useState)(0);
  const [offsetLeft, setOffsetLeft] = (0, import_react81.useState)(0);
  const [scrollMoving, setScrollMoving] = (0, import_react81.useState)(false);
  const onScrollbarStartMove = () => {
    setScrollMoving(true);
  };
  const onScrollbarStopMove = () => {
    setScrollMoving(false);
  };
  const sharedConfig = {
    getKey: getKey5
  };
  function syncScrollTop(newTop) {
    setOffsetTop((origin) => {
      let value;
      if (typeof newTop === "function") {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      const alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  const rangeRef = (0, import_react81.useRef)({
    start: 0,
    end: mergedData.length
  });
  const diffItemRef = (0, import_react81.useRef)();
  const [diffItem] = useDiffItem(mergedData, getKey5);
  diffItemRef.current = diffItem;
  const {
    scrollHeight,
    start,
    end,
    offset: fillerOffset
  } = React176.useMemo(() => {
    var _a;
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      return {
        scrollHeight: ((_a = fillerInnerRef.current) == null ? void 0 : _a.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    let itemTop = 0;
    let startIndex;
    let startOffset;
    let endIndex;
    const dataLen = mergedData.length;
    for (let i = 0; i < dataLen; i += 1) {
      const item = mergedData[i];
      const key = getKey5(item);
      const cacheHeight = heights.get(key);
      const currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= offsetTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > offsetTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]);
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  React176.useLayoutEffect(() => {
    const changedRecord = heights.getRecord();
    if (changedRecord.size === 1) {
      const recordKey = Array.from(changedRecord.keys())[0];
      const prevCacheHeight = changedRecord.get(recordKey);
      const startItem = mergedData[start];
      if (startItem && prevCacheHeight === void 0) {
        const startIndexKey = getKey5(startItem);
        if (startIndexKey === recordKey) {
          const realStartHeight = heights.get(recordKey);
          const diffHeight = realStartHeight - itemHeight;
          syncScrollTop((ori) => {
            return ori + diffHeight;
          });
        }
      }
    }
    heights.resetRecord();
  }, [scrollHeight]);
  const [size, setSize] = React176.useState({
    width: 0,
    height
  });
  const onHolderResize = (sizeInfo) => {
    setSize({
      width: sizeInfo.offsetWidth,
      height: sizeInfo.offsetHeight
    });
  };
  const verticalScrollBarRef = (0, import_react81.useRef)();
  const horizontalScrollBarRef = (0, import_react81.useRef)();
  const horizontalScrollBarSpinSize = React176.useMemo(() => getSpinSize(size.width, scrollWidth), [size.width, scrollWidth]);
  const verticalScrollBarSpinSize = React176.useMemo(() => getSpinSize(size.height, scrollHeight), [size.height, scrollHeight]);
  const maxScrollHeight = scrollHeight - height;
  const maxScrollHeightRef = (0, import_react81.useRef)(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    let newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  const isScrollAtTop = offsetTop <= 0;
  const isScrollAtBottom = offsetTop >= maxScrollHeight;
  const isScrollAtLeft = offsetLeft <= 0;
  const isScrollAtRight = offsetLeft >= scrollWidth;
  const originScroll = useOriginScroll_default(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
  const getVirtualScrollInfo = () => ({
    x: isRTL ? -offsetLeft : offsetLeft,
    y: offsetTop
  });
  const lastVirtualScrollInfoRef = (0, import_react81.useRef)(getVirtualScrollInfo());
  const triggerScroll = useEvent_default((params) => {
    if (onVirtualScroll) {
      const nextInfo = {
        ...getVirtualScrollInfo(),
        ...params
      };
      if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
        onVirtualScroll(nextInfo);
        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });
  function onScrollBar(newScrollOffset, horizontal) {
    const newOffset = newScrollOffset;
    if (horizontal) {
      (0, import_react_dom4.flushSync)(() => {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }
  function onFallbackScroll(e3) {
    const {
      scrollTop: newScrollTop
    } = e3.currentTarget;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll == null ? void 0 : onScroll(e3);
    triggerScroll();
  }
  const keepInHorizontalRange = (nextOffsetLeft) => {
    let tmpOffsetLeft = nextOffsetLeft;
    const max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
    return tmpOffsetLeft;
  };
  const onWheelDelta = useEvent_default((offsetXY, fromHorizontal) => {
    if (fromHorizontal) {
      (0, import_react_dom4.flushSync)(() => {
        setOffsetLeft((left) => {
          const nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
          return keepInHorizontalRange(nextOffsetLeft);
        });
      });
      triggerScroll();
    } else {
      syncScrollTop((top) => {
        const newTop = top + offsetXY;
        return newTop;
      });
    }
  });
  const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta);
  useMobileTouchMove(useVirtual, componentRef, (isHorizontal, delta, smoothOffset, e3) => {
    const event = e3;
    if (originScroll(isHorizontal, delta, smoothOffset)) {
      return false;
    }
    if (!event || !event._virtualHandled) {
      if (event) {
        event._virtualHandled = true;
      }
      onRawWheel({
        preventDefault() {
        },
        deltaX: isHorizontal ? delta : 0,
        deltaY: isHorizontal ? 0 : delta
      });
      return true;
    }
    return false;
  });
  useScrollDrag(inVirtual, componentRef, (offset3) => {
    syncScrollTop((top) => top + offset3);
  });
  useLayoutEffect_default(() => {
    function onMozMousePixelScroll(e3) {
      const scrollingUpAtTop = isScrollAtTop && e3.detail < 0;
      const scrollingDownAtBottom = isScrollAtBottom && e3.detail > 0;
      if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
        e3.preventDefault();
      }
    }
    const componentEle = componentRef.current;
    componentEle.addEventListener("wheel", onRawWheel, {
      passive: false
    });
    componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
      passive: true
    });
    componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
      passive: false
    });
    return () => {
      componentEle.removeEventListener("wheel", onRawWheel);
      componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
      componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    };
  }, [useVirtual, isScrollAtTop, isScrollAtBottom]);
  useLayoutEffect_default(() => {
    if (scrollWidth) {
      const newOffsetLeft = keepInHorizontalRange(offsetLeft);
      setOffsetLeft(newOffsetLeft);
      triggerScroll({
        x: newOffsetLeft
      });
    }
  }, [size.width, scrollWidth]);
  const delayHideScrollBar = () => {
    var _a, _b;
    (_a = verticalScrollBarRef.current) == null ? void 0 : _a.delayHidden();
    (_b = horizontalScrollBarRef.current) == null ? void 0 : _b.delayHidden();
  };
  const scrollTo2 = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey5, () => collectHeight(true), syncScrollTop, delayHideScrollBar);
  React176.useImperativeHandle(ref, () => ({
    nativeElement: containerRef.current,
    getScrollInfo: getVirtualScrollInfo,
    scrollTo: (config) => {
      function isPosScroll(arg) {
        return arg && typeof arg === "object" && ("left" in arg || "top" in arg);
      }
      if (isPosScroll(config)) {
        if (config.left !== void 0) {
          setOffsetLeft(keepInHorizontalRange(config.left));
        }
        scrollTo2(config.top);
      } else {
        scrollTo2(config);
      }
    }
  }));
  useLayoutEffect_default(() => {
    if (onVisibleChange) {
      const renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  const getSize3 = useGetSize(mergedData, getKey5, heights, itemHeight);
  const extraContent = extraRender == null ? void 0 : extraRender({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize: getSize3
  });
  const listChildren = useChildren(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
  let componentStyle = null;
  if (height) {
    componentStyle = {
      [fullHeight ? "height" : "maxHeight"]: height,
      ...ScrollStyle
    };
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollWidth) {
        componentStyle.overflowX = "hidden";
      }
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  const containerProps = {};
  if (isRTL) {
    containerProps.dir = "rtl";
  }
  return React176.createElement("div", _extends9({
    ref: containerRef,
    style: {
      ...style2,
      position: "relative"
    },
    className: mergedClassName
  }, containerProps, restProps), React176.createElement(es_default, {
    onResize: onHolderResize
  }, React176.createElement(Component8, {
    className: `${prefixCls}-holder`,
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll,
    onMouseEnter: delayHideScrollBar
  }, React176.createElement(Filler_default, {
    prefixCls,
    height: scrollHeight,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    scrollWidth,
    onInnerResize: collectHeight,
    ref: fillerInnerRef,
    innerProps,
    rtl: isRTL,
    extra: extraContent
  }, listChildren))), inVirtual && scrollHeight > height && React176.createElement(ScrollBar_default, {
    ref: verticalScrollBarRef,
    prefixCls,
    scrollOffset: offsetTop,
    scrollRange: scrollHeight,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: verticalScrollBarSpinSize,
    containerSize: size.height,
    style: styles == null ? void 0 : styles.verticalScrollBar,
    thumbStyle: styles == null ? void 0 : styles.verticalScrollBarThumb,
    showScrollBar
  }), inVirtual && scrollWidth > size.width && React176.createElement(ScrollBar_default, {
    ref: horizontalScrollBarRef,
    prefixCls,
    scrollOffset: offsetLeft,
    scrollRange: scrollWidth,
    rtl: isRTL,
    onScroll: onScrollBar,
    onStartMove: onScrollbarStartMove,
    onStopMove: onScrollbarStopMove,
    spinSize: horizontalScrollBarSpinSize,
    containerSize: size.width,
    horizontal: true,
    style: styles == null ? void 0 : styles.horizontalScrollBar,
    thumbStyle: styles == null ? void 0 : styles.horizontalScrollBarThumb,
    showScrollBar
  }));
}
var List2 = React176.forwardRef(RawList);
List2.displayName = "List";
var List_default2 = List2;

// node_modules/@rc-component/virtual-list/es/index.js
var es_default11 = List_default2;

// node_modules/@rc-component/select/es/OptionList.js
var React177 = __toESM(require_react());
var import_react82 = __toESM(require_react());

// node_modules/@rc-component/select/es/utils/platformUtil.js
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

// node_modules/@rc-component/select/es/OptionList.js
function _extends22() {
  _extends22 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends22.apply(this, arguments);
}
function isTitleType2(content) {
  return typeof content === "string" || typeof content === "number";
}
var OptionList = (_, ref) => {
  var _a, _b;
  const {
    prefixCls,
    id,
    open: open3,
    multiple,
    mode,
    searchValue,
    toggleOpen,
    notFoundContent,
    onPopupScroll,
    showScrollBar
  } = useBaseProps();
  const {
    maxCount,
    flattenOptions: flattenOptions2,
    onActiveValue,
    defaultActiveFirstOption,
    onSelect,
    menuItemSelectedIcon,
    rawValues,
    fieldNames,
    virtual,
    direction,
    listHeight,
    listItemHeight,
    optionRender,
    classNames: contextClassNames,
    styles: contextStyles
  } = React177.useContext(SelectContext_default);
  const itemPrefixCls = `${prefixCls}-item`;
  const memoFlattenOptions = useMemo(() => flattenOptions2, [open3, flattenOptions2], (prev2, next2) => next2[0] && prev2[1] !== next2[1]);
  const listRef = React177.useRef(null);
  const overMaxCount = React177.useMemo(() => multiple && isValidCount(maxCount) && (rawValues == null ? void 0 : rawValues.size) >= maxCount, [multiple, maxCount, rawValues == null ? void 0 : rawValues.size]);
  const onListMouseDown = (event) => {
    event.preventDefault();
  };
  const scrollIntoView = (args) => {
    var _a2;
    (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo(typeof args === "number" ? {
      index: args
    } : args);
  };
  const isSelected = React177.useCallback((value) => {
    if (mode === "combobox") {
      return false;
    }
    return rawValues.has(value);
  }, [mode, [...rawValues].toString(), rawValues.size]);
  const getEnabledActiveIndex = (index2, offset3 = 1) => {
    const len = memoFlattenOptions.length;
    for (let i = 0; i < len; i += 1) {
      const current = (index2 + i * offset3 + len) % len;
      const {
        group,
        data
      } = memoFlattenOptions[current] || {};
      if (!group && !(data == null ? void 0 : data.disabled) && (isSelected(data.value) || !overMaxCount)) {
        return current;
      }
    }
    return -1;
  };
  const [activeIndex, setActiveIndex] = React177.useState(() => getEnabledActiveIndex(0));
  const setActive = (index2, fromKeyboard = false) => {
    setActiveIndex(index2);
    const info = {
      source: fromKeyboard ? "keyboard" : "mouse"
    };
    const flattenItem = memoFlattenOptions[index2];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index2, info);
  };
  (0, import_react82.useEffect)(() => {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  const isAriaSelected = React177.useCallback((value) => {
    if (mode === "combobox") {
      return String(value).toLowerCase() === searchValue.toLowerCase();
    }
    return rawValues.has(value);
  }, [mode, searchValue, [...rawValues].toString(), rawValues.size]);
  (0, import_react82.useEffect)(() => {
    var _a2;
    let timeoutId;
    if (!multiple && open3 && rawValues.size === 1) {
      const value = Array.from(rawValues)[0];
      const index2 = memoFlattenOptions.findIndex(({
        data
      }) => searchValue ? String(data.value).startsWith(searchValue) : data.value === value);
      if (index2 !== -1) {
        setActive(index2);
        timeoutId = setTimeout(() => {
          scrollIntoView(index2);
        });
      }
    }
    if (open3) {
      (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo(void 0);
    }
    return () => clearTimeout(timeoutId);
  }, [open3, searchValue]);
  const onSelectValue = (value) => {
    if (value !== void 0) {
      onSelect(value, {
        selected: !rawValues.has(value)
      });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  };
  React177.useImperativeHandle(ref, () => ({
    onKeyDown: (event) => {
      const {
        which,
        ctrlKey
      } = event;
      switch (which) {
        case KeyCode_default.N:
        case KeyCode_default.P:
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset3 = 0;
          if (which === KeyCode_default.UP) {
            offset3 = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset3 = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode_default.N) {
              offset3 = 1;
            } else if (which === KeyCode_default.P) {
              offset3 = -1;
            }
          }
          if (offset3 !== 0) {
            const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
            scrollIntoView(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        case KeyCode_default.TAB:
        case KeyCode_default.ENTER: {
          const item = memoFlattenOptions[activeIndex];
          if (!item || item.data.disabled) {
            return onSelectValue(void 0);
          }
          if (!overMaxCount || rawValues.has(item.value)) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (open3) {
            event.preventDefault();
          }
          break;
        }
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open3) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    },
    scrollTo: (index2) => {
      scrollIntoView(index2);
    }
  }));
  if (memoFlattenOptions.length === 0) {
    return React177.createElement("div", {
      role: "listbox",
      id: `${id}_list`,
      className: `${itemPrefixCls}-empty`,
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  const omitFieldNameList = Object.keys(fieldNames).map((key) => fieldNames[key]);
  const getLabel = (item) => item.label;
  function getItemAriaProps(item, index2) {
    const {
      group
    } = item;
    return {
      role: group ? "presentation" : "option",
      id: `${id}_list_${index2}`
    };
  }
  const renderItem2 = (index2) => {
    const item = memoFlattenOptions[index2];
    if (!item) {
      return null;
    }
    const itemData = item.data || {};
    const {
      value
    } = itemData;
    const {
      group
    } = item;
    const attrs = pickAttrs(itemData, true);
    const mergedLabel = getLabel(item);
    return item ? React177.createElement("div", _extends22({
      "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
    }, attrs, {
      key: index2
    }, getItemAriaProps(item, index2), {
      "aria-selected": isAriaSelected(value)
    }), value) : null;
  };
  const a11yProps = {
    role: "listbox",
    id: `${id}_list`
  };
  return React177.createElement(React177.Fragment, null, virtual && React177.createElement("div", _extends22({}, a11yProps, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), renderItem2(activeIndex - 1), renderItem2(activeIndex), renderItem2(activeIndex + 1)), React177.createElement(es_default11, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual,
    direction,
    innerProps: virtual ? null : a11yProps,
    showScrollBar,
    className: (_a = contextClassNames == null ? void 0 : contextClassNames.popup) == null ? void 0 : _a.list,
    style: (_b = contextStyles == null ? void 0 : contextStyles.popup) == null ? void 0 : _b.list
  }, (item, itemIndex) => {
    var _a2, _b2;
    const {
      group,
      groupOption,
      data,
      label,
      value
    } = item;
    const {
      key
    } = data;
    if (group) {
      const groupTitle = data.title ?? (isTitleType2(label) ? label.toString() : void 0);
      return React177.createElement("div", {
        className: clsx(itemPrefixCls, `${itemPrefixCls}-group`, data.className),
        title: groupTitle
      }, label !== void 0 ? label : key);
    }
    const {
      disabled,
      title,
      children,
      style: style2,
      className,
      ...otherProps
    } = data;
    const passedProps = omit(otherProps, omitFieldNameList);
    const selected = isSelected(value);
    const mergedDisabled = disabled || !selected && overMaxCount;
    const optionPrefixCls = `${itemPrefixCls}-option`;
    const optionClassName = clsx(itemPrefixCls, optionPrefixCls, className, (_a2 = contextClassNames == null ? void 0 : contextClassNames.popup) == null ? void 0 : _a2.listItem, {
      [`${optionPrefixCls}-grouped`]: groupOption,
      [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
      [`${optionPrefixCls}-disabled`]: mergedDisabled,
      [`${optionPrefixCls}-selected`]: selected
    });
    const mergedLabel = getLabel(item);
    const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
    const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
    let optionTitle = isTitleType2(content) ? content.toString() : void 0;
    if (title !== void 0) {
      optionTitle = title;
    }
    return React177.createElement("div", _extends22({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
      "aria-selected": virtual ? void 0 : isAriaSelected(value),
      className: optionClassName,
      title: optionTitle,
      onMouseMove: () => {
        if (activeIndex === itemIndex || mergedDisabled) {
          return;
        }
        setActive(itemIndex);
      },
      onClick: () => {
        if (!mergedDisabled) {
          onSelectValue(value);
        }
      },
      style: {
        ...(_b2 = contextStyles == null ? void 0 : contextStyles.popup) == null ? void 0 : _b2.listItem,
        ...style2
      }
    }), React177.createElement("div", {
      className: `${optionPrefixCls}-content`
    }, typeof optionRender === "function" ? optionRender(item, {
      index: itemIndex
    }) : content), React177.isValidElement(menuItemSelectedIcon) || selected, iconVisible && React177.createElement(TransBtn_default, {
      className: `${itemPrefixCls}-option-state`,
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        value,
        disabled: mergedDisabled,
        isSelected: selected
      }
    }, selected ? "" : null));
  }));
};
var RefOptionList = React177.forwardRef(OptionList);
if (true) {
  RefOptionList.displayName = "OptionList";
}
var OptionList_default = RefOptionList;

// node_modules/@rc-component/select/es/hooks/useCache.js
var React178 = __toESM(require_react());
var useCache_default = (labeledValues, valueOptions) => {
  const cacheRef = React178.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  const filledLabeledValues = React178.useMemo(() => {
    const {
      values: prevValueCache,
      options: prevOptionCache
    } = cacheRef.current;
    const patchedValues = labeledValues.map((item) => {
      var _a;
      if (item.label === void 0) {
        return {
          ...item,
          label: (_a = prevValueCache.get(item.value)) == null ? void 0 : _a.label
        };
      }
      return item;
    });
    const valueCache = /* @__PURE__ */ new Map();
    const optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach((item) => {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  const getOption = React178.useCallback((val) => valueOptions.get(val) || cacheRef.current.options.get(val), [valueOptions]);
  return [filledLabeledValues, getOption];
};

// node_modules/@rc-component/select/es/hooks/useFilterOptions.js
var React179 = __toESM(require_react());
function includes(test, search) {
  return toArray4(test).join("").toUpperCase().includes(search);
}
var useFilterOptions_default = (options, fieldNames, searchValue, filterOption2, optionFilterProp) => {
  return React179.useMemo(() => {
    if (!searchValue || filterOption2 === false) {
      return options;
    }
    const {
      options: fieldOptions,
      label: fieldLabel,
      value: fieldValue
    } = fieldNames;
    const filteredOptions = [];
    const customizeFilter = typeof filterOption2 === "function";
    const upperSearch = searchValue.toUpperCase();
    const filterFunc = customizeFilter ? filterOption2 : (_, option) => {
      if (optionFilterProp && optionFilterProp.length) {
        return optionFilterProp.some((prop) => includes(option[prop], upperSearch));
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
    options.forEach((item) => {
      if (item[fieldOptions]) {
        const matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValue, wrapOption(subItem)));
          if (subOptions.length) {
            filteredOptions.push({
              ...item,
              [fieldOptions]: subOptions
            });
          }
        }
        return;
      }
      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption2, optionFilterProp, searchValue, fieldNames]);
};

// node_modules/@rc-component/select/es/hooks/useOptions.js
var React181 = __toESM(require_react());

// node_modules/@rc-component/select/es/utils/legacyUtil.js
var React180 = __toESM(require_react());
function convertNodeToOption(node2) {
  const {
    key,
    props: {
      children,
      value,
      ...restProps
    }
  } = node2;
  return {
    key,
    value: value !== void 0 ? value : key,
    children,
    ...restProps
  };
}
function convertChildrenToData(nodes, optionOnly = false) {
  return toArray(nodes).map((node2, index2) => {
    if (!React180.isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      type: {
        isSelectOptGroup
      },
      key,
      props: {
        children,
        ...restProps
      }
    } = node2;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node2);
    }
    return {
      key: `__RC_SELECT_GRP__${key === null ? index2 : key}__`,
      label: key,
      ...restProps,
      options: convertChildrenToData(children)
    };
  }).filter((data) => data);
}

// node_modules/@rc-component/select/es/hooks/useOptions.js
var useOptions = (options, children, fieldNames, optionFilterProp, optionLabelProp) => {
  return React181.useMemo(() => {
    let mergedOptions = options;
    const childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    const valueOptions = /* @__PURE__ */ new Map();
    const labelOptions = /* @__PURE__ */ new Map();
    const setLabelOptions = (labelOptionsMap, option, key) => {
      if (key && typeof key === "string") {
        labelOptionsMap.set(option[key], option);
      }
    };
    const dig = (optionList, isChildren = false) => {
      for (let i = 0; i < optionList.length; i += 1) {
        const option = optionList[i];
        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          optionFilterProp.forEach((prop) => {
            setLabelOptions(labelOptions, option, prop);
          });
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    };
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
};
var useOptions_default = useOptions;

// node_modules/@rc-component/select/es/hooks/useRefFunc.js
var React182 = __toESM(require_react());
function useRefFunc(callback) {
  const funcRef = React182.useRef();
  funcRef.current = callback;
  const cacheFn = React182.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}

// node_modules/@rc-component/select/es/utils/warningPropsUtil.js
var React183 = __toESM(require_react());
function warningProps(props) {
  const {
    mode,
    options,
    children,
    backfill,
    allowClear,
    placeholder,
    getInputElement,
    showSearch,
    onSearch,
    defaultOpen,
    autoFocus,
    labelInValue,
    value,
    optionLabelProp
  } = props;
  const multiple = isMultiple(mode);
  const mergedShowSearch = showSearch !== void 0 ? showSearch : multiple || mode === "combobox";
  const mergedOptions = options || convertChildrenToData(children);
  warning_default(mode !== "tags" || mergedOptions.every((opt) => !opt.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag.");
  if (mode === "tags" || mode === "combobox") {
    const hasNumberValue = mergedOptions.some((item) => {
      if (item.options) {
        return item.options.some((opt) => typeof ("value" in opt ? opt.value : opt.key) === "number");
      }
      return typeof ("value" in item ? item.value : item.key) === "number";
    });
    warning_default(!hasNumberValue, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  warning_default(mode !== "combobox" || !optionLabelProp, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.");
  warning_default(mode === "combobox" || !backfill, "`backfill` only works with `combobox` mode.");
  warning_default(mode === "combobox" || !getInputElement, "`getInputElement` only work with `combobox` mode.");
  noteOnce(mode !== "combobox" || !getInputElement || !allowClear || !placeholder, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.");
  if (onSearch && !mergedShowSearch && mode !== "combobox" && mode !== "tags") {
    warning_default(false, "`onSearch` should work with `showSearch` instead of use alone.");
  }
  noteOnce(!defaultOpen || autoFocus, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.");
  if (value !== void 0 && value !== null) {
    const values = toArray4(value);
    warning_default(!labelInValue || values.every((val) => typeof val === "object" && ("key" in val || "value" in val)), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`");
    warning_default(!multiple || Array.isArray(value), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (children) {
    let invalidateChildType = null;
    toArray(children).some((node2) => {
      if (!React183.isValidElement(node2) || !node2.type) {
        return false;
      }
      const {
        type: type5
      } = node2;
      if (type5.isSelectOption) {
        return false;
      }
      if (type5.isSelectOptGroup) {
        const allChildrenValid = toArray(node2.props.children).every((subNode) => {
          if (!React183.isValidElement(subNode) || !node2.type || subNode.type.isSelectOption) {
            return true;
          }
          invalidateChildType = subNode.type;
          return false;
        });
        if (allChildrenValid) {
          return false;
        }
        return true;
      }
      invalidateChildType = type5;
      return true;
    });
    if (invalidateChildType) {
      warning_default(false, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${invalidateChildType.displayName || invalidateChildType.name || invalidateChildType}\`.`);
    }
  }
}
function warningNullOptions(options, fieldNames) {
  if (options) {
    const recursiveOptions = (optionsList, inGroup = false) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames == null ? void 0 : fieldNames.value] === null) {
          warning_default(false, "`value` in Select options should not be `null`.");
          return true;
        }
        if (!inGroup && Array.isArray(option[fieldNames == null ? void 0 : fieldNames.options]) && recursiveOptions(option[fieldNames == null ? void 0 : fieldNames.options], true)) {
          break;
        }
      }
    };
    recursiveOptions(options);
  }
}
var warningPropsUtil_default = warningProps;

// node_modules/@rc-component/select/es/hooks/useSearchConfig.js
var React184 = __toESM(require_react());
function useSearchConfig(showSearch, props, mode) {
  const {
    filterOption: filterOption2,
    searchValue,
    optionFilterProp,
    filterSort,
    onSearch,
    autoClearSearchValue
  } = props;
  return React184.useMemo(() => {
    const isObject2 = typeof showSearch === "object";
    const searchConfig = {
      filterOption: filterOption2,
      searchValue,
      optionFilterProp,
      filterSort,
      onSearch,
      autoClearSearchValue,
      ...isObject2 ? showSearch : {}
    };
    return [isObject2 || mode === "combobox" || mode === "tags" || mode === "multiple" && showSearch === void 0 ? true : showSearch, searchConfig];
  }, [mode, showSearch, filterOption2, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue]);
}

// node_modules/@rc-component/select/es/Select.js
function _extends23() {
  _extends23 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends23.apply(this, arguments);
}
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value) {
  return !value || typeof value !== "object";
}
var Select = React185.forwardRef((props, ref) => {
  const {
    id,
    mode,
    prefixCls = "rc-select",
    backfill,
    fieldNames,
    // Search
    showSearch,
    searchValue: legacySearchValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterOption: legacyFilterOption,
    optionFilterProp: legacyOptionFilterProp,
    filterSort: legacyFilterSort,
    // Select
    onSelect,
    onDeselect,
    onActive,
    popupMatchSelectWidth = true,
    optionLabelProp,
    options,
    optionRender,
    children,
    defaultActiveFirstOption,
    menuItemSelectedIcon,
    virtual,
    direction,
    listHeight = 200,
    listItemHeight = 20,
    labelRender,
    // Value
    value,
    defaultValue,
    labelInValue,
    onChange,
    maxCount,
    classNames,
    styles,
    ...restProps
  } = props;
  const searchProps = {
    searchValue: legacySearchValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterOption: legacyFilterOption,
    optionFilterProp: legacyOptionFilterProp,
    filterSort: legacyFilterSort
  };
  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps, mode);
  const {
    filterOption: filterOption2,
    searchValue,
    optionFilterProp,
    filterSort,
    onSearch,
    autoClearSearchValue = true
  } = searchConfig;
  const normalizedOptionFilterProp = React185.useMemo(() => {
    if (!optionFilterProp)
      return [];
    return Array.isArray(optionFilterProp) ? optionFilterProp : [optionFilterProp];
  }, [optionFilterProp]);
  const mergedId = useId_default(id);
  const multiple = isMultiple(mode);
  const childrenAsData = !!(!options && children);
  const mergedFilterOption = React185.useMemo(() => {
    if (filterOption2 === void 0 && mode === "combobox") {
      return false;
    }
    return filterOption2;
  }, [filterOption2, mode]);
  const mergedFieldNames = React185.useMemo(
    () => fillFieldNames(fieldNames, childrenAsData),
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(fieldNames),
      childrenAsData
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const parsedOptions = useOptions_default(options, children, mergedFieldNames, normalizedOptionFilterProp, optionLabelProp);
  const {
    valueOptions,
    labelOptions,
    options: mergedOptions
  } = parsedOptions;
  const convert2LabelValues = React185.useCallback((draftValues) => {
    const valueList = toArray4(draftValues);
    return valueList.map((val) => {
      let rawValue;
      let rawLabel;
      let rawDisabled;
      let rawTitle;
      if (isRawValue(val)) {
        rawValue = val;
      } else {
        rawLabel = val.label;
        rawValue = val.value;
      }
      const option = valueOptions.get(rawValue);
      if (option) {
        if (rawLabel === void 0)
          rawLabel = option == null ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        rawDisabled = option == null ? void 0 : option.disabled;
        rawTitle = option == null ? void 0 : option.title;
        if (!optionLabelProp) {
          const optionLabel = option == null ? void 0 : option[mergedFieldNames.label];
          if (optionLabel !== void 0 && !React185.isValidElement(optionLabel) && !React185.isValidElement(rawLabel) && optionLabel !== rawLabel) {
            warning_default(false, "`label` of `value` is not same as `label` in Select options.");
          }
        }
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawValue,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]);
  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
  const rawLabeledValues = React185.useMemo(() => {
    var _a;
    const newInternalValue = multiple && internalValue === null ? [] : internalValue;
    const values = convert2LabelValues(newInternalValue);
    if (mode === "combobox" && isComboNoValue((_a = values[0]) == null ? void 0 : _a.value)) {
      return [];
    }
    return values;
  }, [internalValue, convert2LabelValues, mode, multiple]);
  const [mergedValues, getMixedOption] = useCache_default(rawLabeledValues, valueOptions);
  const displayValues = React185.useMemo(() => {
    if (!mode && mergedValues.length === 1) {
      const firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
        return [];
      }
    }
    return mergedValues.map((item) => ({
      ...item,
      label: (typeof labelRender === "function" ? labelRender(item) : item.label) ?? item.value
    }));
  }, [mode, mergedValues, labelRender]);
  const rawValues = React185.useMemo(() => new Set(mergedValues.map((val) => val.value)), [mergedValues]);
  React185.useEffect(() => {
    var _a;
    if (mode === "combobox") {
      const strValue = (_a = mergedValues[0]) == null ? void 0 : _a.value;
      setSearchValue(hasValue(strValue) ? String(strValue) : "");
    }
  }, [mergedValues]);
  const createTagOption = useRefFunc((val, label) => {
    const mergedLabel = label ?? val;
    return {
      [mergedFieldNames.value]: val,
      [mergedFieldNames.label]: mergedLabel
    };
  });
  const filledTagOptions = React185.useMemo(() => {
    if (mode !== "tags") {
      return mergedOptions;
    }
    const cloneOptions = [...mergedOptions];
    const existOptions = (val) => valueOptions.has(val);
    [...mergedValues].sort((a, b) => a.value < b.value ? -1 : 1).forEach((item) => {
      const val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  const filteredOptions = useFilterOptions_default(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, normalizedOptionFilterProp);
  const filledSearchOptions = React185.useMemo(() => {
    const hasItemMatchingSearch = (item) => {
      if (normalizedOptionFilterProp.length) {
        return normalizedOptionFilterProp.some((prop) => (item == null ? void 0 : item[prop]) === mergedSearchValue);
      }
      return (item == null ? void 0 : item.value) === mergedSearchValue;
    };
    if (mode !== "tags" || !mergedSearchValue || filteredOptions.some((item) => hasItemMatchingSearch(item))) {
      return filteredOptions;
    }
    if (filteredOptions.some((item) => item[mergedFieldNames.value] === mergedSearchValue)) {
      return filteredOptions;
    }
    return [createTagOption(mergedSearchValue), ...filteredOptions];
  }, [createTagOption, normalizedOptionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
  const sorter = (inputOptions) => {
    const sortedOptions = [...inputOptions].sort((a, b) => filterSort(a, b, {
      searchValue: mergedSearchValue
    }));
    return sortedOptions.map((item) => {
      if (Array.isArray(item.options)) {
        return {
          ...item,
          options: item.options.length > 0 ? sorter(item.options) : item.options
        };
      }
      return item;
    });
  };
  const orderedFilteredOptions = React185.useMemo(() => {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return sorter(filledSearchOptions);
  }, [filledSearchOptions, filterSort, mergedSearchValue]);
  const displayOptions = React185.useMemo(() => flattenOptions(orderedFilteredOptions, {
    fieldNames: mergedFieldNames,
    childrenAsData
  }), [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
  const triggerChange = (values) => {
    const labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);
    if (onChange && // Trigger event only when value changed
    (labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index2) => {
      var _a;
      return ((_a = mergedValues[index2]) == null ? void 0 : _a.value) !== (newVal == null ? void 0 : newVal.value);
    }))) {
      const returnValues = labelInValue ? labeledValues.map(({
        label: l2,
        value: v
      }) => ({
        label: l2,
        value: v
      })) : labeledValues.map((v) => v.value);
      const returnOptions = labeledValues.map((v) => injectPropsWithOption(getMixedOption(v.value)));
      onChange(
        // Value
        multiple ? returnValues : returnValues[0],
        // Option
        multiple ? returnOptions : returnOptions[0]
      );
    }
  };
  const [activeValue, setActiveValue] = React185.useState(null);
  const [accessibilityIndex, setAccessibilityIndex] = React185.useState(0);
  const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
  const activeEventRef = React185.useRef();
  const onActiveValue = React185.useCallback((active, index2, {
    source = "keyboard"
  } = {}) => {
    setAccessibilityIndex(index2);
    if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
      setActiveValue(String(active));
    }
    const promise = Promise.resolve().then(() => {
      if (activeEventRef.current === promise) {
        onActive == null ? void 0 : onActive(active);
      }
    });
    activeEventRef.current = promise;
  }, [backfill, mode, onActive]);
  const triggerSelect = (val, selected, type5) => {
    const getSelectEnt = () => {
      const option = getMixedOption(val);
      return [labelInValue ? {
        label: option == null ? void 0 : option[mergedFieldNames.label],
        value: val
      } : val, injectPropsWithOption(option)];
    };
    if (selected && onSelect) {
      const [wrappedValue, option] = getSelectEnt();
      onSelect(wrappedValue, option);
    } else if (!selected && onDeselect && type5 !== "clear") {
      const [wrappedValue, option] = getSelectEnt();
      onDeselect(wrappedValue, option);
    }
  };
  const onInternalSelect = useRefFunc((val, info) => {
    let cloneValues;
    const mergedSelect = multiple ? info.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [...mergedValues, val] : [val];
    } else {
      cloneValues = mergedValues.filter((v) => v.value !== val);
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect);
    if (mode === "combobox") {
      setActiveValue("");
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue("");
      setActiveValue("");
    }
  });
  const onDisplayValuesChange = (nextValues, info) => {
    triggerChange(nextValues);
    const {
      type: type5,
      values
    } = info;
    if (type5 === "remove" || type5 === "clear") {
      values.forEach((item) => {
        triggerSelect(item.value, false, type5);
      });
    }
  };
  const onInternalSearch = (searchText, info) => {
    setSearchValue(searchText);
    setActiveValue(null);
    if (info.source === "submit") {
      const formatted = (searchText || "").trim();
      if (formatted) {
        const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, formatted]));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue("");
      }
      return;
    }
    if (info.source !== "blur") {
      if (mode === "combobox") {
        triggerChange(searchText);
      }
      onSearch == null ? void 0 : onSearch(searchText);
    }
  };
  const onInternalSearchSplit = (words) => {
    let patchValues = words;
    if (mode !== "tags") {
      patchValues = words.map((word) => {
        const opt = labelOptions.get(word);
        return opt == null ? void 0 : opt.value;
      }).filter((val) => val !== void 0);
    }
    const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues, ...patchValues]));
    triggerChange(newRawValues);
    newRawValues.forEach((newRawValue) => {
      triggerSelect(newRawValue, true);
    });
  };
  const selectContext = React185.useMemo(() => {
    const realVirtual = virtual !== false && popupMatchSelectWidth !== false;
    return {
      ...parsedOptions,
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      direction,
      listHeight,
      listItemHeight,
      childrenAsData,
      maxCount,
      optionRender,
      classNames,
      styles
    };
  }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, popupMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender, classNames, styles]);
  if (true) {
    warningPropsUtil_default(props);
    warningNullOptions(mergedOptions, mergedFieldNames);
  }
  return React185.createElement(SelectContext_default.Provider, {
    value: selectContext
  }, React185.createElement(BaseSelect_default, _extends23({}, restProps, {
    // >>> MISC
    id: mergedId,
    prefixCls,
    ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    classNames,
    styles,
    displayValues,
    onDisplayValuesChange,
    maxCount,
    direction,
    showSearch: mergedShowSearch,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    autoClearSearchValue,
    onSearchSplit: onInternalSearchSplit,
    popupMatchSelectWidth,
    OptionList: OptionList_default,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
  })));
});
if (true) {
  Select.displayName = "Select";
}
var TypedSelect = Select;
TypedSelect.Option = Option_default;
TypedSelect.OptGroup = OptGroup_default;
var Select_default = TypedSelect;

// node_modules/@rc-component/select/es/index.js
var es_default12 = Select_default;

// node_modules/antd/es/_util/statusUtils.js
var getStatusClassNames = (prefixCls, status, hasFeedback) => {
  return clsx({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
};
var getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

// node_modules/antd/es/config-provider/defaultRenderEmpty.js
var import_react84 = __toESM(require_react());

// node_modules/antd/es/empty/index.js
var React188 = __toESM(require_react());

// node_modules/antd/es/empty/empty.js
var React186 = __toESM(require_react());
var Empty = () => {
  const [, token2] = useToken();
  const [locale6] = useLocale_default("Empty");
  const bgColor = new FastColor(token2.colorBgBase);
  const themeStyle = bgColor.toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return React186.createElement("svg", {
    style: themeStyle,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, React186.createElement("title", null, (locale6 == null ? void 0 : locale6.description) || "Empty"), React186.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, React186.createElement("g", {
    transform: "translate(24 31.67)"
  }, React186.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), React186.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), React186.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), React186.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), React186.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), React186.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), React186.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, React186.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), React186.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
if (true) {
  Empty.displayName = "EmptyImage";
}
var empty_default = Empty;

// node_modules/antd/es/empty/simple.js
var React187 = __toESM(require_react());
var import_react83 = __toESM(require_react());
var Simple = () => {
  const [, token2] = useToken();
  const [locale6] = useLocale_default("Empty");
  const {
    colorFill,
    colorFillTertiary,
    colorFillQuaternary,
    colorBgContainer
  } = token2;
  const {
    borderColor,
    shadowColor,
    contentColor
  } = (0, import_react83.useMemo)(() => ({
    borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
    shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
    contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
  }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
  return React187.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, React187.createElement("title", null, (locale6 == null ? void 0 : locale6.description) || "Empty"), React187.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, React187.createElement("ellipse", {
    fill: shadowColor,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), React187.createElement("g", {
    fillRule: "nonzero",
    stroke: borderColor
  }, React187.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), React187.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: contentColor
  }))));
};
if (true) {
  Simple.displayName = "SimpleImage";
}
var simple_default = Simple;

// node_modules/antd/es/empty/style/index.js
var genSharedEmptyStyle = (token2) => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      //  &-image  hashId
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${componentCls}-description`]: {
        color: token2.colorTextDescription
      },
      //  &-footer  hashId
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDescription,
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDescription,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
};
var style_default12 = genStyleHooks("Empty", (token2) => {
  const {
    componentCls,
    controlHeightLG,
    calc
  } = token2;
  const emptyToken = merge2(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
  });
  return genSharedEmptyStyle(emptyToken);
});

// node_modules/antd/es/empty/index.js
var defaultEmptyImg = React188.createElement(empty_default, null);
var simpleEmptyImg = React188.createElement(simple_default, null);
var Empty2 = (props) => {
  const {
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    image,
    description,
    children,
    imageStyle,
    style: style2,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    image: contextImage
  } = useComponentConfig("empty");
  const prefixCls = getPrefixCls("empty", customizePrefixCls);
  const [hashId, cssVarCls] = style_default12(prefixCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const [locale6] = useLocale_default("Empty");
  const des = typeof description !== "undefined" ? description : locale6 == null ? void 0 : locale6.description;
  const alt = typeof des === "string" ? des : "empty";
  const mergedImage = image ?? contextImage ?? defaultEmptyImg;
  let imageNode = null;
  if (typeof mergedImage === "string") {
    imageNode = React188.createElement("img", {
      draggable: false,
      alt,
      src: mergedImage
    });
  } else {
    imageNode = mergedImage;
  }
  if (true) {
    const warning5 = devUseWarning("Empty");
    [["imageStyle", "styles.image"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return React188.createElement("div", {
    className: clsx(hashId, cssVarCls, prefixCls, contextClassName, {
      [`${prefixCls}-normal`]: mergedImage === simpleEmptyImg,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, mergedClassNames.root),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    ...restProps
  }, React188.createElement("div", {
    className: clsx(`${prefixCls}-image`, mergedClassNames.image),
    style: {
      ...imageStyle,
      ...mergedStyles.image
    }
  }, imageNode), des && React188.createElement("div", {
    className: clsx(`${prefixCls}-description`, mergedClassNames.description),
    style: mergedStyles.description
  }, des), children && React188.createElement("div", {
    className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
    style: mergedStyles.footer
  }, children));
};
Empty2.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty2.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
if (true) {
  Empty2.displayName = "Empty";
}
var empty_default2 = Empty2;

// node_modules/antd/es/config-provider/defaultRenderEmpty.js
var DefaultRenderEmpty = (props) => {
  const {
    componentName
  } = props;
  const {
    getPrefixCls
  } = (0, import_react84.useContext)(ConfigContext);
  const prefix2 = getPrefixCls("empty");
  switch (componentName) {
    case "Table":
    case "List":
      return import_react84.default.createElement(empty_default2, {
        image: empty_default2.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return import_react84.default.createElement(empty_default2, {
        image: empty_default2.PRESENTED_IMAGE_SIMPLE,
        className: `${prefix2}-small`
      });
    case "Table.filter":
      return null;
    default:
      return import_react84.default.createElement(empty_default2, null);
  }
};
var defaultRenderEmpty_default = DefaultRenderEmpty;

// node_modules/antd/es/form/hooks/useVariants.js
var React190 = __toESM(require_react());
var useVariant = (component, variant, legacyBordered) => {
  const {
    variant: configVariant,
    [component]: componentConfig
  } = React190.useContext(ConfigContext);
  const ctxVariant = React190.useContext(VariantContext);
  const configComponentVariant = componentConfig == null ? void 0 : componentConfig.variant;
  let mergedVariant;
  if (typeof variant !== "undefined") {
    mergedVariant = variant;
  } else if (legacyBordered === false) {
    mergedVariant = "borderless";
  } else {
    mergedVariant = ctxVariant ?? configComponentVariant ?? configVariant ?? "outlined";
  }
  const enableVariantCls = Variants.includes(mergedVariant);
  return [mergedVariant, enableVariantCls];
};
var useVariants_default = useVariant;

// node_modules/antd/es/select/mergedBuiltinPlacements.js
var getBuiltInPlacements2 = (popupOverflow) => {
  const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
  const sharedConfig = {
    overflow: {
      adjustX: true,
      adjustY: true,
      shiftY: true
    },
    htmlRegion,
    dynamicInset: true
  };
  return {
    bottomLeft: {
      ...sharedConfig,
      points: ["tl", "bl"],
      offset: [0, 4]
    },
    bottomRight: {
      ...sharedConfig,
      points: ["tr", "br"],
      offset: [0, 4]
    },
    topLeft: {
      ...sharedConfig,
      points: ["bl", "tl"],
      offset: [0, -4]
    },
    topRight: {
      ...sharedConfig,
      points: ["br", "tr"],
      offset: [0, -4]
    }
  };
};
function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
  return buildInPlacements || getBuiltInPlacements2(popupOverflow);
}
var mergedBuiltinPlacements_default = mergedBuiltinPlacements;

// node_modules/antd/es/select/style/dropdown.js
var genItemStyle = (token2) => {
  const {
    optionHeight,
    optionFontSize,
    optionLineHeight,
    optionPadding
  } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: optionHeight,
    padding: optionPadding,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: optionFontSize,
    lineHeight: optionLineHeight,
    boxSizing: "border-box"
  };
};
var genSingleStyle = (token2) => {
  const {
    antCls,
    componentCls
  } = token2;
  const selectItemCls = `${componentCls}-item`;
  const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
  const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
  const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
  const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
  const selectedItemCls = `${selectItemCls}-option-selected`;
  return [
    {
      [`${componentCls}-dropdown`]: {
        // ========================== Popup ==========================
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
          animationName: slideUpIn
        },
        [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownIn
        },
        [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
          animationName: slideUpOut
        },
        [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        [selectItemCls]: {
          ...genItemStyle(token2),
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": {
              flex: "auto",
              ...textEllipsis
            },
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.optionActiveBg
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.optionSelectedColor,
              fontWeight: token2.optionSelectedFontWeight,
              backgroundColor: token2.optionSelectedBg,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": {
            ...genItemStyle(token2),
            color: token2.colorTextDisabled
          }
        },
        // https://github.com/ant-design/ant-design/pull/46646
        [`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
          borderEndStartRadius: 0,
          borderEndEndRadius: 0,
          [`& + ${selectedItemCls}`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        },
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
var dropdown_default = genSingleStyle;

// node_modules/antd/es/select/style/select-input-customize.js
var genSelectInputCustomizeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-customize`]: {
      border: 0,
      padding: 0,
      fontSize: "inherit",
      lineHeight: "inherit",
      [`${componentCls}-placeholder`]: {
        display: "none"
      },
      [`${componentCls}-content`]: {
        margin: 0,
        padding: 0,
        "&-value": {
          display: "none"
        }
      }
    }
  };
};
var select_input_customize_default = genSelectInputCustomizeStyle;

// node_modules/antd/es/select/style/select-input-multiple.js
var FIXED_INPUT_MIN_WIDTH = 4;
var genSelectInputMultipleStyle = (token2) => {
  const {
    componentCls,
    calc,
    iconCls,
    paddingXS,
    paddingXXS,
    INTERNAL_FIXED_ITEM_MARGIN,
    lineWidth,
    colorIcon,
    colorIconHover,
    inputPaddingHorizontalBase
  } = token2;
  return {
    "&-multiple": {
      "--select-multi-item-background": token2.multipleItemBg,
      "--select-multi-item-border-color": "transparent",
      "--select-multi-item-border-radius": token2.borderRadiusSM,
      "--select-multi-item-height": token2.multipleItemHeight,
      "--select-multi-padding-base": `calc((var(--select-height) - var(--select-multi-item-height)) / 2)`,
      "--select-multi-padding-vertical": `calc(var(--select-multi-padding-base) - ${INTERNAL_FIXED_ITEM_MARGIN} - ${lineWidth})`,
      "--select-multi-item-padding-horizontal": `calc(${inputPaddingHorizontalBase} - var(--select-multi-padding-vertical) - ${lineWidth} * 2)`,
      // ========================================================
      // ==                        Base                        ==
      // ========================================================
      // ========================= Root =========================
      paddingBlock: `var(--select-multi-padding-vertical)`,
      paddingInlineStart: `calc(var(--select-multi-padding-base) - ${lineWidth})`,
      // ======================== Prefix ========================
      [`${componentCls}-prefix`]: {
        marginInlineStart: "var(--select-multi-item-padding-horizontal)"
      },
      [`${componentCls}-prefix + ${componentCls}-content`]: {
        [`${componentCls}-placeholder`]: {
          insetInlineStart: 0
        },
        [`${componentCls}-content-item${componentCls}-content-item-suffix`]: {
          marginInlineStart: 0
        }
      },
      // ===================== Placeholder ======================
      [`${componentCls}-placeholder`]: {
        position: "absolute",
        lineHeight: "var(--select-line-height)",
        insetInlineStart: "var(--select-multi-item-padding-horizontal)",
        width: "calc(100% - var(--select-multi-item-padding-horizontal))",
        top: "50%",
        transform: "translateY(-50%)"
      },
      // ======================= Content ========================
      [`${componentCls}-content`]: {
        flexWrap: "wrap",
        alignItems: "center",
        lineHeight: 1,
        "&-item-prefix": {
          height: "var(--select-font-size)"
        },
        "&-item": {
          lineHeight: 1,
          maxWidth: `calc(100% - ${FIXED_INPUT_MIN_WIDTH}px)`
        },
        [`${componentCls}-content-item-prefix + ${componentCls}-content-item-suffix,
          ${componentCls}-content-item-suffix:first-child`]: {
          marginInlineStart: "var(--select-multi-item-padding-horizontal)"
        },
        [`${componentCls}-selection-item`]: {
          lineHeight: `calc(var(--select-multi-item-height) - ${lineWidth} * 2)`,
          border: `${lineWidth} solid var(--select-multi-item-border-color)`,
          display: "flex",
          marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
          marginInlineEnd: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
          background: `var(--select-multi-item-background)`,
          borderRadius: `var(--select-multi-item-border-radius)`,
          paddingInlineStart: paddingXS,
          paddingInlineEnd: paddingXXS,
          transition: ["height", "line-height", "padding"].map((key) => `${key} ${token2.motionDurationSlow}`).join(","),
          // >>> Content
          "&-content": {
            ...textEllipsis,
            marginInlineEnd: paddingXXS
          },
          // >>> Remove
          "&-remove": {
            ...resetIcon(),
            display: "inline-flex",
            alignItems: "center",
            color: colorIcon,
            fontWeight: "bold",
            fontSize: 10,
            lineHeight: "inherit",
            cursor: "pointer",
            [`> ${iconCls}`]: {
              verticalAlign: "-0.2em"
            },
            "&:hover": {
              color: colorIconHover
            }
          }
        },
        [`${componentCls}-input`]: {
          lineHeight: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).add("var(--select-multi-item-height)").equal(),
          width: "calc(var(--select-input-width, 0) * 1px)",
          minWidth: FIXED_INPUT_MIN_WIDTH,
          maxWidth: "100%",
          transition: `line-height ${token2.motionDurationSlow}`
        }
      },
      // ========================================================
      // ==                        Size                        ==
      // ========================================================
      [`&${componentCls}-sm`]: {
        "--select-multi-item-height": token2.multipleItemHeightSM,
        "--select-multi-item-border-radius": token2.borderRadiusXS
      },
      [`&${componentCls}-lg`]: {
        "--select-multi-item-height": token2.multipleItemHeightLG,
        "--select-multi-item-border-radius": token2.borderRadius
      },
      // ========================================================
      // ==                      Variants                      ==
      // ========================================================
      [`&${componentCls}-filled`]: {
        "--select-multi-item-border-color": token2.colorSplit,
        "--select-multi-item-background": token2.colorBgContainer,
        [`&${componentCls}-disabled`]: {
          "--select-multi-item-border-color": "transparent"
        }
      }
    }
  };
};
var select_input_multiple_default = genSelectInputMultipleStyle;

// node_modules/antd/es/select/style/select-input.js
var genSelectInputVariableStyle = (token2, colors) => {
  const {
    componentCls
  } = token2;
  const {
    border,
    borderHover,
    borderActive,
    borderOutline
  } = colors;
  const baseBG = colors.background || token2.colorBgContainer;
  return {
    "--select-border-color": border,
    "--select-background": baseBG,
    "--select-color": colors.color || token2.colorText,
    [`&:not(${componentCls}-disabled)`]: {
      "&:hover": {
        "--select-border-color": borderHover,
        "--select-background": colors.backgroundHover || baseBG
      },
      [`&${componentCls}-focused`]: {
        "--select-border-color": borderActive,
        "--select-background": colors.backgroundActive || baseBG,
        boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${borderOutline}`
      }
    },
    [`&${componentCls}-disabled`]: {
      "--select-border-color": colors.borderDisabled || colors.border,
      "--select-background": colors.backgroundDisabled || colors.background
    }
  };
};
var genSelectInputVariantStyle = (token2, variant, colors, errorColors = {}, warningColors = {}, patchStyle) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-${variant}`]: [genSelectInputVariableStyle(token2, colors), {
      [`&${componentCls}-status-error`]: genSelectInputVariableStyle(token2, {
        ...colors,
        color: errorColors.color || token2.colorError,
        ...errorColors
      }),
      [`&${componentCls}-status-warning`]: genSelectInputVariableStyle(token2, {
        ...colors,
        color: warningColors.color || token2.colorWarning,
        ...warningColors
      })
    }, patchStyle]
  };
};
var genSelectInputStyle = (token2) => {
  const {
    componentCls,
    calc,
    fontHeight,
    controlHeight,
    iconCls
  } = token2;
  return {
    [componentCls]: [
      {
        // Border
        "--select-border-radius": token2.borderRadius,
        "--select-border-color": "#000",
        "--select-border-size": token2.lineWidth,
        // Background
        "--select-background": token2.colorBgContainer,
        // Font
        "--select-font-size": token2.fontSize,
        "--select-line-height": token2.lineHeight,
        "--select-font-height": fontHeight,
        "--select-color": token2.colorText,
        // Size
        "--select-height": controlHeight,
        "--select-padding-horizontal": calc(token2.paddingSM).sub(token2.lineWidth).equal(),
        "--select-padding-vertical": "calc((var(--select-height) - var(--select-font-height)) / 2 - var(--select-border-size))",
        // ==========================================================
        // ==                         Base                         ==
        // ==========================================================
        ...resetComponent(token2, true),
        display: "inline-flex",
        // gap: calc(token.paddingXXS).mul(1.5).equal(),
        flexWrap: "nowrap",
        position: "relative",
        transition: `all ${token2.motionDurationSlow}`,
        alignItems: "flex-start",
        outline: 0,
        cursor: "pointer",
        // Border
        borderRadius: "var(--select-border-radius)",
        borderWidth: "var(--select-border-size)",
        borderStyle: token2.lineType,
        borderColor: "var(--select-border-color)",
        // Background
        background: "var(--select-background)",
        // Font
        fontSize: "var(--select-font-size)",
        lineHeight: "var(--select-line-height)",
        color: "var(--select-color)",
        // Padding
        paddingInline: "var(--select-padding-horizontal)",
        paddingBlock: "var(--select-padding-vertical)",
        // ========================= Prefix =========================
        [`${componentCls}-prefix`]: {
          flex: "none",
          lineHeight: 1
        },
        // ====================== Placeholder =======================
        [`${componentCls}-placeholder`]: {
          ...textEllipsis,
          color: token2.colorTextPlaceholder,
          pointerEvents: "none",
          zIndex: 1
        },
        // ======================== Content =========================
        [`${componentCls}-content`]: {
          flex: "auto",
          minWidth: 0,
          position: "relative",
          display: "flex",
          marginInlineEnd: calc(token2.paddingXXS).mul(1.5).equal(),
          "&:before": {
            content: '"\\a0"',
            width: 0,
            overflow: "hidden"
          },
          // >>> Value
          "&-value": {
            ...textEllipsis,
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
            zIndex: 1
          },
          // >>> Input: should only take effect for not customize mode
          // input element with readOnly use cursor pointer
          "input[readonly]": {
            cursor: "inherit",
            caretColor: "transparent"
          }
        },
        [`&-open ${componentCls}-content-value`]: {
          color: token2.colorTextPlaceholder
        },
        // ========================= Suffix =========================
        [`${componentCls}-suffix`]: {
          flex: "none",
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          "> :not(:last-child)": {
            marginInlineEnd: token2.marginXS
          }
        },
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          alignSelf: "center",
          [iconCls]: {
            verticalAlign: "top"
          }
        },
        // ==========================================================
        // ==                       Disabled                       ==
        // ==========================================================
        "&-disabled": {
          background: token2.colorBgContainerDisabled,
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        // ==========================================================
        // ==                         Size                         ==
        // ==========================================================
        "&-sm": {
          "--select-height": token2.controlHeightSM,
          "--select-padding-horizontal": calc(token2.paddingXS).sub(token2.lineWidth).equal(),
          "--select-border-radius": token2.borderRadiusSM
        },
        "&-lg": {
          "--select-height": token2.controlHeightLG,
          "--select-font-size": token2.fontSizeLG,
          "--select-line-height": token2.lineHeightLG,
          "--select-font-height": token2.fontHeightLG,
          "--select-border-radius": token2.borderRadiusLG
        }
      },
      // ============================================================
      // ==                         Input                          ==
      // ============================================================
      {
        [`&:not(${componentCls}-customize)`]: {
          [`${componentCls}-input`]: {
            outline: "none",
            background: "transparent",
            appearance: "none",
            border: 0,
            margin: 0,
            padding: 0,
            color: "inherit",
            "&::-webkit-search-cancel-button": {
              display: "none",
              appearance: "none"
            }
          }
        }
      },
      // ============================================================
      // ==                         Single                         ==
      // ============================================================
      {
        [`&-single:not(${componentCls}-customize)`]: {
          [`${componentCls}-input`]: {
            position: "absolute",
            insetInline: 0,
            insetBlock: "calc(var(--select-padding-vertical) * -1)",
            lineHeight: "calc(var(--select-font-height) + var(--select-padding-vertical) * 2)"
          },
          // Content center align
          [`${componentCls}-content`]: {
            alignSelf: "center"
          }
        }
      },
      // ============================================================
      // ==                        Multiple                        ==
      // ============================================================
      select_input_multiple_default(token2),
      // ========================= Variant ==========================
      // >>> Outlined
      genSelectInputVariantStyle(
        token2,
        "outlined",
        {
          border: token2.colorBorder,
          borderHover: token2.hoverBorderColor,
          borderActive: token2.activeBorderColor,
          borderOutline: token2.activeOutlineColor,
          borderDisabled: token2.colorBorderDisabled
        },
        // Error
        {
          border: token2.colorError,
          borderHover: token2.colorErrorHover,
          borderActive: token2.colorError,
          borderOutline: token2.colorErrorOutline
        },
        // Warning
        {
          border: token2.colorWarning,
          borderHover: token2.colorWarningHover,
          borderActive: token2.colorWarning,
          borderOutline: token2.colorWarningOutline
        }
      ),
      // >>> Filled
      genSelectInputVariantStyle(
        token2,
        "filled",
        {
          border: "transparent",
          borderHover: "transparent",
          borderActive: token2.activeBorderColor,
          borderOutline: "transparent",
          borderDisabled: token2.colorBorderDisabled,
          background: token2.colorFillTertiary,
          backgroundHover: token2.colorFillSecondary,
          backgroundActive: token2.colorBgContainer
        },
        // Error
        {
          background: token2.colorErrorBg,
          backgroundHover: token2.colorErrorBgHover,
          borderActive: token2.colorError
        },
        // Warning
        {
          background: token2.colorWarningBg,
          backgroundHover: token2.colorWarningBgHover,
          borderActive: token2.colorWarning
        }
      ),
      // >>> Borderless
      genSelectInputVariantStyle(token2, "borderless", {
        border: "transparent",
        borderHover: "transparent",
        borderActive: "transparent",
        borderOutline: "transparent",
        background: "transparent"
      }),
      // Underlined
      genSelectInputVariantStyle(
        token2,
        "underlined",
        {
          border: token2.colorBorder,
          borderHover: token2.hoverBorderColor,
          borderActive: token2.activeBorderColor,
          borderOutline: "transparent"
        },
        // Error
        {
          border: token2.colorError,
          borderHover: token2.colorErrorHover,
          borderActive: token2.colorError
        },
        // Warning
        {
          border: token2.colorWarning,
          borderHover: token2.colorWarningHover,
          borderActive: token2.colorWarning
        },
        {
          borderRadius: 0,
          borderTopColor: "transparent",
          borderRightColor: "transparent",
          borderLeftColor: "transparent"
        }
      ),
      // ============================================================
      // ==                         Custom                         ==
      // ============================================================
      select_input_customize_default(token2)
    ]
  };
};
var select_input_default = genSelectInputStyle;

// node_modules/antd/es/select/style/token.js
var prepareComponentToken11 = (token2) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    controlPaddingHorizontal,
    zIndexPopupBase,
    colorText,
    fontWeightStrong,
    controlItemBgActive,
    controlItemBgHover,
    colorBgContainer,
    colorFillSecondary,
    colorBgContainerDisabled,
    colorTextDisabled,
    colorPrimaryHover,
    colorPrimary,
    controlOutline
  } = token2;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
  const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  return {
    INTERNAL_FIXED_ITEM_MARGIN,
    zIndexPopup: zIndexPopupBase + 50,
    optionSelectedColor: colorText,
    optionSelectedFontWeight: fontWeightStrong,
    optionSelectedBg: controlItemBgActive,
    optionActiveBg: controlItemBgHover,
    optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    optionFontSize: fontSize,
    optionLineHeight: lineHeight,
    optionHeight: controlHeight,
    selectorBg: colorBgContainer,
    clearBg: colorBgContainer,
    singleItemHeightLG: controlHeightLG,
    multipleItemBg: colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
    hoverBorderColor: colorPrimaryHover,
    activeBorderColor: colorPrimary,
    activeOutlineColor: controlOutline,
    selectAffixPadding: paddingXXS
  };
};

// node_modules/antd/es/select/style/index.js
var genBaseStyle5 = (token2) => {
  const {
    antCls,
    componentCls,
    inputPaddingHorizontalBase
  } = token2;
  const hoverShowClearStyle = {
    [`${componentCls}-clear`]: {
      opacity: 1,
      background: token2.colorBgBase,
      borderRadius: "50%"
    }
  };
  return {
    [componentCls]: {
      ...resetComponent(token2),
      // ======================== Selection ========================
      [`${componentCls}-selection-item`]: {
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none",
        ...textEllipsis,
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${antCls}-typography`]: {
          display: "inline"
        }
      },
      // ========================= Prefix ==========================
      [`${componentCls}-prefix`]: {
        flex: "none",
        marginInlineEnd: token2.selectAffixPadding
      },
      // ========================== Clear ==========================
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        // https://github.com/ant-design/ant-design/issues/54205
        // Force GPU compositing on Safari to prevent flickering on opacity/transform transitions
        transform: "translateZ(0)",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorIcon
        }
      },
      "@media(hover:none)": hoverShowClearStyle,
      "&:hover": hoverShowClearStyle
    },
    // ========================= Feedback ==========================
    [`${componentCls}-status`]: {
      "&-error, &-warning, &-success, &-validating": {
        [`&${componentCls}-has-feedback`]: {
          [`${componentCls}-clear`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
          }
        }
      }
    }
  };
};
var genSelectStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [componentCls]: {
        // ==================== In Form ====================
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    genBaseStyle5(token2),
    // Dropdown
    dropdown_default(token2),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      focusElCls: `${componentCls}-focused`
    })
  ];
};
var style_default13 = genStyleHooks("Select", (token2, {
  rootPrefixCls
}) => {
  const selectToken = merge2(token2, {
    rootPrefixCls,
    inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(token2.lineWidth).equal(),
    multipleSelectItemHeight: token2.multipleItemHeight,
    selectHeight: token2.controlHeight
  });
  return [genSelectStyle(selectToken), select_input_default(selectToken)];
}, prepareComponentToken11, {
  unitless: {
    optionLineHeight: true,
    optionSelectedFontWeight: true
  }
});

// node_modules/antd/es/select/useIcons.js
var React191 = __toESM(require_react());
function useIcons({
  suffixIcon,
  clearIcon,
  menuItemSelectedIcon,
  removeIcon,
  loading,
  multiple,
  hasFeedback,
  showSuffixIcon,
  feedbackIcon,
  showArrow,
  componentName
}) {
  if (true) {
    const warning5 = devUseWarning(componentName);
    warning5.deprecated(!clearIcon, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  }
  const mergedClearIcon = clearIcon ?? React191.createElement(CloseCircleFilled_default, null);
  const getSuffixIconNode = (arrowIcon) => {
    if (suffixIcon === null && !hasFeedback && !showArrow) {
      return null;
    }
    return React191.createElement(React191.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
  };
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(React191.createElement(LoadingOutlined_default, {
      spin: true
    }));
  } else {
    mergedSuffixIcon = ({
      open: open3,
      showSearch
    }) => {
      if (open3 && showSearch) {
        return getSuffixIconNode(React191.createElement(SearchOutlined_default, null));
      }
      return getSuffixIconNode(React191.createElement(DownOutlined_default, null));
    };
  }
  let mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = React191.createElement(CheckOutlined_default, null);
  } else {
    mergedItemIcon = null;
  }
  let mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = React191.createElement(CloseOutlined_default, null);
  }
  return {
    // TODO: remove as when all the deps bumped
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}

// node_modules/antd/es/select/usePopupRender.js
var import_react85 = __toESM(require_react());
function usePopupRender(renderFn) {
  return import_react85.default.useMemo(() => {
    if (!renderFn) {
      return void 0;
    }
    return (...args) => import_react85.default.createElement(ContextIsolator_default, {
      space: true
    }, renderFn.apply(void 0, args));
  }, [renderFn]);
}
var usePopupRender_default = usePopupRender;

// node_modules/antd/es/select/useShowArrow.js
function useShowArrow(suffixIcon, showArrow) {
  return showArrow !== void 0 ? showArrow : suffixIcon !== null;
}

// node_modules/antd/es/select/index.js
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = (props, ref) => {
  var _a, _b, _c, _d, _e;
  const {
    prefixCls: customizePrefixCls,
    bordered,
    className,
    rootClassName,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    listHeight = 256,
    placement,
    listItemHeight: customListItemHeight,
    size: customizeSize,
    disabled: customDisabled,
    notFoundContent,
    status: customStatus,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    direction: propDirection,
    style: style2,
    allowClear,
    variant: customizeVariant,
    popupStyle,
    dropdownStyle,
    transitionName,
    tagRender,
    maxCount,
    prefix: prefix2,
    dropdownRender,
    /**
     * @since 5.25.0
     */
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    styles,
    classNames,
    ...rest
  } = props;
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    renderEmpty,
    direction: contextDirection,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow
  } = React193.useContext(ConfigContext);
  const {
    showSearch,
    style: contextStyle,
    styles: contextStyles,
    className: contextClassName,
    classNames: contextClassNames
  } = useComponentConfig("select");
  const [, token2] = useToken();
  const listItemHeight = customListItemHeight ?? (token2 == null ? void 0 : token2.controlHeight);
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const direction = propDirection ?? contextDirection;
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default("select", customizeVariant, bordered);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const mode = React193.useMemo(() => {
    const {
      mode: m
    } = props;
    if (m === "combobox") {
      return void 0;
    }
    if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m;
  }, [props.mode]);
  const isMultiple2 = mode === "multiple" || mode === "tags";
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React193.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = (renderEmpty == null ? void 0 : renderEmpty("Select")) || React193.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }
  const {
    suffixIcon,
    itemIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...rest,
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    prefixCls,
    componentName: "Select"
  });
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React193.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedProps = {
    ...props,
    variant,
    status: mergedStatus,
    disabled: mergedDisabled,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupClassName = clsx((_a = mergedClassNames.popup) == null ? void 0 : _a.root, popupClassName, dropdownClassName, {
    [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
  }, rootClassName, cssVarCls, rootCls, hashId);
  const mergedPopupStyle = {
    ...(_b = mergedStyles.popup) == null ? void 0 : _b.root,
    ...popupStyle ?? dropdownStyle
  };
  const mergedClassName = clsx({
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${variant}`]: enableVariantCls,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
  const memoPlacement = React193.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  if (true) {
    const warning5 = devUseWarning("Select");
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning5.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning5(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
    true ? warning5(!(typeof maxCount !== "undefined" && !isMultiple2), "usage", "`maxCount` only works with mode `multiple` or `tags`") : void 0;
  }
  const [zIndex] = useZIndex("SelectLike", ((_d = (_c = mergedStyles.popup) == null ? void 0 : _c.root) == null ? void 0 : _d.zIndex) ?? (mergedPopupStyle == null ? void 0 : mergedPopupStyle.zIndex));
  return React193.createElement(es_default12, {
    ref,
    virtual,
    classNames: mergedClassNames,
    styles: mergedStyles,
    showSearch,
    ...selectProps,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    popupMatchSelectWidth: mergedPopupMatchSelectWidth,
    transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: memoPlacement,
    direction,
    prefix: prefix2,
    suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    allowClear: mergedAllowClear,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    popupClassName: mergedPopupClassName,
    disabled: mergedDisabled,
    popupStyle: {
      ...(_e = mergedStyles.popup) == null ? void 0 : _e.root,
      ...mergedPopupStyle,
      zIndex
    },
    maxCount: isMultiple2 ? maxCount : void 0,
    tagRender: isMultiple2 ? tagRender : void 0,
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange
  });
};
if (true) {
  InternalSelect.displayName = "Select";
}
var Select2 = React193.forwardRef(InternalSelect);
var PurePanel3 = PurePanel_default3(Select2, "popupAlign");
Select2.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select2.Option = Option_default;
Select2.OptGroup = OptGroup_default;
Select2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel3;
if (true) {
  Select2.displayName = "Select";
}
var select_default = Select2;

// node_modules/antd/es/auto-complete/AutoComplete.js
var React194 = __toESM(require_react());
var {
  Option: Option2
} = select_default;
function isSelectOptionOrSelectOptGroup(child) {
  return (child == null ? void 0 : child.type) && (child.type.isSelectOption || child.type.isSelectOptGroup);
}
var AutoComplete = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    popupClassName,
    dropdownClassName,
    children,
    dataSource,
    rootClassName,
    dropdownStyle,
    dropdownRender,
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    styles,
    classNames
  } = props;
  const childNodes = toArray(children);
  const mergedPopupRender = popupRender || dropdownRender;
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  let customizeInput;
  if (childNodes.length === 1 && React194.isValidElement(childNodes[0]) && !isSelectOptionOrSelectOptGroup(childNodes[0])) {
    [customizeInput] = childNodes;
  }
  const getInputElement = customizeInput ? () => customizeInput : void 0;
  let optionChildren;
  if (childNodes.length && isSelectOptionOrSelectOptGroup(childNodes[0])) {
    optionChildren = children;
  } else {
    optionChildren = dataSource ? dataSource.map((item) => {
      if (React194.isValidElement(item)) {
        return item;
      }
      switch (typeof item) {
        case "string":
          return React194.createElement(Option2, {
            key: item,
            value: item
          }, item);
        case "object": {
          const {
            value: optionValue
          } = item;
          return React194.createElement(Option2, {
            key: optionValue,
            value: optionValue
          }, item.text);
        }
        default:
          return void 0;
      }
    }) : [];
  }
  if (true) {
    const warning5 = devUseWarning("AutoComplete");
    true ? warning5(!customizeInput || !("size" in props), "usage", "You need to control style self instead of setting `size` when using customize input.") : void 0;
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      dataSource: "options"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning5.deprecated(!(oldProp in props), oldProp, newProp);
    });
  }
  const {
    getPrefixCls
  } = React194.useContext(ConfigContext);
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const mergedProps = {
    ...props,
    dataSource,
    status: props.status,
    popupMatchSelectWidth: props.popupMatchSelectWidth || props.dropdownMatchSelectWidth,
    popupRender: mergedPopupRender,
    onOpenChange: mergedOnOpenChange
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const finalClassNames = React194.useMemo(() => {
    var _a, _b, _c;
    return {
      root: clsx(`${prefixCls}-auto-complete`, className, rootClassName, mergedClassNames.root, {
        [`${prefixCls}-customize`]: customizeInput
      }),
      prefix: mergedClassNames.prefix,
      input: mergedClassNames.input,
      placeholder: mergedClassNames.placeholder,
      content: mergedClassNames.content,
      popup: {
        root: clsx(popupClassName, dropdownClassName, (_a = mergedClassNames.popup) == null ? void 0 : _a.root),
        list: (_b = mergedClassNames.popup) == null ? void 0 : _b.list,
        listItem: (_c = mergedClassNames.popup) == null ? void 0 : _c.listItem
      }
    };
  }, [prefixCls, className, rootClassName, mergedClassNames, popupClassName, dropdownClassName]);
  const finalStyles = React194.useMemo(() => {
    var _a, _b, _c;
    return {
      root: {
        ...mergedStyles.root,
        ...style2
      },
      input: mergedStyles.input,
      prefix: mergedStyles.prefix,
      placeholder: mergedStyles.placeholder,
      content: mergedStyles.content,
      popup: {
        root: {
          ...dropdownStyle,
          ...(_a = mergedStyles.popup) == null ? void 0 : _a.root
        },
        list: (_b = mergedStyles.popup) == null ? void 0 : _b.list,
        listItem: (_c = mergedStyles.popup) == null ? void 0 : _c.listItem
      }
    };
  }, [mergedStyles, style2, dropdownStyle]);
  return React194.createElement(select_default, {
    ref,
    suffixIcon: null,
    ...omit(props, ["dataSource", "dropdownClassName", "popupClassName"]),
    prefixCls,
    classNames: finalClassNames,
    styles: finalStyles,
    mode: select_default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange,
    // Internal api
    getInputElement
  }, optionChildren);
};
var RefAutoComplete = React194.forwardRef(AutoComplete);
if (true) {
  RefAutoComplete.displayName = "AutoComplete";
}
var AutoComplete_default = RefAutoComplete;

// node_modules/antd/es/auto-complete/index.js
var {
  Option: Option3
} = select_default;
var PurePanel4 = PurePanel_default3(AutoComplete_default, "popupAlign", (props) => omit(props, ["visible"]));
var AutoComplete2 = AutoComplete_default;
AutoComplete2.Option = Option3;
AutoComplete2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel4;
var auto_complete_default = AutoComplete2;

// node_modules/antd/es/avatar/Avatar.js
var React197 = __toESM(require_react());

// node_modules/antd/es/_util/responsiveObserver.js
var import_react86 = __toESM(require_react());
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var getResponsiveMap = (token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`
});
var validateBreakpoints = (token2) => {
  const indexableToken = token2;
  const revBreakpoints = [].concat(responsiveArray).reverse();
  revBreakpoints.forEach((breakpoint, i) => {
    const breakpointUpper = breakpoint.toUpperCase();
    const screenMin = `screen${breakpointUpper}Min`;
    const screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen])) {
      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
    }
    if (i < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax])) {
        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
      }
      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
      }
    }
  });
  return token2;
};
var matchScreen = (screens, screenSizes) => {
  if (!screenSizes) {
    return;
  }
  for (const breakpoint of responsiveArray) {
    if (screens[breakpoint] && (screenSizes == null ? void 0 : screenSizes[breakpoint]) !== void 0) {
      return screenSizes[breakpoint];
    }
  }
};
var useResponsiveObserver = () => {
  const [, token2] = useToken();
  const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
  return import_react86.default.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      responsiveMap,
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size) {
          this.register();
        }
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size) {
          this.unregister();
        }
      },
      register() {
        Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
          const listener = ({
            matches
          }) => {
            this.dispatch({
              ...screens,
              [screen]: matches
            });
          };
          const mql = window.matchMedia(mediaQuery);
          if (typeof (mql == null ? void 0 : mql.addEventListener) === "function") {
            mql.addEventListener("change", listener);
          }
          this.matchHandlers[mediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      unregister() {
        Object.values(responsiveMap).forEach((mediaQuery) => {
          var _a;
          const handler = this.matchHandlers[mediaQuery];
          if (typeof ((_a = handler == null ? void 0 : handler.mql) == null ? void 0 : _a.removeEventListener) === "function") {
            handler.mql.removeEventListener("change", handler == null ? void 0 : handler.listener);
          }
        });
        subscribers.clear();
      }
    };
  }, [responsiveMap]);
};
var responsiveObserver_default = useResponsiveObserver;

// node_modules/antd/es/grid/hooks/useBreakpoint.js
var import_react87 = __toESM(require_react());
function useBreakpoint(refreshOnChange = true, defaultScreens = {}) {
  const screensRef = (0, import_react87.useRef)(defaultScreens);
  const [, forceUpdate] = useForceUpdate();
  const responsiveObserver = responsiveObserver_default();
  useLayoutEffect_default(() => {
    const token2 = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  return screensRef.current;
}
var useBreakpoint_default = useBreakpoint;

// node_modules/antd/es/avatar/AvatarContext.js
var React196 = __toESM(require_react());
var AvatarContext = React196.createContext({});
var AvatarContext_default = AvatarContext;

// node_modules/antd/es/avatar/style/index.js
var genBaseStyle6 = (token2) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    iconFontSize,
    iconFontSizeLG,
    iconFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token2;
  const avatarSizeStyle = (size, fontSize, iconFontSize2, radius2) => ({
    width: size,
    height: size,
    borderRadius: "50%",
    fontSize,
    [`&${componentCls}-square`]: {
      borderRadius: radius2
    },
    [`&${componentCls}-icon`]: {
      fontSize: iconFontSize2,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${unit(lineWidth)} ${lineType} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      },
      ...avatarSizeStyle(containerSize, textFontSize, iconFontSize, borderRadius),
      "&-lg": {
        ...avatarSizeStyle(containerSizeLG, textFontSizeLG, iconFontSizeLG, borderRadiusLG)
      },
      "&-sm": {
        ...avatarSizeStyle(containerSizeSM, textFontSizeSM, iconFontSizeSM, borderRadiusSM)
      },
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    }
  };
};
var genGroupStyle2 = (token2) => {
  const {
    componentCls,
    groupBorderColor,
    groupOverlapping,
    groupSpace
  } = token2;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [componentCls]: {
        borderColor: groupBorderColor
      },
      "> *:not(:first-child)": {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
};
var prepareComponentToken12 = (token2) => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token2;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: fontSize,
    textFontSizeLG: fontSize,
    textFontSizeSM: fontSize,
    iconFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    iconFontSizeLG: fontSizeHeading3,
    iconFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
};
var style_default14 = genStyleHooks("Avatar", (token2) => {
  const {
    colorTextLightSolid,
    colorTextPlaceholder
  } = token2;
  const avatarToken = merge2(token2, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid
  });
  return [genBaseStyle6(avatarToken), genGroupStyle2(avatarToken)];
}, prepareComponentToken12);

// node_modules/antd/es/avatar/Avatar.js
var Avatar = React197.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    shape,
    size: customSize,
    src,
    srcSet,
    icon,
    className,
    rootClassName,
    style: style2,
    alt,
    draggable,
    children,
    crossOrigin,
    gap = 4,
    onError,
    ...others
  } = props;
  const [scale, setScale] = React197.useState(1);
  const [mounted, setMounted] = React197.useState(false);
  const [isImgExist, setIsImgExist] = React197.useState(true);
  const avatarNodeRef = React197.useRef(null);
  const avatarChildrenRef = React197.useRef(null);
  const avatarNodeMergedRef = composeRef(ref, avatarNodeRef);
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("avatar");
  const avatarCtx = React197.useContext(AvatarContext_default);
  const setScaleParam = () => {
    if (!avatarChildrenRef.current || !avatarNodeRef.current) {
      return;
    }
    const childrenWidth = avatarChildrenRef.current.offsetWidth;
    const nodeWidth = avatarNodeRef.current.offsetWidth;
    if (childrenWidth !== 0 && nodeWidth !== 0) {
      if (gap * 2 < nodeWidth) {
        setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
      }
    }
  };
  React197.useEffect(() => {
    setMounted(true);
  }, []);
  React197.useEffect(() => {
    setIsImgExist(true);
    setScale(1);
  }, [src]);
  React197.useEffect(setScaleParam, [gap]);
  const handleImgLoadError = () => {
    const errorFlag = onError == null ? void 0 : onError();
    if (errorFlag !== false) {
      setIsImgExist(false);
    }
  };
  const size = useSize_default((ctxSize) => customSize ?? (avatarCtx == null ? void 0 : avatarCtx.size) ?? ctxSize ?? "default");
  const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint_default(needResponsive);
  const responsiveSizeStyle = React197.useMemo(() => {
    if (typeof size !== "object") {
      return {};
    }
    const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
    const currentSize = size[currentBreakpoint];
    return currentSize ? {
      width: currentSize,
      height: currentSize,
      fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
    } : {};
  }, [screens, size, icon, children]);
  if (true) {
    const warning5 = devUseWarning("Avatar");
    true ? warning5(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default14(prefixCls, rootCls);
  const sizeCls = clsx({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const hasImageElement = React197.isValidElement(src);
  const mergedShape = shape || (avatarCtx == null ? void 0 : avatarCtx.shape) || "circle";
  const classString = clsx(prefixCls, sizeCls, contextClassName, `${prefixCls}-${mergedShape}`, {
    [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
    [`${prefixCls}-icon`]: !!icon
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const sizeStyle = typeof size === "number" ? {
    width: size,
    height: size,
    fontSize: icon ? size / 2 : 18
  } : {};
  let childrenToRender;
  if (typeof src === "string" && isImgExist) {
    childrenToRender = React197.createElement("img", {
      src,
      draggable,
      srcSet,
      onError: handleImgLoadError,
      alt,
      crossOrigin
    });
  } else if (hasImageElement) {
    childrenToRender = src;
  } else if (icon) {
    childrenToRender = icon;
  } else if (mounted || scale !== 1) {
    const transformString = `scale(${scale})`;
    const childrenStyle = {
      msTransform: transformString,
      WebkitTransform: transformString,
      transform: transformString
    };
    childrenToRender = React197.createElement(es_default, {
      onResize: setScaleParam
    }, React197.createElement("span", {
      className: `${prefixCls}-string`,
      ref: avatarChildrenRef,
      style: childrenStyle
    }, children));
  } else {
    childrenToRender = React197.createElement("span", {
      className: `${prefixCls}-string`,
      style: {
        opacity: 0
      },
      ref: avatarChildrenRef
    }, children);
  }
  return React197.createElement("span", {
    ...others,
    style: {
      ...sizeStyle,
      ...responsiveSizeStyle,
      ...contextStyle,
      ...style2
    },
    className: classString,
    ref: avatarNodeMergedRef
  }, childrenToRender);
});
if (true) {
  Avatar.displayName = "Avatar";
}
var Avatar_default2 = Avatar;

// node_modules/antd/es/avatar/AvatarGroup.js
var React205 = __toESM(require_react());

// node_modules/antd/es/popover/index.js
var React204 = __toESM(require_react());
var import_react90 = __toESM(require_react());

// node_modules/antd/es/_util/getRenderPropValue.js
var getRenderPropValue = (propValue) => {
  if (!propValue) {
    return null;
  }
  return typeof propValue === "function" ? propValue() : propValue;
};

// node_modules/antd/es/tooltip/index.js
var React202 = __toESM(require_react());

// node_modules/@rc-component/tooltip/es/Popup.js
var React198 = __toESM(require_react());
var Popup2 = (props) => {
  const {
    children,
    prefixCls,
    id,
    classNames,
    styles,
    className,
    style: style2
  } = props;
  return React198.createElement("div", {
    id,
    className: clsx(`${prefixCls}-container`, classNames == null ? void 0 : classNames.container, className),
    style: {
      ...styles == null ? void 0 : styles.container,
      ...style2
    },
    role: "tooltip"
  }, typeof children === "function" ? children() : children);
};
var Popup_default2 = Popup2;

// node_modules/@rc-component/tooltip/es/Tooltip.js
var React199 = __toESM(require_react());
var import_react88 = __toESM(require_react());

// node_modules/@rc-component/tooltip/es/placements.js
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
};
var autoAdjustOverflowLeftRight = {
  adjustX: 1,
  shiftY: true
};
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset
  }
};

// node_modules/@rc-component/tooltip/es/Tooltip.js
function _extends24() {
  _extends24 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends24.apply(this, arguments);
}
var Tooltip = React199.forwardRef((props, ref) => {
  const {
    trigger = ["hover"],
    mouseEnterDelay = 0,
    mouseLeaveDelay = 0.1,
    prefixCls = "rc-tooltip",
    children,
    onVisibleChange,
    afterVisibleChange,
    motion: motion2,
    placement = "right",
    align = {},
    destroyOnHidden = false,
    defaultVisible,
    getTooltipContainer,
    arrowContent,
    overlay,
    id,
    showArrow = true,
    classNames,
    styles,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const triggerRef = (0, import_react88.useRef)(null);
  (0, import_react88.useImperativeHandle)(ref, () => triggerRef.current);
  const extraProps = {
    ...restProps
  };
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  const mergedArrow = React199.useMemo(() => {
    if (!showArrow) {
      return false;
    }
    const arrowConfig = showArrow === true ? {} : showArrow;
    return {
      ...arrowConfig,
      className: clsx(arrowConfig.className, classNames == null ? void 0 : classNames.arrow),
      style: {
        ...arrowConfig.style,
        ...styles == null ? void 0 : styles.arrow
      },
      content: arrowConfig.content ?? arrowContent
    };
  }, [showArrow, classNames == null ? void 0 : classNames.arrow, styles == null ? void 0 : styles.arrow, arrowContent]);
  const getChildren = ({
    open: open3
  }) => {
    const child = React199.Children.only(children);
    const ariaProps = {
      "aria-describedby": overlay && open3 ? mergedId : void 0
    };
    return React199.cloneElement(child, ariaProps);
  };
  return React199.createElement(es_default4, _extends24({
    popupClassName: classNames == null ? void 0 : classNames.root,
    prefixCls,
    popup: React199.createElement(Popup_default2, {
      key: "content",
      prefixCls,
      id: mergedId,
      classNames,
      styles
    }, overlay),
    action: trigger,
    builtinPlacements: placements,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onOpenChange: onVisibleChange,
    afterOpenChange: afterVisibleChange,
    popupMotion: motion2,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyOnHidden,
    mouseLeaveDelay,
    popupStyle: styles == null ? void 0 : styles.root,
    mouseEnterDelay,
    arrow: mergedArrow,
    uniqueContainerClassName: classNames == null ? void 0 : classNames.uniqueContainer,
    uniqueContainerStyle: styles == null ? void 0 : styles.uniqueContainer
  }, extraProps), getChildren);
});
var Tooltip_default = Tooltip;

// node_modules/@rc-component/tooltip/es/index.js
var es_default13 = Tooltip_default;

// node_modules/antd/es/style/roundedArrow.js
function getArrowToken(token2) {
  const {
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter
  } = token2;
  const unitWidth = sizePopupArrow / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = borderRadiusOuter * 1 / Math.sqrt(2);
  const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
  const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
  const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
  const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
  const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
  return {
    arrowShadowWidth: shadowWidth,
    arrowPath,
    arrowPolygon
  };
}
var genRoundedArrow = (token2, bgColor, boxShadow) => {
  const {
    sizePopupArrow,
    arrowPolygon,
    arrowPath,
    arrowShadowWidth,
    borderRadiusXS,
    calc
  } = token2;
  return {
    pointerEvents: "none",
    width: sizePopupArrow,
    height: sizePopupArrow,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: sizePopupArrow,
      height: calc(sizePopupArrow).div(2).equal(),
      background: bgColor,
      clipPath: {
        _multi_value_: true,
        value: [arrowPolygon, arrowPath]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: arrowShadowWidth,
      height: arrowShadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${unit(borderRadiusXS)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
};

// node_modules/antd/es/style/placementArrow.js
var MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
  const {
    contentRadius,
    limitVerticalRadius
  } = options;
  const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
  return {
    arrowOffsetHorizontal: arrowOffset,
    arrowOffsetVertical
  };
}
function isInject(valid, code) {
  if (!valid) {
    return {};
  }
  return code;
}
function getArrowStyle(token2, colorBg, options) {
  const {
    componentCls,
    boxShadowPopoverArrow,
    arrowOffsetVertical,
    arrowOffsetHorizontal
  } = token2;
  const {
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options || {};
  return {
    [componentCls]: {
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [{
        position: "absolute",
        zIndex: 1,
        // lift it up so the menu wouldn't cask shadow on it
        display: "block",
        ...genRoundedArrow(token2, colorBg, boxShadowPopoverArrow),
        "&:before": {
          background: colorBg
        }
      }],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      ...isInject(!!arrowPlacement.top, {
        [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        "&-placement-topLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-topRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      }),
      // >>>>> Bottom
      ...isInject(!!arrowPlacement.bottom, {
        [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        "&-placement-bottomLeft": {
          "--arrow-offset-horizontal": arrowOffsetHorizontal,
          [`> ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        },
        "&-placement-bottomRight": {
          "--arrow-offset-horizontal": `calc(100% - ${unit(arrowOffsetHorizontal)})`,
          [`> ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        }
      }),
      // >>>>> Left
      ...isInject(!!arrowPlacement.left, {
        [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-leftBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      }),
      // >>>>> Right
      ...isInject(!!arrowPlacement.right, {
        [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right > ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop > ${componentCls}-arrow`]: {
          top: arrowOffsetVertical
        },
        [`&-placement-rightBottom > ${componentCls}-arrow`]: {
          bottom: arrowOffsetVertical
        }
      })
    }
  };
}

// node_modules/antd/es/_util/placements.js
function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow3) {
  if (autoAdjustOverflow3 === false) {
    return {
      adjustX: false,
      adjustY: false
    };
  }
  const overflow = autoAdjustOverflow3 && typeof autoAdjustOverflow3 === "object" ? autoAdjustOverflow3 : {};
  const baseOverflow = {};
  switch (placement) {
    case "top":
    case "bottom":
      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
      baseOverflow.shiftY = true;
      baseOverflow.adjustY = true;
      break;
    case "left":
    case "right":
      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
      baseOverflow.shiftX = true;
      baseOverflow.adjustX = true;
      break;
  }
  const mergedOverflow = {
    ...baseOverflow,
    ...overflow
  };
  if (!mergedOverflow.shiftX) {
    mergedOverflow.adjustX = true;
  }
  if (!mergedOverflow.shiftY) {
    mergedOverflow.adjustY = true;
  }
  return mergedOverflow;
}
var PlacementAlignMap = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
};
var ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
};
var DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function getPlacements(config) {
  const {
    arrowWidth,
    autoAdjustOverflow: autoAdjustOverflow3,
    arrowPointAtCenter,
    offset: offset3,
    borderRadius,
    visibleFirst
  } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {};
  const arrowOffset = getArrowOffsetToken({
    contentRadius: borderRadius,
    limitVerticalRadius: true
  });
  Object.keys(PlacementAlignMap).forEach((key) => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
    const placementInfo = {
      ...template,
      offset: [0, 0],
      dynamicInset: true
    };
    placementMap[key] = placementInfo;
    if (DisableAutoArrowList.has(key)) {
      placementInfo.autoArrow = false;
    }
    switch (key) {
      case "top":
      case "topLeft":
      case "topRight":
        placementInfo.offset[1] = -halfArrowWidth - offset3;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        placementInfo.offset[1] = halfArrowWidth + offset3;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        placementInfo.offset[0] = -halfArrowWidth - offset3;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        placementInfo.offset[0] = halfArrowWidth + offset3;
        break;
    }
    if (arrowPointAtCenter) {
      switch (key) {
        case "topLeft":
        case "bottomLeft":
          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case "topRight":
        case "bottomRight":
          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
        case "leftTop":
        case "rightTop":
          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
          break;
        case "leftBottom":
        case "rightBottom":
          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
          break;
      }
    }
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow3);
    if (visibleFirst) {
      placementInfo.htmlRegion = "visibleFirst";
    }
  });
  return placementMap;
}

// node_modules/antd/es/tooltip/hook/useMergedArrow.js
var import_react89 = __toESM(require_react());
var useMergedArrow = (providedArrow, providedContextArrow) => {
  const toConfig = (arrow) => typeof arrow === "boolean" ? {
    show: arrow
  } : arrow || {};
  return import_react89.default.useMemo(() => {
    const arrowConfig = toConfig(providedArrow);
    const contextArrowConfig = toConfig(providedContextArrow);
    return {
      ...contextArrowConfig,
      ...arrowConfig,
      show: arrowConfig.show ?? contextArrowConfig.show ?? true
    };
  }, [providedArrow, providedContextArrow]);
};
var useMergedArrow_default = useMergedArrow;

// node_modules/antd/es/tooltip/PurePanel.js
var React201 = __toESM(require_react());

// node_modules/antd/es/tooltip/style/index.js
var genTooltipStyle = (token2) => {
  const {
    calc,
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    arrowOffsetHorizontal,
    sizePopupArrow
  } = token2;
  const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
  const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
  const sharedBodyStyle = {
    minWidth: centerAlignMinWidth,
    minHeight: controlHeight,
    padding: `${unit(token2.calc(paddingSM).div(2).equal())} ${unit(paddingXS)}`,
    color: `var(--ant-tooltip-color, ${tooltipColor})`,
    textAlign: "start",
    textDecoration: "none",
    wordWrap: "break-word",
    backgroundColor: tooltipBg,
    borderRadius: tooltipBorderRadius,
    boxShadow: boxShadowSecondary,
    boxSizing: "border-box"
  };
  const sharedTransformOrigin = {
    // When use `autoArrow`, origin will follow the arrow position
    "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
    transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" ")
  };
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        width: "max-content",
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        ...sharedTransformOrigin,
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        // Wrapper for the tooltip content
        [`${componentCls}-container`]: [sharedBodyStyle, initFadeMotion(token2, true)],
        [`&:has(~ ${componentCls}-unique-container)`]: {
          [`${componentCls}-container`]: {
            border: "none",
            background: "transparent",
            boxShadow: "none"
          }
        },
        // Align placement should have another min width
        [[`&-placement-topLeft`, `&-placement-topRight`, `&-placement-bottomLeft`, `&-placement-bottomRight`].join(",")]: {
          minWidth: edgeAlignMinWidth
        },
        // Limit left and right placement radius
        [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        // generator for preset color
        ...genPresetColor(token2, (colorKey, {
          darkColor
        }) => ({
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-container`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        })),
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow
      }
    },
    // Unique Body
    {
      [`${componentCls}-unique-container`]: {
        ...sharedBodyStyle,
        ...sharedTransformOrigin,
        position: "absolute",
        zIndex: calc(zIndexPopup).sub(1).equal(),
        "&-hidden": {
          display: "none"
        },
        "&-visible": {
          transition: `all ${token2.motionDurationSlow}`
        }
      }
    }
  ];
};
var prepareComponentToken13 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 70,
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadius,
    limitVerticalRadius: true
  }),
  ...getArrowToken(merge2(token2, {
    borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
  }))
});
var style_default15 = (prefixCls, rootCls, injectStyle = true) => {
  const useStyle = genStyleHooks("Tooltip", (token2) => {
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgSpotlight
    } = token2;
    const TooltipToken = merge2(token2, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgSpotlight
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, prepareComponentToken13, {
    resetStyle: false,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle
  });
  return useStyle(prefixCls, rootCls);
};

// node_modules/antd/es/_util/colors.js
var inverseColors = PresetColors.map((color) => `${color}-inverse`);
var PresetStatusColors = ["success", "processing", "error", "default", "warning"];
function isPresetColor(color, includeInverse = true) {
  if (includeInverse) {
    return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
  }
  return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
  return PresetStatusColors.includes(color);
}

// node_modules/antd/es/tooltip/util.js
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = clsx({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  const rgb = generateColor2(color).toRgb();
  const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
  const textColor = luminance < 0.5 ? "#FFF" : "#000";
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    overlayStyle["--ant-tooltip-color"] = textColor;
    arrowStyle["--antd-arrow-background-color"] = color;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}

// node_modules/antd/es/tooltip/PurePanel.js
var PurePanel5 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title,
    color,
    overlayInnerStyle,
    classNames,
    styles
  } = props;
  const {
    getPrefixCls
  } = React201.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default15(prefixCls, rootCls);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const innerStyles = React201.useMemo(() => {
    const mergedStyle = {
      ...overlayInnerStyle,
      ...colorInfo.overlayStyle
    };
    return {
      container: mergedStyle
    };
  }, [overlayInnerStyle, colorInfo.overlayStyle]);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [innerStyles, styles], {
    props: mergedProps
  });
  const rootClassName = clsx(rootCls, hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
  return React201.createElement("div", {
    className: rootClassName,
    style: arrowContentStyle
  }, React201.createElement("div", {
    className: `${prefixCls}-arrow`
  }), React201.createElement(Popup_default2, {
    ...props,
    className: hashId,
    prefixCls,
    classNames: mergedClassNames,
    styles: mergedStyles
  }, title));
};
var PurePanel_default4 = PurePanel5;

// node_modules/antd/es/tooltip/index.js
var InternalTooltip = React202.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    color,
    children,
    afterOpenChange,
    arrow: tooltipArrow,
    destroyTooltipOnHide,
    destroyOnHidden,
    title,
    overlay,
    trigger,
    builtinPlacements,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    motion: motion2,
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    rootClassName,
    styles,
    classNames,
    onOpenChange,
    // Legacy
    overlayInnerStyle,
    overlayStyle,
    overlayClassName,
    ...restProps
  } = props;
  const [, token2] = useToken();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("tooltip");
  const mergedArrow = useMergedArrow_default(tooltipArrow, contextArrow);
  const mergedShowArrow = mergedArrow.show;
  const mergedTrigger = trigger || contextTrigger || "hover";
  const warning5 = devUseWarning("Tooltip");
  const tooltipRef = React202.useRef(null);
  const forceAlign = () => {
    var _a;
    (_a = tooltipRef.current) == null ? void 0 : _a.forceAlign();
  };
  React202.useImperativeHandle(ref, () => {
    var _a, _b;
    return {
      forceAlign,
      nativeElement: (_a = tooltipRef.current) == null ? void 0 : _a.nativeElement,
      popupElement: (_b = tooltipRef.current) == null ? void 0 : _b.popupElement
    };
  });
  if (true) {
    [["overlayStyle", "styles.root"], ["overlayInnerStyle", "styles.container"], ["overlayClassName", "classNames.root"], ["destroyTooltipOnHide", "destroyOnHidden"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    true ? warning5(!destroyTooltipOnHide || typeof destroyTooltipOnHide === "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly.") : void 0;
  }
  const [open3, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const noTitle = !title && !overlay && title !== 0;
  const onInternalOpenChange = (vis) => {
    setOpen(noTitle ? false : vis);
    if (!noTitle && onOpenChange) {
      onOpenChange(vis);
    }
  };
  const tooltipPlacements = React202.useMemo(() => {
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: (mergedArrow == null ? void 0 : mergedArrow.pointAtCenter) ?? false,
      autoAdjustOverflow: autoAdjustOverflow3,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius,
      offset: token2.marginXXS,
      visibleFirst: true
    });
  }, [mergedArrow, builtinPlacements, token2, mergedShowArrow, autoAdjustOverflow3]);
  const memoOverlay = React202.useMemo(() => {
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  }, [overlay, title]);
  const memoOverlayWrapper = React202.createElement(ContextIsolator_default, {
    space: true
  }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
  const mergedProps = {
    ...props,
    trigger: mergedTrigger,
    color,
    placement,
    builtinPlacements,
    openClassName,
    arrow: tooltipArrow,
    autoAdjustOverflow: autoAdjustOverflow3,
    getPopupContainer,
    children,
    destroyTooltipOnHide,
    destroyOnHidden
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props["data-popover-inject"];
  let tempOpen = open3;
  if (!("open" in props) && noTitle) {
    tempOpen = false;
  }
  const child = React202.isValidElement(children) && !isFragment2(children) ? children : React202.createElement("span", null, children);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === "string" ? clsx(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default15(prefixCls, rootCls, !injectFromPopover);
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const themeCls = clsx(rootCls, hashId, cssVarCls);
  const rootClassNames = clsx(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, colorInfo.className, rootClassName, themeCls, contextClassName, mergedClassNames.root);
  const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
  const containerStyle = {
    ...mergedStyles.container,
    ...overlayInnerStyle,
    ...colorInfo.overlayStyle
  };
  const content = React202.createElement(es_default13, {
    unique: true,
    ...restProps,
    trigger: mergedTrigger,
    zIndex,
    showArrow: mergedShowArrow,
    placement,
    mouseEnterDelay,
    mouseLeaveDelay,
    prefixCls,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow,
      uniqueContainer: clsx(themeCls, mergedClassNames.container)
    },
    styles: {
      root: {
        ...arrowContentStyle,
        ...mergedStyles.root,
        ...contextStyle,
        ...overlayStyle
      },
      container: containerStyle,
      uniqueContainer: containerStyle,
      arrow: mergedStyles.arrow
    },
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: tooltipRef,
    builtinPlacements: tooltipPlacements,
    overlay: memoOverlayWrapper,
    visible: tempOpen,
    onVisibleChange: onInternalOpenChange,
    afterVisibleChange: afterOpenChange,
    arrowContent: React202.createElement("span", {
      className: `${prefixCls}-arrow-content`
    }),
    motion: {
      motionName: getTransitionName2(rootPrefixCls, "zoom-big-fast", typeof (motion2 == null ? void 0 : motion2.motionName) === "string" ? motion2 == null ? void 0 : motion2.motionName : void 0),
      motionDeadline: 1e3
    },
    destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
  }, tempOpen ? cloneElement3(child, {
    className: childCls
  }) : child);
  return React202.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, content);
});
var Tooltip2 = InternalTooltip;
if (true) {
  Tooltip2.displayName = "Tooltip";
}
Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default4;
Tooltip2.UniqueProvider = UniqueProvider_default2;
var tooltip_default = Tooltip2;

// node_modules/antd/es/popover/PurePanel.js
var React203 = __toESM(require_react());

// node_modules/antd/es/popover/style/index.js
var genBaseStyle7 = (token2) => {
  const {
    componentCls,
    popoverColor,
    titleMinWidth,
    fontWeightStrong,
    innerPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG,
    zIndexPopup,
    titleMarginBottom,
    colorBgElevated,
    popoverBg,
    titleBorderBottom,
    innerContentPadding,
    titlePadding
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        // When use `autoArrow`, origin will follow the arrow position
        "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
        transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
        "--antd-arrow-background-color": colorBgElevated,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-container`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          padding: innerPadding
        },
        [`${componentCls}-title`]: {
          minWidth: titleMinWidth,
          marginBottom: titleMarginBottom,
          color: colorTextHeading,
          fontWeight: fontWeightStrong,
          borderBottom: titleBorderBottom,
          padding: titlePadding
        },
        [`${componentCls}-content`]: {
          color: popoverColor,
          padding: innerContentPadding
        }
      }
    },
    // Arrow Style
    getArrowStyle(token2, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: token2.sizePopupArrow,
        display: "inline-block"
      }
    }
  ];
};
var genColorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
};
var prepareComponentToken14 = (token2) => {
  const {
    lineWidth,
    controlHeight,
    fontHeight,
    padding,
    wireframe,
    zIndexPopupBase,
    borderRadiusLG,
    marginXS,
    lineType,
    colorSplit,
    paddingSM
  } = token2;
  const titlePaddingBlockDist = controlHeight - fontHeight;
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    titleMinWidth: 177,
    zIndexPopup: zIndexPopupBase + 30,
    ...getArrowToken(token2),
    ...getArrowOffsetToken({
      contentRadius: borderRadiusLG,
      limitVerticalRadius: true
    }),
    // internal
    innerPadding: wireframe ? 0 : 12,
    titleMarginBottom: wireframe ? 0 : marginXS,
    titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
    titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
    innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
  };
};
var style_default16 = genStyleHooks("Popover", (token2) => {
  const {
    colorBgElevated,
    colorText
  } = token2;
  const popoverToken = merge2(token2, {
    popoverBg: colorBgElevated,
    popoverColor: colorText
  });
  return [genBaseStyle7(popoverToken), genColorStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, prepareComponentToken14, {
  resetStyle: false,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});

// node_modules/antd/es/popover/PurePanel.js
var Overlay = (props) => {
  const {
    title,
    content,
    prefixCls,
    classNames,
    styles
  } = props;
  if (!title && !content) {
    return null;
  }
  return React203.createElement(React203.Fragment, null, title && React203.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames == null ? void 0 : classNames.title),
    style: styles == null ? void 0 : styles.title
  }, title), content && React203.createElement("div", {
    className: clsx(`${prefixCls}-content`, classNames == null ? void 0 : classNames.content),
    style: styles == null ? void 0 : styles.content
  }, content));
};
var RawPurePanel = (props) => {
  const {
    hashId,
    prefixCls,
    className,
    style: style2,
    placement = "top",
    title,
    content,
    children,
    classNames,
    styles
  } = props;
  const titleNode = getRenderPropValue(title);
  const contentNode = getRenderPropValue(content);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], {
    props: mergedProps
  });
  const rootClassName = clsx(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
  return React203.createElement("div", {
    className: rootClassName,
    style: style2
  }, React203.createElement("div", {
    className: `${prefixCls}-arrow`
  }), React203.createElement(Popup_default2, {
    ...props,
    className: hashId,
    prefixCls,
    classNames: mergedClassNames,
    styles: mergedStyles
  }, children || React203.createElement(Overlay, {
    prefixCls,
    title: titleNode,
    content: contentNode,
    classNames: mergedClassNames,
    styles: mergedStyles
  })));
};
var PurePanel6 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React203.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [hashId, cssVarCls] = style_default16(prefixCls);
  return React203.createElement(RawPurePanel, {
    ...restProps,
    prefixCls,
    hashId,
    className: clsx(className, cssVarCls)
  });
};
var PurePanel_default5 = PurePanel6;

// node_modules/antd/es/popover/index.js
var InternalPopover = React204.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    content,
    overlayClassName,
    placement = "top",
    trigger,
    children,
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    onOpenChange,
    overlayStyle = {},
    styles,
    classNames,
    motion: motion2,
    arrow: popoverArrow,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("popover");
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [hashId, cssVarCls] = style_default16(prefixCls);
  const rootPrefixCls = getPrefixCls();
  const mergedArrow = useMergedArrow_default(popoverArrow, contextArrow);
  const mergedTrigger = trigger || contextTrigger || "hover";
  const mergedProps = {
    ...props,
    placement,
    trigger: mergedTrigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayStyle,
    styles,
    classNames
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(overlayClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root);
  const [open3, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const settingOpen = (value, e3) => {
    setOpen(value);
    onOpenChange == null ? void 0 : onOpenChange(value, e3);
  };
  const onKeyDown2 = (e3) => {
    if (e3.keyCode === KeyCode_default.ESC) {
      settingOpen(false, e3);
    }
  };
  const onInternalOpenChange = (value) => {
    settingOpen(value);
  };
  const titleNode = getRenderPropValue(title);
  const contentNode = getRenderPropValue(content);
  return React204.createElement(tooltip_default, {
    unique: false,
    arrow: mergedArrow,
    placement,
    trigger: mergedTrigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    ...restProps,
    prefixCls,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow
    },
    styles: {
      root: {
        ...mergedStyles.root,
        ...contextStyle,
        ...overlayStyle
      },
      container: mergedStyles.container,
      arrow: mergedStyles.arrow
    },
    ref,
    open: open3,
    onOpenChange: onInternalOpenChange,
    overlay: titleNode || contentNode ? React204.createElement(Overlay, {
      prefixCls,
      title: titleNode,
      content: contentNode,
      classNames: mergedClassNames,
      styles: mergedStyles
    }) : null,
    motion: {
      motionName: getTransitionName2(rootPrefixCls, "zoom-big", typeof (motion2 == null ? void 0 : motion2.motionName) === "string" ? motion2 == null ? void 0 : motion2.motionName : void 0)
    },
    "data-popover-inject": true
  }, cloneElement3(children, {
    onKeyDown: (e3) => {
      var _a, _b;
      if ((0, import_react90.isValidElement)(children)) {
        (_b = children == null ? void 0 : (_a = children.props).onKeyDown) == null ? void 0 : _b.call(_a, e3);
      }
      onKeyDown2(e3);
    }
  }));
});
var Popover = InternalPopover;
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default5;
if (true) {
  Popover.displayName = "Popover";
}
var popover_default = Popover;

// node_modules/antd/es/avatar/AvatarGroup.js
var AvatarContextProvider = (props) => {
  const {
    size,
    shape
  } = React205.useContext(AvatarContext_default);
  const avatarContextValue = React205.useMemo(() => ({
    size: props.size || size,
    shape: props.shape || shape
  }), [props.size, props.shape, size, shape]);
  return React205.createElement(AvatarContext_default.Provider, {
    value: avatarContextValue
  }, props.children);
};
var AvatarGroup = (props) => {
  var _a, _b, _c;
  const {
    getPrefixCls,
    direction
  } = React205.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    maxCount,
    maxStyle,
    size,
    shape,
    maxPopoverPlacement,
    maxPopoverTrigger,
    children,
    max
  } = props;
  if (true) {
    const warning5 = devUseWarning("Avatar.Group");
    [["maxCount", "max={{ count: number }}"], ["maxStyle", "max={{ style: CSSProperties }}"], ["maxPopoverPlacement", "max={{ popover: PopoverProps }}"], ["maxPopoverTrigger", "max={{ popover: PopoverProps }}"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default14(prefixCls, rootCls);
  const cls = clsx(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const childrenWithProps = toArray(children).map((child, index2) => cloneElement3(child, {
    // eslint-disable-next-line react/no-array-index-key
    key: `avatar-key-${index2}`
  }));
  const mergeCount = (max == null ? void 0 : max.count) || maxCount;
  const numOfChildren = childrenWithProps.length;
  if (mergeCount && mergeCount < numOfChildren) {
    const childrenShow = childrenWithProps.slice(0, mergeCount);
    const childrenHidden = childrenWithProps.slice(mergeCount, numOfChildren);
    const mergeStyle = (max == null ? void 0 : max.style) || maxStyle;
    const mergePopoverTrigger = ((_a = max == null ? void 0 : max.popover) == null ? void 0 : _a.trigger) || maxPopoverTrigger || "hover";
    const mergePopoverPlacement = ((_b = max == null ? void 0 : max.popover) == null ? void 0 : _b.placement) || maxPopoverPlacement || "top";
    const popoverProps = {
      content: childrenHidden,
      ...max == null ? void 0 : max.popover,
      placement: mergePopoverPlacement,
      trigger: mergePopoverTrigger,
      rootClassName: clsx(`${groupPrefixCls}-popover`, (_c = max == null ? void 0 : max.popover) == null ? void 0 : _c.rootClassName)
    };
    childrenShow.push(React205.createElement(popover_default, {
      key: "avatar-popover-key",
      destroyOnHidden: true,
      ...popoverProps
    }, React205.createElement(Avatar_default2, {
      style: mergeStyle
    }, `+${numOfChildren - mergeCount}`)));
    return React205.createElement(AvatarContextProvider, {
      shape,
      size
    }, React205.createElement("div", {
      className: cls,
      style: style2
    }, childrenShow));
  }
  return React205.createElement(AvatarContextProvider, {
    shape,
    size
  }, React205.createElement("div", {
    className: cls,
    style: style2
  }, childrenWithProps));
};
var AvatarGroup_default = AvatarGroup;

// node_modules/antd/es/avatar/index.js
var Avatar2 = Avatar_default2;
Avatar2.Group = AvatarGroup_default;
var avatar_default = Avatar2;

// node_modules/antd/es/back-top/index.js
var import_react91 = __toESM(require_react());

// node_modules/antd/es/back-top/style/index.js
var genSharedBackTopStyle = (token2) => {
  const {
    componentCls,
    backTopFontSize,
    backTopSize,
    zIndexPopup
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "fixed",
      insetInlineEnd: token2.backTopInlineEnd,
      insetBlockEnd: token2.backTopBlockEnd,
      zIndex: zIndexPopup,
      width: 40,
      height: 40,
      cursor: "pointer",
      "&:empty": {
        display: "none"
      },
      [`${componentCls}-content`]: {
        width: backTopSize,
        height: backTopSize,
        overflow: "hidden",
        color: token2.backTopColor,
        textAlign: "center",
        backgroundColor: token2.backTopBackground,
        borderRadius: backTopSize,
        transition: `all ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.backTopHoverBackground,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      // change to .backtop .backtop-icon
      [`${componentCls}-icon`]: {
        fontSize: backTopFontSize,
        lineHeight: unit(backTopSize)
      }
    }
  };
};
var genMediaBackTopStyle = (token2) => {
  const {
    componentCls,
    screenMD,
    screenXS,
    backTopInlineEndMD,
    backTopInlineEndXS
  } = token2;
  return {
    [`@media (max-width: ${unit(screenMD)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndMD
      }
    },
    [`@media (max-width: ${unit(screenXS)})`]: {
      [componentCls]: {
        insetInlineEnd: backTopInlineEndXS
      }
    }
  };
};
var prepareComponentToken15 = (token2) => ({
  zIndexPopup: token2.zIndexBase + 10
});
var style_default17 = genStyleHooks("BackTop", (token2) => {
  const {
    fontSizeHeading3,
    colorTextDescription,
    colorTextLightSolid,
    colorText,
    controlHeightLG,
    calc
  } = token2;
  const backTopToken = merge2(token2, {
    backTopBackground: colorTextDescription,
    backTopColor: colorTextLightSolid,
    backTopHoverBackground: colorText,
    backTopFontSize: fontSizeHeading3,
    backTopSize: controlHeightLG,
    backTopBlockEnd: calc(controlHeightLG).mul(1.25).equal(),
    backTopInlineEnd: calc(controlHeightLG).mul(2.5).equal(),
    backTopInlineEndMD: calc(controlHeightLG).mul(1.5).equal(),
    backTopInlineEndXS: calc(controlHeightLG).mul(0.5).equal()
  });
  return [genSharedBackTopStyle(backTopToken), genMediaBackTopStyle(backTopToken)];
}, prepareComponentToken15);

// node_modules/antd/es/back-top/index.js
var BackTop = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    visibilityHeight = 400,
    target,
    onClick,
    duration = 450,
    children
  } = props;
  const [visible, setVisible] = import_react91.default.useState(visibilityHeight === 0);
  const ref = import_react91.default.useRef(null);
  const getDefaultTarget2 = () => {
    var _a;
    return ((_a = ref.current) == null ? void 0 : _a.ownerDocument) || window;
  };
  const handleScroll = throttleByAnimationFrame_default((e3) => {
    const scrollTop = getScroll_default(e3.target);
    setVisible(scrollTop >= visibilityHeight);
  });
  if (true) {
    const warning5 = devUseWarning("BackTop");
    warning5.deprecated(false, "BackTop", "FloatButton.BackTop");
  }
  import_react91.default.useEffect(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({
      target: container
    });
    container == null ? void 0 : container.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container == null ? void 0 : container.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = (e3) => {
    scrollTo(0, {
      getContainer: target || getDefaultTarget2,
      duration
    });
    onClick == null ? void 0 : onClick(e3);
  };
  const {
    getPrefixCls,
    direction
  } = import_react91.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("back-top", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default17(prefixCls, rootCls);
  const classString = clsx(hashId, cssVarCls, prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName);
  const divProps = omit(props, ["prefixCls", "className", "rootClassName", "children", "visibilityHeight", "target"]);
  const defaultElement = import_react91.default.createElement("div", {
    className: `${prefixCls}-content`
  }, import_react91.default.createElement("div", {
    className: `${prefixCls}-icon`
  }, import_react91.default.createElement(VerticalAlignTopOutlined_default, null)));
  return import_react91.default.createElement("div", {
    ...divProps,
    className: classString,
    onClick: scrollToTop,
    ref
  }, import_react91.default.createElement(es_default2, {
    visible,
    motionName: `${rootPrefixCls}-fade`
  }, ({
    className: motionClassName
  }) => cloneElement3(children || defaultElement, ({
    className: cloneCls
  }) => ({
    className: clsx(motionClassName, cloneCls)
  }))));
};
if (true) {
  BackTop.displayName = "Deprecated.BackTop";
}
var back_top_default = BackTop;

// node_modules/antd/es/badge/Badge.js
var React209 = __toESM(require_react());
var import_react92 = __toESM(require_react());

// node_modules/antd/es/badge/ScrollNumber.js
var React208 = __toESM(require_react());

// node_modules/antd/es/badge/SingleNumber.js
var React207 = __toESM(require_react());
var UnitNumber = (props) => {
  const {
    prefixCls,
    value,
    current,
    offset: offset3 = 0
  } = props;
  let style2;
  if (offset3) {
    style2 = {
      position: "absolute",
      top: `${offset3}00%`,
      left: 0
    };
  }
  return React207.createElement("span", {
    style: style2,
    className: clsx(`${prefixCls}-only-unit`, {
      current
    })
  }, value);
};
function getOffset(start, end, unit3) {
  let index2 = start;
  let offset3 = 0;
  while ((index2 + 10) % 10 !== end) {
    index2 += unit3;
    offset3 += unit3;
  }
  return offset3;
}
var SingleNumber = (props) => {
  const {
    prefixCls,
    count: originCount,
    value: originValue
  } = props;
  const value = Number(originValue);
  const count = Math.abs(originCount);
  const [prevValue, setPrevValue] = React207.useState(value);
  const [prevCount, setPrevCount] = React207.useState(count);
  const onTransitionEnd = () => {
    setPrevValue(value);
    setPrevCount(count);
  };
  React207.useEffect(() => {
    const timer = setTimeout(onTransitionEnd, 1e3);
    return () => clearTimeout(timer);
  }, [value]);
  let unitNodes;
  let offsetStyle;
  if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
    unitNodes = [React207.createElement(UnitNumber, {
      ...props,
      key: value,
      current: true
    })];
    offsetStyle = {
      transition: "none"
    };
  } else {
    unitNodes = [];
    const end = value + 10;
    const unitNumberList = [];
    for (let index2 = value; index2 <= end; index2 += 1) {
      unitNumberList.push(index2);
    }
    const unit3 = prevCount < count ? 1 : -1;
    const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
    const cutUnitNumberList = unit3 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex);
    unitNodes = cutUnitNumberList.map((n2, index2) => {
      const singleUnit = n2 % 10;
      return React207.createElement(UnitNumber, {
        ...props,
        key: n2,
        value: singleUnit,
        offset: unit3 < 0 ? index2 - prevIndex : index2,
        current: index2 === prevIndex
      });
    });
    offsetStyle = {
      transform: `translateY(${-getOffset(prevValue, value, unit3)}00%)`
    };
  }
  return React207.createElement("span", {
    className: `${prefixCls}-only`,
    style: offsetStyle,
    onTransitionEnd
  }, unitNodes);
};
var SingleNumber_default = SingleNumber;

// node_modules/antd/es/badge/ScrollNumber.js
var ScrollNumber = React208.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    count,
    className,
    motionClassName,
    style: style2,
    title,
    show,
    component: Component8 = "sup",
    children,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React208.useContext(ConfigContext);
  const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
  const newProps = {
    ...restProps,
    "data-show": show,
    style: style2,
    className: clsx(prefixCls, className, motionClassName),
    title
  };
  let numberNodes = count;
  if (count && Number(count) % 1 === 0) {
    const numberList = String(count).split("");
    numberNodes = React208.createElement("bdi", null, numberList.map((num, i) => React208.createElement(SingleNumber_default, {
      prefixCls,
      count: Number(count),
      value: num,
      // eslint-disable-next-line react/no-array-index-key
      key: numberList.length - i
    })));
  }
  if (style2 == null ? void 0 : style2.borderColor) {
    newProps.style = {
      ...style2,
      boxShadow: `0 0 0 1px ${style2.borderColor} inset`
    };
  }
  if (children) {
    return cloneElement3(children, (oriProps) => ({
      className: clsx(`${prefixCls}-custom-component`, oriProps == null ? void 0 : oriProps.className, motionClassName)
    }));
  }
  return React208.createElement(Component8, {
    ...newProps,
    ref
  }, numberNodes);
});
var ScrollNumber_default = ScrollNumber;

// node_modules/antd/es/badge/style/index.js
var antStatusProcessing = new Keyframes_default("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
});
var antZoomBadgeIn = new Keyframes_default("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
});
var antZoomBadgeOut = new Keyframes_default("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
});
var antNoWrapperZoomBadgeIn = new Keyframes_default("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
});
var antNoWrapperZoomBadgeOut = new Keyframes_default("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
});
var antBadgeLoadingCircle = new Keyframes_default("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
});
var genSharedBadgeStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeShadowSize,
    textFontSize,
    textFontSizeSM,
    statusSize,
    dotSize,
    textFontWeight,
    indicatorHeight,
    indicatorHeightSM,
    marginXS,
    calc
  } = token2;
  const numberPrefixCls = `${antCls}-scroll-number`;
  const colorPreset = genPresetColor(token2, (colorKey, {
    darkColor
  }) => ({
    [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
      background: darkColor,
      [`&:not(${componentCls}-count)`]: {
        color: darkColor
      },
      "a:hover &": {
        background: darkColor
      }
    }
  }));
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        display: "inline-flex",
        justifyContent: "center",
        zIndex: token2.indicatorZIndex,
        minWidth: indicatorHeight,
        height: indicatorHeight,
        color: token2.badgeTextColor,
        fontWeight: textFontWeight,
        fontSize: textFontSize,
        lineHeight: unit(indicatorHeight),
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token2.badgeColor,
        borderRadius: calc(indicatorHeight).div(2).equal(),
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token2.badgeShadowColor}`,
        transition: `background ${token2.motionDurationMid}`,
        a: {
          color: token2.badgeTextColor
        },
        "a:hover": {
          color: token2.badgeTextColor
        },
        "a:hover &": {
          background: token2.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: indicatorHeightSM,
        height: indicatorHeightSM,
        fontSize: textFontSizeSM,
        lineHeight: unit(indicatorHeightSM),
        borderRadius: calc(indicatorHeightSM).div(2).equal()
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${unit(token2.paddingXS)}`,
        bdi: {
          unicodeBidi: "plaintext"
        }
      },
      [`${componentCls}-dot`]: {
        zIndex: token2.indicatorZIndex,
        width: dotSize,
        minWidth: dotSize,
        height: dotSize,
        background: token2.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${unit(badgeShadowSize)} ${token2.badgeShadowColor}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          // Magic number, but seems better experience
          display: "inline-block",
          width: statusSize,
          height: statusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token2.colorInfo,
          backgroundColor: token2.colorInfo,
          borderColor: "currentcolor",
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token2.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token2.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token2.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token2.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token2.colorText,
          fontSize: token2.fontSize
        }
      },
      ...colorPreset,
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [numberPrefixCls]: {
        overflow: "hidden",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack}`,
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: indicatorHeight,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: indicatorHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }
  };
};
var prepareToken3 = (token2) => {
  const {
    fontHeight,
    lineWidth,
    marginXS,
    colorBorderBg
  } = token2;
  const badgeFontHeight = fontHeight;
  const badgeShadowSize = lineWidth;
  const badgeTextColor = token2.colorTextLightSolid;
  const badgeColor = token2.colorError;
  const badgeColorHover = token2.colorErrorHover;
  const badgeToken = merge2(token2, {
    badgeFontHeight,
    badgeShadowSize,
    badgeTextColor,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: `brightness(75%)`
  });
  return badgeToken;
};
var prepareComponentToken16 = (token2) => {
  const {
    fontSize,
    lineHeight,
    fontSizeSM,
    lineWidth
  } = token2;
  return {
    indicatorZIndex: "auto",
    indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
    indicatorHeightSM: fontSize,
    dotSize: fontSizeSM / 2,
    textFontSize: fontSizeSM,
    textFontSizeSM: fontSizeSM,
    textFontWeight: "normal",
    statusSize: fontSizeSM / 2
  };
};
var style_default18 = genStyleHooks("Badge", (token2) => {
  const badgeToken = prepareToken3(token2);
  return genSharedBadgeStyle(badgeToken);
}, prepareComponentToken16);

// node_modules/antd/es/badge/Badge.js
var Badge = React209.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
    children,
    status,
    text,
    color,
    count = null,
    overflowCount = 99,
    dot = false,
    size = "default",
    title,
    offset: offset3,
    style: style2,
    className,
    rootClassName,
    classNames,
    styles,
    showZero = false,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("badge");
  const prefixCls = getPrefixCls("badge", customizePrefixCls);
  const [hashId, cssVarCls] = style_default18(prefixCls);
  const mergedProps = {
    ...props,
    overflowCount,
    size,
    dot,
    showZero
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
  const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0 || text === "0" || text === 0;
  const ignoreCount = count === null || isZero && !showZero;
  const hasStatus = (isNonNullable_default(status) || isNonNullable_default(color)) && ignoreCount;
  const hasStatusValue = isNonNullable_default(status) || !isZero;
  const showAsDot = dot && !isZero;
  const mergedCount = showAsDot ? "" : numberedDisplayCount;
  const isHidden = (0, import_react92.useMemo)(() => {
    const isEmpty2 = (!isNonNullable_default(mergedCount) || mergedCount === "") && (!isNonNullable_default(text) || text === "");
    return (isEmpty2 || isZero && !showZero) && !showAsDot;
  }, [mergedCount, isZero, showZero, showAsDot, text]);
  const countRef = (0, import_react92.useRef)(count);
  if (!isHidden) {
    countRef.current = count;
  }
  const livingCount = countRef.current;
  const displayCountRef = (0, import_react92.useRef)(mergedCount);
  if (!isHidden) {
    displayCountRef.current = mergedCount;
  }
  const displayCount = displayCountRef.current;
  const isDotRef = (0, import_react92.useRef)(showAsDot);
  if (!isHidden) {
    isDotRef.current = showAsDot;
  }
  const mergedStyle = (0, import_react92.useMemo)(() => {
    if (!offset3) {
      return {
        ...contextStyle,
        ...style2
      };
    }
    const horizontalOffset = Number.parseInt(offset3[0], 10);
    const offsetStyle = {
      marginTop: offset3[1],
      insetInlineEnd: -horizontalOffset
    };
    return {
      ...offsetStyle,
      ...contextStyle,
      ...style2
    };
  }, [offset3, style2, contextStyle]);
  const titleNode = title ?? (typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0);
  const showStatusTextNode = !isHidden && (text === 0 ? showZero : !!text && text !== true);
  const statusTextNode = !showStatusTextNode ? null : React209.createElement("span", {
    className: `${prefixCls}-status-text`
  }, text);
  const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement3(livingCount, (oriProps) => ({
    style: {
      ...mergedStyle,
      ...oriProps.style
    }
  }));
  const isInternalColor = isPresetColor(color, false);
  const statusCls = clsx(mergedClassNames.indicator, {
    [`${prefixCls}-status-dot`]: hasStatus,
    [`${prefixCls}-status-${status}`]: !!status,
    [`${prefixCls}-color-${color}`]: isInternalColor
  });
  const statusStyle = {};
  if (color && !isInternalColor) {
    statusStyle.color = color;
    statusStyle.background = color;
  }
  const badgeClassName = clsx(prefixCls, {
    [`${prefixCls}-status`]: hasStatus,
    [`${prefixCls}-not-a-wrapper`]: !children,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, contextClassName, mergedClassNames.root, hashId, cssVarCls);
  if (!children && hasStatus && (text || hasStatusValue || !ignoreCount)) {
    const statusTextColor = mergedStyle.color;
    return React209.createElement("span", {
      ...restProps,
      className: badgeClassName,
      style: {
        ...mergedStyles.root,
        ...mergedStyle
      }
    }, React209.createElement("span", {
      className: statusCls,
      style: {
        ...mergedStyles.indicator,
        ...statusStyle
      }
    }), showStatusTextNode && React209.createElement("span", {
      style: {
        color: statusTextColor
      },
      className: `${prefixCls}-status-text`
    }, text));
  }
  return React209.createElement("span", {
    ref,
    ...restProps,
    className: badgeClassName,
    style: mergedStyles.root
  }, children, React209.createElement(es_default2, {
    visible: !isHidden,
    motionName: `${prefixCls}-zoom`,
    motionAppear: false,
    motionDeadline: 1e3
  }, ({
    className: motionClassName
  }) => {
    const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
    const isDot = isDotRef.current;
    const scrollNumberCls = clsx(mergedClassNames.indicator, {
      [`${prefixCls}-dot`]: isDot,
      [`${prefixCls}-count`]: !isDot,
      [`${prefixCls}-count-sm`]: size === "small",
      [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color}`]: isInternalColor
    });
    let scrollNumberStyle = {
      ...mergedStyles.indicator,
      ...mergedStyle
    };
    if (color && !isInternalColor) {
      scrollNumberStyle = scrollNumberStyle || {};
      scrollNumberStyle.background = color;
    }
    return React209.createElement(ScrollNumber_default, {
      prefixCls: scrollNumberPrefixCls,
      show: !isHidden,
      motionClassName,
      className: scrollNumberCls,
      count: displayCount,
      title: titleNode,
      style: scrollNumberStyle,
      key: "scrollNumber"
    }, displayNode);
  }), statusTextNode);
});
if (true) {
  Badge.displayName = "Badge";
}
var Badge_default = Badge;

// node_modules/antd/es/badge/Ribbon.js
var React210 = __toESM(require_react());

// node_modules/antd/es/badge/style/ribbon.js
var genRibbonStyle = (token2) => {
  const {
    antCls,
    badgeFontHeight,
    marginXS,
    badgeRibbonOffset,
    calc
  } = token2;
  const ribbonPrefixCls = `${antCls}-ribbon`;
  const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
  const statusRibbonPreset = genPresetColor(token2, (colorKey, {
    darkColor
  }) => ({
    [`&${ribbonPrefixCls}-color-${colorKey}`]: {
      background: darkColor,
      color: darkColor
    }
  }));
  return {
    [ribbonWrapperPrefixCls]: {
      position: "relative"
    },
    [ribbonPrefixCls]: {
      ...resetComponent(token2),
      position: "absolute",
      top: marginXS,
      padding: `0 ${unit(token2.paddingXS)}`,
      color: token2.colorPrimary,
      lineHeight: unit(badgeFontHeight),
      whiteSpace: "nowrap",
      backgroundColor: token2.colorPrimary,
      borderRadius: token2.borderRadiusSM,
      [`${ribbonPrefixCls}-content`]: {
        color: token2.badgeTextColor
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${unit(calc(badgeRibbonOffset).div(2).equal())} solid`,
        transform: token2.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token2.badgeRibbonCornerFilter
      },
      ...statusRibbonPreset,
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var ribbon_default = genStyleHooks(["Badge", "Ribbon"], (token2) => {
  const badgeToken = prepareToken3(token2);
  return genRibbonStyle(badgeToken);
}, prepareComponentToken16);

// node_modules/antd/es/badge/Ribbon.js
var Ribbon = (props) => {
  const {
    className,
    prefixCls: customizePrefixCls,
    style: style2,
    color,
    children,
    text,
    placement = "end",
    rootClassName,
    styles,
    classNames: ribbonClassNames
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("ribbon");
  const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
  const wrapperCls = `${prefixCls}-wrapper`;
  const [hashId, cssVarCls] = ribbon_default(prefixCls, wrapperCls);
  const mergedProps = {
    ...props,
    placement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, ribbonClassNames], [contextStyles, styles], {
    props: mergedProps
  });
  const colorInPreset = isPresetColor(color, false);
  const ribbonCls = clsx(prefixCls, `${prefixCls}-placement-${placement}`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-color-${color}`]: colorInPreset
  }, className, contextClassName, mergedClassNames.indicator);
  const colorStyle = {};
  const cornerColorStyle = {};
  if (color && !colorInPreset) {
    colorStyle.background = color;
    cornerColorStyle.color = color;
  }
  return React210.createElement("div", {
    className: clsx(wrapperCls, rootClassName, hashId, cssVarCls, mergedClassNames.root),
    style: mergedStyles.root
  }, children, React210.createElement("div", {
    className: clsx(ribbonCls, hashId),
    style: {
      ...colorStyle,
      ...mergedStyles.indicator,
      ...contextStyle,
      ...style2
    }
  }, React210.createElement("span", {
    className: clsx(`${prefixCls}-content`, mergedClassNames.content),
    style: mergedStyles.content
  }, text), React210.createElement("div", {
    className: `${prefixCls}-corner`,
    style: cornerColorStyle
  })));
};
if (true) {
  Ribbon.displayName = "Ribbon";
}
var Ribbon_default = Ribbon;

// node_modules/antd/es/badge/index.js
var Badge2 = Badge_default;
Badge2.Ribbon = Ribbon_default;
var badge_default = Badge2;

// node_modules/antd/es/breadcrumb/Breadcrumb.js
var React247 = __toESM(require_react());

// node_modules/antd/es/breadcrumb/BreadcrumbContext.js
var import_react93 = __toESM(require_react());
var BreadcrumbContext = import_react93.default.createContext({});
var BreadcrumbContext_default = BreadcrumbContext;

// node_modules/antd/es/breadcrumb/BreadcrumbItem.js
var React246 = __toESM(require_react());

// node_modules/antd/es/dropdown/dropdown.js
var React243 = __toESM(require_react());

// node_modules/@rc-component/dropdown/es/Dropdown.js
var import_react95 = __toESM(require_react());

// node_modules/@rc-component/dropdown/es/hooks/useAccessibility.js
var React212 = __toESM(require_react());
var {
  ESC,
  TAB
} = KeyCode_default;
function useAccessibility({
  visible,
  triggerRef,
  onVisibleChange,
  autoFocus,
  overlayRef
}) {
  const focusMenuRef = React212.useRef(false);
  const handleCloseMenuAndReturnFocus = () => {
    var _a, _b;
    if (visible) {
      (_b = (_a = triggerRef.current) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      onVisibleChange == null ? void 0 : onVisibleChange(false);
    }
  };
  const focusMenu = () => {
    var _a;
    if ((_a = overlayRef.current) == null ? void 0 : _a.focus) {
      overlayRef.current.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  const handleKeyDown = (event) => {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        let focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  React212.useEffect(() => {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        raf_default(focusMenu, 3);
      }
      return () => {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return () => {
      focusMenuRef.current = false;
    };
  }, [visible]);
}

// node_modules/@rc-component/dropdown/es/Overlay.js
var import_react94 = __toESM(require_react());
var Overlay2 = (0, import_react94.forwardRef)((props, ref) => {
  const {
    overlay,
    arrow,
    prefixCls
  } = props;
  const overlayNode = (0, import_react94.useMemo)(() => {
    let overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  }, [overlay]);
  const composedRef = composeRef(ref, getNodeRef(overlayNode));
  return import_react94.default.createElement(import_react94.default.Fragment, null, arrow && import_react94.default.createElement("div", {
    className: `${prefixCls}-arrow`
  }), import_react94.default.cloneElement(overlayNode, {
    ref: supportRef(overlayNode) ? composedRef : void 0
  }));
});
var Overlay_default = Overlay2;

// node_modules/@rc-component/dropdown/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset2 = [0, 0];
var placements2 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset2
  }
};
var placements_default = placements2;

// node_modules/@rc-component/dropdown/es/Dropdown.js
function _extends25() {
  _extends25 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends25.apply(this, arguments);
}
var Dropdown = import_react95.default.forwardRef((props, ref) => {
  var _a;
  const {
    arrow = false,
    prefixCls = "rc-dropdown",
    transitionName,
    animation,
    align,
    placement = "bottomLeft",
    placements: placements5 = placements_default,
    getPopupContainer,
    showAction,
    hideAction,
    overlayClassName,
    overlayStyle,
    visible,
    trigger = ["hover"],
    autoFocus,
    overlay,
    children,
    onVisibleChange,
    ...otherProps
  } = props;
  const [triggerVisible, setTriggerVisible] = import_react95.default.useState();
  const mergedVisible = "visible" in props ? visible : triggerVisible;
  const mergedMotionName = animation ? `${prefixCls}-${animation}` : transitionName;
  const triggerRef = import_react95.default.useRef(null);
  const overlayRef = import_react95.default.useRef(null);
  const childRef = import_react95.default.useRef(null);
  import_react95.default.useImperativeHandle(ref, () => triggerRef.current);
  const handleVisibleChange = (newVisible) => {
    setTriggerVisible(newVisible);
    onVisibleChange == null ? void 0 : onVisibleChange(newVisible);
  };
  useAccessibility({
    visible: mergedVisible,
    triggerRef: childRef,
    onVisibleChange: handleVisibleChange,
    autoFocus,
    overlayRef
  });
  const onClick = (e3) => {
    const {
      onOverlayClick
    } = props;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e3);
    }
  };
  const getMenuElement = () => import_react95.default.createElement(Overlay_default, {
    ref: overlayRef,
    overlay,
    prefixCls,
    arrow
  });
  const getMenuElementOrLambda = () => {
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  const getMinOverlayWidthMatchTrigger = () => {
    const {
      minOverlayWidthMatchTrigger,
      alignPoint
    } = props;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint;
  };
  const getOpenClassName = () => {
    const {
      openClassName
    } = props;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return `${prefixCls}-open`;
  };
  const childrenNode = import_react95.default.cloneElement(children, {
    className: clsx((_a = children.props) == null ? void 0 : _a.className, mergedVisible && getOpenClassName()),
    ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
  });
  let triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return import_react95.default.createElement(es_default4, _extends25({
    builtinPlacements: placements5
  }, otherProps, {
    prefixCls,
    ref: triggerRef,
    popupClassName: clsx(overlayClassName, {
      [`${prefixCls}-show-arrow`]: arrow
    }),
    popupStyle: overlayStyle,
    action: trigger,
    showAction,
    hideAction: triggerHideAction,
    popupPlacement: placement,
    popupAlign: align,
    popupMotion: {
      motionName: mergedMotionName
    },
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onOpenChange: handleVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), childrenNode);
});
var Dropdown_default = Dropdown;

// node_modules/@rc-component/dropdown/es/index.js
var es_default14 = Dropdown_default;

// node_modules/antd/es/_util/isPrimitive.js
var isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
var isPrimitive_default = isPrimitive;

// node_modules/antd/es/menu/index.js
var React242 = __toESM(require_react());
var import_react102 = __toESM(require_react());

// node_modules/@rc-component/menu/es/Menu.js
var React234 = __toESM(require_react());
var import_react98 = __toESM(require_react());
var import_react_dom5 = __toESM(require_react_dom());

// node_modules/@rc-component/menu/es/context/IdContext.js
var React215 = __toESM(require_react());
var IdContext = React215.createContext(null);
function getMenuId(uuid6, eventKey) {
  return `${uuid6}-${eventKey}`;
}
function useMenuId(eventKey) {
  const id = React215.useContext(IdContext);
  return getMenuId(id, eventKey);
}

// node_modules/@rc-component/menu/es/context/MenuContext.js
var React216 = __toESM(require_react());
var MenuContext = React216.createContext(null);
function mergeProps2(origin, target) {
  const clone = {
    ...origin
  };
  Object.keys(target).forEach((key) => {
    const value = target[key];
    if (value !== void 0) {
      clone[key] = value;
    }
  });
  return clone;
}
function InheritableContextProvider({
  children,
  locked,
  ...restProps
}) {
  const context = React216.useContext(MenuContext);
  const inheritableContext = useMemo(() => mergeProps2(context, restProps), [context, restProps], (prev2, next2) => !locked && (prev2[0] !== next2[0] || !isEqual_default(prev2[1], next2[1], true)));
  return React216.createElement(MenuContext.Provider, {
    value: inheritableContext
  }, children);
}

// node_modules/@rc-component/menu/es/context/PathContext.js
var React217 = __toESM(require_react());
var EmptyList = [];
var PathRegisterContext = React217.createContext(null);
function useMeasure() {
  return React217.useContext(PathRegisterContext);
}
var PathTrackerContext = React217.createContext(EmptyList);
function useFullPath(eventKey) {
  const parentKeyPath = React217.useContext(PathTrackerContext);
  return React217.useMemo(() => eventKey !== void 0 ? [...parentKeyPath, eventKey] : parentKeyPath, [parentKeyPath, eventKey]);
}
var PathUserContext = React217.createContext(null);

// node_modules/@rc-component/menu/es/context/PrivateContext.js
var React218 = __toESM(require_react());
var PrivateContext = React218.createContext({});
var PrivateContext_default = PrivateContext;

// node_modules/@rc-component/util/es/Dom/focus.js
var import_react96 = __toESM(require_react());
function focusable(node2, includePositive = false) {
  if (isVisible_default(node2)) {
    const nodeName = node2.nodeName.toLowerCase();
    const isFocusableElement = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
      node2.isContentEditable || // Anchor with href element
      nodeName === "a" && !!node2.getAttribute("href")
    );
    const tabIndexAttr = node2.getAttribute("tabindex");
    const tabIndexNum = Number(tabIndexAttr);
    let tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node2, includePositive = false) {
  const res = [...node2.querySelectorAll("*")].filter((child) => {
    return focusable(child, includePositive);
  });
  if (focusable(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
function triggerFocus(element, option) {
  if (!element)
    return;
  element.focus(option);
  const {
    cursor
  } = option || {};
  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}

// node_modules/@rc-component/menu/es/hooks/useAccessibility.js
var React219 = __toESM(require_react());
var {
  LEFT,
  RIGHT,
  UP,
  DOWN,
  ENTER,
  ESC: ESC2,
  HOME,
  END
} = KeyCode_default;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset2(mode, isRootLevel, isRtl, which) {
  var _a;
  const prev2 = "prev";
  const next2 = "next";
  const children = "children";
  const parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  const inline2 = {
    [UP]: prev2,
    [DOWN]: next2
  };
  const horizontal = {
    [LEFT]: isRtl ? next2 : prev2,
    [RIGHT]: isRtl ? prev2 : next2,
    [DOWN]: children,
    [ENTER]: children
  };
  const vertical = {
    [UP]: prev2,
    [DOWN]: next2,
    [ENTER]: children,
    [ESC2]: parent,
    [LEFT]: isRtl ? children : parent,
    [RIGHT]: isRtl ? parent : children
  };
  const offsets = {
    inline: inline2,
    horizontal,
    vertical,
    inlineSub: inline2,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  const type5 = (_a = offsets[`${mode}${isRootLevel ? "" : "Sub"}`]) == null ? void 0 : _a[which];
  switch (type5) {
    case prev2:
      return {
        offset: -1,
        sibling: true
      };
    case next2:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  let current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  let current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  const list = getFocusNodeList(container, true);
  return list.filter((ele) => elements.has(ele));
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset3 = 1) {
  if (!parentQueryContainer) {
    return null;
  }
  const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  const count = sameLevelFocusableMenuElementList.length;
  let focusIndex = sameLevelFocusableMenuElementList.findIndex((ele) => focusMenuElement === ele);
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
var refreshElements = (keys2, id) => {
  const elements = /* @__PURE__ */ new Set();
  const key2element = /* @__PURE__ */ new Map();
  const element2key = /* @__PURE__ */ new Map();
  keys2.forEach((key) => {
    const element = document.querySelector(`[data-menu-id='${getMenuId(id, key)}']`);
    if (element) {
      elements.add(element);
      element2key.set(element, key);
      key2element.set(key, element);
    }
  });
  return {
    elements,
    key2element,
    element2key
  };
};
function useAccessibility2(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  const rafRef = React219.useRef();
  const activeRef = React219.useRef();
  activeRef.current = activeKey;
  const cleanRaf = () => {
    raf_default.cancel(rafRef.current);
  };
  React219.useEffect(() => () => {
    cleanRaf();
  }, []);
  return (e3) => {
    const {
      which
    } = e3;
    if ([...ArrowKeys, ENTER, ESC2, HOME, END].includes(which)) {
      const keys2 = getKeys();
      let refreshedElements = refreshElements(keys2, id);
      const {
        elements,
        key2element,
        element2key
      } = refreshedElements;
      const activeElement = key2element.get(activeKey);
      const focusMenuElement = getFocusElement(activeElement, elements);
      const focusMenuKey = element2key.get(focusMenuElement);
      const offsetObj = getOffset2(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e3.preventDefault();
      }
      const tryFocus = (menuElement) => {
        if (menuElement) {
          let focusTargetElement = menuElement;
          const link = menuElement.querySelector("a");
          if (link == null ? void 0 : link.getAttribute("href")) {
            focusTargetElement = link;
          }
          const targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = raf_default(() => {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        let parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        let targetElement;
        const focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = raf_default(() => {
          refreshedElements = refreshElements(keys2, id);
          const controlId = focusMenuElement.getAttribute("aria-controls");
          const subQueryContainer = document.getElementById(controlId);
          const targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);
          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        const keyPath = getKeyPath(focusMenuKey, true);
        const parentKey = keyPath[keyPath.length - 2];
        const parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown == null ? void 0 : originOnKeyDown(e3);
  };
}

// node_modules/@rc-component/menu/es/hooks/useKeyRecords.js
var React220 = __toESM(require_react());
var import_react97 = __toESM(require_react());

// node_modules/@rc-component/menu/es/utils/timeUtil.js
function nextSlice(callback) {
  Promise.resolve().then(callback);
}

// node_modules/@rc-component/menu/es/hooks/useKeyRecords.js
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = (keyPath) => keyPath.join(PATH_SPLIT);
var getPathKeys = (keyPathStr) => keyPathStr.split(PATH_SPLIT);
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  const [, internalForceUpdate] = React220.useState({});
  const key2pathRef = (0, import_react97.useRef)(/* @__PURE__ */ new Map());
  const path2keyRef = (0, import_react97.useRef)(/* @__PURE__ */ new Map());
  const [overflowKeys, setOverflowKeys] = React220.useState([]);
  const updateRef = (0, import_react97.useRef)(0);
  const destroyRef = (0, import_react97.useRef)(false);
  const forceUpdate = () => {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  const registerPath = (0, import_react97.useCallback)((key, keyPath) => {
    if (true) {
      warning_default(!key2pathRef.current.has(key), `Duplicated key '${key}' used in Menu by path [${keyPath.join(" > ")}]`);
    }
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    const id = updateRef.current;
    nextSlice(() => {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  const unregisterPath = (0, import_react97.useCallback)((key, keyPath) => {
    const connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  const refreshOverflowKeys = (0, import_react97.useCallback)((keys2) => {
    setOverflowKeys(keys2);
  }, []);
  const getKeyPath = (0, import_react97.useCallback)((eventKey, includeOverflow) => {
    const fullPath = key2pathRef.current.get(eventKey) || "";
    const keys2 = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY);
    }
    return keys2;
  }, [overflowKeys]);
  const isSubPathKey = (0, import_react97.useCallback)((pathKeys, eventKey) => pathKeys.filter((item) => item !== void 0).some((pathKey2) => {
    const pathKeyList = getKeyPath(pathKey2, true);
    return pathKeyList.includes(eventKey);
  }), [getKeyPath]);
  const getKeys = () => {
    const keys2 = [...key2pathRef.current.keys()];
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  };
  const getSubPathKeys = (0, import_react97.useCallback)((key) => {
    const connectedPath = `${key2pathRef.current.get(key)}${PATH_SPLIT}`;
    const pathKeys = /* @__PURE__ */ new Set();
    [...path2keyRef.current.keys()].forEach((pathKey2) => {
      if (pathKey2.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey2));
      }
    });
    return pathKeys;
  }, []);
  React220.useEffect(() => () => {
    destroyRef.current = true;
  }, []);
  return {
    // Register
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    // Util
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}

// node_modules/@rc-component/menu/es/hooks/useMemoCallback.js
var React221 = __toESM(require_react());
function useMemoCallback(func) {
  const funRef = React221.useRef(func);
  funRef.current = func;
  const callback = React221.useCallback((...args) => {
    var _a;
    return (_a = funRef.current) == null ? void 0 : _a.call(funRef, ...args);
  }, []);
  return func ? callback : void 0;
}

// node_modules/@rc-component/menu/es/MenuItem.js
var React225 = __toESM(require_react());

// node_modules/@rc-component/menu/es/hooks/useActive.js
var React222 = __toESM(require_react());
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  const {
    // Active
    activeKey,
    onActive,
    onInactive
  } = React222.useContext(MenuContext);
  const ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = (domEvent) => {
      onMouseEnter == null ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = (domEvent) => {
      onMouseLeave == null ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}

// node_modules/@rc-component/menu/es/hooks/useDirectionStyle.js
var React223 = __toESM(require_react());
function useDirectionStyle(level) {
  const {
    mode,
    rtl,
    inlineIndent
  } = React223.useContext(MenuContext);
  if (mode !== "inline") {
    return null;
  }
  const len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}

// node_modules/@rc-component/menu/es/Icon.js
var React224 = __toESM(require_react());
function Icon({
  icon,
  props,
  children
}) {
  let iconNode;
  if (icon === null || icon === false) {
    return null;
  }
  if (typeof icon === "function") {
    iconNode = React224.createElement(icon, {
      ...props
    });
  } else if (typeof icon !== "boolean") {
    iconNode = icon;
  }
  return iconNode || children || null;
}

// node_modules/@rc-component/menu/es/utils/warnUtil.js
function warnItemProp({
  item,
  ...restInfo
}) {
  Object.defineProperty(restInfo, "item", {
    get: () => {
      warning_default(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}

// node_modules/@rc-component/menu/es/MenuItem.js
function _extends26() {
  _extends26 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends26.apply(this, arguments);
}
var LegacyMenuItem = class extends React225.Component {
  render() {
    const {
      title,
      attribute,
      elementRef,
      ...restProps
    } = this.props;
    const passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
    warning_default(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
    return React225.createElement(es_default10.Item, _extends26({}, attribute, {
      title: typeof title === "string" ? title : void 0
    }, passedProps, {
      ref: elementRef
    }));
  }
};
var InternalMenuItem = React225.forwardRef((props, ref) => {
  const {
    style: style2,
    className,
    eventKey,
    warnKey,
    disabled,
    itemIcon,
    children,
    // Aria
    role,
    // Active
    onMouseEnter,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onFocus,
    ...restProps
  } = props;
  const domDataId = useMenuId(eventKey);
  const {
    prefixCls,
    onItemClick,
    disabled: contextDisabled,
    overflowDisabled,
    // Icon
    itemIcon: contextItemIcon,
    // Select
    selectedKeys,
    // Active
    onActive
  } = React225.useContext(MenuContext);
  const {
    _internalRenderMenuItem
  } = React225.useContext(PrivateContext_default);
  const itemCls = `${prefixCls}-item`;
  const legacyMenuItemRef = React225.useRef();
  const elementRef = React225.useRef();
  const mergedDisabled = contextDisabled || disabled;
  const mergedEleRef = useComposeRef(ref, elementRef);
  const connectedKeys = useFullPath(eventKey);
  if (warnKey) {
    warning_default(false, "MenuItem should not leave undefined `key`.");
  }
  const getEventInfo = (e3) => {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: [...connectedKeys].reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e3
    };
  };
  const mergedItemIcon = itemIcon || contextItemIcon;
  const {
    active,
    ...activeProps
  } = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave);
  const selected = selectedKeys.includes(eventKey);
  const directionStyle = useDirectionStyle(connectedKeys.length);
  const onInternalClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    const info = getEventInfo(e3);
    onClick == null ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  };
  const onInternalKeyDown = (e3) => {
    onKeyDown2 == null ? void 0 : onKeyDown2(e3);
    if (e3.which === KeyCode_default.ENTER) {
      const info = getEventInfo(e3);
      onClick == null ? void 0 : onClick(warnItemProp(info));
      onItemClick(info);
    }
  };
  const onInternalFocus = (e3) => {
    onActive(eventKey);
    onFocus == null ? void 0 : onFocus(e3);
  };
  const optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  let renderNode = React225.createElement(LegacyMenuItem, _extends26({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: {
      ...directionStyle,
      ...style2
    },
    className: clsx(itemCls, {
      [`${itemCls}-active`]: active,
      [`${itemCls}-selected`]: selected,
      [`${itemCls}-disabled`]: mergedDisabled
    }, className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, React225.createElement(Icon, {
    props: {
      ...props,
      isSelected: selected
    },
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
});
function MenuItem(props, ref) {
  const {
    eventKey
  } = props;
  const measure = useMeasure();
  const connectedKeyPath = useFullPath(eventKey);
  React225.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return React225.createElement(InternalMenuItem, _extends26({}, props, {
    ref
  }));
}
var MenuItem_default = React225.forwardRef(MenuItem);

// node_modules/@rc-component/menu/es/SubMenu/index.js
var React230 = __toESM(require_react());

// node_modules/@rc-component/menu/es/SubMenu/SubMenuList.js
var React226 = __toESM(require_react());
function _extends27() {
  _extends27 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends27.apply(this, arguments);
}
var InternalSubMenuList = ({
  className,
  children,
  ...restProps
}, ref) => {
  const {
    prefixCls,
    mode,
    rtl
  } = React226.useContext(MenuContext);
  return React226.createElement("ul", _extends27({
    className: clsx(prefixCls, rtl && `${prefixCls}-rtl`, `${prefixCls}-sub`, `${prefixCls}-${mode === "inline" ? "inline" : "vertical"}`, className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref
  }), children);
};
var SubMenuList = React226.forwardRef(InternalSubMenuList);
if (true) {
  SubMenuList.displayName = "SubMenuList";
}
var SubMenuList_default = SubMenuList;

// node_modules/@rc-component/menu/es/utils/commonUtil.js
var React227 = __toESM(require_react());
function parseChildren(children, keyPath) {
  return toArray(children).map((child, index2) => {
    var _a;
    if (React227.isValidElement(child)) {
      const {
        key
      } = child;
      let eventKey = ((_a = child.props) == null ? void 0 : _a.eventKey) ?? key;
      const emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = `tmp_key-${[...keyPath, index2].join("-")}`;
      }
      const cloneProps = {
        key: eventKey,
        eventKey
      };
      if (emptyKey) {
        cloneProps.warnKey = true;
      }
      return React227.cloneElement(child, cloneProps);
    }
    return child;
  });
}

// node_modules/@rc-component/menu/es/SubMenu/PopupTrigger.js
var React228 = __toESM(require_react());

// node_modules/@rc-component/menu/es/placements.js
var autoAdjustOverflow2 = {
  adjustX: 1,
  adjustY: 1
};
var placements3 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow2
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow2
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow2
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow2
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow2
  }
};

// node_modules/@rc-component/menu/es/utils/motionUtil.js
function getMotion3(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}

// node_modules/@rc-component/menu/es/SubMenu/PopupTrigger.js
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger({
  prefixCls,
  visible,
  children,
  popup,
  popupStyle,
  popupClassName,
  popupOffset,
  disabled,
  mode,
  onVisibleChange
}) {
  const {
    getPopupContainer,
    rtl,
    subMenuOpenDelay,
    subMenuCloseDelay,
    builtinPlacements,
    triggerSubMenuAction,
    forceSubMenuRender,
    rootClassName,
    // Motion
    motion: motion2,
    defaultMotions
  } = React228.useContext(MenuContext);
  const [innerVisible, setInnerVisible] = React228.useState(false);
  const placement = rtl ? {
    ...placementsRtl,
    ...builtinPlacements
  } : {
    ...placements3,
    ...builtinPlacements
  };
  const popupPlacement = popupPlacementMap[mode];
  const targetMotion = getMotion3(mode, motion2, defaultMotions);
  const targetMotionRef = React228.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  const mergedMotion = {
    ...targetMotionRef.current,
    leavedClassName: `${prefixCls}-hidden`,
    removeOnLeave: false,
    motionAppear: true
  };
  const visibleRef = React228.useRef();
  React228.useEffect(() => {
    visibleRef.current = raf_default(() => {
      setInnerVisible(visible);
    });
    return () => {
      raf_default.cancel(visibleRef.current);
    };
  }, [visible]);
  return React228.createElement(es_default4, {
    prefixCls,
    popupClassName: clsx(`${prefixCls}-popup`, {
      [`${prefixCls}-rtl`]: rtl
    }, popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupStyle,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    fresh: true
  }, children);
}

// node_modules/@rc-component/menu/es/SubMenu/InlineSubMenuList.js
var React229 = __toESM(require_react());
function _extends28() {
  _extends28 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends28.apply(this, arguments);
}
function InlineSubMenuList({
  id,
  open: open3,
  keyPath,
  children
}) {
  const fixedMode = "inline";
  const {
    prefixCls,
    forceSubMenuRender,
    motion: motion2,
    defaultMotions,
    mode
  } = React229.useContext(MenuContext);
  const sameModeRef = React229.useRef(false);
  sameModeRef.current = mode === fixedMode;
  const [destroy3, setDestroy] = React229.useState(!sameModeRef.current);
  const mergedOpen = sameModeRef.current ? open3 : false;
  React229.useEffect(() => {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  const mergedMotion = {
    ...getMotion3(fixedMode, motion2, defaultMotions)
  };
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  const originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = (newVisible) => {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged == null ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy3) {
    return null;
  }
  return React229.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, React229.createElement(es_default2, _extends28({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: `${prefixCls}-hidden`
  }), ({
    className: motionClassName,
    style: motionStyle
  }) => {
    return React229.createElement(SubMenuList_default, {
      id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}

// node_modules/@rc-component/menu/es/SubMenu/index.js
function _extends29() {
  _extends29 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends29.apply(this, arguments);
}
var InternalSubMenu = React230.forwardRef((props, ref) => {
  const {
    style: style2,
    className,
    styles,
    classNames: menuClassNames,
    title,
    eventKey,
    warnKey,
    disabled,
    internalPopupClose,
    children,
    // Icons
    itemIcon,
    expandIcon,
    // Popup
    popupClassName,
    popupOffset,
    popupStyle,
    // Events
    onClick,
    onMouseEnter,
    onMouseLeave,
    onTitleClick,
    onTitleMouseEnter,
    onTitleMouseLeave,
    popupRender: propsPopupRender,
    ...restProps
  } = props;
  const domDataId = useMenuId(eventKey);
  const {
    prefixCls,
    mode,
    openKeys,
    // Disabled
    disabled: contextDisabled,
    overflowDisabled,
    // ActiveKey
    activeKey,
    // SelectKey
    selectedKeys,
    // Icon
    itemIcon: contextItemIcon,
    expandIcon: contextExpandIcon,
    // Events
    onItemClick,
    onOpenChange,
    onActive,
    popupRender: contextPopupRender
  } = React230.useContext(MenuContext);
  const {
    _internalRenderSubMenuItem
  } = React230.useContext(PrivateContext_default);
  const {
    isSubPathKey
  } = React230.useContext(PathUserContext);
  const connectedPath = useFullPath();
  const subMenuPrefixCls = `${prefixCls}-submenu`;
  const mergedDisabled = contextDisabled || disabled;
  const elementRef = React230.useRef();
  const popupRef = React230.useRef();
  if (warnKey) {
    warning_default(false, "SubMenu should not leave undefined `key`.");
  }
  const mergedItemIcon = itemIcon ?? contextItemIcon;
  const mergedExpandIcon = expandIcon ?? contextExpandIcon;
  const originOpen = openKeys.includes(eventKey);
  const open3 = !overflowDisabled && originOpen;
  const childrenSelected = isSubPathKey(selectedKeys, eventKey);
  const {
    active,
    ...activeProps
  } = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave);
  const [childrenActive, setChildrenActive] = React230.useState(false);
  const triggerChildrenActive = (newActive) => {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  const onInternalMouseEnter = (domEvent) => {
    triggerChildrenActive(true);
    onMouseEnter == null ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  const onInternalMouseLeave = (domEvent) => {
    triggerChildrenActive(false);
    onMouseLeave == null ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  const mergedActive = React230.useMemo(() => {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  const directionStyle = useDirectionStyle(connectedPath.length);
  const onInternalTitleClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    onTitleClick == null ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e3
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  const onMergedItemClick = useMemoCallback((info) => {
    onClick == null ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  });
  const onPopupVisibleChange = (newVisible) => {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  const onInternalFocus = () => {
    onActive(eventKey);
  };
  const popupId = domDataId && `${domDataId}-popup`;
  const expandIconNode = React230.useMemo(() => React230.createElement(Icon, {
    icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
    props: {
      ...props,
      isOpen: open3,
      // [Legacy] Not sure why need this mark
      isSubMenu: true
    }
  }, React230.createElement("i", {
    className: `${subMenuPrefixCls}-arrow`
  })), [mode, mergedExpandIcon, props, open3, subMenuPrefixCls]);
  let titleNode = React230.createElement("div", _extends29({
    role: "menuitem",
    style: directionStyle,
    className: `${subMenuPrefixCls}-title`,
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open3,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, expandIconNode);
  const triggerModeRef = React230.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1) {
    triggerModeRef.current = "vertical";
  } else {
    triggerModeRef.current = mode;
  }
  const popupContentTriggerMode = triggerModeRef.current;
  const renderPopupContent = React230.useMemo(() => {
    const originNode = React230.createElement(InheritableContextProvider, {
      classNames: menuClassNames,
      styles,
      mode: popupContentTriggerMode === "horizontal" ? "vertical" : popupContentTriggerMode
    }, React230.createElement(SubMenuList_default, {
      id: popupId,
      ref: popupRef
    }, children));
    const mergedPopupRender = propsPopupRender || contextPopupRender;
    if (mergedPopupRender) {
      const node2 = mergedPopupRender(originNode, {
        item: props,
        keys: connectedPath
      });
      return node2;
    }
    return originNode;
  }, [propsPopupRender, contextPopupRender, connectedPath, popupId, children, props, popupContentTriggerMode]);
  if (!overflowDisabled) {
    const triggerMode = triggerModeRef.current;
    titleNode = React230.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open3 && mode !== "inline",
      popupClassName,
      popupOffset,
      popupStyle,
      popup: renderPopupContent,
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  let listNode = React230.createElement(es_default10.Item, _extends29({
    ref,
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: clsx(subMenuPrefixCls, `${subMenuPrefixCls}-${mode}`, className, {
      [`${subMenuPrefixCls}-open`]: open3,
      [`${subMenuPrefixCls}-active`]: mergedActive,
      [`${subMenuPrefixCls}-selected`]: childrenSelected,
      [`${subMenuPrefixCls}-disabled`]: mergedDisabled
    }),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && React230.createElement(InlineSubMenuList, {
    id: popupId,
    open: open3,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open3,
      disabled: mergedDisabled
    });
  }
  return React230.createElement(InheritableContextProvider, {
    classNames: menuClassNames,
    styles,
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
});
var SubMenu = React230.forwardRef((props, ref) => {
  const {
    eventKey,
    children
  } = props;
  const connectedKeyPath = useFullPath(eventKey);
  const childList = parseChildren(children, connectedKeyPath);
  const measure = useMeasure();
  React230.useEffect(() => {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return () => {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  let renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = React230.createElement(InternalSubMenu, _extends29({
      ref
    }, props), childList);
  }
  return React230.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
});
if (true) {
  SubMenu.displayName = "SubMenu";
}
var SubMenu_default = SubMenu;

// node_modules/@rc-component/menu/es/utils/nodeUtil.js
var React233 = __toESM(require_react());

// node_modules/@rc-component/menu/es/Divider.js
var React231 = __toESM(require_react());
function Divider({
  className,
  style: style2
}) {
  const {
    prefixCls
  } = React231.useContext(MenuContext);
  const measure = useMeasure();
  if (measure) {
    return null;
  }
  return React231.createElement("li", {
    role: "separator",
    className: clsx(`${prefixCls}-item-divider`, className),
    style: style2
  });
}

// node_modules/@rc-component/menu/es/MenuItemGroup.js
var React232 = __toESM(require_react());
function _extends30() {
  _extends30 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends30.apply(this, arguments);
}
var InternalMenuItemGroup = React232.forwardRef((props, ref) => {
  const {
    className,
    title,
    eventKey,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    classNames: menuClassNames,
    styles
  } = React232.useContext(MenuContext);
  const groupPrefixCls = `${prefixCls}-item-group`;
  return React232.createElement("li", _extends30({
    ref,
    role: "presentation"
  }, restProps, {
    onClick: (e3) => e3.stopPropagation(),
    className: clsx(groupPrefixCls, className)
  }), React232.createElement("div", {
    role: "presentation",
    className: clsx(`${groupPrefixCls}-title`, menuClassNames == null ? void 0 : menuClassNames.listTitle),
    style: styles == null ? void 0 : styles.listTitle,
    title: typeof title === "string" ? title : void 0
  }, title), React232.createElement("ul", {
    role: "group",
    className: clsx(`${groupPrefixCls}-list`, menuClassNames == null ? void 0 : menuClassNames.list),
    style: styles == null ? void 0 : styles.list
  }, children));
});
var MenuItemGroup = React232.forwardRef((props, ref) => {
  const {
    eventKey,
    children
  } = props;
  const connectedKeyPath = useFullPath(eventKey);
  const childList = parseChildren(children, connectedKeyPath);
  const measure = useMeasure();
  if (measure) {
    return childList;
  }
  return React232.createElement(InternalMenuItemGroup, _extends30({
    ref
  }, omit(props, ["warnKey"])), childList);
});
if (true) {
  MenuItemGroup.displayName = "MenuItemGroup";
}
var MenuItemGroup_default = MenuItemGroup;

// node_modules/@rc-component/menu/es/utils/nodeUtil.js
function _extends31() {
  _extends31 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends31.apply(this, arguments);
}
function convertItemsToNodes2(list, components2, prefixCls) {
  const {
    item: MergedMenuItem,
    group: MergedMenuItemGroup,
    submenu: MergedSubMenu,
    divider: MergedDivider
  } = components2;
  return (list || []).map((opt, index2) => {
    if (opt && typeof opt === "object") {
      const {
        label,
        children,
        key,
        type: type5,
        extra,
        ...restProps
      } = opt;
      const mergedKey = key ?? `tmp-${index2}`;
      if (children || type5 === "group") {
        if (type5 === "group") {
          return React233.createElement(MergedMenuItemGroup, _extends31({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes2(children, components2, prefixCls));
        }
        return React233.createElement(MergedSubMenu, _extends31({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes2(children, components2, prefixCls));
      }
      if (type5 === "divider") {
        return React233.createElement(MergedDivider, _extends31({
          key: mergedKey
        }, restProps));
      }
      return React233.createElement(MergedMenuItem, _extends31({
        key: mergedKey
      }, restProps, {
        extra
      }), label, (!!extra || extra === 0) && React233.createElement("span", {
        className: `${prefixCls}-item-extra`
      }, extra));
    }
    return null;
  }).filter((opt) => opt);
}
function parseItems(children, items, keyPath, components2, prefixCls) {
  let childNodes = children;
  const mergedComponents = {
    divider: Divider,
    item: MenuItem_default,
    group: MenuItemGroup_default,
    submenu: SubMenu_default,
    ...components2
  };
  if (items) {
    childNodes = convertItemsToNodes2(items, mergedComponents, prefixCls);
  }
  return parseChildren(childNodes, keyPath);
}

// node_modules/@rc-component/menu/es/Menu.js
function _extends32() {
  _extends32 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends32.apply(this, arguments);
}
var EMPTY_LIST2 = [];
var Menu = React234.forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls = "rc-menu",
    rootClassName,
    style: style2,
    className,
    styles,
    classNames: menuClassNames,
    tabIndex = 0,
    items,
    children,
    direction,
    id,
    // Mode
    mode = "vertical",
    inlineCollapsed,
    // Disabled
    disabled,
    disabledOverflow,
    // Open
    subMenuOpenDelay = 0.1,
    subMenuCloseDelay = 0.1,
    forceSubMenuRender,
    defaultOpenKeys,
    openKeys,
    // Active
    activeKey,
    defaultActiveFirst,
    // Selection
    selectable = true,
    multiple = false,
    defaultSelectedKeys,
    selectedKeys,
    onSelect,
    onDeselect,
    // Level
    inlineIndent = 24,
    // Motion
    motion: motion2,
    defaultMotions,
    // Popup
    triggerSubMenuAction = "hover",
    builtinPlacements,
    // Icon
    itemIcon,
    expandIcon,
    overflowedIndicator = "...",
    overflowedIndicatorPopupClassName,
    // Function
    getPopupContainer,
    // Events
    onClick,
    onOpenChange,
    onKeyDown: onKeyDown2,
    // Deprecated
    openAnimation,
    openTransitionName,
    // Internal
    _internalRenderMenuItem,
    _internalRenderSubMenuItem,
    _internalComponents,
    popupRender,
    ...restProps
  } = props;
  const [childList, measureChildList] = React234.useMemo(() => [parseItems(children, items, EMPTY_LIST2, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST2, {}, prefixCls)], [children, items, _internalComponents]);
  const [mounted, setMounted] = React234.useState(false);
  const containerRef = React234.useRef();
  const uuid6 = useId_default(id ? `rc-menu-uuid-${id}` : "rc-menu-uuid");
  const isRtl = direction === "rtl";
  if (true) {
    warning_default(!openAnimation && !openTransitionName, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  }
  const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);
  const mergedOpenKeys = innerOpenKeys || EMPTY_LIST2;
  const triggerOpenKeys = (keys2, forceFlush = false) => {
    function doUpdate() {
      setMergedOpenKeys(keys2);
      onOpenChange == null ? void 0 : onOpenChange(keys2);
    }
    if (forceFlush) {
      (0, import_react_dom5.flushSync)(doUpdate);
    } else {
      doUpdate();
    }
  };
  const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = React234.useState(mergedOpenKeys);
  const mountRef = React234.useRef(false);
  const [mergedMode, mergedInlineCollapsed] = React234.useMemo(() => {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]);
  const isInlineMode = mergedMode === "inline";
  const [internalMode, setInternalMode] = React234.useState(mergedMode);
  const [internalInlineCollapsed, setInternalInlineCollapsed] = React234.useState(mergedInlineCollapsed);
  React234.useEffect(() => {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST2);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  const [lastVisibleIndex, setLastVisibleIndex] = React234.useState(0);
  const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  React234.useEffect(() => {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  React234.useEffect(() => {
    mountRef.current = true;
    return () => {
      mountRef.current = false;
    };
  }, []);
  const {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  } = useKeyRecords();
  const registerPathContext = React234.useMemo(() => ({
    registerPath,
    unregisterPath
  }), [registerPath, unregisterPath]);
  const pathUserContext = React234.useMemo(() => ({
    isSubPathKey
  }), [isSubPathKey]);
  React234.useEffect(() => {
    refreshOverflowKeys(allVisible ? EMPTY_LIST2 : childList.slice(lastVisibleIndex + 1).map((child) => child.key));
  }, [lastVisibleIndex, allVisible]);
  const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && ((_a = childList[0]) == null ? void 0 : _a.key), activeKey);
  const onActive = useMemoCallback((key) => {
    setMergedActiveKey(key);
  });
  const onInactive = useMemoCallback(() => {
    setMergedActiveKey(void 0);
  });
  (0, import_react98.useImperativeHandle)(ref, () => {
    return {
      list: containerRef.current,
      focus: (options) => {
        var _a2, _b;
        const keys2 = getKeys();
        const {
          elements,
          key2element,
          element2key
        } = refreshElements(keys2, uuid6);
        const focusableElements = getFocusableElements(containerRef.current, elements);
        let shouldFocusKey;
        if (mergedActiveKey && keys2.includes(mergedActiveKey)) {
          shouldFocusKey = mergedActiveKey;
        } else {
          shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : (_a2 = childList.find((node2) => !node2.props.disabled)) == null ? void 0 : _a2.key;
        }
        const elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          (_b = elementToFocus == null ? void 0 : elementToFocus.focus) == null ? void 0 : _b.call(elementToFocus, options);
        }
      },
      findItem: ({
        key: itemKey3
      }) => {
        const keys2 = getKeys();
        const {
          key2element
        } = refreshElements(keys2, uuid6);
        return key2element.get(itemKey3) || null;
      }
    };
  });
  const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);
  const mergedSelectKeys = React234.useMemo(() => {
    if (Array.isArray(internalSelectKeys)) {
      return internalSelectKeys;
    }
    if (internalSelectKeys === null || internalSelectKeys === void 0) {
      return EMPTY_LIST2;
    }
    return [internalSelectKeys];
  }, [internalSelectKeys]);
  const triggerSelection = (info) => {
    if (selectable) {
      const {
        key: targetKey
      } = info;
      const exist = mergedSelectKeys.includes(targetKey);
      let newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter((key) => key !== targetKey);
        } else {
          newSelectKeys = [...mergedSelectKeys, targetKey];
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      const selectInfo = {
        ...info,
        selectedKeys: newSelectKeys
      };
      if (exist) {
        onDeselect == null ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect == null ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST2);
    }
  };
  const onInternalClick = useMemoCallback((info) => {
    onClick == null ? void 0 : onClick(warnItemProp(info));
    triggerSelection(info);
  });
  const onInternalOpenChange = useMemoCallback((key, open3) => {
    let newOpenKeys = mergedOpenKeys.filter((k) => k !== key);
    if (open3) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      const subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter((k) => !subPathKeys.has(k));
    }
    if (!isEqual_default(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  const triggerAccessibilityOpen = (key, open3) => {
    const nextOpen = open3 ?? !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  const onInternalKeyDown = useAccessibility2(internalMode, mergedActiveKey, isRtl, uuid6, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  React234.useEffect(() => {
    setMounted(true);
  }, []);
  const privateContext = React234.useMemo(() => ({
    _internalRenderMenuItem,
    _internalRenderSubMenuItem
  }), [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  const wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
    // Need wrap for overflow dropdown that do not response for open
    childList.map((child, index2) => (
      // Always wrap provider to avoid sub node re-mount
      React234.createElement(InheritableContextProvider, {
        key: child.key,
        overflowDisabled: index2 > lastVisibleIndex,
        classNames: menuClassNames,
        styles
      }, child)
    ))
  );
  const container = React234.createElement(es_default10, _extends32({
    id,
    ref: containerRef,
    prefixCls: `${prefixCls}-overflow`,
    component: "ul",
    itemComponent: MenuItem_default,
    className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {
      [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,
      [`${prefixCls}-rtl`]: isRtl
    }, rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: (node2) => node2,
    renderRawRest: (omitItems) => {
      const len = omitItems.length;
      const originOmitItems = len ? childList.slice(-len) : null;
      return React234.createElement(SubMenu_default, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== "horizontal" || disabledOverflow ? es_default10.INVALIDATE : es_default10.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: (newLastIndex) => {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return React234.createElement(PrivateContext_default.Provider, {
    value: privateContext
  }, React234.createElement(IdContext.Provider, {
    value: uuid6
  }, React234.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    classNames: menuClassNames,
    styles,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion2 : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange,
    popupRender
  }, React234.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), React234.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, React234.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, measureChildList)))));
});
var Menu_default = Menu;

// node_modules/@rc-component/menu/es/index.js
var ExportMenu = Menu_default;
ExportMenu.Item = MenuItem_default;
ExportMenu.SubMenu = SubMenu_default;
ExportMenu.ItemGroup = MenuItemGroup_default;
ExportMenu.Divider = Divider;
var es_default15 = ExportMenu;

// node_modules/antd/es/layout/Sider.js
var React236 = __toESM(require_react());
var import_react99 = __toESM(require_react());

// node_modules/antd/es/layout/context.js
var React235 = __toESM(require_react());
var LayoutContext = React235.createContext({
  siderHook: {
    addSider: () => null,
    removeSider: () => null
  }
});

// node_modules/antd/es/layout/style/index.js
var genLayoutStyle = (token2) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    footerBg,
    headerHeight,
    headerPadding,
    headerColor,
    footerPadding,
    fontSize,
    bodyBg,
    headerBg
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: bodyBg,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // ==================== Header ====================
    [`${componentCls}-header`]: {
      height: headerHeight,
      padding: headerPadding,
      color: headerColor,
      lineHeight: unit(headerHeight),
      background: headerBg,
      // Other components/menu/style/index.less line:686
      // Integration with header element so menu items have the same height
      [`${antCls}-menu`]: {
        lineHeight: "inherit"
      }
    },
    // ==================== Footer ====================
    [`${componentCls}-footer`]: {
      padding: footerPadding,
      color: colorText,
      fontSize,
      background: footerBg
    },
    // =================== Content ====================
    [`${componentCls}-content`]: {
      flex: "auto",
      color: colorText,
      // fix firefox can't set height smaller than content on flex item
      minHeight: 0
    }
  };
};
var prepareComponentToken17 = (token2) => {
  const {
    colorBgLayout,
    controlHeight,
    controlHeightLG,
    colorText,
    controlHeightSM,
    marginXXS,
    colorTextLightSolid,
    colorBgContainer
  } = token2;
  const paddingInline = controlHeightLG * 1.25;
  return {
    // Deprecated
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140",
    bodyBg: colorBgLayout,
    headerBg: "#001529",
    headerHeight: controlHeight * 2,
    headerPadding: `0 ${paddingInline}px`,
    headerColor: colorText,
    footerPadding: `${controlHeightSM}px ${paddingInline}px`,
    footerBg: colorBgLayout,
    siderBg: "#001529",
    triggerHeight: controlHeightLG + marginXXS * 2,
    triggerBg: "#002140",
    triggerColor: colorTextLightSolid,
    zeroTriggerWidth: controlHeightLG,
    zeroTriggerHeight: controlHeightLG,
    lightSiderBg: colorBgContainer,
    lightTriggerBg: colorBgContainer,
    lightTriggerColor: colorText
  };
};
var DEPRECATED_TOKENS = [["colorBgBody", "bodyBg"], ["colorBgHeader", "headerBg"], ["colorBgTrigger", "triggerBg"]];
var style_default19 = genStyleHooks("Layout", genLayoutStyle, prepareComponentToken17, {
  deprecatedTokens: DEPRECATED_TOKENS
});

// node_modules/antd/es/layout/style/sider.js
var genSiderStyle = (token2) => {
  const {
    componentCls,
    siderBg,
    motionDurationMid,
    motionDurationSlow,
    antCls,
    triggerHeight,
    triggerColor,
    triggerBg,
    headerHeight,
    zeroTriggerWidth,
    zeroTriggerHeight,
    borderRadiusLG,
    lightSiderBg,
    lightTriggerColor,
    lightTriggerBg,
    bodyBg
  } = token2;
  return {
    [componentCls]: {
      position: "relative",
      // fix firefox can't set width smaller than content on flex item
      minWidth: 0,
      background: siderBg,
      transition: `all ${motionDurationMid}, background 0s`,
      "&-has-trigger": {
        paddingBottom: triggerHeight
      },
      "&-right": {
        order: 1
      },
      [`${componentCls}-children`]: {
        height: "100%",
        // Hack for fixing margin collapse bug
        // https://github.com/ant-design/ant-design/issues/7967
        // solution from https://stackoverflow.com/a/33132624/3040605
        marginTop: -0.1,
        paddingTop: 0.1,
        [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
          width: "auto"
        }
      },
      [`&-zero-width ${componentCls}-children`]: {
        overflow: "hidden"
      },
      [`${componentCls}-trigger`]: {
        position: "fixed",
        bottom: 0,
        zIndex: 1,
        height: triggerHeight,
        color: triggerColor,
        lineHeight: unit(triggerHeight),
        textAlign: "center",
        background: triggerBg,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-zero-width-trigger`]: {
        position: "absolute",
        top: headerHeight,
        insetInlineEnd: token2.calc(zeroTriggerWidth).mul(-1).equal(),
        zIndex: 1,
        width: zeroTriggerWidth,
        height: zeroTriggerHeight,
        color: triggerColor,
        fontSize: token2.fontSizeXL,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: siderBg,
        borderRadius: `0 ${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0`,
        cursor: "pointer",
        transition: `background ${motionDurationSlow} ease`,
        "&::after": {
          position: "absolute",
          inset: 0,
          background: "transparent",
          transition: `all ${motionDurationSlow}`,
          content: '""'
        },
        "&:hover::after": {
          background: `rgba(255, 255, 255, 0.2)`
        },
        "&-right": {
          insetInlineStart: token2.calc(zeroTriggerWidth).mul(-1).equal(),
          borderRadius: `${unit(borderRadiusLG)} 0 0 ${unit(borderRadiusLG)}`
        }
      },
      // Light
      "&-light": {
        background: lightSiderBg,
        [`${componentCls}-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg
        },
        [`${componentCls}-zero-width-trigger`]: {
          color: lightTriggerColor,
          background: lightTriggerBg,
          border: `1px solid ${bodyBg}`,
          // Safe to modify to any other color
          borderInlineStart: 0
        }
      }
    }
  };
};
var sider_default = genStyleHooks(["Layout", "Sider"], genSiderStyle, prepareComponentToken17, {
  deprecatedTokens: DEPRECATED_TOKENS
});

// node_modules/antd/es/layout/Sider.js
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
};
var isNumeric = (val) => !Number.isNaN(Number.parseFloat(val)) && Number.isFinite(Number(val));
var SiderContext = React236.createContext({});
var generateId = (() => {
  let i = 0;
  return (prefix2 = "") => {
    i += 1;
    return `${prefix2}${i}`;
  };
})();
var Sider = React236.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    trigger,
    children,
    defaultCollapsed = false,
    theme = "dark",
    style: style2 = {},
    collapsible = false,
    reverseArrow = false,
    width = 200,
    collapsedWidth = 80,
    zeroWidthTriggerStyle,
    breakpoint,
    onCollapse,
    onBreakpoint,
    ...otherProps
  } = props;
  const {
    siderHook
  } = (0, import_react99.useContext)(LayoutContext);
  const [collapsed, setCollapsed] = (0, import_react99.useState)("collapsed" in props ? props.collapsed : defaultCollapsed);
  const [below, setBelow] = (0, import_react99.useState)(false);
  (0, import_react99.useEffect)(() => {
    if ("collapsed" in props) {
      setCollapsed(props.collapsed);
    }
  }, [props.collapsed]);
  const handleSetCollapsed = (value, type5) => {
    if (!("collapsed" in props)) {
      setCollapsed(value);
    }
    onCollapse == null ? void 0 : onCollapse(value, type5);
  };
  const {
    getPrefixCls,
    direction
  } = (0, import_react99.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
  const [hashId, cssVarCls] = sider_default(prefixCls);
  const responsiveHandlerRef = (0, import_react99.useRef)(null);
  responsiveHandlerRef.current = (mql) => {
    setBelow(mql.matches);
    onBreakpoint == null ? void 0 : onBreakpoint(mql.matches);
    if (collapsed !== mql.matches) {
      handleSetCollapsed(mql.matches, "responsive");
    }
  };
  (0, import_react99.useEffect)(() => {
    function responsiveHandler(mql2) {
      var _a;
      return (_a = responsiveHandlerRef.current) == null ? void 0 : _a.call(responsiveHandlerRef, mql2);
    }
    let mql;
    if (typeof (window == null ? void 0 : window.matchMedia) !== "undefined" && breakpoint && breakpoint in dimensionMaxMap) {
      mql = window.matchMedia(`screen and (max-width: ${dimensionMaxMap[breakpoint]})`);
      if (typeof (mql == null ? void 0 : mql.addEventListener) === "function") {
        mql.addEventListener("change", responsiveHandler);
      }
      responsiveHandler(mql);
    }
    return () => {
      if (typeof (mql == null ? void 0 : mql.removeEventListener) === "function") {
        mql.removeEventListener("change", responsiveHandler);
      }
    };
  }, [breakpoint]);
  (0, import_react99.useEffect)(() => {
    const uniqueId = generateId("ant-sider-");
    siderHook.addSider(uniqueId);
    return () => siderHook.removeSider(uniqueId);
  }, []);
  const toggle = () => {
    handleSetCollapsed(!collapsed, "clickTrigger");
  };
  const divProps = omit(otherProps, ["collapsed"]);
  const rawWidth = collapsed ? collapsedWidth : width;
  const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
  const zeroWidthTrigger = Number.parseFloat(String(collapsedWidth || 0)) === 0 ? React236.createElement("span", {
    onClick: toggle,
    className: clsx(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
    style: zeroWidthTriggerStyle
  }, trigger || React236.createElement(BarsOutlined_default, null)) : null;
  const reverseIcon = direction === "rtl" === !reverseArrow;
  const iconObj = {
    expanded: reverseIcon ? React236.createElement(RightOutlined_default, null) : React236.createElement(LeftOutlined_default, null),
    collapsed: reverseIcon ? React236.createElement(LeftOutlined_default, null) : React236.createElement(RightOutlined_default, null)
  };
  const status = collapsed ? "collapsed" : "expanded";
  const defaultTrigger = iconObj[status];
  const triggerDom = trigger !== null ? zeroWidthTrigger || React236.createElement("div", {
    className: `${prefixCls}-trigger`,
    onClick: toggle,
    style: {
      width: siderWidth
    }
  }, trigger || defaultTrigger) : null;
  const divStyle = {
    ...style2,
    flex: `0 0 ${siderWidth}`,
    maxWidth: siderWidth,
    // Fix width transition bug in IE11
    minWidth: siderWidth,
    // https://github.com/ant-design/ant-design/issues/6349
    width: siderWidth
  };
  const siderCls = clsx(prefixCls, `${prefixCls}-${theme}`, {
    [`${prefixCls}-collapsed`]: !!collapsed,
    [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
    [`${prefixCls}-below`]: !!below,
    [`${prefixCls}-zero-width`]: Number.parseFloat(siderWidth) === 0
  }, className, hashId, cssVarCls);
  const contextValue = React236.useMemo(() => ({
    siderCollapsed: collapsed
  }), [collapsed]);
  return React236.createElement(SiderContext.Provider, {
    value: contextValue
  }, React236.createElement("aside", {
    className: siderCls,
    ...divProps,
    style: divStyle,
    ref
  }, React236.createElement("div", {
    className: `${prefixCls}-children`
  }, children), collapsible || below && zeroWidthTrigger ? triggerDom : null));
});
if (true) {
  Sider.displayName = "Sider";
}
var Sider_default = Sider;

// node_modules/antd/es/menu/menu.js
var React241 = __toESM(require_react());
var import_react101 = __toESM(require_react());

// node_modules/antd/es/menu/MenuContext.js
var import_react100 = __toESM(require_react());
var MenuContext2 = (0, import_react100.createContext)({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false,
  styles: null,
  classNames: null
});
var MenuContext_default = MenuContext2;

// node_modules/antd/es/menu/MenuDivider.js
var React237 = __toESM(require_react());
var MenuDivider = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    dashed,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React237.useContext(ConfigContext);
  const prefixCls = getPrefixCls("menu", customizePrefixCls);
  const classString = clsx({
    [`${prefixCls}-item-divider-dashed`]: !!dashed
  }, className);
  return React237.createElement(Divider, {
    className: classString,
    ...restProps
  });
};
var MenuDivider_default = MenuDivider;

// node_modules/antd/es/menu/MenuItem.js
var React238 = __toESM(require_react());
var MenuItem2 = (props) => {
  const {
    className,
    children,
    icon,
    title,
    danger,
    extra
  } = props;
  const {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed,
    styles,
    classNames
  } = React238.useContext(MenuContext_default);
  const renderItemChildren = (inlineCollapsed) => {
    const label = children == null ? void 0 : children[0];
    const wrapNode = React238.createElement("span", {
      className: clsx(`${prefixCls}-title-content`, firstLevel ? classNames.itemContent : classNames.subMenu.itemContent, {
        [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
      }),
      style: firstLevel ? styles.itemContent : styles.subMenu.itemContent
    }, children);
    if (!icon || React238.isValidElement(children) && children.type === "span") {
      if (children && inlineCollapsed && firstLevel && typeof label === "string") {
        return React238.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, label.charAt(0));
      }
    }
    return wrapNode;
  };
  const {
    siderCollapsed
  } = React238.useContext(SiderContext);
  let tooltipTitle = title;
  if (typeof title === "undefined") {
    tooltipTitle = firstLevel ? children : "";
  } else if (title === false) {
    tooltipTitle = "";
  }
  const tooltipProps = {
    title: tooltipTitle
  };
  if (!siderCollapsed && !isInlineCollapsed) {
    tooltipProps.title = null;
    tooltipProps.open = false;
  }
  const childrenLength = toArray(children).length;
  let returnNode = React238.createElement(MenuItem_default, {
    ...omit(props, ["title", "icon", "danger"]),
    className: clsx(firstLevel ? classNames.item : classNames.subMenu.item, {
      [`${prefixCls}-item-danger`]: danger,
      [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
    }, className),
    style: {
      ...firstLevel ? styles.item : styles.subMenu.item,
      ...props.style
    },
    title: typeof title === "string" ? title : void 0
  }, cloneElement3(icon, (oriProps) => ({
    className: clsx(`${prefixCls}-item-icon`, firstLevel ? classNames.itemIcon : classNames.subMenu.itemIcon, oriProps.className),
    style: {
      ...firstLevel ? styles.itemIcon : styles.subMenu.itemIcon,
      ...oriProps.style
    }
  })), renderItemChildren(isInlineCollapsed));
  if (!disableMenuItemTitleTooltip) {
    returnNode = React238.createElement(tooltip_default, {
      ...tooltipProps,
      placement: direction === "rtl" ? "left" : "right",
      classNames: {
        root: `${prefixCls}-inline-collapsed-tooltip`
      }
    }, returnNode);
  }
  return returnNode;
};
var MenuItem_default2 = MenuItem2;

// node_modules/antd/es/menu/OverrideContext.js
var React239 = __toESM(require_react());
var OverrideContext = React239.createContext(null);
var OverrideProvider = React239.forwardRef((props, ref) => {
  const {
    children,
    ...restProps
  } = props;
  const override = React239.useContext(OverrideContext);
  const context = React239.useMemo(() => ({
    ...override,
    ...restProps
  }), [
    override,
    restProps.prefixCls,
    // restProps.expandIcon, Not mark as deps since this is a ReactNode
    restProps.mode,
    restProps.selectable,
    restProps.rootClassName
    // restProps.validator, Not mark as deps since this is a function
  ]);
  const canRef = supportNodeRef(children);
  const mergedRef = useComposeRef(ref, canRef ? getNodeRef(children) : null);
  return React239.createElement(OverrideContext.Provider, {
    value: context
  }, React239.createElement(ContextIsolator_default, {
    space: true
  }, canRef ? React239.cloneElement(children, {
    ref: mergedRef
  }) : children));
});
var OverrideContext_default = OverrideContext;

// node_modules/antd/es/menu/style/horizontal.js
var getHorizontalStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    horizontalLineHeight,
    colorSplit,
    lineWidth,
    lineType,
    itemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: horizontalLineHeight,
      border: 0,
      borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: itemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
};
var horizontal_default = getHorizontalStyle;

// node_modules/antd/es/menu/style/rtl.js
var getRTLStyle = ({
  componentCls,
  menuArrowOffset,
  calc
}) => ({
  [`${componentCls}-rtl`]: {
    direction: "rtl"
  },
  [`${componentCls}-submenu-rtl`]: {
    transformOrigin: "100% 0"
  },
  // Vertical Arrow
  [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
    [`${componentCls}-submenu-arrow`]: {
      "&::before": {
        transform: `rotate(-45deg) translateY(${unit(calc(menuArrowOffset).mul(-1).equal())})`
      },
      "&::after": {
        transform: `rotate(45deg) translateY(${unit(menuArrowOffset)})`
      }
    }
  }
});
var rtl_default = getRTLStyle;

// node_modules/antd/es/menu/style/theme.js
var accessibilityFocus = (token2) => genFocusOutline(token2);
var getThemeStyle = (token2, themeSuffix) => {
  const {
    componentCls,
    itemColor,
    itemSelectedColor,
    subMenuItemSelectedColor,
    groupTitleColor,
    itemBg,
    subMenuItemBg,
    itemSelectedBg,
    activeBarHeight,
    activeBarWidth,
    activeBarBorderWidth,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    itemPaddingInline,
    motionDurationMid,
    itemHoverColor,
    lineType,
    colorSplit,
    // Disabled
    itemDisabledColor,
    // Danger
    dangerItemColor,
    dangerItemHoverColor,
    dangerItemSelectedColor,
    dangerItemActiveBg,
    dangerItemSelectedBg,
    // Bg
    popupBg,
    itemHoverBg,
    itemActiveBg,
    menuSubMenuBg,
    // Horizontal
    horizontalItemSelectedColor,
    horizontalItemSelectedBg,
    horizontalItemBorderRadius,
    horizontalItemHoverBg
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
      color: itemColor,
      background: itemBg,
      [`&${componentCls}-root:focus-visible`]: {
        ...accessibilityFocus(token2)
      },
      // ======================== Item ========================
      [`${componentCls}-item`]: {
        "&-group-title, &-extra": {
          color: groupTitleColor
        }
      },
      [`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: {
        color: subMenuItemSelectedColor
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        color: itemColor,
        [`&:not(${componentCls}-item-disabled):focus-visible`]: {
          ...accessibilityFocus(token2)
        }
      },
      // Disabled
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${itemDisabledColor} !important`
      },
      // Hover
      [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
        [`&:hover, > ${componentCls}-submenu-title:hover`]: {
          color: itemHoverColor
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: itemHoverBg
          },
          "&:active": {
            backgroundColor: itemActiveBg
          }
        }
      },
      // Danger - only Item has
      [`${componentCls}-item-danger`]: {
        color: dangerItemColor,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: dangerItemHoverColor
          }
        },
        [`&${componentCls}-item:active`]: {
          background: dangerItemActiveBg
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: itemSelectedColor,
        // Danger
        [`&${componentCls}-item-danger`]: {
          color: dangerItemSelectedColor
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: itemSelectedBg,
        // Danger
        [`&${componentCls}-item-danger`]: {
          backgroundColor: dangerItemSelectedBg
        }
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      // =====  =======
      // dark popupBg rest  darkPopupBg
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      [`&${componentCls}-submenu-popup > ${componentCls}`]: {
        backgroundColor: popupBg
      },
      // =====  end =======
      // ====================== Horizontal ======================
      [`&${componentCls}-horizontal`]: {
        ...themeSuffix === "dark" ? {
          borderBottom: 0
        } : {},
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: activeBarBorderWidth,
          marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
          marginBottom: 0,
          borderRadius: horizontalItemBorderRadius,
          "&::after": {
            position: "absolute",
            insetInline: itemPaddingInline,
            bottom: 0,
            borderBottom: `${unit(activeBarHeight)} solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            background: horizontalItemHoverBg,
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          },
          "&-selected": {
            color: horizontalItemSelectedColor,
            backgroundColor: horizontalItemSelectedBg,
            "&:hover": {
              backgroundColor: horizontalItemSelectedBg
            },
            "&::after": {
              borderBottomWidth: activeBarHeight,
              borderBottomColor: horizontalItemSelectedColor
            }
          }
        }
      },
      // ================== Inline & Vertical ===================
      //
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${unit(activeBarBorderWidth)} ${lineType} ${colorSplit}`
        }
      },
      // ======================== Inline ========================
      [`&${componentCls}-inline`]: {
        // Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: subMenuItemBg
        },
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${unit(activeBarWidth)} solid ${itemSelectedColor}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          // Danger
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: dangerItemSelectedColor
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
};
var theme_default2 = getThemeStyle;

// node_modules/antd/es/menu/style/vertical.js
var getVerticalInlineStyle = (token2) => {
  const {
    componentCls,
    itemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    itemMarginBlock,
    itemWidth,
    itemPaddingInline
  } = token2;
  const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
  return {
    [`${componentCls}-item`]: {
      position: "relative",
      overflow: "hidden"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight),
      paddingInline: itemPaddingInline,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: itemMarginBlock,
      width: itemWidth
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: itemHeight,
      lineHeight: unit(itemHeight)
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
};
var getVerticalStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    itemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionEaseOut,
    paddingXL,
    itemMarginInline,
    fontSizeLG,
    motionDurationFast,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary,
    collapsedWidth,
    collapsedIconSize
  } = token2;
  const inlineItemStyle = {
    height: itemHeight,
    lineHeight: unit(itemHeight),
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        "&-inline, &-vertical": {
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          },
          ...getVerticalInlineStyle(token2)
        }
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: {
          ...getVerticalInlineStyle(token2),
          boxShadow: boxShadowSecondary
        }
      }
    },
    // Vertical only
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${unit(token2.calc(controlHeightLG).mul(2.5).equal())})`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        // >>>>> Item
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    // Inline Collapse Only
    {
      [`${componentCls}-inline-collapsed`]: {
        width: collapsedWidth,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${unit(token2.calc(collapsedIconSize).div(2).equal())} - ${unit(itemMarginInline)})`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: collapsedIconSize,
            lineHeight: unit(itemHeight),
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: {
          ...textEllipsis,
          paddingInline: paddingXS
        }
      }
    }
  ];
};
var vertical_default = getVerticalStyle;

// node_modules/antd/es/menu/style/index.js
var genMenuItemStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    iconSize,
    iconMarginInlineEnd
  } = token2;
  return {
    // >>>>> Item
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: iconSize,
        fontSize: iconSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: iconMarginInlineEnd,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: {
        ...resetIcon()
      },
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important",
        cursor: "not-allowed",
        pointerEvents: "none"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
};
var genSubMenuArrowStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        // 
        "&::before, &::after": {
          position: "absolute",
          width: token2.calc(menuArrowSize).mul(0.6).equal(),
          height: token2.calc(menuArrowSize).mul(0.15).equal(),
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${unit(menuArrowOffset)})`
        }
      }
    }
  };
};
var getBaseStyle = (token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    subMenuItemBorderRadius,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    groupTitleLineHeight,
    groupTitleFontSize
  } = token2;
  return [
    // Misc
    {
      "": {
        [componentCls]: {
          ...clearFix(),
          // Hidden
          "&-hidden": {
            display: "none"
          }
        }
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...clearFix(),
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize,
        lineHeight: 0,
        // Fix display inline-block gap
        listStyle: "none",
        outline: "none",
        // Magic cubic here but smooth transition
        transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.itemBorderRadius
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${unit(paddingXS)} ${unit(padding)}`,
          fontSize: groupTitleFontSize,
          lineHeight: groupTitleLineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`,
          "&-with-extra": {
            display: "inline-flex",
            alignItems: "center",
            width: "100%"
          },
          // https://github.com/ant-design/ant-design/issues/41143
          [`> ${antCls}-typography-ellipsis-single-line`]: {
            display: "inline",
            verticalAlign: "unset"
          },
          [`${componentCls}-item-extra`]: {
            marginInlineStart: "auto",
            paddingInlineStart: token2.padding
          }
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        },
        // Item
        ...genMenuItemStyle(token2),
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${unit(token2.calc(fontSize).mul(2).equal())} ${unit(padding)}`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            [`&${componentCls}-submenu`]: {
              background: "transparent"
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: 0,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            },
            [`> ${componentCls}`]: {
              borderRadius: borderRadiusLG,
              ...genMenuItemStyle(token2),
              ...genSubMenuArrowStyle(token2),
              [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                borderRadius: subMenuItemBorderRadius
              },
              [`${componentCls}-submenu-title::after`]: {
                transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
              }
            }
          },
          [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
            transformOrigin: "100% 0"
          },
          [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
            transformOrigin: "100% 100%"
          },
          [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
            transformOrigin: "0 100%"
          },
          [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
            transformOrigin: "0 0"
          },
          [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
            paddingInlineEnd: token2.paddingXS
          },
          [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
            paddingInlineStart: token2.paddingXS
          },
          [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
            paddingBottom: token2.paddingXS
          },
          [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
            paddingTop: token2.paddingXS
          }
        },
        ...genSubMenuArrowStyle(token2),
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          // 
          "&::before": {
            transform: `rotate(-45deg) translateX(${unit(menuArrowOffset)})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          // 
          transform: `translateY(${unit(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
          "&::after": {
            transform: `rotate(-45deg) translateX(${unit(token2.calc(menuArrowOffset).mul(-1).equal())})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${unit(menuArrowOffset)})`
          }
        }
      }
    },
    // Integration with header element so menu items have the same height
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
};
var prepareComponentToken18 = (token2) => {
  const {
    colorPrimary,
    colorError,
    colorTextDisabled,
    colorErrorBg,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorFillAlter,
    colorFillContent,
    lineWidth,
    lineWidthBold,
    controlItemBgActive,
    colorBgTextHover,
    controlHeightLG,
    lineHeight,
    colorBgElevated,
    marginXXS,
    padding,
    fontSize,
    controlHeightSM,
    fontSizeLG,
    colorTextLightSolid,
    colorErrorHover
  } = token2;
  const activeBarWidth = token2.activeBarWidth ?? 0;
  const activeBarBorderWidth = token2.activeBarBorderWidth ?? lineWidth;
  const itemMarginInline = token2.itemMarginInline ?? token2.marginXXS;
  const colorTextDark = new FastColor(colorTextLightSolid).setA(0.65).toRgbString();
  return {
    dropdownWidth: 160,
    zIndexPopup: token2.zIndexPopupBase + 50,
    radiusItem: token2.borderRadiusLG,
    itemBorderRadius: token2.borderRadiusLG,
    radiusSubMenuItem: token2.borderRadiusSM,
    subMenuItemBorderRadius: token2.borderRadiusSM,
    colorItemText: colorText,
    itemColor: colorText,
    colorItemTextHover: colorText,
    itemHoverColor: colorText,
    colorItemTextHoverHorizontal: colorPrimary,
    horizontalItemHoverColor: colorPrimary,
    colorGroupTitle: colorTextDescription,
    groupTitleColor: colorTextDescription,
    colorItemTextSelected: colorPrimary,
    itemSelectedColor: colorPrimary,
    subMenuItemSelectedColor: colorPrimary,
    colorItemTextSelectedHorizontal: colorPrimary,
    horizontalItemSelectedColor: colorPrimary,
    colorItemBg: colorBgContainer,
    itemBg: colorBgContainer,
    colorItemBgHover: colorBgTextHover,
    itemHoverBg: colorBgTextHover,
    colorItemBgActive: colorFillContent,
    itemActiveBg: controlItemBgActive,
    colorSubItemBg: colorFillAlter,
    subMenuItemBg: colorFillAlter,
    colorItemBgSelected: controlItemBgActive,
    itemSelectedBg: controlItemBgActive,
    colorItemBgSelectedHorizontal: "transparent",
    horizontalItemSelectedBg: "transparent",
    colorActiveBarWidth: 0,
    activeBarWidth,
    colorActiveBarHeight: lineWidthBold,
    activeBarHeight: lineWidthBold,
    colorActiveBarBorderSize: lineWidth,
    activeBarBorderWidth,
    // Disabled
    colorItemTextDisabled: colorTextDisabled,
    itemDisabledColor: colorTextDisabled,
    // Danger
    colorDangerItemText: colorError,
    dangerItemColor: colorError,
    colorDangerItemTextHover: colorError,
    dangerItemHoverColor: colorError,
    colorDangerItemTextSelected: colorError,
    dangerItemSelectedColor: colorError,
    colorDangerItemBgActive: colorErrorBg,
    dangerItemActiveBg: colorErrorBg,
    colorDangerItemBgSelected: colorErrorBg,
    dangerItemSelectedBg: colorErrorBg,
    itemMarginInline,
    horizontalItemBorderRadius: 0,
    horizontalItemHoverBg: "transparent",
    itemHeight: controlHeightLG,
    groupTitleLineHeight: lineHeight,
    collapsedWidth: controlHeightLG * 2,
    popupBg: colorBgElevated,
    itemMarginBlock: marginXXS,
    itemPaddingInline: padding,
    horizontalLineHeight: `${controlHeightLG * 1.15}px`,
    iconSize: fontSize,
    iconMarginInlineEnd: controlHeightSM - fontSize,
    collapsedIconSize: fontSizeLG,
    groupTitleFontSize: fontSize,
    // Disabled
    darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(0.25).toRgbString(),
    // Dark
    darkItemColor: colorTextDark,
    darkDangerItemColor: colorError,
    darkItemBg: "#001529",
    darkPopupBg: "#001529",
    darkSubMenuItemBg: "#000c17",
    darkItemSelectedColor: colorTextLightSolid,
    darkItemSelectedBg: colorPrimary,
    darkDangerItemSelectedBg: colorError,
    darkItemHoverBg: "transparent",
    darkGroupTitleColor: colorTextDark,
    darkItemHoverColor: colorTextLightSolid,
    darkDangerItemHoverColor: colorErrorHover,
    darkDangerItemSelectedColor: colorTextLightSolid,
    darkDangerItemActiveBg: colorError,
    // internal
    itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
  };
};
var style_default20 = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
  const useStyle = genStyleHooks("Menu", (token2) => {
    const {
      colorBgElevated,
      controlHeightLG,
      fontSize,
      darkItemColor,
      darkDangerItemColor,
      darkItemBg,
      darkSubMenuItemBg,
      darkItemSelectedColor,
      darkItemSelectedBg,
      darkDangerItemSelectedBg,
      darkItemHoverBg,
      darkGroupTitleColor,
      darkItemHoverColor,
      darkItemDisabledColor,
      darkDangerItemHoverColor,
      darkDangerItemSelectedColor,
      darkDangerItemActiveBg,
      popupBg,
      darkPopupBg
    } = token2;
    const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
    const menuToken = merge2(token2, {
      menuArrowSize,
      menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
      menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
      menuSubMenuBg: colorBgElevated,
      calc: token2.calc,
      popupBg
    });
    const menuDarkToken = merge2(menuToken, {
      itemColor: darkItemColor,
      itemHoverColor: darkItemHoverColor,
      groupTitleColor: darkGroupTitleColor,
      itemSelectedColor: darkItemSelectedColor,
      subMenuItemSelectedColor: darkItemSelectedColor,
      itemBg: darkItemBg,
      popupBg: darkPopupBg,
      subMenuItemBg: darkSubMenuItemBg,
      itemActiveBg: "transparent",
      itemSelectedBg: darkItemSelectedBg,
      activeBarHeight: 0,
      activeBarBorderWidth: 0,
      itemHoverBg: darkItemHoverBg,
      // Disabled
      itemDisabledColor: darkItemDisabledColor,
      // Danger
      dangerItemColor: darkDangerItemColor,
      dangerItemHoverColor: darkDangerItemHoverColor,
      dangerItemSelectedColor: darkDangerItemSelectedColor,
      dangerItemActiveBg: darkDangerItemActiveBg,
      dangerItemSelectedBg: darkDangerItemSelectedBg,
      menuSubMenuBg: darkSubMenuItemBg,
      // Horizontal
      horizontalItemSelectedColor: darkItemSelectedColor,
      horizontalItemSelectedBg: darkItemSelectedBg
    });
    return [
      // Basic
      getBaseStyle(menuToken),
      // Horizontal
      horizontal_default(menuToken),
      // Hard code for some light style
      // Vertical
      vertical_default(menuToken),
      // Hard code for some light style
      // Theme
      theme_default2(menuToken, "light"),
      theme_default2(menuDarkToken, "dark"),
      // RTL
      rtl_default(menuToken),
      // Motion
      collapse_default(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, prepareComponentToken18, {
    deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
    // Dropdown will handle menu style self. We do not need to handle this.
    injectStyle,
    unitless: {
      groupTitleLineHeight: true
    }
  });
  return useStyle(prefixCls, rootCls);
};

// node_modules/antd/es/menu/SubMenu.js
var React240 = __toESM(require_react());
var SubMenu2 = (props) => {
  const {
    popupClassName,
    icon,
    title,
    theme: customTheme
  } = props;
  const context = React240.useContext(MenuContext_default);
  const {
    prefixCls,
    inlineCollapsed,
    theme: contextTheme,
    classNames,
    styles
  } = context;
  const parentPath = useFullPath();
  let titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? React240.createElement("div", {
      className: `${prefixCls}-inline-collapsed-noicon`
    }, title.charAt(0)) : React240.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title);
  } else {
    const titleIsSpan = React240.isValidElement(title) && title.type === "span";
    titleNode = React240.createElement(React240.Fragment, null, cloneElement3(icon, (oriProps) => ({
      className: clsx(oriProps.className, `${prefixCls}-item-icon`, classNames.itemIcon),
      style: {
        ...oriProps.style,
        ...styles.itemIcon
      }
    })), titleIsSpan ? title : React240.createElement("span", {
      className: `${prefixCls}-title-content`
    }, title));
  }
  const contextValue = React240.useMemo(() => ({
    ...context,
    firstLevel: false
  }), [context]);
  const [zIndex] = useZIndex("Menu");
  return React240.createElement(MenuContext_default.Provider, {
    value: contextValue
  }, React240.createElement(SubMenu_default, {
    ...omit(props, ["icon"]),
    title: titleNode,
    classNames: {
      list: classNames.subMenu.list,
      listTitle: classNames.subMenu.itemTitle
    },
    styles: {
      list: styles.subMenu.list,
      listTitle: styles.subMenu.itemTitle
    },
    popupClassName: clsx(prefixCls, popupClassName, classNames.popup.root, `${prefixCls}-${customTheme || contextTheme}`),
    popupStyle: {
      zIndex,
      // fix: https://github.com/ant-design/ant-design/issues/47826#issuecomment-2360737237
      ...props.popupStyle,
      ...styles.popup.root
    }
  }));
};
var SubMenu_default2 = SubMenu2;

// node_modules/antd/es/menu/menu.js
function isEmptyIcon(icon) {
  return icon === null || icon === false;
}
var MENU_COMPONENTS = {
  item: MenuItem_default2,
  submenu: SubMenu_default2,
  divider: MenuDivider_default
};
var InternalMenu = (0, import_react101.forwardRef)((props, ref) => {
  var _a;
  const override = React241.useContext(OverrideContext_default);
  const overrideObj = override || {};
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    theme = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    rootClassName,
    mode,
    selectable,
    onClick,
    overflowedIndicatorPopupClassName,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    menu
  } = React241.useContext(ConfigContext);
  const {
    getPrefixCls,
    getPopupContainer,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("menu");
  const rootPrefixCls = getPrefixCls();
  const passedProps = omit(restProps, ["collapsedWidth"]);
  if (true) {
    const warning5 = devUseWarning("Menu");
    true ? warning5(!("inlineCollapsed" in props && mode !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline.") : void 0;
    warning5.deprecated("items" in props && !props.children, "children", "items");
  }
  (_a = overrideObj.validator) == null ? void 0 : _a.call(overrideObj, {
    mode
  });
  const onItemClick = useEvent_default((...args) => {
    var _a2;
    onClick == null ? void 0 : onClick(...args);
    (_a2 = overrideObj.onClick) == null ? void 0 : _a2.call(overrideObj);
  });
  const mergedMode = overrideObj.mode || mode;
  const mergedSelectable = selectable ?? overrideObj.selectable;
  const mergedInlineCollapsed = inlineCollapsed ?? siderCollapsed;
  const mergedProps = {
    ...props,
    mode: mergedMode,
    inlineCollapsed: mergedInlineCollapsed,
    selectable: mergedSelectable,
    theme
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    },
    subMenu: {
      _default: "item"
    }
  });
  const defaultMotions = {
    horizontal: {
      motionName: `${rootPrefixCls}-slide-up`
    },
    inline: motion_default(rootPrefixCls),
    other: {
      motionName: `${rootPrefixCls}-zoom-big`
    }
  };
  const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default20(prefixCls, rootCls, !override);
  const menuClassName = clsx(`${prefixCls}-${theme}`, contextClassName, className);
  const mergedExpandIcon = React241.useMemo(() => {
    var _a2;
    if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
      return expandIcon || null;
    }
    if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
      return overrideObj.expandIcon || null;
    }
    if (typeof (menu == null ? void 0 : menu.expandIcon) === "function" || isEmptyIcon(menu == null ? void 0 : menu.expandIcon)) {
      return (menu == null ? void 0 : menu.expandIcon) || null;
    }
    const mergedIcon = expandIcon ?? (overrideObj == null ? void 0 : overrideObj.expandIcon) ?? (menu == null ? void 0 : menu.expandIcon);
    return cloneElement3(mergedIcon, {
      className: clsx(`${prefixCls}-submenu-expand-icon`, React241.isValidElement(mergedIcon) ? (_a2 = mergedIcon.props) == null ? void 0 : _a2.className : void 0)
    });
  }, [expandIcon, overrideObj == null ? void 0 : overrideObj.expandIcon, menu == null ? void 0 : menu.expandIcon, prefixCls]);
  const contextValue = React241.useMemo(() => ({
    prefixCls,
    inlineCollapsed: mergedInlineCollapsed || false,
    direction,
    firstLevel: true,
    theme,
    mode: mergedMode,
    disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme, mergedMode, mergedClassNames, mergedStyles]);
  return React241.createElement(OverrideContext_default.Provider, {
    value: null
  }, React241.createElement(MenuContext_default.Provider, {
    value: contextValue
  }, React241.createElement(es_default15, {
    getPopupContainer,
    overflowedIndicator: React241.createElement(EllipsisOutlined_default, null),
    overflowedIndicatorPopupClassName: clsx(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
    classNames: {
      list: mergedClassNames.list,
      listTitle: mergedClassNames.itemTitle
    },
    styles: {
      list: mergedStyles.list,
      listTitle: mergedStyles.itemTitle
    },
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick,
    ...passedProps,
    inlineCollapsed: mergedInlineCollapsed,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    className: menuClassName,
    prefixCls,
    direction,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref,
    rootClassName: clsx(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls, mergedClassNames.root),
    _internalComponents: MENU_COMPONENTS
  })));
});
var menu_default = InternalMenu;

// node_modules/antd/es/menu/index.js
var Menu2 = (0, import_react102.forwardRef)((props, ref) => {
  const menuRef = (0, import_react102.useRef)(null);
  const context = React242.useContext(SiderContext);
  (0, import_react102.useImperativeHandle)(ref, () => ({
    menu: menuRef.current,
    focus: (options) => {
      var _a;
      (_a = menuRef.current) == null ? void 0 : _a.focus(options);
    }
  }));
  return React242.createElement(menu_default, {
    ref: menuRef,
    ...props,
    ...context
  });
});
Menu2.Item = MenuItem_default2;
Menu2.SubMenu = SubMenu_default2;
Menu2.Divider = MenuDivider_default;
Menu2.ItemGroup = MenuItemGroup_default;
if (true) {
  Menu2.displayName = "Menu";
}
var menu_default2 = Menu2;

// node_modules/antd/es/dropdown/style/status.js
var genStatusStyle = (token2) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token2;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
};
var status_default = genStatusStyle;

// node_modules/antd/es/dropdown/style/index.js
var genBaseStyle8 = (token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    paddingBlock,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        // Makes vertical dropdowns have a scrollbar once they become taller than the viewport.
        "&-menu-vertical": {
          maxHeight: "100vh",
          overflowY: "auto"
        },
        [`&-trigger${antCls}-btn`]: {
          [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          }
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      }
    },
    // =============================================================
    // ==                        Arrow style                      ==
    // =============================================================
    getArrowStyle(token2, colorBgElevated, {
      arrowPlacement: {
        top: true,
        bottom: true
      }
    }),
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        ...resetComponent(token2),
        [menuCls]: {
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          ...genFocusStyle(token2),
          "&:empty": {
            padding: 0,
            boxShadow: "none"
          },
          [`${menuCls}-item-group-title`]: {
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          // ======================= Item Content =======================
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "&-with-extra": {
              display: "inline-flex",
              alignItems: "center",
              width: "100%"
            },
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            },
            [`${menuCls}-item-extra`]: {
              paddingInlineStart: token2.padding,
              marginInlineStart: "auto",
              fontSize: token2.fontSizeSM,
              color: token2.colorTextDescription
            }
          },
          // =========================== Item ===========================
          [`${menuCls}-item, ${menuCls}-submenu-title`]: {
            display: "flex",
            margin: 0,
            padding: `${unit(paddingBlock)} ${unit(controlPaddingHorizontal)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            "&:hover, &-active": {
              backgroundColor: token2.controlItemBgHover
            },
            ...genFocusStyle(token2),
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              // By design
              margin: `${unit(token2.marginXXS)} 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorIcon,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          },
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${unit(token2.marginXS)}`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
  ];
};
var prepareComponentToken19 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50,
  paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2,
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token2)
});
var style_default21 = genStyleHooks("Dropdown", (token2) => {
  const {
    marginXXS,
    sizePopupArrow,
    paddingXXS,
    componentCls
  } = token2;
  const dropdownToken = merge2(token2, {
    menuCls: `${componentCls}-menu`,
    dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle8(dropdownToken), status_default(dropdownToken)];
}, prepareComponentToken19, {
  resetStyle: false
});

// node_modules/antd/es/dropdown/dropdown.js
var Dropdown2 = (props) => {
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    popupRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    overlayStyle,
    open: open3,
    onOpenChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    placement = "",
    transitionName,
    classNames,
    styles,
    destroyPopupOnHide,
    destroyOnHidden
  } = props;
  const {
    getPrefixCls,
    direction,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("dropdown");
  const mergedProps = {
    ...props,
    mouseEnterDelay,
    mouseLeaveDelay,
    autoAdjustOverflow: autoAdjustOverflow3
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedRootStyles = {
    ...contextStyle,
    ...overlayStyle,
    ...mergedStyles.root
  };
  const mergedPopupRender = popupRender || dropdownRender;
  const warning5 = devUseWarning("Dropdown");
  if (true) {
    const deprecatedProps = {
      dropdownRender: "popupRender",
      destroyPopupOnHide: "destroyOnHidden",
      overlayClassName: "classNames.root",
      overlayStyle: "styles.root"
    };
    Object.entries(deprecatedProps).forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (placement.includes("Center")) {
      warning5.deprecated(!placement.includes("Center"), `placement: ${placement}`, `placement: ${placement.slice(0, placement.indexOf("Center"))}`);
    }
  }
  const memoTransitionName = React243.useMemo(() => {
    const rootPrefixCls = getPrefixCls();
    if (transitionName !== void 0) {
      return transitionName;
    }
    if (placement.includes("top")) {
      return `${rootPrefixCls}-slide-down`;
    }
    return `${rootPrefixCls}-slide-up`;
  }, [getPrefixCls, placement, transitionName]);
  const memoPlacement = React243.useMemo(() => {
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      return placement.slice(0, placement.indexOf("Center"));
    }
    return placement;
  }, [placement, direction]);
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default21(prefixCls, rootCls);
  const [, token2] = useToken();
  const child = React243.Children.only(isPrimitive_default(children) ? React243.createElement("span", null, children) : children);
  const popupTrigger = cloneElement3(child, {
    className: clsx(`${prefixCls}-trigger`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, child.props.className),
    disabled: child.props.disabled ?? disabled
  });
  const triggerActions = disabled ? [] : trigger;
  const alignPoint = !!(triggerActions == null ? void 0 : triggerActions.includes("contextMenu"));
  const [mergedOpen, setOpen] = useControlledState(false, open3);
  const onInnerOpenChange = useEvent_default((nextOpen) => {
    onOpenChange == null ? void 0 : onOpenChange(nextOpen, {
      source: "trigger"
    });
    setOpen(nextOpen);
  });
  const overlayClassNameCustomized = clsx(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow3,
    offset: token2.marginXXS,
    arrowWidth: arrow ? token2.sizePopupArrow : 0,
    borderRadius: token2.borderRadius
  });
  const onMenuClick = useEvent_default(() => {
    if ((menu == null ? void 0 : menu.selectable) && (menu == null ? void 0 : menu.multiple)) {
      return;
    }
    onOpenChange == null ? void 0 : onOpenChange(false, {
      source: "menu"
    });
    setOpen(false);
  });
  const renderOverlay = () => {
    const menuClassNames = omit(mergedClassNames, ["root"]);
    const menuStyles = omit(mergedStyles, ["root"]);
    let overlayNode;
    if (menu == null ? void 0 : menu.items) {
      overlayNode = React243.createElement(menu_default2, {
        ...menu,
        classNames: {
          ...menuClassNames,
          subMenu: {
            ...menuClassNames
          }
        },
        styles: {
          ...menuStyles,
          subMenu: {
            ...menuStyles
          }
        }
      });
    }
    if (mergedPopupRender) {
      overlayNode = mergedPopupRender(overlayNode);
    }
    overlayNode = React243.Children.only(typeof overlayNode === "string" ? React243.createElement("span", null, overlayNode) : overlayNode);
    return React243.createElement(OverrideProvider, {
      prefixCls: `${prefixCls}-menu`,
      rootClassName: clsx(cssVarCls, rootCls),
      expandIcon: React243.createElement("span", {
        className: `${prefixCls}-menu-submenu-arrow`
      }, direction === "rtl" ? React243.createElement(LeftOutlined_default, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      }) : React243.createElement(RightOutlined_default, {
        className: `${prefixCls}-menu-submenu-arrow-icon`
      })),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: ({
        mode
      }) => {
        true ? warning5(!mode || mode === "vertical", "usage", `mode="${mode}" is not supported for Dropdown's Menu.`) : void 0;
      }
    }, overlayNode);
  };
  const [zIndex, contextZIndex] = useZIndex("Dropdown", mergedRootStyles.zIndex);
  let renderNode = React243.createElement(es_default14, {
    alignPoint,
    ...omit(props, ["rootClassName", "onOpenChange"]),
    mouseEnterDelay,
    mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: memoTransitionName,
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: memoPlacement,
    onVisibleChange: onInnerOpenChange,
    overlayStyle: {
      ...mergedRootStyles,
      zIndex
    },
    autoDestroy: destroyOnHidden ?? destroyPopupOnHide
  }, popupTrigger);
  if (zIndex) {
    renderNode = React243.createElement(zindexContext_default.Provider, {
      value: contextZIndex
    }, renderNode);
  }
  return renderNode;
};
var PurePanel7 = PurePanel_default3(Dropdown2, "align", void 0, "dropdown", (prefixCls) => prefixCls);
var WrapPurePanel = (props) => React243.createElement(PurePanel7, {
  ...props
}, React243.createElement("span", null));
Dropdown2._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
if (true) {
  Dropdown2.displayName = "Dropdown";
}
var dropdown_default2 = Dropdown2;

// node_modules/antd/es/breadcrumb/BreadcrumbSeparator.js
var React244 = __toESM(require_react());
var BreadcrumbSeparator = ({
  children
}) => {
  const {
    getPrefixCls
  } = React244.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb");
  const breadcrumbContext = React244.useContext(BreadcrumbContext_default);
  const {
    classNames: mergedClassNames,
    styles: mergedStyles
  } = breadcrumbContext;
  return React244.createElement("li", {
    className: clsx(`${prefixCls}-separator`, mergedClassNames == null ? void 0 : mergedClassNames.separator),
    style: mergedStyles == null ? void 0 : mergedStyles.separator,
    "aria-hidden": "true"
  }, children === "" ? children : children || "/");
};
BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
var BreadcrumbSeparator_default = BreadcrumbSeparator;

// node_modules/antd/es/breadcrumb/useItemRender.js
var React245 = __toESM(require_react());
function getBreadcrumbName(route, params) {
  if (!isNonNullable_default(route.title)) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
}
function renderItem(prefixCls, item, children, href) {
  if (!isNonNullable_default(children)) {
    return null;
  }
  const {
    className,
    onClick,
    ...restItem
  } = item;
  const passedProps = {
    ...pickAttrs(restItem, {
      data: true,
      aria: true
    }),
    onClick
  };
  if (href !== void 0) {
    return React245.createElement("a", {
      ...passedProps,
      className: clsx(`${prefixCls}-link`, className),
      href
    }, children);
  }
  return React245.createElement("span", {
    ...passedProps,
    className: clsx(`${prefixCls}-link`, className)
  }, children);
}
function useItemRender(prefixCls, itemRender) {
  const mergedItemRender = (item, params, routes, path2, href) => {
    if (itemRender) {
      return itemRender(item, params, routes, path2);
    }
    const name = getBreadcrumbName(item, params);
    return renderItem(prefixCls, item, name, href);
  };
  return mergedItemRender;
}

// node_modules/antd/es/breadcrumb/BreadcrumbItem.js
var InternalBreadcrumbItem = (props) => {
  const {
    prefixCls,
    separator = "/",
    children,
    menu,
    dropdownProps,
    href
  } = props;
  const breadcrumbContext = React246.useContext(BreadcrumbContext_default);
  const {
    classNames: mergedClassNames,
    styles: mergedStyles
  } = breadcrumbContext;
  const renderBreadcrumbNode = (breadcrumbItem) => {
    if (menu) {
      const mergeDropDownProps = {
        ...dropdownProps
      };
      if (menu) {
        const {
          items,
          ...menuProps
        } = menu || {};
        mergeDropDownProps.menu = {
          ...menuProps,
          items: items == null ? void 0 : items.map(({
            key,
            title,
            label,
            path: path2,
            ...itemProps
          }, index2) => {
            let mergedLabel = label ?? title;
            if (path2) {
              mergedLabel = React246.createElement("a", {
                href: `${href}${path2}`
              }, mergedLabel);
            }
            return {
              ...itemProps,
              key: key ?? index2,
              label: mergedLabel
            };
          })
        };
      }
      return React246.createElement(dropdown_default2, {
        placement: "bottom",
        ...mergeDropDownProps
      }, React246.createElement("span", {
        className: `${prefixCls}-overlay-link`
      }, breadcrumbItem, React246.createElement(DownOutlined_default, null)));
    }
    return breadcrumbItem;
  };
  const link = renderBreadcrumbNode(children);
  if (isNonNullable_default(link)) {
    return React246.createElement(React246.Fragment, null, React246.createElement("li", {
      className: mergedClassNames == null ? void 0 : mergedClassNames.item,
      style: mergedStyles == null ? void 0 : mergedStyles.item
    }, link), separator && React246.createElement(BreadcrumbSeparator_default, null, separator));
  }
  return null;
};
var BreadcrumbItem = (props) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    href,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React246.useContext(ConfigContext);
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  return React246.createElement(InternalBreadcrumbItem, {
    ...restProps,
    prefixCls
  }, renderItem(prefixCls, restProps, children, href));
};
BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/antd/es/breadcrumb/style/index.js
var genBreadcrumbStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    calc
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      color: token2.itemColor,
      fontSize: token2.fontSize,
      [iconCls]: {
        fontSize: token2.iconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: {
        color: token2.linkColor,
        transition: `color ${token2.motionDurationMid}`,
        padding: `0 ${unit(token2.paddingXXS)}`,
        borderRadius: token2.borderRadiusSM,
        height: token2.fontHeight,
        display: "inline-block",
        marginInline: calc(token2.marginXXS).mul(-1).equal(),
        "&:hover": {
          color: token2.linkHoverColor,
          backgroundColor: token2.colorBgTextHover
        },
        ...genFocusStyle(token2)
      },
      "li:last-child": {
        color: token2.lastItemColor
      },
      [`${componentCls}-separator`]: {
        marginInline: token2.separatorMargin,
        color: token2.separatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token2.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token2.borderRadiusSM,
        height: token2.fontHeight,
        display: "inline-block",
        padding: `0 ${unit(token2.paddingXXS)}`,
        marginInline: calc(token2.marginXXS).mul(-1).equal(),
        [`> ${iconCls}`]: {
          marginInlineStart: token2.marginXXS,
          fontSize: token2.fontSizeIcon
        },
        "&:hover": {
          color: token2.linkHoverColor,
          backgroundColor: token2.colorBgTextHover,
          a: {
            color: token2.linkHoverColor
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken20 = (token2) => ({
  itemColor: token2.colorTextDescription,
  lastItemColor: token2.colorText,
  iconFontSize: token2.fontSize,
  linkColor: token2.colorTextDescription,
  linkHoverColor: token2.colorText,
  separatorColor: token2.colorTextDescription,
  separatorMargin: token2.marginXS
});
var style_default22 = genStyleHooks("Breadcrumb", (token2) => {
  const breadcrumbToken = merge2(token2, {});
  return genBreadcrumbStyle(breadcrumbToken);
}, prepareComponentToken20);

// node_modules/antd/es/breadcrumb/useItems.js
var import_react103 = __toESM(require_react());
function route2item(route) {
  const {
    breadcrumbName,
    children,
    ...rest
  } = route;
  const clone = {
    title: breadcrumbName,
    ...rest
  };
  if (children) {
    clone.menu = {
      items: children.map(({
        breadcrumbName: itemBreadcrumbName,
        ...itemProps
      }) => ({
        ...itemProps,
        title: itemBreadcrumbName
      }))
    };
  }
  return clone;
}
function useItems2(items, routes) {
  return (0, import_react103.useMemo)(() => {
    if (items) {
      return items;
    }
    if (routes) {
      return routes.map(route2item);
    }
    return null;
  }, [items, routes]);
}

// node_modules/antd/es/breadcrumb/Breadcrumb.js
var getPath = (params, path2) => {
  if (path2 === void 0) {
    return path2;
  }
  let mergedPath = (path2 || "").replace(/^\//, "");
  Object.keys(params).forEach((key) => {
    mergedPath = mergedPath.replace(`:${key}`, params[key]);
  });
  return mergedPath;
};
var Breadcrumb = (props) => {
  const {
    prefixCls: customizePrefixCls,
    separator,
    style: style2,
    className,
    rootClassName,
    routes: legacyRoutes,
    items,
    children,
    itemRender,
    params = {},
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    separator: contextSeparator
  } = useComponentConfig("breadcrumb");
  const mergedSeparator = separator ?? contextSeparator ?? "/";
  let crumbs;
  const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
  const [hashId, cssVarCls] = style_default22(prefixCls);
  const mergedItems = useItems2(items, legacyRoutes);
  const mergedProps = React247.useMemo(() => {
    return {
      ...props,
      separator: mergedSeparator
    };
  }, [props, mergedSeparator]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning5 = devUseWarning("Breadcrumb");
    warning5.deprecated(!legacyRoutes, "routes", "items");
    if (!mergedItems || mergedItems.length === 0) {
      const childList = toArray(children);
      warning5.deprecated(childList.length === 0, "Breadcrumb.Item and Breadcrumb.Separator", "items");
      childList.forEach((element) => {
        if (element) {
          true ? warning5(element.type && (element.type.__ANT_BREADCRUMB_ITEM === true || element.type.__ANT_BREADCRUMB_SEPARATOR === true), "usage", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children") : void 0;
        }
      });
    }
  }
  const mergedItemRender = useItemRender(prefixCls, itemRender);
  if (mergedItems && mergedItems.length > 0) {
    const paths = [];
    const itemRenderRoutes = items || legacyRoutes;
    crumbs = mergedItems.map((item, index2) => {
      const {
        path: path2,
        key,
        type: type5,
        menu,
        onClick,
        className: itemClassName,
        style: style3,
        separator: itemSeparator,
        dropdownProps
      } = item;
      const mergedPath = getPath(params, path2);
      if (mergedPath !== void 0) {
        paths.push(mergedPath);
      }
      const mergedKey = key ?? index2;
      if (type5 === "separator") {
        return React247.createElement(BreadcrumbSeparator_default, {
          key: mergedKey
        }, itemSeparator);
      }
      const itemProps = {};
      const isLastItem = index2 === mergedItems.length - 1;
      if (menu) {
        itemProps.menu = menu;
      }
      let {
        href
      } = item;
      if (paths.length && mergedPath !== void 0) {
        href = `#/${paths.join("/")}`;
      }
      return React247.createElement(InternalBreadcrumbItem, {
        key: mergedKey,
        ...itemProps,
        ...pickAttrs(item, {
          data: true,
          aria: true
        }),
        className: itemClassName,
        style: style3,
        dropdownProps,
        href,
        separator: isLastItem ? "" : mergedSeparator,
        onClick,
        prefixCls
      }, mergedItemRender(item, params, itemRenderRoutes, paths, href));
    });
  } else if (children) {
    const childrenLength = toArray(children).length;
    crumbs = toArray(children).map((element, index2) => {
      if (!element) {
        return element;
      }
      const isLastItem = index2 === childrenLength - 1;
      return cloneElement3(element, {
        separator: isLastItem ? "" : mergedSeparator,
        // eslint-disable-next-line react/no-array-index-key
        key: index2
      });
    });
  }
  const breadcrumbClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const memoizedValue = React247.useMemo(() => ({
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [mergedClassNames, mergedStyles]);
  return React247.createElement(BreadcrumbContext_default.Provider, {
    value: memoizedValue
  }, React247.createElement("nav", {
    className: breadcrumbClassName,
    style: mergedStyle,
    ...restProps
  }, React247.createElement("ol", null, crumbs)));
};
Breadcrumb.Item = BreadcrumbItem_default;
Breadcrumb.Separator = BreadcrumbSeparator_default;
if (true) {
  Breadcrumb.displayName = "Breadcrumb";
}
var Breadcrumb_default = Breadcrumb;

// node_modules/antd/es/breadcrumb/index.js
var breadcrumb_default = Breadcrumb_default;

// node_modules/antd/es/button/index.js
var button_default = Button_default;

// node_modules/@rc-component/picker/es/generate/dayjs.js
var import_dayjs = __toESM(require_dayjs_min());
var import_weekday = __toESM(require_weekday());
var import_localeData = __toESM(require_localeData());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_weekYear = __toESM(require_weekYear());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_customParseFormat = __toESM(require_customParseFormat());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekday.default);
import_dayjs.default.extend(import_localeData.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend(function(o3, c) {
  var proto = c.prototype;
  var oldFormat = proto.format;
  proto.format = function f(formatStr) {
    var str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
var localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  // todo: dayjs has no fr_BE locale, use fr at present
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = function parseLocale2(locale6) {
  var mapLocale = localeMap[locale6];
  return mapLocale || locale6.split("_")[0];
};
var parseNoMatchNotice = function parseNoMatchNotice2() {
};
var generateConfig = {
  // get
  getNow: function getNow() {
    var now2 = (0, import_dayjs.default)();
    if (typeof now2.tz === "function") {
      return now2.tz();
    }
    return now2;
  },
  getFixedDate: function getFixedDate(string3) {
    return (0, import_dayjs.default)(string3, ["YYYY-M-DD", "YYYY-MM-DD"]);
  },
  getEndDate: function getEndDate(date4) {
    return date4.endOf("month");
  },
  getWeekDay: function getWeekDay(date4) {
    var clone = date4.locale("en");
    return clone.weekday() + clone.localeData().firstDayOfWeek();
  },
  getYear: function getYear(date4) {
    return date4.year();
  },
  getMonth: function getMonth(date4) {
    return date4.month();
  },
  getDate: function getDate(date4) {
    return date4.date();
  },
  getHour: function getHour(date4) {
    return date4.hour();
  },
  getMinute: function getMinute(date4) {
    return date4.minute();
  },
  getSecond: function getSecond(date4) {
    return date4.second();
  },
  getMillisecond: function getMillisecond(date4) {
    return date4.millisecond();
  },
  // set
  addYear: function addYear(date4, diff) {
    return date4.add(diff, "year");
  },
  addMonth: function addMonth(date4, diff) {
    return date4.add(diff, "month");
  },
  addDate: function addDate(date4, diff) {
    return date4.add(diff, "day");
  },
  setYear: function setYear(date4, year) {
    return date4.year(year);
  },
  setMonth: function setMonth(date4, month) {
    return date4.month(month);
  },
  setDate: function setDate(date4, num) {
    return date4.date(num);
  },
  setHour: function setHour(date4, hour) {
    return date4.hour(hour);
  },
  setMinute: function setMinute(date4, minute) {
    return date4.minute(minute);
  },
  setSecond: function setSecond(date4, second) {
    return date4.second(second);
  },
  setMillisecond: function setMillisecond(date4, milliseconds) {
    return date4.millisecond(milliseconds);
  },
  // Compare
  isAfter: function isAfter(date1, date22) {
    return date1.isAfter(date22);
  },
  isValidate: function isValidate(date4) {
    return date4.isValid();
  },
  locale: {
    getWeekFirstDay: function getWeekFirstDay(locale6) {
      return (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().firstDayOfWeek();
    },
    getWeekFirstDate: function getWeekFirstDate(locale6, date4) {
      return date4.locale(parseLocale(locale6)).weekday(0);
    },
    getWeek: function getWeek(locale6, date4) {
      return date4.locale(parseLocale(locale6)).week();
    },
    getShortWeekDays: function getShortWeekDays(locale6) {
      return (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().weekdaysMin();
    },
    getShortMonths: function getShortMonths(locale6) {
      return (0, import_dayjs.default)().locale(parseLocale(locale6)).localeData().monthsShort();
    },
    format: function format2(locale6, date4, _format) {
      return date4.locale(parseLocale(locale6)).format(_format);
    },
    parse: function parse2(locale6, text, formats) {
      var localeStr = parseLocale(locale6);
      for (var i = 0; i < formats.length; i += 1) {
        var format3 = formats[i];
        var formatText = text;
        if (format3.includes("wo") || format3.includes("Wo")) {
          var year = formatText.split("-")[0];
          var weekStr = formatText.split("-")[1];
          var firstWeek = (0, import_dayjs.default)(year, "YYYY").startOf("year").locale(localeStr);
          for (var j = 0; j <= 52; j += 1) {
            var nextWeek = firstWeek.add(j, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        var date4 = (0, import_dayjs.default)(formatText, format3, true).locale(localeStr);
        if (date4.isValid()) {
          return date4;
        }
      }
      if (text) {
        parseNoMatchNotice();
      }
      return null;
    }
  }
};
var dayjs_default = generateConfig;

// node_modules/antd/es/calendar/generateCalendar.js
var React301 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/RangePicker.js
var React289 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerTrigger/index.js
var React249 = __toESM(require_react());

// node_modules/@rc-component/picker/es/utils/uiUtil.js
function getRealPlacement(placement, rtl) {
  if (placement !== void 0) {
    return placement;
  }
  return rtl ? "bottomRight" : "bottomLeft";
}

// node_modules/@rc-component/picker/es/PickerInput/context.js
var React248 = __toESM(require_react());
var PickerContext = React248.createContext(null);
var context_default7 = PickerContext;

// node_modules/@rc-component/picker/es/PickerTrigger/index.js
function _typeof3(o3) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof3(o3);
}
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(t2) {
  var i = _toPrimitive2(t2, "string");
  return "symbol" == _typeof3(i) ? i : String(i);
}
function _toPrimitive2(t2, r2) {
  if ("object" != _typeof3(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof3(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(_ref) {
  var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range3 = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
  var _React$useContext = React249.useContext(context_default7), prefixCls = _React$useContext.prefixCls;
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var realPlacement = getRealPlacement(placement, direction === "rtl");
  return React249.createElement(es_default4, {
    showAction: [],
    hideAction: ["click"],
    popupPlacement: realPlacement,
    builtinPlacements,
    prefixCls: dropdownPrefixCls,
    popupMotion: {
      motionName: transitionName
    },
    popup: popupElement,
    popupAlign,
    popupVisible: visible,
    popupClassName: clsx(popupClassName, _defineProperty3(_defineProperty3({}, "".concat(dropdownPrefixCls, "-range"), range3), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
    popupStyle,
    stretch: "minWidth",
    getPopupContainer,
    onPopupVisibleChange: function onPopupVisibleChange(nextVisible) {
      if (!nextVisible) {
        onClose();
      }
    }
  }, children);
}
var PickerTrigger_default = PickerTrigger;

// node_modules/@rc-component/picker/es/utils/miscUtil.js
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray2(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o3, minLen);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function leftPad(str, length2) {
  var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  var current = String(str);
  while (current.length < length2) {
    current = "".concat(fill).concat(current);
  }
  return current;
}
function toArray5(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function fillIndex(ori, index2, value) {
  var clone = _toConsumableArray2(ori);
  clone[index2] = value;
  return clone;
}
function pickProps(props, keys2) {
  var clone = {};
  var mergedKeys = keys2 || Object.keys(props);
  mergedKeys.forEach(function(key) {
    if (props[key] !== void 0) {
      clone[key] = props[key];
    }
  });
  return clone;
}
function getRowFormat(picker, locale6, format3) {
  if (format3) {
    return format3;
  }
  switch (picker) {
    case "time":
      return locale6.fieldTimeFormat;
    case "datetime":
      return locale6.fieldDateTimeFormat;
    case "month":
      return locale6.fieldMonthFormat;
    case "year":
      return locale6.fieldYearFormat;
    case "quarter":
      return locale6.fieldQuarterFormat;
    case "week":
      return locale6.fieldWeekFormat;
    default:
      return locale6.fieldDateFormat;
  }
}
function getFromDate(calendarValues, activeIndexList, activeIndex) {
  var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
  var firstValuedIndex = activeIndexList.find(function(index2) {
    return calendarValues[index2];
  });
  return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
}

// node_modules/@rc-component/picker/es/PickerTrigger/util.js
function pickTriggerProps(props) {
  return pickProps(props, ["placement", "builtinPlacements", "popupAlign", "getPopupContainer", "transitionName", "direction"]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useCellRender.js
var React250 = __toESM(require_react());
function _typeof4(o3) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof4(o3);
}
function ownKeys3(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread3(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t2), true).forEach(function(r3) {
      _defineProperty4(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(t2) {
  var i = _toPrimitive3(t2, "string");
  return "symbol" == _typeof4(i) ? i : String(i);
}
function _toPrimitive3(t2, r2) {
  if ("object" != _typeof4(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof4(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useCellRender(cellRender, dateRender, monthCellRender, range3) {
  if (true) {
    warning_default(!dateRender, "'dateRender' is deprecated. Please use 'cellRender' instead.");
    warning_default(!monthCellRender, "'monthCellRender' is deprecated. Please use 'cellRender' instead.");
  }
  var mergedCellRender = React250.useMemo(function() {
    if (cellRender) {
      return cellRender;
    }
    return function(current, info) {
      var date4 = current;
      if (dateRender && info.type === "date") {
        return dateRender(date4, info.today);
      }
      if (monthCellRender && info.type === "month") {
        return monthCellRender(date4, info.locale);
      }
      return info.originNode;
    };
  }, [cellRender, monthCellRender, dateRender]);
  var onInternalCellRender = React250.useCallback(function(date4, info) {
    return mergedCellRender(date4, _objectSpread3(_objectSpread3({}, info), {}, {
      range: range3
    }));
  }, [mergedCellRender, range3]);
  return onInternalCellRender;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldsInvalidate.js
var React251 = __toESM(require_react());
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray3(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray3(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray3(o3, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useFieldsInvalidate(calendarValue, isInvalidateDate) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var _React$useState = React251.useState([false, false]), _React$useState2 = _slicedToArray2(_React$useState, 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
  var onSelectorInvalid = function onSelectorInvalid2(invalid, index2) {
    setFieldsInvalidates(function(ori) {
      return fillIndex(ori, index2, invalid);
    });
  };
  var submitInvalidates = React251.useMemo(function() {
    return fieldsInvalidates.map(function(invalid, index2) {
      if (invalid) {
        return true;
      }
      var current = calendarValue[index2];
      if (!current) {
        return false;
      }
      if (!allowEmpty[index2] && !current) {
        return true;
      }
      if (current && isInvalidateDate(current, {
        activeIndex: index2
      })) {
        return true;
      }
      return false;
    });
  }, [calendarValue, fieldsInvalidates, isInvalidateDate, allowEmpty]);
  return [submitInvalidates, onSelectorInvalid];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFilledProps.js
var React255 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useLocale.js
var import_react104 = __toESM(require_react());
function _typeof5(o3) {
  "@babel/helpers - typeof";
  return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof5(o3);
}
function ownKeys4(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread4(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys4(Object(t2), true).forEach(function(r3) {
      _defineProperty5(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty5(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey4(t2) {
  var i = _toPrimitive4(t2, "string");
  return "symbol" == _typeof5(i) ? i : String(i);
}
function _toPrimitive4(t2, r2) {
  if ("object" != _typeof5(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof5(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
  var timeFormat = "";
  var cells = [];
  if (showHour) {
    cells.push(showMeridiem ? "hh" : "HH");
  }
  if (showMinute) {
    cells.push("mm");
  }
  if (showSecond) {
    cells.push("ss");
  }
  timeFormat = cells.join(":");
  if (showMillisecond) {
    timeFormat += ".SSS";
  }
  if (showMeridiem) {
    timeFormat += " A";
  }
  return timeFormat;
}
function fillLocale(locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
  var fieldDateTimeFormat = locale6.fieldDateTimeFormat, fieldDateFormat = locale6.fieldDateFormat, fieldTimeFormat = locale6.fieldTimeFormat, fieldMonthFormat = locale6.fieldMonthFormat, fieldYearFormat = locale6.fieldYearFormat, fieldWeekFormat = locale6.fieldWeekFormat, fieldQuarterFormat = locale6.fieldQuarterFormat, yearFormat = locale6.yearFormat, cellYearFormat = locale6.cellYearFormat, cellQuarterFormat = locale6.cellQuarterFormat, dayFormat = locale6.dayFormat, cellDateFormat = locale6.cellDateFormat;
  var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
  return _objectSpread4(_objectSpread4({}, locale6), {}, {
    fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
    fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
    fieldTimeFormat: fieldTimeFormat || timeFormat,
    fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
    fieldYearFormat: fieldYearFormat || "YYYY",
    fieldWeekFormat: fieldWeekFormat || "gggg-wo",
    fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
    yearFormat: yearFormat || "YYYY",
    cellYearFormat: cellYearFormat || "YYYY",
    cellQuarterFormat: cellQuarterFormat || "[Q]Q",
    cellDateFormat: cellDateFormat || dayFormat || "D"
  });
}
function useLocale2(locale6, showProps) {
  var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
  return import_react104.default.useMemo(function() {
    return fillLocale(locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours);
  }, [locale6, showHour, showMinute, showSecond, showMillisecond, use12Hours]);
}

// node_modules/@rc-component/picker/es/hooks/useTimeConfig.js
function ownKeys5(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread5(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys5(Object(t2), true).forEach(function(r3) {
      _defineProperty6(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys5(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey5(t2) {
  var i = _toPrimitive5(t2, "string");
  return "symbol" == _typeof6(i) ? i : String(i);
}
function _toPrimitive5(t2, r2) {
  if ("object" != _typeof6(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof6(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray3(arr, i) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i) || _unsupportedIterableToArray4(arr, i) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray4(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray4(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray4(o3, minLen);
}
function _arrayLikeToArray4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit3(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof6(o3) {
  "@babel/helpers - typeof";
  return _typeof6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof6(o3);
}
function checkShow(format3, keywords, show) {
  return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
    return format3.includes(keyword);
  });
}
var showTimeKeys = [
  // 'format',
  "showNow",
  "showHour",
  "showMinute",
  "showSecond",
  "showMillisecond",
  "use12Hours",
  "hourStep",
  "minuteStep",
  "secondStep",
  "millisecondStep",
  "hideDisabledOptions",
  "defaultValue",
  "disabledHours",
  "disabledMinutes",
  "disabledSeconds",
  "disabledMilliseconds",
  "disabledTime",
  "changeOnScroll",
  "defaultOpenValue"
];
function pickTimeProps(props) {
  var timeProps = pickProps(props, showTimeKeys);
  var format3 = props.format, picker = props.picker;
  var propFormat = null;
  if (format3) {
    propFormat = format3;
    if (Array.isArray(propFormat)) {
      propFormat = propFormat[0];
    }
    propFormat = _typeof6(propFormat) === "object" ? propFormat.format : propFormat;
  }
  if (picker === "time") {
    timeProps.format = propFormat;
  }
  return [timeProps, propFormat];
}
function isStringFormat(format3) {
  return format3 && typeof format3 === "string";
}
function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
  return [showHour, showMinute, showSecond, showMillisecond].some(function(show) {
    return show !== void 0;
  });
}
function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
  var parsedShowHour = showHour;
  var parsedShowMinute = showMinute;
  var parsedShowSecond = showSecond;
  if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
    parsedShowHour = true;
    parsedShowMinute = true;
    parsedShowSecond = true;
  } else if (hasShowConfig) {
    var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
    var existFalse = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === false;
    });
    var existTrue = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
      return show === true;
    });
    var defaultShow = existFalse ? true : !existTrue;
    parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
    parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
    parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
  }
  return [parsedShowHour, parsedShowMinute, parsedShowSecond, showMillisecond];
}
function getTimeProps(componentProps) {
  var showTime = componentProps.showTime;
  var _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray3(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
  var showTimeConfig = showTime && _typeof6(showTime) === "object" ? showTime : {};
  var timeConfig = _objectSpread5(_objectSpread5({
    defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue
  }, pickedProps), showTimeConfig);
  var showMillisecond = timeConfig.showMillisecond;
  var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
  var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
  var _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
  var _fillShowConfig2 = _slicedToArray3(_fillShowConfig, 3);
  showHour = _fillShowConfig2[0];
  showMinute = _fillShowConfig2[1];
  showSecond = _fillShowConfig2[2];
  return [timeConfig, _objectSpread5(_objectSpread5({}, timeConfig), {}, {
    showHour,
    showMinute,
    showSecond,
    showMillisecond
  }), timeConfig.format, propFormat];
}
function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale6) {
  var isTimePicker = picker === "time";
  if (picker === "datetime" || isTimePicker) {
    var pickedProps = timeConfig;
    var defaultLocaleFormat = getRowFormat(picker, locale6, null);
    var baselineFormat = defaultLocaleFormat;
    var formatList = [showTimeFormat, propFormat];
    for (var i = 0; i < formatList.length; i += 1) {
      var format3 = toArray5(formatList[i])[0];
      if (isStringFormat(format3)) {
        baselineFormat = format3;
        break;
      }
    }
    var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
    var use12Hours = pickedProps.use12Hours;
    var showMeridiem = checkShow(baselineFormat, ["a", "A", "LT", "LLL", "LTS"], use12Hours);
    var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
    if (!hasShowConfig) {
      showHour = checkShow(baselineFormat, ["H", "h", "k", "LT", "LLL"]);
      showMinute = checkShow(baselineFormat, ["m", "LT", "LLL"]);
      showSecond = checkShow(baselineFormat, ["s", "LTS"]);
      showMillisecond = checkShow(baselineFormat, ["SSS"]);
    }
    var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
    var _fillShowConfig4 = _slicedToArray3(_fillShowConfig3, 3);
    showHour = _fillShowConfig4[0];
    showMinute = _fillShowConfig4[1];
    showSecond = _fillShowConfig4[2];
    var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
    return _objectSpread5(_objectSpread5({}, pickedProps), {}, {
      // Format
      format: timeFormat,
      // Show Config
      showHour,
      showMinute,
      showSecond,
      showMillisecond,
      use12Hours: showMeridiem
    });
  }
  return null;
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useClearIcon.js
var React253 = __toESM(require_react());
function _typeof7(o3) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof7(o3);
}
function fillClearIcon(prefixCls, allowClear, clearIcon) {
  if (clearIcon) {
    warning_default(false, "`clearIcon` will be removed in future. Please use `allowClear` instead.");
  }
  if (allowClear === false) {
    return null;
  }
  var config = allowClear && _typeof7(allowClear) === "object" ? allowClear : {};
  return config.clearIcon || clearIcon || React253.createElement("span", {
    className: "".concat(prefixCls, "-clear-btn")
  });
}

// node_modules/@rc-component/picker/es/utils/dateUtil.js
var WEEK_DAY_COUNT = 7;
function nullableCompare(value1, value2, oriCompareFn) {
  if (!value1 && !value2 || value1 === value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return oriCompareFn();
}
function isSameDecade(generateConfig2, decade1, decade2) {
  return nullableCompare(decade1, decade2, function() {
    var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
    var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
    return num1 === num2;
  });
}
function isSameYear(generateConfig2, year1, year2) {
  return nullableCompare(year1, year2, function() {
    return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
  });
}
function getQuarter(generateConfig2, date4) {
  var quota = Math.floor(generateConfig2.getMonth(date4) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  return nullableCompare(quarter1, quarter2, function() {
    return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
  });
}
function isSameMonth(generateConfig2, month1, month2) {
  return nullableCompare(month1, month2, function() {
    return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
  });
}
function isSameDate(generateConfig2, date1, date22) {
  return nullableCompare(date1, date22, function() {
    return isSameYear(generateConfig2, date1, date22) && isSameMonth(generateConfig2, date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
  });
}
function isSameTime(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
  });
}
function isSameTimestamp(generateConfig2, time1, time2) {
  return nullableCompare(time1, time2, function() {
    return isSameDate(generateConfig2, time1, time2) && isSameTime(generateConfig2, time1, time2) && generateConfig2.getMillisecond(time1) === generateConfig2.getMillisecond(time2);
  });
}
function isSameWeek(generateConfig2, locale6, date1, date22) {
  return nullableCompare(date1, date22, function() {
    var weekStartDate1 = generateConfig2.locale.getWeekFirstDate(locale6, date1);
    var weekStartDate2 = generateConfig2.locale.getWeekFirstDate(locale6, date22);
    return isSameYear(generateConfig2, weekStartDate1, weekStartDate2) && generateConfig2.locale.getWeek(locale6, date1) === generateConfig2.locale.getWeek(locale6, date22);
  });
}
function isSame(generateConfig2, locale6, source, target, type5) {
  switch (type5) {
    case "date":
      return isSameDate(generateConfig2, source, target);
    case "week":
      return isSameWeek(generateConfig2, locale6.locale, source, target);
    case "month":
      return isSameMonth(generateConfig2, source, target);
    case "quarter":
      return isSameQuarter(generateConfig2, source, target);
    case "year":
      return isSameYear(generateConfig2, source, target);
    case "decade":
      return isSameDecade(generateConfig2, source, target);
    case "time":
      return isSameTime(generateConfig2, source, target);
    default:
      return isSameTimestamp(generateConfig2, source, target);
  }
}
function isInRange(generateConfig2, startDate, endDate, current) {
  if (!startDate || !endDate || !current) {
    return false;
  }
  return generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
function isSameOrAfter(generateConfig2, locale6, date1, date22, type5) {
  if (isSame(generateConfig2, locale6, date1, date22, type5)) {
    return true;
  }
  return generateConfig2.isAfter(date1, date22);
}
function getWeekStartDate(locale6, generateConfig2, value) {
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale6);
  var monthStartDate = generateConfig2.setDate(value, 1);
  var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function formatValue(value, _ref) {
  var generateConfig2 = _ref.generateConfig, locale6 = _ref.locale, format3 = _ref.format;
  if (!value) {
    return "";
  }
  return typeof format3 === "function" ? format3(value) : generateConfig2.locale.format(locale6.locale, value, format3);
}
function fillTime(generateConfig2, date4, time) {
  var tmpDate = date4;
  var getFn = ["getHour", "getMinute", "getSecond", "getMillisecond"];
  var setFn = ["setHour", "setMinute", "setSecond", "setMillisecond"];
  setFn.forEach(function(fn, index2) {
    if (time) {
      tmpDate = generateConfig2[fn](tmpDate, generateConfig2[getFn[index2]](time));
    } else {
      tmpDate = generateConfig2[fn](tmpDate, 0);
    }
  });
  return tmpDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useDisabledBoundary.js
function useDisabledBoundary(generateConfig2, locale6, disabledDate, minDate, maxDate) {
  var mergedDisabledDate = useEvent_default(function(date4, info) {
    if (disabledDate && disabledDate(date4, info)) {
      return true;
    }
    if (minDate && generateConfig2.isAfter(minDate, date4) && !isSame(generateConfig2, locale6, minDate, date4, info.type)) {
      return true;
    }
    if (maxDate && generateConfig2.isAfter(date4, maxDate) && !isSame(generateConfig2, locale6, maxDate, date4, info.type)) {
      return true;
    }
    return false;
  });
  return mergedDisabledDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFieldFormat.js
var React254 = __toESM(require_react());
function _typeof8(o3) {
  "@babel/helpers - typeof";
  return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof8(o3);
}
function useFieldFormat(picker, locale6, format3) {
  return React254.useMemo(function() {
    var rawFormat = getRowFormat(picker, locale6, format3);
    var formatList = toArray5(rawFormat);
    var firstFormat = formatList[0];
    var maskFormat = _typeof8(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
    return [
      // Format list
      formatList.map(function(config) {
        return typeof config === "string" || typeof config === "function" ? config : config.format;
      }),
      // Mask Format
      maskFormat
    ];
  }, [picker, locale6, format3]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useInputReadOnly.js
function useInputReadOnly(formatList, inputReadOnly, multiple) {
  if (typeof formatList[0] === "function" || multiple) {
    return true;
  }
  return inputReadOnly;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useInvalidate.js
function _typeof9(o3) {
  "@babel/helpers - typeof";
  return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof9(o3);
}
function ownKeys6(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread6(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys6(Object(t2), true).forEach(function(r3) {
      _defineProperty7(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys6(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty7(obj, key, value) {
  key = _toPropertyKey6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey6(t2) {
  var i = _toPrimitive6(t2, "string");
  return "symbol" == _typeof9(i) ? i : String(i);
}
function _toPrimitive6(t2, r2) {
  if ("object" != _typeof9(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof9(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useInvalidate(generateConfig2, picker, disabledDate, showTime) {
  var isInvalidate = useEvent_default(function(date4, info) {
    var outsideInfo = _objectSpread6({
      type: picker
    }, info);
    delete outsideInfo.activeIndex;
    if (
      // Date object is invalid
      !generateConfig2.isValidate(date4) || // Date is disabled by `disabledDate`
      disabledDate && disabledDate(date4, outsideInfo)
    ) {
      return true;
    }
    if ((picker === "date" || picker === "time") && showTime) {
      var _showTime$disabledTim;
      var range3 = info && info.activeIndex === 1 ? "end" : "start";
      var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date4, range3, {
        from: outsideInfo.from
      })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
      var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
      var mergedDisabledHours = disabledHours || legacyDisabledHours;
      var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
      var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
      var hour = generateConfig2.getHour(date4);
      var minute = generateConfig2.getMinute(date4);
      var second = generateConfig2.getSecond(date4);
      var millisecond = generateConfig2.getMillisecond(date4);
      if (mergedDisabledHours && mergedDisabledHours().includes(hour)) {
        return true;
      }
      if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) {
        return true;
      }
      if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) {
        return true;
      }
      if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) {
        return true;
      }
    }
    return false;
  });
  return isInvalidate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useFilledProps.js
function _typeof10(o3) {
  "@babel/helpers - typeof";
  return _typeof10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof10(o3);
}
function ownKeys7(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread7(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys7(Object(t2), true).forEach(function(r3) {
      _defineProperty8(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys7(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty8(obj, key, value) {
  key = _toPropertyKey7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey7(t2) {
  var i = _toPrimitive7(t2, "string");
  return "symbol" == _typeof10(i) ? i : String(i);
}
function _toPrimitive7(t2, r2) {
  if ("object" != _typeof10(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof10(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray4(arr, i) {
  return _arrayWithHoles4(arr) || _iterableToArrayLimit4(arr, i) || _unsupportedIterableToArray5(arr, i) || _nonIterableRest4();
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray5(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray5(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray5(o3, minLen);
}
function _arrayLikeToArray5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit4(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useList(value) {
  var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var values = React255.useMemo(function() {
    var list = value ? toArray5(value) : value;
    if (fillMode && list) {
      list[1] = list[1] || list[0];
    }
    return list;
  }, [value, fillMode]);
  return values;
}
function useFilledProps(props, updater) {
  var generateConfig2 = props.generateConfig, locale6 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$previewValue = props.previewValue, previewValue = _props$previewValue === void 0 ? "hover" : _props$previewValue, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components2 = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format3 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
  var values = useList(value);
  var defaultValues = useList(defaultValue);
  var pickerValues = useList(pickerValue);
  var defaultPickerValues = useList(defaultPickerValue);
  var internalPicker = picker === "date" && showTime ? "datetime" : picker;
  var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
  var complexPicker = multipleInteractivePicker || multiple;
  var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
  var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray4(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
  var mergedLocale = useLocale2(locale6, localeTimeProps);
  var mergedShowTime = React255.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale]);
  if (picker === "time") {
    if (["disabledHours", "disabledMinutes", "disabledSeconds"].some(function(key) {
      return props[key];
    })) {
      warning_default(false, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
    }
  }
  var filledProps = React255.useMemo(function() {
    return _objectSpread7(_objectSpread7({}, props), {}, {
      previewValue,
      prefixCls,
      locale: mergedLocale,
      picker,
      styles,
      classNames,
      order,
      components: _objectSpread7({
        input: inputRender
      }, components2),
      clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
      showTime: mergedShowTime,
      value: values,
      defaultValue: defaultValues,
      pickerValue: pickerValues,
      defaultPickerValue: defaultPickerValues
    }, updater === null || updater === void 0 ? void 0 : updater());
  }, [props]);
  var _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format3), _useFieldFormat2 = _slicedToArray4(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
  var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
  var disabledBoundaryDate = useDisabledBoundary(generateConfig2, locale6, disabledDate, minDate, maxDate);
  var isInvalidateDate = useInvalidate(generateConfig2, picker, disabledBoundaryDate, mergedShowTime);
  var mergedProps = React255.useMemo(function() {
    return _objectSpread7(_objectSpread7({}, filledProps), {}, {
      needConfirm: mergedNeedConfirm,
      inputReadOnly: mergedInputReadOnly,
      disabledDate: disabledBoundaryDate
    });
  }, [filledProps, mergedNeedConfirm, mergedInputReadOnly, disabledBoundaryDate]);
  return [mergedProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useDelayState.js
var import_react105 = __toESM(require_react());
function _slicedToArray5(arr, i) {
  return _arrayWithHoles5(arr) || _iterableToArrayLimit5(arr, i) || _unsupportedIterableToArray6(arr, i) || _nonIterableRest5();
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray6(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray6(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray6(o3, minLen);
}
function _arrayLikeToArray6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit5(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles5(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useDelayState(value, defaultValue, onChange) {
  var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray5(_useControlledState, 2), state = _useControlledState2[0], setState = _useControlledState2[1];
  var _React$useState = import_react105.default.useState({}), _React$useState2 = _slicedToArray5(_React$useState, 2), forceUpdate = _React$useState2[1];
  var triggerUpdate = useEvent_default(function(nextState) {
    setState(nextState);
    forceUpdate({});
  });
  var nextValueRef = import_react105.default.useRef(value);
  var rafRef = import_react105.default.useRef();
  var cancelRaf = function cancelRaf2() {
    raf_default.cancel(rafRef.current);
  };
  var doUpdate = useEvent_default(function() {
    triggerUpdate(nextValueRef.current);
    if (onChange && state !== nextValueRef.current) {
      onChange(nextValueRef.current);
    }
  });
  var updateValue = useEvent_default(function(next2, immediately) {
    cancelRaf();
    nextValueRef.current = next2;
    if (next2 || immediately) {
      doUpdate();
    } else {
      rafRef.current = raf_default(doUpdate);
    }
  });
  import_react105.default.useEffect(function() {
    return cancelRaf;
  }, []);
  return [state, updateValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useOpen.js
function _slicedToArray6(arr, i) {
  return _arrayWithHoles6(arr) || _iterableToArrayLimit6(arr, i) || _unsupportedIterableToArray7(arr, i) || _nonIterableRest6();
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray7(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray7(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray7(o3, minLen);
}
function _arrayLikeToArray7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit6(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles6(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useOpen2(open3, defaultOpen) {
  var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
  var mergedOpen = disabledList.every(function(disabled) {
    return disabled;
  }) ? false : open3;
  var _useDelayState = useDelayState(mergedOpen, defaultOpen || false, onOpenChange), _useDelayState2 = _slicedToArray6(_useDelayState, 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
  function setOpen(next2) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!config.inherit || rafOpen) {
      setRafOpen(next2, config.force);
    }
  }
  return [rafOpen, setOpen];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/usePickerRef.js
var React257 = __toESM(require_react());
function usePickerRef(ref) {
  var selectorRef = React257.useRef();
  React257.useImperativeHandle(ref, function() {
    var _selectorRef$current;
    return {
      nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
      focus: function focus(options) {
        var _selectorRef$current2;
        (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options);
      },
      blur: function blur() {
        var _selectorRef$current3;
        (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
      }
    };
  });
  return selectorRef;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/usePresets.js
var React258 = __toESM(require_react());
function _slicedToArray7(arr, i) {
  return _arrayWithHoles7(arr) || _iterableToArrayLimit7(arr, i) || _unsupportedIterableToArray8(arr, i) || _nonIterableRest7();
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray8(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray8(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray8(o3, minLen);
}
function _arrayLikeToArray8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit7(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function usePresets(presets, legacyRanges) {
  return React258.useMemo(function() {
    if (presets) {
      return presets;
    }
    if (legacyRanges) {
      warning_default(false, "`ranges` is deprecated. Please use `presets` instead.");
      return Object.entries(legacyRanges).map(function(_ref) {
        var _ref2 = _slicedToArray7(_ref, 2), label = _ref2[0], value = _ref2[1];
        return {
          label,
          value
        };
      });
    }
    return [];
  }, [presets, legacyRanges]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeActive.js
var React260 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/hooks/useLockEffect.js
var React259 = __toESM(require_react());
function useLockEffect(condition, callback) {
  var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var callbackRef = React259.useRef(callback);
  callbackRef.current = callback;
  useLayoutUpdateEffect(function() {
    if (condition) {
      callbackRef.current(condition);
    } else {
      var id = raf_default(function() {
        callbackRef.current(condition);
      }, delayFrames);
      return function() {
        raf_default.cancel(id);
      };
    }
  }, [condition]);
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeActive.js
function _slicedToArray8(arr, i) {
  return _arrayWithHoles8(arr) || _iterableToArrayLimit8(arr, i) || _unsupportedIterableToArray9(arr, i) || _nonIterableRest8();
}
function _nonIterableRest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray9(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray9(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray9(o3, minLen);
}
function _arrayLikeToArray9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit8(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useRangeActive(disabled) {
  var empty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var _React$useState = React260.useState(0), _React$useState2 = _slicedToArray8(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
  var _React$useState3 = React260.useState(false), _React$useState4 = _slicedToArray8(_React$useState3, 2), focused = _React$useState4[0], setFocused = _React$useState4[1];
  var activeListRef = React260.useRef([]);
  var submitIndexRef = React260.useRef(null);
  var lastOperationRef = React260.useRef(null);
  var updateSubmitIndex = function updateSubmitIndex2(index2) {
    submitIndexRef.current = index2;
  };
  var hasActiveSubmitValue = function hasActiveSubmitValue2(index2) {
    return submitIndexRef.current === index2;
  };
  var triggerFocus2 = function triggerFocus3(nextFocus) {
    setFocused(nextFocus);
  };
  var lastOperation = function lastOperation2(type5) {
    if (type5) {
      lastOperationRef.current = type5;
    }
    return lastOperationRef.current;
  };
  var nextActiveIndex = function nextActiveIndex2(nextValue) {
    var list = activeListRef.current;
    var filledActiveSet = new Set(list.filter(function(index2) {
      return nextValue[index2] || empty2[index2];
    }));
    var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
    if (filledActiveSet.size >= 2 || disabled[nextIndex]) {
      return null;
    }
    return nextIndex;
  };
  useLockEffect(focused || mergedOpen, function() {
    if (!focused) {
      activeListRef.current = [];
      updateSubmitIndex(null);
    }
  });
  React260.useEffect(function() {
    if (focused) {
      activeListRef.current.push(activeIndex);
    }
  }, [focused, activeIndex]);
  return [focused, triggerFocus2, lastOperation, activeIndex, setActiveIndex, nextActiveIndex, activeListRef.current, updateSubmitIndex, hasActiveSubmitValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeDisabledDate.js
function _typeof11(o3) {
  "@babel/helpers - typeof";
  return _typeof11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof11(o3);
}
function ownKeys8(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread8(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys8(Object(t2), true).forEach(function(r3) {
      _defineProperty9(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys8(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty9(obj, key, value) {
  key = _toPropertyKey8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey8(t2) {
  var i = _toPrimitive8(t2, "string");
  return "symbol" == _typeof11(i) ? i : String(i);
}
function _toPrimitive8(t2, r2) {
  if ("object" != _typeof11(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof11(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray9(arr, i) {
  return _arrayWithHoles9(arr) || _iterableToArrayLimit9(arr, i) || _unsupportedIterableToArray10(arr, i) || _nonIterableRest9();
}
function _nonIterableRest9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray10(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray10(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray10(o3, minLen);
}
function _arrayLikeToArray10(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit9(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig2, locale6, disabledDate) {
  var activeIndex = activeIndexList[activeIndexList.length - 1];
  var rangeDisabledDate = function rangeDisabledDate2(date4, info) {
    var _values = _slicedToArray9(values, 2), start = _values[0], end = _values[1];
    var mergedInfo = _objectSpread8(_objectSpread8({}, info), {}, {
      from: getFromDate(values, activeIndexList)
    });
    if (activeIndex === 1 && disabled[0] && start && // Same date isOK
    !isSame(generateConfig2, locale6, start, date4, mergedInfo.type) && // Before start date
    generateConfig2.isAfter(start, date4)) {
      return true;
    }
    if (activeIndex === 0 && disabled[1] && end && // Same date isOK
    !isSame(generateConfig2, locale6, end, date4, mergedInfo.type) && // After end date
    generateConfig2.isAfter(date4, end)) {
      return true;
    }
    return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date4, mergedInfo);
  };
  return rangeDisabledDate;
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangePickerValue.js
var React261 = __toESM(require_react());
function _slicedToArray10(arr, i) {
  return _arrayWithHoles10(arr) || _iterableToArrayLimit10(arr, i) || _unsupportedIterableToArray11(arr, i) || _nonIterableRest10();
}
function _nonIterableRest10() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray11(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray11(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray11(o3, minLen);
}
function _arrayLikeToArray11(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit10(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles10(arr) {
  if (Array.isArray(arr))
    return arr;
}
function offsetPanelDate(generateConfig2, picker, date4, offset3) {
  switch (picker) {
    case "date":
    case "week":
      return generateConfig2.addMonth(date4, offset3);
    case "month":
    case "quarter":
      return generateConfig2.addYear(date4, offset3);
    case "year":
      return generateConfig2.addYear(date4, offset3 * 10);
    case "decade":
      return generateConfig2.addYear(date4, offset3 * 100);
    default:
      return date4;
  }
}
var EMPTY_LIST3 = [];
function useRangePickerValue(generateConfig2, locale6, calendarValue, modes, open3, activeIndex, pickerMode, multiplePanel) {
  var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST3;
  var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST3;
  var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST3;
  var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
  var minDate = arguments.length > 12 ? arguments[12] : void 0;
  var maxDate = arguments.length > 13 ? arguments[13] : void 0;
  var isTimePicker = pickerMode === "time";
  var mergedActiveIndex = activeIndex || 0;
  var getDefaultPickerValue = function getDefaultPickerValue2(index2) {
    var now2 = generateConfig2.getNow();
    if (isTimePicker) {
      now2 = fillTime(generateConfig2, now2);
    }
    return defaultPickerValue[index2] || calendarValue[index2] || now2;
  };
  var _pickerValue = _slicedToArray10(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
  var _useControlledState = useControlledState(function() {
    return getDefaultPickerValue(0);
  }, startPickerValue), _useControlledState2 = _slicedToArray10(_useControlledState, 2), mergedStartPickerValue = _useControlledState2[0], setStartPickerValue = _useControlledState2[1];
  var _useControlledState3 = useControlledState(function() {
    return getDefaultPickerValue(1);
  }, endPickerValue), _useControlledState4 = _slicedToArray10(_useControlledState3, 2), mergedEndPickerValue = _useControlledState4[0], setEndPickerValue = _useControlledState4[1];
  var currentPickerValue = React261.useMemo(function() {
    var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
    return isTimePicker ? current : fillTime(generateConfig2, current, timeDefaultValue[mergedActiveIndex]);
  }, [isTimePicker, mergedStartPickerValue, mergedEndPickerValue, mergedActiveIndex, generateConfig2, timeDefaultValue]);
  var setCurrentPickerValue = function setCurrentPickerValue2(nextPickerValue) {
    var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
    var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
    updater(nextPickerValue);
    var clone = [mergedStartPickerValue, mergedEndPickerValue];
    clone[mergedActiveIndex] = nextPickerValue;
    if (onPickerValueChange && (!isSame(generateConfig2, locale6, mergedStartPickerValue, clone[0], pickerMode) || !isSame(generateConfig2, locale6, mergedEndPickerValue, clone[1], pickerMode))) {
      onPickerValueChange(clone, {
        source,
        range: mergedActiveIndex === 1 ? "end" : "start",
        mode: modes
      });
    }
  };
  var getEndDatePickerValue = function getEndDatePickerValue2(startDate, endDate) {
    if (multiplePanel) {
      var SAME_CHECKER = {
        date: "month",
        week: "month",
        month: "year",
        quarter: "year"
      };
      var mode = SAME_CHECKER[pickerMode];
      if (mode && !isSame(generateConfig2, locale6, startDate, endDate, mode)) {
        return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
      }
      if (pickerMode === "year" && startDate) {
        var srcYear = Math.floor(generateConfig2.getYear(startDate) / 10);
        var tgtYear = Math.floor(generateConfig2.getYear(endDate) / 10);
        if (srcYear !== tgtYear) {
          return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
        }
      }
    }
    return endDate;
  };
  var prevActiveIndexRef = React261.useRef(null);
  useLayoutEffect_default(function() {
    if (open3) {
      if (!defaultPickerValue[mergedActiveIndex]) {
        var nextPickerValue = isTimePicker ? null : generateConfig2.getNow();
        if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) {
          nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
        } else if (calendarValue[mergedActiveIndex]) {
          nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
        } else if (calendarValue[mergedActiveIndex ^ 1]) {
          nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
        }
        if (nextPickerValue) {
          if (minDate && generateConfig2.isAfter(minDate, nextPickerValue)) {
            nextPickerValue = minDate;
          }
          var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, nextPickerValue, 1) : nextPickerValue;
          if (maxDate && generateConfig2.isAfter(offsetPickerValue, maxDate)) {
            nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, maxDate, -1) : maxDate;
          }
          setCurrentPickerValue(nextPickerValue, "reset");
        }
      }
    }
  }, [open3, mergedActiveIndex, calendarValue[mergedActiveIndex]]);
  React261.useEffect(function() {
    if (open3) {
      prevActiveIndexRef.current = mergedActiveIndex;
    } else {
      prevActiveIndexRef.current = null;
    }
  }, [open3, mergedActiveIndex]);
  useLayoutEffect_default(function() {
    if (open3 && defaultPickerValue) {
      if (defaultPickerValue[mergedActiveIndex]) {
        setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
      }
    }
  }, [open3, mergedActiveIndex]);
  return [currentPickerValue, setCurrentPickerValue];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeValue.js
var React263 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useSyncState.js
var React262 = __toESM(require_react());
function _slicedToArray11(arr, i) {
  return _arrayWithHoles11(arr) || _iterableToArrayLimit11(arr, i) || _unsupportedIterableToArray12(arr, i) || _nonIterableRest11();
}
function _nonIterableRest11() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray12(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray12(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray12(o3, minLen);
}
function _arrayLikeToArray12(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit11(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles11(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useSyncState3(defaultValue, controlledValue) {
  var valueRef = React262.useRef(defaultValue);
  var _React$useState = React262.useState({}), _React$useState2 = _slicedToArray11(_React$useState, 2), forceUpdate = _React$useState2[1];
  var getter = function getter2(useControlledValueFirst) {
    return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
  };
  var setter = function setter2(nextValue) {
    valueRef.current = nextValue;
    forceUpdate({});
  };
  return [getter, setter, getter(true)];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useRangeValue.js
function _slicedToArray12(arr, i) {
  return _arrayWithHoles12(arr) || _iterableToArrayLimit12(arr, i) || _unsupportedIterableToArray13(arr, i) || _nonIterableRest12();
}
function _nonIterableRest12() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit12(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles12(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray3(arr) {
  return _arrayWithoutHoles3(arr) || _iterableToArray3(arr) || _unsupportedIterableToArray13(arr) || _nonIterableSpread3();
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray13(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray13(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray13(o3, minLen);
}
function _iterableToArray3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray13(arr);
}
function _arrayLikeToArray13(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var EMPTY_VALUE = [];
function useUtil(generateConfig2, locale6, formatList) {
  var getDateTexts = function getDateTexts2(dates) {
    return dates.map(function(date4) {
      return formatValue(date4, {
        generateConfig: generateConfig2,
        locale: locale6,
        format: formatList[0]
      });
    });
  };
  var isSameDates = function isSameDates2(source, target) {
    var maxLen = Math.max(source.length, target.length);
    var diffIndex = -1;
    for (var i = 0; i < maxLen; i += 1) {
      var prev2 = source[i] || null;
      var next2 = target[i] || null;
      if (prev2 !== next2 && !isSameTimestamp(generateConfig2, prev2, next2)) {
        diffIndex = i;
        break;
      }
    }
    return [diffIndex < 0, diffIndex !== 0];
  };
  return [getDateTexts, isSameDates];
}
function orderDates(dates, generateConfig2) {
  return _toConsumableArray3(dates).sort(function(a, b) {
    return generateConfig2.isAfter(a, b) ? 1 : -1;
  });
}
function useCalendarValue(mergedValue) {
  var _useSyncState = useSyncState3(mergedValue), _useSyncState2 = _slicedToArray12(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
  var syncWithValue = useEvent_default(function() {
    setCalendarValue(mergedValue);
  });
  React263.useEffect(function() {
    syncWithValue();
  }, [mergedValue]);
  return [calendarValue, setCalendarValue];
}
function useInnerValue(generateConfig2, locale6, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
  var _useControlledState = useControlledState(defaultValue, value), _useControlledState2 = _slicedToArray12(_useControlledState, 2), innerValue = _useControlledState2[0], setInnerValue = _useControlledState2[1];
  var mergedValue = innerValue || EMPTY_VALUE;
  var _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray12(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
  var _useUtil = useUtil(generateConfig2, locale6, formatList), _useUtil2 = _slicedToArray12(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
  var triggerCalendarChange = useEvent_default(function(nextCalendarValues) {
    var clone = _toConsumableArray3(nextCalendarValues);
    if (rangeValue) {
      for (var i = 0; i < 2; i += 1) {
        clone[i] = clone[i] || null;
      }
    } else if (order) {
      clone = orderDates(clone.filter(function(date4) {
        return date4;
      }), generateConfig2);
    }
    var _isSameDates = isSameDates(calendarValue(), clone), _isSameDates2 = _slicedToArray12(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
    if (!isSameMergedDates) {
      setCalendarValue(clone);
      if (onCalendarChange) {
        var cellTexts = getDateTexts(clone);
        onCalendarChange(clone, cellTexts, {
          range: isSameStart ? "end" : "start"
        });
      }
    }
  });
  var triggerOk = function triggerOk2() {
    if (onOk) {
      onOk(calendarValue());
    }
  };
  return [mergedValue, setInnerValue, calendarValue, triggerCalendarChange, triggerOk];
}
function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open3, isInvalidateDate) {
  var generateConfig2 = info.generateConfig, locale6 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
  var orderOnChange = disabled.some(function(d) {
    return d;
  }) ? false : order;
  var _useUtil3 = useUtil(generateConfig2, locale6, formatList), _useUtil4 = _slicedToArray12(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
  var _useSyncState3 = useSyncState3(mergedValue), _useSyncState4 = _slicedToArray12(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
  var syncWithValue = useEvent_default(function() {
    setSubmitValue(mergedValue);
  });
  React263.useEffect(function() {
    syncWithValue();
  }, [mergedValue]);
  var triggerSubmit = useEvent_default(function(nextValue) {
    var isNullValue = nextValue === null;
    var clone = _toConsumableArray3(nextValue || submitValue());
    if (isNullValue) {
      var maxLen = Math.max(disabled.length, clone.length);
      for (var i = 0; i < maxLen; i += 1) {
        if (!disabled[i]) {
          clone[i] = null;
        }
      }
    }
    if (orderOnChange && clone[0] && clone[1]) {
      clone = orderDates(clone, generateConfig2);
    }
    triggerCalendarChange(clone);
    var _clone = clone, _clone2 = _slicedToArray12(_clone, 2), start = _clone2[0], end = _clone2[1];
    var startEmpty = !start;
    var endEmpty = !end;
    var validateEmptyDateRange = allowEmpty ? (
      // Validate empty start
      (!startEmpty || allowEmpty[0]) && // Validate empty end
      (!endEmpty || allowEmpty[1])
    ) : true;
    var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig2, locale6, start, end, picker) || generateConfig2.isAfter(end, start);
    var validateDates = (
      // Validate start
      (disabled[0] || !start || !isInvalidateDate(start, {
        activeIndex: 0
      })) && // Validate end
      (disabled[1] || !end || !isInvalidateDate(end, {
        from: start,
        activeIndex: 1
      }))
    );
    var allPassed = (
      // Null value is from clear button
      isNullValue || // Normal check
      validateEmptyDateRange && validateOrder && validateDates
    );
    if (allPassed) {
      setInnerValue(clone);
      var _isSameDates3 = isSameDates(clone, mergedValue), _isSameDates4 = _slicedToArray12(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
      if (onChange && !isSameMergedDates) {
        var everyEmpty = clone.every(function(val) {
          return !val;
        });
        onChange(
          // Return null directly if all date are empty
          isNullValue && everyEmpty ? null : clone,
          everyEmpty ? null : getDateTexts(clone)
        );
      }
    }
    return allPassed;
  });
  var flushSubmit = useEvent_default(function(index2, needTriggerChange) {
    var nextSubmitValue = fillIndex(submitValue(), index2, getCalendarValue()[index2]);
    setSubmitValue(nextSubmitValue);
    if (needTriggerChange) {
      triggerSubmit();
    }
  });
  var interactiveFinished = !focused && !open3;
  useLockEffect(!interactiveFinished, function() {
    if (interactiveFinished) {
      triggerSubmit();
      triggerCalendarChange(mergedValue);
      syncWithValue();
    }
  }, 2);
  return [flushSubmit, triggerSubmit];
}

// node_modules/@rc-component/picker/es/PickerInput/hooks/useShowNow.js
function useShowNow(picker, mode, showNow, showToday, rangePicker) {
  if (mode !== "date" && mode !== "time") {
    return false;
  }
  if (showNow !== void 0) {
    return showNow;
  }
  if (showToday !== void 0) {
    return showToday;
  }
  return !rangePicker && (picker === "date" || picker === "time");
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/index.js
var React283 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Popup/Footer.js
var React265 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useTimeInfo.js
var React264 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/util.js
function _toConsumableArray4(arr) {
  return _arrayWithoutHoles4(arr) || _iterableToArray4(arr) || _unsupportedIterableToArray14(arr) || _nonIterableSpread4();
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray14(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray14(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray14(o3, minLen);
}
function _iterableToArray4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles4(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray14(arr);
}
function _arrayLikeToArray14(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function findValidateTime(date4, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig2) {
  var nextDate = date4;
  function alignValidate(getUnitValue2, setUnitValue, units) {
    var nextValue = generateConfig2[getUnitValue2](nextDate);
    var nextUnit = units.find(function(unit3) {
      return unit3.value === nextValue;
    });
    if (!nextUnit || nextUnit.disabled) {
      var validateUnits = units.filter(function(unit3) {
        return !unit3.disabled;
      });
      var reverseEnabledUnits = _toConsumableArray4(validateUnits).reverse();
      var validateUnit = reverseEnabledUnits.find(function(unit3) {
        return unit3.value <= nextValue;
      }) || validateUnits[0];
      if (validateUnit) {
        nextValue = validateUnit.value;
        nextDate = generateConfig2[setUnitValue](nextDate, nextValue);
      }
    }
    return nextValue;
  }
  var nextHour = alignValidate("getHour", "setHour", getHourUnits());
  var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
  var nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
  alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond));
  return nextDate;
}

// node_modules/@rc-component/picker/es/hooks/useTimeInfo.js
function _typeof12(o3) {
  "@babel/helpers - typeof";
  return _typeof12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof12(o3);
}
function ownKeys9(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread9(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys9(Object(t2), true).forEach(function(r3) {
      _defineProperty10(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys9(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty10(obj, key, value) {
  key = _toPropertyKey9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey9(t2) {
  var i = _toPrimitive9(t2, "string");
  return "symbol" == _typeof12(i) ? i : String(i);
}
function _toPrimitive9(t2, r2) {
  if ("object" != _typeof12(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof12(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray13(arr, i) {
  return _arrayWithHoles13(arr) || _iterableToArrayLimit13(arr, i) || _unsupportedIterableToArray15(arr, i) || _nonIterableRest13();
}
function _nonIterableRest13() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray15(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray15(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray15(o3, minLen);
}
function _arrayLikeToArray15(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit13(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles13(arr) {
  if (Array.isArray(arr))
    return arr;
}
function emptyDisabled() {
  return [];
}
function generateUnits(start, end) {
  var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
  var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
  var units = [];
  var integerStep = step >= 1 ? step | 0 : 1;
  for (var i = start; i <= end; i += integerStep) {
    var disabled = disabledUnits.includes(i);
    if (!disabled || !hideDisabledOptions) {
      units.push({
        label: leftPad(i, pad),
        value: i,
        disabled
      });
    }
  }
  return units;
}
function useTimeInfo(generateConfig2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var date4 = arguments.length > 2 ? arguments[2] : void 0;
  var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
  var mergedDate = React264.useMemo(function() {
    return date4 || generateConfig2.getNow();
  }, [date4, generateConfig2]);
  if (true) {
    var isHourStepValid = 24 % hourStep === 0;
    var isMinuteStepValid = 60 % minuteStep === 0;
    var isSecondStepValid = 60 % secondStep === 0;
    warning_default(isHourStepValid, "`hourStep` ".concat(hourStep, " is invalid. It should be a factor of 24."));
    warning_default(isMinuteStepValid, "`minuteStep` ".concat(minuteStep, " is invalid. It should be a factor of 60."));
    warning_default(isSecondStepValid, "`secondStep` ".concat(secondStep, " is invalid. It should be a factor of 60."));
  }
  var getDisabledTimes = React264.useCallback(function(targetDate) {
    var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
    return [disabledConfig.disabledHours || disabledHours || emptyDisabled, disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled, disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled, disabledConfig.disabledMilliseconds || emptyDisabled];
  }, [disabledTime, disabledHours, disabledMinutes, disabledSeconds]);
  var _React$useMemo = React264.useMemo(function() {
    return getDisabledTimes(mergedDate);
  }, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray13(_React$useMemo, 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
  var getAllUnits = React264.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
    var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
    var rowHourUnits2 = use12Hours ? hours.map(function(unit3) {
      return _objectSpread9(_objectSpread9({}, unit3), {}, {
        label: leftPad(unit3.value % 12 || 12, 2)
      });
    }) : hours;
    var getMinuteUnits2 = function getMinuteUnits3(nextHour) {
      return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
    };
    var getSecondUnits2 = function getSecondUnits3(nextHour, nextMinute) {
      return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
    };
    var getMillisecondUnits2 = function getMillisecondUnits3(nextHour, nextMinute, nextSecond) {
      return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
    };
    return [rowHourUnits2, getMinuteUnits2, getSecondUnits2, getMillisecondUnits2];
  }, [hideDisabledOptions, hourStep, use12Hours, millisecondStep, minuteStep, secondStep]);
  var _React$useMemo3 = React264.useMemo(function() {
    return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
  }, [getAllUnits, mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds]), _React$useMemo4 = _slicedToArray13(_React$useMemo3, 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
  var getValidTime = function getValidTime2(nextTime, certainDate) {
    var getCheckHourUnits = function getCheckHourUnits2() {
      return rowHourUnits;
    };
    var getCheckMinuteUnits = getMinuteUnits;
    var getCheckSecondUnits = getSecondUnits;
    var getCheckMillisecondUnits = getMillisecondUnits;
    if (certainDate) {
      var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray13(_getDisabledTimes, 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
      var _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray13(_getAllUnits, 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
      getCheckHourUnits = function getCheckHourUnits2() {
        return targetRowHourUnits;
      };
      getCheckMinuteUnits = targetGetMinuteUnits;
      getCheckSecondUnits = targetGetSecondUnits;
      getCheckMillisecondUnits = targetGetMillisecondUnits;
    }
    var validateDate = findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig2);
    return validateDate;
  };
  return [
    // getValidTime
    getValidTime,
    // Units
    rowHourUnits,
    getMinuteUnits,
    getSecondUnits,
    getMillisecondUnits
  ];
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/Footer.js
function _slicedToArray14(arr, i) {
  return _arrayWithHoles14(arr) || _iterableToArrayLimit14(arr, i) || _unsupportedIterableToArray16(arr, i) || _nonIterableRest14();
}
function _nonIterableRest14() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray16(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray16(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray16(o3, minLen);
}
function _arrayLikeToArray16(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit14(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles14(arr) {
  if (Array.isArray(arr))
    return arr;
}
function Footer2(props) {
  var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig2 = props.generateConfig, disabledDate = props.disabledDate;
  var _React$useContext = React265.useContext(context_default7), prefixCls = _React$useContext.prefixCls, locale6 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button2 = _React$useContext$but === void 0 ? "button" : _React$useContext$but, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var now2 = generateConfig2.getNow();
  var _useTimeInfo = useTimeInfo(generateConfig2, showTime, now2), _useTimeInfo2 = _slicedToArray14(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
  var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
  var nowDisabled = disabledDate(now2, {
    type: mode
  });
  var onInternalNow = function onInternalNow2() {
    if (!nowDisabled) {
      var validateNow = getValidTime(now2);
      onNow(validateNow);
    }
  };
  var nowPrefixCls = "".concat(prefixCls, "-now");
  var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
  var presetNode = showNow && React265.createElement("li", {
    className: nowPrefixCls
  }, React265.createElement("a", {
    className: clsx(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
    "aria-disabled": nowDisabled,
    onClick: onInternalNow
  }, internalMode === "date" ? locale6.today : locale6.now));
  var okNode = needConfirm && React265.createElement("li", {
    className: "".concat(prefixCls, "-ok")
  }, React265.createElement(Button2, {
    disabled: invalid,
    onClick: onSubmit
  }, locale6.ok));
  var rangeNode = (presetNode || okNode) && React265.createElement("ul", {
    className: "".concat(prefixCls, "-ranges")
  }, presetNode, okNode);
  if (!extraNode && !rangeNode) {
    return null;
  }
  return React265.createElement("div", {
    className: clsx("".concat(prefixCls, "-footer"), classNames.popup.footer),
    style: styles.popup.footer
  }, extraNode && React265.createElement("div", {
    className: "".concat(prefixCls, "-footer-extra")
  }, extraNode), rangeNode);
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/PopupPanel.js
var React281 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/index.js
var React280 = __toESM(require_react());

// node_modules/@rc-component/picker/es/hooks/useToggleDates.js
function _toConsumableArray5(arr) {
  return _arrayWithoutHoles5(arr) || _iterableToArray5(arr) || _unsupportedIterableToArray17(arr) || _nonIterableSpread5();
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray17(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray17(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray17(o3, minLen);
}
function _iterableToArray5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles5(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray17(arr);
}
function _arrayLikeToArray17(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function useToggleDates(generateConfig2, locale6, panelMode) {
  function toggleDates(list, target) {
    var index2 = list.findIndex(function(date4) {
      return isSame(generateConfig2, locale6, date4, target, panelMode);
    });
    if (index2 === -1) {
      return [].concat(_toConsumableArray5(list), [target]);
    }
    var sliceList = _toConsumableArray5(list);
    sliceList.splice(index2, 1);
    return sliceList;
  }
  return toggleDates;
}

// node_modules/@rc-component/picker/es/PickerPanel/context.js
var React266 = __toESM(require_react());
var SharedPanelContext = React266.createContext(null);
var PanelContext = React266.createContext(null);
function usePanelContext() {
  return React266.useContext(PanelContext);
}
function useInfo(props, panelType) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale6 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
  var _React$useContext = React266.useContext(SharedPanelContext), classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var now2 = generateConfig2.getNow();
  var info = {
    now: now2,
    values,
    pickerValue,
    prefixCls,
    classNames,
    styles,
    disabledDate,
    minDate,
    maxDate,
    cellRender,
    hoverValue,
    hoverRangeValue,
    onHover,
    locale: locale6,
    generateConfig: generateConfig2,
    onSelect,
    panelType,
    // Icons
    prevIcon,
    nextIcon,
    superPrevIcon,
    superNextIcon
  };
  return [info, now2];
}
var PickerHackContext = React266.createContext({});
if (true) {
  PickerHackContext.displayName = "PickerHackContext";
}

// node_modules/@rc-component/picker/es/PickerPanel/DatePanel/index.js
var React269 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/PanelBody.js
var React267 = __toESM(require_react());
function _typeof13(o3) {
  "@babel/helpers - typeof";
  return _typeof13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof13(o3);
}
function ownKeys10(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread10(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys10(Object(t2), true).forEach(function(r3) {
      _defineProperty11(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys10(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty11(obj, key, value) {
  key = _toPropertyKey10(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey10(t2) {
  var i = _toPrimitive10(t2, "string");
  return "symbol" == _typeof13(i) ? i : String(i);
}
function _toPrimitive10(t2, r2) {
  if ("object" != _typeof13(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof13(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray15(arr, i) {
  return _arrayWithHoles15(arr) || _iterableToArrayLimit15(arr, i) || _unsupportedIterableToArray18(arr, i) || _nonIterableRest15();
}
function _nonIterableRest15() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray18(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray18(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray18(o3, minLen);
}
function _arrayLikeToArray18(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit15(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles15(arr) {
  if (Array.isArray(arr))
    return arr;
}
function PanelBody(props) {
  var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, type5 = _usePanelContext.panelType, now2 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig2 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale6 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
  var mergedDisabledDate = disabledDate || contextDisabledDate;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var _React$useContext = React267.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
  var matchValues = function matchValues2(date4) {
    return values.some(function(singleValue) {
      return singleValue && isSame(generateConfig2, locale6, date4, singleValue, type5);
    });
  };
  var rows = [];
  for (var row = 0; row < rowNum; row += 1) {
    var rowNode = [];
    var rowStartDate = void 0;
    var _loop = function _loop2() {
      var offset3 = row * colNum + col;
      var currentDate = getCellDate(baseDate, offset3);
      var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, {
        type: type5
      });
      if (col === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          rowNode.push(prefixColumn(rowStartDate));
        }
      }
      var inRange = false;
      var rangeStart = false;
      var rangeEnd = false;
      if (cellSelection && hoverRangeValue) {
        var _hoverRangeValue = _slicedToArray15(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
        inRange = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
        rangeStart = isSame(generateConfig2, locale6, currentDate, hoverStart, type5);
        rangeEnd = isSame(generateConfig2, locale6, currentDate, hoverEnd, type5);
      }
      var title = titleFormat ? formatValue(currentDate, {
        locale: locale6,
        format: titleFormat,
        generateConfig: generateConfig2
      }) : void 0;
      var inner = React267.createElement("div", {
        className: "".concat(cellPrefixCls, "-inner")
      }, getCellText(currentDate));
      rowNode.push(React267.createElement("td", {
        key: col,
        title,
        className: clsx(cellPrefixCls, classNames.item, _objectSpread10(_defineProperty11(_defineProperty11(_defineProperty11(_defineProperty11(_defineProperty11(_defineProperty11({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date4) {
          return isSame(generateConfig2, locale6, currentDate, date4, type5);
        })), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && // WeekPicker use row instead
        type5 !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
        style: styles.item,
        onClick: function onClick() {
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        onDoubleClick: function onDoubleClick() {
          if (!disabled && onCellDblClick) {
            onCellDblClick();
          }
        },
        onMouseEnter: function onMouseEnter() {
          if (!disabled) {
            onHover === null || onHover === void 0 || onHover(currentDate);
          }
        },
        onMouseLeave: function onMouseLeave() {
          if (!disabled) {
            onHover === null || onHover === void 0 || onHover(null);
          }
        }
      }, cellRender ? cellRender(currentDate, {
        prefixCls,
        originNode: inner,
        today: now2,
        type: type5,
        locale: locale6
      }) : inner));
    };
    for (var col = 0; col < colNum; col += 1) {
      _loop();
    }
    rows.push(React267.createElement("tr", {
      key: row,
      className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
    }, rowNode));
  }
  return React267.createElement("div", {
    className: clsx("".concat(prefixCls, "-body"), classNames.body),
    style: styles.body
  }, React267.createElement("table", {
    className: clsx("".concat(prefixCls, "-content"), classNames.content),
    style: styles.content
  }, headerCells && React267.createElement("thead", null, React267.createElement("tr", null, headerCells)), React267.createElement("tbody", null, rows)));
}

// node_modules/@rc-component/picker/es/PickerPanel/PanelHeader.js
var React268 = __toESM(require_react());
var HIDDEN_STYLE = {
  visibility: "hidden"
};
function PanelHeader(props) {
  var offset3 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig2 = _usePanelContext.generateConfig, locale6 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type5 = _usePanelContext.panelType;
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var _React$useContext = React268.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
  var disabledOffsetPrev = React268.useMemo(function() {
    if (!minDate || !offset3 || !getEnd) {
      return false;
    }
    var prevPanelLimitDate = getEnd(offset3(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, prevPanelLimitDate, minDate, type5);
  }, [minDate, offset3, pickerValue, getEnd, generateConfig2, locale6, type5]);
  var disabledSuperOffsetPrev = React268.useMemo(function() {
    if (!minDate || !superOffset || !getEnd) {
      return false;
    }
    var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, prevPanelLimitDate, minDate, type5);
  }, [minDate, superOffset, pickerValue, getEnd, generateConfig2, locale6, type5]);
  var disabledOffsetNext = React268.useMemo(function() {
    if (!maxDate || !offset3 || !getStart) {
      return false;
    }
    var nextPanelLimitDate = getStart(offset3(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, maxDate, nextPanelLimitDate, type5);
  }, [maxDate, offset3, pickerValue, getStart, generateConfig2, locale6, type5]);
  var disabledSuperOffsetNext = React268.useMemo(function() {
    if (!maxDate || !superOffset || !getStart) {
      return false;
    }
    var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
    return !isSameOrAfter(generateConfig2, locale6, maxDate, nextPanelLimitDate, type5);
  }, [maxDate, superOffset, pickerValue, getStart, generateConfig2, locale6, type5]);
  var onOffset = function onOffset2(distance) {
    if (offset3) {
      onChange(offset3(distance, pickerValue));
    }
  };
  var onSuperOffset = function onSuperOffset2(distance) {
    if (superOffset) {
      onChange(superOffset(distance, pickerValue));
    }
  };
  if (hideHeader) {
    return null;
  }
  var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
  var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
  var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
  var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
  return React268.createElement("div", {
    className: clsx(headerPrefixCls, classNames.header),
    style: styles.header
  }, superOffset && React268.createElement("button", {
    type: "button",
    "aria-label": locale6.previousYear,
    onClick: function onClick() {
      return onSuperOffset(-1);
    },
    tabIndex: -1,
    className: clsx(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
    disabled: disabledSuperOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE : {}
  }, superPrevIcon), offset3 && React268.createElement("button", {
    type: "button",
    "aria-label": locale6.previousMonth,
    onClick: function onClick() {
      return onOffset(-1);
    },
    tabIndex: -1,
    className: clsx(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
    disabled: disabledOffsetPrev,
    style: hidePrev ? HIDDEN_STYLE : {}
  }, prevIcon), React268.createElement("div", {
    className: "".concat(headerPrefixCls, "-view")
  }, children), offset3 && React268.createElement("button", {
    type: "button",
    "aria-label": locale6.nextMonth,
    onClick: function onClick() {
      return onOffset(1);
    },
    tabIndex: -1,
    className: clsx(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
    disabled: disabledOffsetNext,
    style: hideNext ? HIDDEN_STYLE : {}
  }, nextIcon), superOffset && React268.createElement("button", {
    type: "button",
    "aria-label": locale6.nextYear,
    onClick: function onClick() {
      return onSuperOffset(1);
    },
    tabIndex: -1,
    className: clsx(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
    disabled: disabledSuperOffsetNext,
    style: hideNext ? HIDDEN_STYLE : {}
  }, superNextIcon));
}
var PanelHeader_default = PanelHeader;

// node_modules/@rc-component/picker/es/PickerPanel/DatePanel/index.js
function _typeof14(o3) {
  "@babel/helpers - typeof";
  return _typeof14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof14(o3);
}
function _extends33() {
  _extends33 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends33.apply(this, arguments);
}
function _defineProperty12(obj, key, value) {
  key = _toPropertyKey11(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey11(t2) {
  var i = _toPrimitive11(t2, "string");
  return "symbol" == _typeof14(i) ? i : String(i);
}
function _toPrimitive11(t2, r2) {
  if ("object" != _typeof14(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof14(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray16(arr, i) {
  return _arrayWithHoles16(arr) || _iterableToArrayLimit16(arr, i) || _unsupportedIterableToArray19(arr, i) || _nonIterableRest16();
}
function _nonIterableRest16() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray19(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray19(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray19(o3, minLen);
}
function _arrayLikeToArray19(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit16(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles16(arr) {
  if (Array.isArray(arr))
    return arr;
}
function DatePanel(props) {
  var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale6 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
  var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var isWeek = mode === "week";
  var _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray16(_useInfo, 2), info = _useInfo2[0], now2 = _useInfo2[1];
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale6.locale);
  var monthStartDate = generateConfig2.setDate(pickerValue, 1);
  var baseDate = getWeekStartDate(locale6.locale, generateConfig2, monthStartDate);
  var month = generateConfig2.getMonth(pickerValue);
  var showPrefixColumn = showWeek === void 0 ? isWeek : showWeek;
  var prefixColumn = showPrefixColumn ? function(date4) {
    var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date4, {
      type: "week"
    });
    return React269.createElement("td", {
      key: "week",
      className: clsx(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty12({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: function onClick() {
        if (!disabled) {
          onSelect(date4);
        }
      },
      onMouseEnter: function onMouseEnter() {
        if (!disabled) {
          onHover === null || onHover === void 0 || onHover(date4);
        }
      },
      onMouseLeave: function onMouseLeave() {
        if (!disabled) {
          onHover === null || onHover === void 0 || onHover(null);
        }
      }
    }, React269.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, generateConfig2.locale.getWeek(locale6.locale, date4)));
  } : null;
  var headerCells = [];
  var weekDaysLocale = locale6.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale6.locale) : []);
  if (prefixColumn) {
    headerCells.push(React269.createElement("th", {
      key: "empty"
    }, React269.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, locale6.week)));
  }
  for (var i = 0; i < WEEK_DAY_COUNT; i += 1) {
    headerCells.push(React269.createElement("th", {
      key: i
    }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
  }
  var getCellDate = function getCellDate2(date4, offset3) {
    return generateConfig2.addDate(date4, offset3);
  };
  var getCellText = function getCellText2(date4) {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellDateFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2(date4) {
    var classObj = _defineProperty12(_defineProperty12({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth(generateConfig2, date4, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate(generateConfig2, date4, now2));
    return classObj;
  };
  var monthsLocale = locale6.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale6.locale) : []);
  var yearNode = React269.createElement("button", {
    type: "button",
    "aria-label": locale6.yearSelect,
    key: "year",
    onClick: function onClick() {
      onModeChange("year", pickerValue);
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }));
  var monthNode = React269.createElement("button", {
    type: "button",
    "aria-label": locale6.monthSelect,
    key: "month",
    onClick: function onClick() {
      onModeChange("month", pickerValue);
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-month-btn")
  }, locale6.monthFormat ? formatValue(pickerValue, {
    locale: locale6,
    format: locale6.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]);
  var monthYearNodes = locale6.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return React269.createElement(PanelContext.Provider, {
    value: info
  }, React269.createElement("div", {
    className: clsx(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week"))
  }, React269.createElement(PanelHeader_default, {
    offset: function offset3(distance) {
      return generateConfig2.addMonth(pickerValue, distance);
    },
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date4) {
      return generateConfig2.setDate(date4, 1);
    },
    getEnd: function getEnd(date4) {
      var clone = generateConfig2.setDate(date4, 1);
      clone = generateConfig2.addMonth(clone, 1);
      return generateConfig2.addDate(clone, -1);
    }
  }, monthYearNodes), React269.createElement(PanelBody, _extends33({
    titleFormat: locale6.fieldDateFormat
  }, props, {
    colNum: WEEK_DAY_COUNT,
    rowNum: 6,
    baseDate,
    headerCells,
    getCellDate,
    getCellText,
    getCellClassName,
    prefixColumn,
    cellSelection: !isWeek
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/DateTimePanel/index.js
var React274 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/index.js
var React273 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
var React272 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
var React271 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/useScrollTo.js
var React270 = __toESM(require_react());
var SPEED_PTG = 1 / 3;
function useScrollTo2(ulRef, value) {
  var scrollingRef = React270.useRef(false);
  var scrollRafRef = React270.useRef(null);
  var scrollDistRef = React270.useRef(null);
  var isScrolling = function isScrolling2() {
    return scrollingRef.current;
  };
  var stopScroll = function stopScroll2() {
    raf_default.cancel(scrollRafRef.current);
    scrollingRef.current = false;
  };
  var scrollRafTimesRef = React270.useRef();
  var startScroll = function startScroll2() {
    var ul = ulRef.current;
    scrollDistRef.current = null;
    scrollRafTimesRef.current = 0;
    if (ul) {
      var targetLi = ul.querySelector('[data-value="'.concat(value, '"]'));
      var firstLi = ul.querySelector("li");
      var doScroll = function doScroll2() {
        stopScroll();
        scrollingRef.current = true;
        scrollRafTimesRef.current += 1;
        var currentTop = ul.scrollTop;
        var firstLiTop = firstLi.offsetTop;
        var targetLiTop = targetLi.offsetTop;
        var targetTop = targetLiTop - firstLiTop;
        if (targetLiTop === 0 && targetLi !== firstLi || !isVisible_default(ul)) {
          if (scrollRafTimesRef.current <= 5) {
            scrollRafRef.current = raf_default(doScroll2);
          }
          return;
        }
        var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
        var dist = Math.abs(targetTop - nextTop);
        if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
          stopScroll();
          return;
        }
        scrollDistRef.current = dist;
        if (dist <= 1) {
          ul.scrollTop = targetTop;
          stopScroll();
          return;
        }
        ul.scrollTop = nextTop;
        scrollRafRef.current = raf_default(doScroll2);
      };
      if (targetLi && firstLi) {
        doScroll();
      }
    }
  };
  var syncScroll = useEvent_default(startScroll);
  return [syncScroll, stopScroll, isScrolling];
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/TimeColumn.js
function _typeof15(o3) {
  "@babel/helpers - typeof";
  return _typeof15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof15(o3);
}
function _defineProperty13(obj, key, value) {
  key = _toPropertyKey12(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey12(t2) {
  var i = _toPrimitive12(t2, "string");
  return "symbol" == _typeof15(i) ? i : String(i);
}
function _toPrimitive12(t2, r2) {
  if ("object" != _typeof15(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof15(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toConsumableArray6(arr) {
  return _arrayWithoutHoles6(arr) || _iterableToArray6(arr) || _unsupportedIterableToArray20(arr) || _nonIterableSpread6();
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray6(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles6(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray20(arr);
}
function _slicedToArray17(arr, i) {
  return _arrayWithHoles17(arr) || _iterableToArrayLimit17(arr, i) || _unsupportedIterableToArray20(arr, i) || _nonIterableRest17();
}
function _nonIterableRest17() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray20(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray20(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray20(o3, minLen);
}
function _arrayLikeToArray20(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit17(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles17(arr) {
  if (Array.isArray(arr))
    return arr;
}
var SCROLL_DELAY = 300;
function flattenUnits(units) {
  return units.map(function(_ref) {
    var value = _ref.value, label = _ref.label, disabled = _ref.disabled;
    return [value, label, disabled].join(",");
  }).join(";");
}
function TimeColumn(props) {
  var units = props.units, value = props.value, optionalValue = props.optionalValue, type5 = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now2 = _usePanelContext.now, locale6 = _usePanelContext.locale, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
  var ulRef = React271.useRef(null);
  var checkDelayRef = React271.useRef();
  var clearDelayCheck = function clearDelayCheck2() {
    clearTimeout(checkDelayRef.current);
  };
  var _useScrollTo = useScrollTo2(ulRef, value !== null && value !== void 0 ? value : optionalValue), _useScrollTo2 = _slicedToArray17(_useScrollTo, 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
  useLayoutEffect_default(function() {
    syncScroll();
    clearDelayCheck();
    return function() {
      stopScroll();
      clearDelayCheck();
    };
  }, [value, optionalValue, flattenUnits(units)]);
  var onInternalScroll = function onInternalScroll2(event) {
    clearDelayCheck();
    var target = event.target;
    if (!isScrolling() && changeOnScroll) {
      checkDelayRef.current = setTimeout(function() {
        var ul = ulRef.current;
        var firstLiTop = ul.querySelector("li").offsetTop;
        var liList = Array.from(ul.querySelectorAll("li"));
        var liTopList = liList.map(function(li) {
          return li.offsetTop - firstLiTop;
        });
        var liDistList = liTopList.map(function(top, index2) {
          if (units[index2].disabled) {
            return Number.MAX_SAFE_INTEGER;
          }
          return Math.abs(top - target.scrollTop);
        });
        var minDist = Math.min.apply(Math, _toConsumableArray6(liDistList));
        var minDistIndex = liDistList.findIndex(function(dist) {
          return dist === minDist;
        });
        var targetUnit = units[minDistIndex];
        if (targetUnit && !targetUnit.disabled) {
          onChange(targetUnit.value);
        }
      }, SCROLL_DELAY);
    }
  };
  var columnPrefixCls = "".concat(panelPrefixCls, "-column");
  return React271.createElement("ul", {
    className: columnPrefixCls,
    ref: ulRef,
    "data-type": type5,
    onScroll: onInternalScroll
  }, units.map(function(_ref2) {
    var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
    var inner = React271.createElement("div", {
      className: "".concat(cellPrefixCls, "-inner")
    }, label);
    return React271.createElement("li", {
      key: unitValue,
      style: styles.item,
      className: clsx(cellPrefixCls, classNames.item, _defineProperty13(_defineProperty13({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
      onClick: function onClick() {
        if (!disabled) {
          onChange(unitValue);
        }
      },
      onDoubleClick: function onDoubleClick() {
        if (!disabled && onDblClick) {
          onDblClick();
        }
      },
      onMouseEnter: function onMouseEnter() {
        onHover(unitValue);
      },
      onMouseLeave: function onMouseLeave() {
        onHover(null);
      },
      "data-value": unitValue
    }, cellRender ? cellRender(unitValue, {
      prefixCls,
      originNode: inner,
      today: now2,
      type: "time",
      subType: type5,
      locale: locale6
    }) : inner);
  }));
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/TimePanelBody/index.js
function _extends34() {
  _extends34 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends34.apply(this, arguments);
}
function _slicedToArray18(arr, i) {
  return _arrayWithHoles18(arr) || _iterableToArrayLimit18(arr, i) || _unsupportedIterableToArray21(arr, i) || _nonIterableRest18();
}
function _nonIterableRest18() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray21(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray21(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray21(o3, minLen);
}
function _arrayLikeToArray21(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit18(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles18(arr) {
  if (Array.isArray(arr))
    return arr;
}
function isAM(hour) {
  return hour < 12;
}
function TimePanelBody(props) {
  var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
  var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, classNames = _usePanelContext.classNames, styles = _usePanelContext.styles, values = _usePanelContext.values, generateConfig2 = _usePanelContext.generateConfig, locale6 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {
  } : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
  var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
  var _React$useContext = React272.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
  var _useTimeInfo = useTimeInfo(generateConfig2, props, value), _useTimeInfo2 = _slicedToArray18(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
  var getUnitValue2 = function getUnitValue3(func) {
    var valueUnitVal = value && generateConfig2[func](value);
    var pickerUnitValue = pickerValue && generateConfig2[func](pickerValue);
    return [valueUnitVal, pickerUnitValue];
  };
  var _getUnitValue = getUnitValue2("getHour"), _getUnitValue2 = _slicedToArray18(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
  var _getUnitValue3 = getUnitValue2("getMinute"), _getUnitValue4 = _slicedToArray18(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
  var _getUnitValue5 = getUnitValue2("getSecond"), _getUnitValue6 = _slicedToArray18(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
  var _getUnitValue7 = getUnitValue2("getMillisecond"), _getUnitValue8 = _slicedToArray18(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
  var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
  var hourUnits = React272.useMemo(function() {
    if (!showMeridiem) {
      return rowHourUnits;
    }
    return isAM(hour) ? rowHourUnits.filter(function(h) {
      return isAM(h.value);
    }) : rowHourUnits.filter(function(h) {
      return !isAM(h.value);
    });
  }, [hour, rowHourUnits, showMeridiem]);
  var getEnabled = function getEnabled2(units, val) {
    var _enabledUnits$;
    var enabledUnits = units.filter(function(unit3) {
      return !unit3.disabled;
    });
    return val !== null && val !== void 0 ? val : (
      // Fallback to enabled value
      enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value
    );
  };
  var validHour = getEnabled(rowHourUnits, hour);
  var minuteUnits = React272.useMemo(function() {
    return getMinuteUnits(validHour);
  }, [getMinuteUnits, validHour]);
  var validMinute = getEnabled(minuteUnits, minute);
  var secondUnits = React272.useMemo(function() {
    return getSecondUnits(validHour, validMinute);
  }, [getSecondUnits, validHour, validMinute]);
  var validSecond = getEnabled(secondUnits, second);
  var millisecondUnits = React272.useMemo(function() {
    return getMillisecondUnits(validHour, validMinute, validSecond);
  }, [getMillisecondUnits, validHour, validMinute, validSecond]);
  var validMillisecond = getEnabled(millisecondUnits, millisecond);
  var meridiemUnits = React272.useMemo(function() {
    if (!showMeridiem) {
      return [];
    }
    var base = generateConfig2.getNow();
    var amDate = generateConfig2.setHour(base, 6);
    var pmDate = generateConfig2.setHour(base, 18);
    var formatMeridiem = function formatMeridiem2(date4, defaultLabel) {
      var cellMeridiemFormat = locale6.cellMeridiemFormat;
      return cellMeridiemFormat ? formatValue(date4, {
        generateConfig: generateConfig2,
        locale: locale6,
        format: cellMeridiemFormat
      }) : defaultLabel;
    };
    return [{
      label: formatMeridiem(amDate, "AM"),
      value: "am",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || !isAM(h.value);
      })
    }, {
      label: formatMeridiem(pmDate, "PM"),
      value: "pm",
      disabled: rowHourUnits.every(function(h) {
        return h.disabled || isAM(h.value);
      })
    }];
  }, [rowHourUnits, showMeridiem, generateConfig2, locale6]);
  var triggerChange = function triggerChange2(nextDate) {
    var validateDate = getValidTime(nextDate);
    onSelect(validateDate);
  };
  var triggerDateTmpl = React272.useMemo(function() {
    var tmpl = value || pickerValue || generateConfig2.getNow();
    var isNotNull = function isNotNull2(num) {
      return num !== null && num !== void 0;
    };
    if (isNotNull(hour)) {
      tmpl = generateConfig2.setHour(tmpl, hour);
      tmpl = generateConfig2.setMinute(tmpl, minute);
      tmpl = generateConfig2.setSecond(tmpl, second);
      tmpl = generateConfig2.setMillisecond(tmpl, millisecond);
    } else if (isNotNull(pickerHour)) {
      tmpl = generateConfig2.setHour(tmpl, pickerHour);
      tmpl = generateConfig2.setMinute(tmpl, pickerMinute);
      tmpl = generateConfig2.setSecond(tmpl, pickerSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, pickerMillisecond);
    } else if (isNotNull(validHour)) {
      tmpl = generateConfig2.setHour(tmpl, validHour);
      tmpl = generateConfig2.setMinute(tmpl, validMinute);
      tmpl = generateConfig2.setSecond(tmpl, validSecond);
      tmpl = generateConfig2.setMillisecond(tmpl, validMillisecond);
    }
    return tmpl;
  }, [value, pickerValue, hour, minute, second, millisecond, validHour, validMinute, validSecond, validMillisecond, pickerHour, pickerMinute, pickerSecond, pickerMillisecond, generateConfig2]);
  var fillColumnValue = function fillColumnValue2(val, func) {
    if (val === null) {
      return null;
    }
    return generateConfig2[func](triggerDateTmpl, val);
  };
  var getNextHourTime = function getNextHourTime2(val) {
    return fillColumnValue(val, "setHour");
  };
  var getNextMinuteTime = function getNextMinuteTime2(val) {
    return fillColumnValue(val, "setMinute");
  };
  var getNextSecondTime = function getNextSecondTime2(val) {
    return fillColumnValue(val, "setSecond");
  };
  var getNextMillisecondTime = function getNextMillisecondTime2(val) {
    return fillColumnValue(val, "setMillisecond");
  };
  var getMeridiemTime = function getMeridiemTime2(val) {
    if (val === null) {
      return null;
    }
    if (val === "am" && !isAM(hour)) {
      return generateConfig2.setHour(triggerDateTmpl, hour - 12);
    } else if (val === "pm" && isAM(hour)) {
      return generateConfig2.setHour(triggerDateTmpl, hour + 12);
    }
    return triggerDateTmpl;
  };
  var onHourChange = function onHourChange2(val) {
    triggerChange(getNextHourTime(val));
  };
  var onMinuteChange = function onMinuteChange2(val) {
    triggerChange(getNextMinuteTime(val));
  };
  var onSecondChange = function onSecondChange2(val) {
    triggerChange(getNextSecondTime(val));
  };
  var onMillisecondChange = function onMillisecondChange2(val) {
    triggerChange(getNextMillisecondTime(val));
  };
  var onMeridiemChange = function onMeridiemChange2(val) {
    triggerChange(getMeridiemTime(val));
  };
  var onHourHover = function onHourHover2(val) {
    onHover(getNextHourTime(val));
  };
  var onMinuteHover = function onMinuteHover2(val) {
    onHover(getNextMinuteTime(val));
  };
  var onSecondHover = function onSecondHover2(val) {
    onHover(getNextSecondTime(val));
  };
  var onMillisecondHover = function onMillisecondHover2(val) {
    onHover(getNextMillisecondTime(val));
  };
  var onMeridiemHover = function onMeridiemHover2(val) {
    onHover(getMeridiemTime(val));
  };
  var sharedColumnProps = {
    onDblClick: onCellDblClick,
    changeOnScroll
  };
  return React272.createElement("div", {
    className: clsx("".concat(prefixCls, "-content"), classNames.content),
    style: styles.content
  }, showHour && React272.createElement(TimeColumn, _extends34({
    units: hourUnits,
    value: hour,
    optionalValue: pickerHour,
    type: "hour",
    onChange: onHourChange,
    onHover: onHourHover
  }, sharedColumnProps)), showMinute && React272.createElement(TimeColumn, _extends34({
    units: minuteUnits,
    value: minute,
    optionalValue: pickerMinute,
    type: "minute",
    onChange: onMinuteChange,
    onHover: onMinuteHover
  }, sharedColumnProps)), showSecond && React272.createElement(TimeColumn, _extends34({
    units: secondUnits,
    value: second,
    optionalValue: pickerSecond,
    type: "second",
    onChange: onSecondChange,
    onHover: onSecondHover
  }, sharedColumnProps)), showMillisecond && React272.createElement(TimeColumn, _extends34({
    units: millisecondUnits,
    value: millisecond,
    optionalValue: pickerMillisecond,
    type: "millisecond",
    onChange: onMillisecondChange,
    onHover: onMillisecondHover
  }, sharedColumnProps)), showMeridiem && React272.createElement(TimeColumn, _extends34({
    units: meridiemUnits,
    value: meridiem,
    type: "meridiem",
    onChange: onMeridiemChange,
    onHover: onMeridiemHover
  }, sharedColumnProps)));
}

// node_modules/@rc-component/picker/es/PickerPanel/TimePanel/index.js
function _slicedToArray19(arr, i) {
  return _arrayWithHoles19(arr) || _iterableToArrayLimit19(arr, i) || _unsupportedIterableToArray22(arr, i) || _nonIterableRest19();
}
function _nonIterableRest19() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray22(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray22(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray22(o3, minLen);
}
function _arrayLikeToArray22(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit19(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles19(arr) {
  if (Array.isArray(arr))
    return arr;
}
function TimePanel(props) {
  var prefixCls = props.prefixCls, value = props.value, locale6 = props.locale, generateConfig2 = props.generateConfig, showTime = props.showTime;
  var _ref = showTime || {}, format3 = _ref.format;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray19(_useInfo, 1), info = _useInfo2[0];
  return React273.createElement(PanelContext.Provider, {
    value: info
  }, React273.createElement("div", {
    className: clsx(panelPrefixCls)
  }, React273.createElement(PanelHeader_default, null, value ? formatValue(value, {
    locale: locale6,
    format: format3,
    generateConfig: generateConfig2
  }) : ""), React273.createElement(TimePanelBody, showTime)));
}

// node_modules/@rc-component/picker/es/PickerPanel/DateTimePanel/index.js
function _extends35() {
  _extends35 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends35.apply(this, arguments);
}
function _slicedToArray20(arr, i) {
  return _arrayWithHoles20(arr) || _iterableToArrayLimit20(arr, i) || _unsupportedIterableToArray23(arr, i) || _nonIterableRest20();
}
function _nonIterableRest20() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray23(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray23(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray23(o3, minLen);
}
function _arrayLikeToArray23(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit20(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles20(arr) {
  if (Array.isArray(arr))
    return arr;
}
function DateTimePanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
  var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
  var _useTimeInfo = useTimeInfo(generateConfig2, showTime), _useTimeInfo2 = _slicedToArray20(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
  var mergeTime = function mergeTime2(date4) {
    if (value) {
      return fillTime(generateConfig2, date4, value);
    }
    return fillTime(generateConfig2, date4, pickerValue);
  };
  var onDateHover = function onDateHover2(date4) {
    onHover === null || onHover === void 0 || onHover(date4 ? mergeTime(date4) : date4);
  };
  var onDateSelect = function onDateSelect2(date4) {
    var cloneDate = mergeTime(date4);
    onSelect(getValidTime(cloneDate, cloneDate));
  };
  return React274.createElement("div", {
    className: panelPrefixCls
  }, React274.createElement(DatePanel, _extends35({}, props, {
    onSelect: onDateSelect,
    onHover: onDateHover
  })), React274.createElement(TimePanel, props));
}

// node_modules/@rc-component/picker/es/PickerPanel/DecadePanel/index.js
var React275 = __toESM(require_react());
function _typeof16(o3) {
  "@babel/helpers - typeof";
  return _typeof16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof16(o3);
}
function _extends36() {
  _extends36 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends36.apply(this, arguments);
}
function _defineProperty14(obj, key, value) {
  key = _toPropertyKey13(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey13(t2) {
  var i = _toPrimitive13(t2, "string");
  return "symbol" == _typeof16(i) ? i : String(i);
}
function _toPrimitive13(t2, r2) {
  if ("object" != _typeof16(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof16(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray21(arr, i) {
  return _arrayWithHoles21(arr) || _iterableToArrayLimit21(arr, i) || _unsupportedIterableToArray24(arr, i) || _nonIterableRest21();
}
function _nonIterableRest21() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray24(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray24(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray24(o3, minLen);
}
function _arrayLikeToArray24(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit21(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles21(arr) {
  if (Array.isArray(arr))
    return arr;
}
function DecadePanel(props) {
  var prefixCls = props.prefixCls, locale6 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
  var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
  var _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray21(_useInfo, 1), info = _useInfo2[0];
  var getStartYear = function getStartYear2(date4) {
    var startYear = Math.floor(generateConfig2.getYear(date4) / 100) * 100;
    return generateConfig2.setYear(date4, startYear);
  };
  var getEndYear = function getEndYear2(date4) {
    var startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 99);
  };
  var startYearDate = getStartYear(pickerValue);
  var endYearDate = getEndYear(pickerValue);
  var baseDate = generateConfig2.addYear(startYearDate, -10);
  var getCellDate = function getCellDate2(date4, offset3) {
    return generateConfig2.addYear(date4, offset3 * 10);
  };
  var getCellText = function getCellText2(date4) {
    var cellYearFormat = locale6.cellYearFormat;
    var startYearStr = formatValue(date4, {
      locale: locale6,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    var endYearStr = formatValue(generateConfig2.addYear(date4, 9), {
      locale: locale6,
      format: cellYearFormat,
      generateConfig: generateConfig2
    });
    return "".concat(startYearStr, "-").concat(endYearStr);
  };
  var getCellClassName = function getCellClassName2(date4) {
    return _defineProperty14({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig2, date4, startYearDate) || isSameDecade(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4));
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var baseStartDate = generateConfig2.setDate(currentDate, 1);
    var baseStartMonth = generateConfig2.setMonth(baseStartDate, 0);
    var baseStartYear = generateConfig2.setYear(baseStartMonth, Math.floor(generateConfig2.getYear(baseStartMonth) / 10) * 10);
    var baseEndYear = generateConfig2.addYear(baseStartYear, 10);
    var baseEndDate = generateConfig2.addDate(baseEndYear, -1);
    return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
  } : null;
  var yearNode = "".concat(formatValue(startYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }), "-").concat(formatValue(endYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }));
  return React275.createElement(PanelContext.Provider, {
    value: info
  }, React275.createElement("div", {
    className: panelPrefixCls
  }, React275.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance * 100);
    },
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), React275.createElement(PanelBody, _extends36({}, props, {
    disabledDate: mergedDisabledDate,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/MonthPanel/index.js
var React276 = __toESM(require_react());
function _typeof17(o3) {
  "@babel/helpers - typeof";
  return _typeof17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof17(o3);
}
function _extends37() {
  _extends37 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends37.apply(this, arguments);
}
function _defineProperty15(obj, key, value) {
  key = _toPropertyKey14(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey14(t2) {
  var i = _toPrimitive14(t2, "string");
  return "symbol" == _typeof17(i) ? i : String(i);
}
function _toPrimitive14(t2, r2) {
  if ("object" != _typeof17(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof17(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray22(arr, i) {
  return _arrayWithHoles22(arr) || _iterableToArrayLimit22(arr, i) || _unsupportedIterableToArray25(arr, i) || _nonIterableRest22();
}
function _nonIterableRest22() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray25(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray25(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray25(o3, minLen);
}
function _arrayLikeToArray25(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit22(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles22(arr) {
  if (Array.isArray(arr))
    return arr;
}
function MonthPanel(props) {
  var prefixCls = props.prefixCls, locale6 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-month-panel");
  var _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray22(_useInfo, 1), info = _useInfo2[0];
  var baseDate = generateConfig2.setMonth(pickerValue, 0);
  var monthsLocale = locale6.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale6.locale) : []);
  var getCellDate = function getCellDate2(date4, offset3) {
    return generateConfig2.addMonth(date4, offset3);
  };
  var getCellText = function getCellText2(date4) {
    var month = generateConfig2.getMonth(date4);
    return locale6.monthFormat ? formatValue(date4, {
      locale: locale6,
      format: locale6.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[month];
  };
  var getCellClassName = function getCellClassName2() {
    return _defineProperty15({}, "".concat(prefixCls, "-cell-in-view"), true);
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startDate = generateConfig2.setDate(currentDate, 1);
    var nextMonthStartDate = generateConfig2.setMonth(startDate, generateConfig2.getMonth(startDate) + 1);
    var endDate = generateConfig2.addDate(nextMonthStartDate, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null;
  var yearNode = React276.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": locale6.yearSelect,
    onClick: function onClick() {
      onModeChange("year");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }));
  return React276.createElement(PanelContext.Provider, {
    value: info
  }, React276.createElement("div", {
    className: panelPrefixCls
  }, React276.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date4) {
      return generateConfig2.setMonth(date4, 0);
    },
    getEnd: function getEnd(date4) {
      return generateConfig2.setMonth(date4, 11);
    }
  }, yearNode), React276.createElement(PanelBody, _extends37({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale6.fieldMonthFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/QuarterPanel/index.js
var React277 = __toESM(require_react());
function _typeof18(o3) {
  "@babel/helpers - typeof";
  return _typeof18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof18(o3);
}
function _extends38() {
  _extends38 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends38.apply(this, arguments);
}
function _defineProperty16(obj, key, value) {
  key = _toPropertyKey15(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey15(t2) {
  var i = _toPrimitive15(t2, "string");
  return "symbol" == _typeof18(i) ? i : String(i);
}
function _toPrimitive15(t2, r2) {
  if ("object" != _typeof18(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof18(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray23(arr, i) {
  return _arrayWithHoles23(arr) || _iterableToArrayLimit23(arr, i) || _unsupportedIterableToArray26(arr, i) || _nonIterableRest23();
}
function _nonIterableRest23() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray26(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray26(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray26(o3, minLen);
}
function _arrayLikeToArray26(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit23(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles23(arr) {
  if (Array.isArray(arr))
    return arr;
}
function QuarterPanel(props) {
  var prefixCls = props.prefixCls, locale6 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
  var _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray23(_useInfo, 1), info = _useInfo2[0];
  var baseDate = generateConfig2.setMonth(pickerValue, 0);
  var getCellDate = function getCellDate2(date4, offset3) {
    return generateConfig2.addMonth(date4, offset3 * 3);
  };
  var getCellText = function getCellText2(date4) {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellQuarterFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2() {
    return _defineProperty16({}, "".concat(prefixCls, "-cell-in-view"), true);
  };
  var yearNode = React277.createElement("button", {
    type: "button",
    key: "year",
    "aria-label": locale6.yearSelect,
    onClick: function onClick() {
      onModeChange("year");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-year-btn")
  }, formatValue(pickerValue, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }));
  return React277.createElement(PanelContext.Provider, {
    value: info
  }, React277.createElement("div", {
    className: panelPrefixCls
  }, React277.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance);
    },
    onChange: onPickerValueChange,
    getStart: function getStart(date4) {
      return generateConfig2.setMonth(date4, 0);
    },
    getEnd: function getEnd(date4) {
      return generateConfig2.setMonth(date4, 11);
    }
  }, yearNode), React277.createElement(PanelBody, _extends38({}, props, {
    titleFormat: locale6.fieldQuarterFormat,
    colNum: 4,
    rowNum: 1,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/WeekPanel/index.js
var React278 = __toESM(require_react());
function _typeof19(o3) {
  "@babel/helpers - typeof";
  return _typeof19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof19(o3);
}
function _extends39() {
  _extends39 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends39.apply(this, arguments);
}
function _defineProperty17(obj, key, value) {
  key = _toPropertyKey16(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey16(t2) {
  var i = _toPrimitive16(t2, "string");
  return "symbol" == _typeof19(i) ? i : String(i);
}
function _toPrimitive16(t2, r2) {
  if ("object" != _typeof19(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof19(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray24(arr, i) {
  return _arrayWithHoles24(arr) || _iterableToArrayLimit24(arr, i) || _unsupportedIterableToArray27(arr, i) || _nonIterableRest24();
}
function _nonIterableRest24() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray27(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray27(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray27(o3, minLen);
}
function _arrayLikeToArray27(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit24(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles24(arr) {
  if (Array.isArray(arr))
    return arr;
}
function WeekPanel(props) {
  var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale6 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
  var localeName = locale6.locale;
  var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
  var rowClassName = function rowClassName2(currentDate) {
    var rangeCls = {};
    if (hoverRangeValue) {
      var _hoverRangeValue = _slicedToArray24(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
      var isRangeStart = isSameWeek(generateConfig2, localeName, rangeStart, currentDate);
      var isRangeEnd = isSameWeek(generateConfig2, localeName, rangeEnd, currentDate);
      rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
      rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
      rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, currentDate);
    }
    if (hoverValue) {
      rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date4) {
        return isSameWeek(generateConfig2, localeName, currentDate, date4);
      });
    }
    return clsx(
      rowPrefixCls,
      _defineProperty17({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig2, localeName, value, currentDate)),
      // Patch for hover range
      rangeCls
    );
  };
  return React278.createElement(DatePanel, _extends39({}, props, {
    mode: "week",
    panelName: "week",
    rowClassName
  }));
}

// node_modules/@rc-component/picker/es/PickerPanel/YearPanel/index.js
var React279 = __toESM(require_react());
function _typeof20(o3) {
  "@babel/helpers - typeof";
  return _typeof20 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof20(o3);
}
function _extends40() {
  _extends40 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends40.apply(this, arguments);
}
function _defineProperty18(obj, key, value) {
  key = _toPropertyKey17(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey17(t2) {
  var i = _toPrimitive17(t2, "string");
  return "symbol" == _typeof20(i) ? i : String(i);
}
function _toPrimitive17(t2, r2) {
  if ("object" != _typeof20(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof20(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray25(arr, i) {
  return _arrayWithHoles25(arr) || _iterableToArrayLimit25(arr, i) || _unsupportedIterableToArray28(arr, i) || _nonIterableRest25();
}
function _nonIterableRest25() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray28(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray28(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray28(o3, minLen);
}
function _arrayLikeToArray28(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit25(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles25(arr) {
  if (Array.isArray(arr))
    return arr;
}
function YearPanel(props) {
  var prefixCls = props.prefixCls, locale6 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
  var panelPrefixCls = "".concat(prefixCls, "-year-panel");
  var _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray25(_useInfo, 1), info = _useInfo2[0];
  var getStartYear = function getStartYear2(date4) {
    var startYear = Math.floor(generateConfig2.getYear(date4) / 10) * 10;
    return generateConfig2.setYear(date4, startYear);
  };
  var getEndYear = function getEndYear2(date4) {
    var startYear = getStartYear(date4);
    return generateConfig2.addYear(startYear, 9);
  };
  var startYearDate = getStartYear(pickerValue);
  var endYearDate = getEndYear(pickerValue);
  var baseDate = generateConfig2.addYear(startYearDate, -1);
  var getCellDate = function getCellDate2(date4, offset3) {
    return generateConfig2.addYear(date4, offset3);
  };
  var getCellText = function getCellText2(date4) {
    return formatValue(date4, {
      locale: locale6,
      format: locale6.cellYearFormat,
      generateConfig: generateConfig2
    });
  };
  var getCellClassName = function getCellClassName2(date4) {
    return _defineProperty18({}, "".concat(prefixCls, "-cell-in-view"), isSameYear(generateConfig2, date4, startYearDate) || isSameYear(generateConfig2, date4, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date4));
  };
  var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
    var startMonth = generateConfig2.setMonth(currentDate, 0);
    var startDate = generateConfig2.setDate(startMonth, 1);
    var endMonth = generateConfig2.addYear(startDate, 1);
    var endDate = generateConfig2.addDate(endMonth, -1);
    return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
  } : null;
  var yearNode = React279.createElement("button", {
    type: "button",
    key: "decade",
    "aria-label": locale6.decadeSelect,
    onClick: function onClick() {
      onModeChange("decade");
    },
    tabIndex: -1,
    className: "".concat(prefixCls, "-decade-btn")
  }, formatValue(startYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }), "-", formatValue(endYearDate, {
    locale: locale6,
    format: locale6.yearFormat,
    generateConfig: generateConfig2
  }));
  return React279.createElement(PanelContext.Provider, {
    value: info
  }, React279.createElement("div", {
    className: panelPrefixCls
  }, React279.createElement(PanelHeader_default, {
    superOffset: function superOffset(distance) {
      return generateConfig2.addYear(pickerValue, distance * 10);
    },
    onChange: onPickerValueChange,
    getStart: getStartYear,
    getEnd: getEndYear
  }, yearNode), React279.createElement(PanelBody, _extends40({}, props, {
    disabledDate: mergedDisabledDate,
    titleFormat: locale6.fieldYearFormat,
    colNum: 3,
    rowNum: 4,
    baseDate,
    getCellDate,
    getCellText,
    getCellClassName
  }))));
}

// node_modules/@rc-component/picker/es/PickerPanel/index.js
function _typeof21(o3) {
  "@babel/helpers - typeof";
  return _typeof21 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof21(o3);
}
function _extends41() {
  _extends41 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends41.apply(this, arguments);
}
function ownKeys11(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread11(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys11(Object(t2), true).forEach(function(r3) {
      _defineProperty19(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys11(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty19(obj, key, value) {
  key = _toPropertyKey18(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey18(t2) {
  var i = _toPrimitive18(t2, "string");
  return "symbol" == _typeof21(i) ? i : String(i);
}
function _toPrimitive18(t2, r2) {
  if ("object" != _typeof21(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof21(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toConsumableArray7(arr) {
  return _arrayWithoutHoles7(arr) || _iterableToArray7(arr) || _unsupportedIterableToArray29(arr) || _nonIterableSpread7();
}
function _nonIterableSpread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles7(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray29(arr);
}
function _slicedToArray26(arr, i) {
  return _arrayWithHoles26(arr) || _iterableToArrayLimit26(arr, i) || _unsupportedIterableToArray29(arr, i) || _nonIterableRest26();
}
function _nonIterableRest26() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray29(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray29(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray29(o3, minLen);
}
function _arrayLikeToArray29(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit26(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles26(arr) {
  if (Array.isArray(arr))
    return arr;
}
var DefaultComponents = {
  date: DatePanel,
  datetime: DateTimePanel,
  week: WeekPanel,
  month: MonthPanel,
  quarter: QuarterPanel,
  year: YearPanel,
  decade: DecadePanel,
  time: TimePanel
};
function PickerPanel(props, ref) {
  var panelClassNames = props.classNames, panelStyles = props.styles, locale6 = props.locale, generateConfig2 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components2 = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
  var _ref = React280.useContext(context_default7) || {}, contextPrefixCls = _ref.prefixCls, pickerClassNames = _ref.classNames, pickerStyles = _ref.styles;
  var mergedPrefixCls = contextPrefixCls || prefixCls || "rc-picker";
  var rootRef = React280.useRef();
  React280.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current
    };
  });
  var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray26(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
  var filledLocale = useLocale2(locale6, localeTimeProps);
  var internalPicker = picker === "date" && showTime ? "datetime" : picker;
  var mergedShowTime = React280.useMemo(function() {
    return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
  }, [internalPicker, showTimeFormat, propFormat, timeProps, filledLocale]);
  var now2 = generateConfig2.getNow();
  var _useControlledState = useControlledState(picker || "date", mode), _useControlledState2 = _slicedToArray26(_useControlledState, 2), mergedMode = _useControlledState2[0], setMergedMode = _useControlledState2[1];
  var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  var toggleDates = useToggleDates(generateConfig2, locale6, internalPicker);
  var _useControlledState3 = useControlledState(defaultValue, value), _useControlledState4 = _slicedToArray26(_useControlledState3, 2), innerValue = _useControlledState4[0], setMergedValue = _useControlledState4[1];
  var mergedValue = React280.useMemo(function() {
    var values = toArray5(innerValue).filter(function(val) {
      return val;
    });
    return multiple ? values : values.slice(0, 1);
  }, [innerValue, multiple]);
  var triggerChange = useEvent_default(function(nextValue) {
    setMergedValue(nextValue);
    if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index2) {
      return !isSame(generateConfig2, locale6, ori, nextValue[index2], internalPicker);
    }))) {
      onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
    }
  });
  var onInternalSelect = useEvent_default(function(newDate) {
    onSelect === null || onSelect === void 0 || onSelect(newDate);
    if (mergedMode === picker) {
      var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
      triggerChange(nextValues);
    }
  });
  var _useControlledState5 = useControlledState(defaultPickerValue || mergedValue[0] || now2, pickerValue), _useControlledState6 = _slicedToArray26(_useControlledState5, 2), mergedPickerValue = _useControlledState6[0], setInternalPickerValue = _useControlledState6[1];
  React280.useEffect(function() {
    if (mergedValue[0] && !pickerValue) {
      setInternalPickerValue(mergedValue[0]);
    }
  }, [mergedValue[0]]);
  var triggerPanelChange = function triggerPanelChange2(viewDate, nextMode) {
    onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
  };
  var setPickerValue = function setPickerValue2(nextPickerValue) {
    var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setInternalPickerValue(nextPickerValue);
    onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
    if (triggerPanelEvent) {
      triggerPanelChange(nextPickerValue);
    }
  };
  var triggerModeChange = function triggerModeChange2(nextMode, viewDate) {
    setMergedMode(nextMode);
    if (viewDate) {
      setPickerValue(viewDate);
    }
    triggerPanelChange(viewDate, nextMode);
  };
  var onPanelValueSelect = function onPanelValueSelect2(nextValue) {
    onInternalSelect(nextValue);
    setPickerValue(nextValue);
    if (mergedMode !== picker) {
      var decadeYearQueue = ["decade", "year"];
      var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
      var pickerQueue = {
        quarter: [].concat(decadeYearQueue, ["quarter"]),
        week: [].concat(_toConsumableArray7(decadeYearMonthQueue), ["week"]),
        date: [].concat(_toConsumableArray7(decadeYearMonthQueue), ["date"])
      };
      var queue = pickerQueue[picker] || decadeYearMonthQueue;
      var index2 = queue.indexOf(mergedMode);
      var nextMode = queue[index2 + 1];
      if (nextMode) {
        triggerModeChange(nextMode, nextValue);
      }
    }
  };
  var hoverRangeDate = React280.useMemo(function() {
    var start;
    var end;
    if (Array.isArray(hoverRangeValue)) {
      var _hoverRangeValue = _slicedToArray26(hoverRangeValue, 2);
      start = _hoverRangeValue[0];
      end = _hoverRangeValue[1];
    } else {
      start = hoverRangeValue;
    }
    if (!start && !end) {
      return null;
    }
    start = start || end;
    end = end || start;
    return generateConfig2.isAfter(start, end) ? [end, start] : [start, end];
  }, [hoverRangeValue, generateConfig2]);
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  var PanelComponent = components2[internalMode] || DefaultComponents[internalMode] || DatePanel;
  var sharedPanelContext = React280.useMemo(function() {
    var _ref2, _pickerClassNames$pop, _ref3, _pickerStyles$popup;
    return {
      classNames: (_ref2 = (_pickerClassNames$pop = pickerClassNames === null || pickerClassNames === void 0 ? void 0 : pickerClassNames.popup) !== null && _pickerClassNames$pop !== void 0 ? _pickerClassNames$pop : panelClassNames) !== null && _ref2 !== void 0 ? _ref2 : {},
      styles: (_ref3 = (_pickerStyles$popup = pickerStyles === null || pickerStyles === void 0 ? void 0 : pickerStyles.popup) !== null && _pickerStyles$popup !== void 0 ? _pickerStyles$popup : panelStyles) !== null && _ref3 !== void 0 ? _ref3 : {}
    };
  }, [pickerClassNames, panelClassNames, pickerStyles, panelStyles]);
  var parentHackContext = React280.useContext(PickerHackContext);
  var pickerPanelContext = React280.useMemo(function() {
    return _objectSpread11(_objectSpread11({}, parentHackContext), {}, {
      hideHeader
    });
  }, [parentHackContext, hideHeader]);
  if (true) {
    warning_default(!mergedValue || mergedValue.every(function(val) {
      return generateConfig2.isValidate(val);
    }), "Invalidate date pass to `value` or `defaultValue`.");
  }
  var panelCls = "".concat(mergedPrefixCls, "-panel");
  var panelProps = pickProps(props, [
    // Week
    "showWeek",
    // Icons
    "prevIcon",
    "nextIcon",
    "superPrevIcon",
    "superNextIcon",
    // Disabled
    "disabledDate",
    "minDate",
    "maxDate",
    // Hover
    "onHover"
  ]);
  return React280.createElement(SharedPanelContext.Provider, {
    value: sharedPanelContext
  }, React280.createElement(PickerHackContext.Provider, {
    value: pickerPanelContext
  }, React280.createElement("div", {
    ref: rootRef,
    tabIndex,
    className: clsx(panelCls, _defineProperty19({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
  }, React280.createElement(PanelComponent, _extends41({}, panelProps, {
    // Time
    showTime: mergedShowTime,
    prefixCls: mergedPrefixCls,
    locale: filledLocale,
    generateConfig: generateConfig2,
    onModeChange: triggerModeChange,
    pickerValue: mergedPickerValue,
    onPickerValueChange: function onPickerValueChange2(nextPickerValue) {
      setPickerValue(nextPickerValue, true);
    },
    value: mergedValue[0],
    onSelect: onPanelValueSelect,
    values: mergedValue,
    cellRender: onInternalCellRender,
    hoverRangeValue: hoverRangeDate,
    hoverValue
  })))));
}
var RefPanelPicker = React280.memo(React280.forwardRef(PickerPanel));
if (true) {
  RefPanelPicker.displayName = "PanelPicker";
}
var PickerPanel_default = RefPanelPicker;

// node_modules/@rc-component/picker/es/PickerInput/Popup/PopupPanel.js
function _typeof22(o3) {
  "@babel/helpers - typeof";
  return _typeof22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof22(o3);
}
function _extends42() {
  _extends42 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends42.apply(this, arguments);
}
function ownKeys12(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread12(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys12(Object(t2), true).forEach(function(r3) {
      _defineProperty20(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys12(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty20(obj, key, value) {
  key = _toPropertyKey19(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey19(t2) {
  var i = _toPrimitive19(t2, "string");
  return "symbol" == _typeof22(i) ? i : String(i);
}
function _toPrimitive19(t2, r2) {
  if ("object" != _typeof22(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof22(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function PopupPanel(props) {
  var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range3 = props.range, hoverValue = props.hoverValue;
  var _React$useContext = React281.useContext(context_default7), prefixCls = _React$useContext.prefixCls, generateConfig2 = _React$useContext.generateConfig;
  var internalOffsetDate = React281.useCallback(function(date4, offset3) {
    return offsetPanelDate(generateConfig2, picker, date4, offset3);
  }, [generateConfig2, picker]);
  var nextPickerValue = React281.useMemo(function() {
    return internalOffsetDate(pickerValue, 1);
  }, [pickerValue, internalOffsetDate]);
  var onSecondPickerValueChange = function onSecondPickerValueChange2(nextDate) {
    onPickerValueChange(internalOffsetDate(nextDate, -1));
  };
  var sharedContext = {
    onCellDblClick: function onCellDblClick() {
      if (needConfirm) {
        onSubmit();
      }
    }
  };
  var hideHeader = picker === "time";
  var pickerProps = _objectSpread12(_objectSpread12({}, props), {}, {
    hoverValue: null,
    hoverRangeValue: null,
    hideHeader
  });
  if (range3) {
    pickerProps.hoverRangeValue = hoverValue;
  } else {
    pickerProps.hoverValue = hoverValue;
  }
  if (multiplePanel) {
    return React281.createElement("div", {
      className: "".concat(prefixCls, "-panels")
    }, React281.createElement(PickerHackContext.Provider, {
      value: _objectSpread12(_objectSpread12({}, sharedContext), {}, {
        hideNext: true
      })
    }, React281.createElement(PickerPanel_default, pickerProps)), React281.createElement(PickerHackContext.Provider, {
      value: _objectSpread12(_objectSpread12({}, sharedContext), {}, {
        hidePrev: true
      })
    }, React281.createElement(PickerPanel_default, _extends42({}, pickerProps, {
      pickerValue: nextPickerValue,
      onPickerValueChange: onSecondPickerValueChange
    }))));
  }
  return React281.createElement(PickerHackContext.Provider, {
    value: _objectSpread12({}, sharedContext)
  }, React281.createElement(PickerPanel_default, pickerProps));
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/PresetPanel.js
var React282 = __toESM(require_react());
function executeValue(value) {
  return typeof value === "function" ? value() : value;
}
function PresetPanel(props) {
  var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
  if (!presets.length) {
    return null;
  }
  return React282.createElement("div", {
    className: "".concat(prefixCls, "-presets")
  }, React282.createElement("ul", null, presets.map(function(_ref, index2) {
    var label = _ref.label, value = _ref.value;
    return React282.createElement("li", {
      key: index2,
      onClick: function onClick() {
        _onClick(executeValue(value));
      },
      onMouseEnter: function onMouseEnter() {
        onHover(executeValue(value));
      },
      onMouseLeave: function onMouseLeave() {
        onHover(null);
      }
    }, label);
  })));
}

// node_modules/@rc-component/picker/es/PickerInput/Popup/index.js
function _typeof23(o3) {
  "@babel/helpers - typeof";
  return _typeof23 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof23(o3);
}
function ownKeys13(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread13(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys13(Object(t2), true).forEach(function(r3) {
      _defineProperty21(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys13(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty21(obj, key, value) {
  key = _toPropertyKey20(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey20(t2) {
  var i = _toPrimitive20(t2, "string");
  return "symbol" == _typeof23(i) ? i : String(i);
}
function _toPrimitive20(t2, r2) {
  if ("object" != _typeof23(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof23(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _extends43() {
  _extends43 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends43.apply(this, arguments);
}
function _slicedToArray27(arr, i) {
  return _arrayWithHoles27(arr) || _iterableToArrayLimit27(arr, i) || _unsupportedIterableToArray30(arr, i) || _nonIterableRest27();
}
function _nonIterableRest27() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray30(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray30(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray30(o3, minLen);
}
function _arrayLikeToArray30(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit27(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles27(arr) {
  if (Array.isArray(arr))
    return arr;
}
function Popup3(props) {
  var _classNames$popup, _styles$popup;
  var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range3 = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [0, 0, 0] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit, classNames = props.classNames, styles = props.styles;
  var _React$useContext = React283.useContext(context_default7), prefixCls = _React$useContext.prefixCls;
  var panelPrefixCls = "".concat(prefixCls, "-panel");
  var rtl = direction === "rtl";
  var arrowRef = React283.useRef(null);
  var wrapperRef = React283.useRef(null);
  var _React$useState = React283.useState(0), _React$useState2 = _slicedToArray27(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
  var _React$useState3 = React283.useState(0), _React$useState4 = _slicedToArray27(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
  var _React$useState5 = React283.useState(0), _React$useState6 = _slicedToArray27(_React$useState5, 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
  var onResize2 = function onResize3(info) {
    if (info.width) {
      setContainerWidth(info.width);
    }
  };
  var _activeInfo = _slicedToArray27(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
  var _React$useState7 = React283.useState(0), _React$useState8 = _slicedToArray27(_React$useState7, 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
  React283.useEffect(function() {
    setRetryTimes(10);
  }, [activeInputLeft]);
  React283.useEffect(function() {
    if (range3 && wrapperRef.current) {
      var _arrowRef$current;
      var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
      var wrapperRect = wrapperRef.current.getBoundingClientRect();
      if (!wrapperRect.height || wrapperRect.right < 0) {
        setRetryTimes(function(times) {
          return Math.max(0, times - 1);
        });
        return;
      }
      var nextArrowOffset = (rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left;
      setArrowOffset(nextArrowOffset);
      if (containerWidth && containerWidth < selectorWidth) {
        var offset3 = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
        var safeOffset = Math.max(0, offset3);
        setContainerOffset(safeOffset);
      } else {
        setContainerOffset(0);
      }
    }
  }, [retryTimes, rtl, containerWidth, activeInputLeft, activeInputRight, selectorWidth, range3]);
  function filterEmpty(list) {
    return list.filter(function(item) {
      return item;
    });
  }
  var valueList = React283.useMemo(function() {
    return filterEmpty(toArray5(value));
  }, [value]);
  var isTimePickerEmptyValue = picker === "time" && !valueList.length;
  var footerSubmitValue = React283.useMemo(function() {
    if (isTimePickerEmptyValue) {
      return filterEmpty([defaultOpenValue]);
    }
    return valueList;
  }, [isTimePickerEmptyValue, valueList, defaultOpenValue]);
  var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
  var disableSubmit = React283.useMemo(function() {
    if (!footerSubmitValue.length) {
      return true;
    }
    return footerSubmitValue.some(function(val) {
      return isInvalid(val);
    });
  }, [footerSubmitValue, isInvalid]);
  var onFooterSubmit = function onFooterSubmit2() {
    if (isTimePickerEmptyValue) {
      onSelect(defaultOpenValue);
    }
    onOk();
    onSubmit();
  };
  var mergedNodes = React283.createElement("div", {
    className: "".concat(prefixCls, "-panel-layout")
  }, React283.createElement(PresetPanel, {
    prefixCls,
    presets,
    onClick: onPresetSubmit,
    onHover: onPresetHover
  }), React283.createElement("div", null, React283.createElement(PopupPanel, _extends43({}, props, {
    value: popupPanelValue
  })), React283.createElement(Footer2, _extends43({}, props, {
    showNow: multiple ? false : showNow,
    invalid: disableSubmit,
    onSubmit: onFooterSubmit
  }))));
  if (panelRender) {
    mergedNodes = panelRender(mergedNodes);
  }
  var containerPrefixCls = "".concat(panelPrefixCls, "-container");
  var marginLeft = "marginLeft";
  var marginRight = "marginRight";
  var renderNode = React283.createElement("div", {
    onMouseDown: onPanelMouseDown,
    tabIndex: -1,
    className: clsx(
      containerPrefixCls,
      // Used for Today Button style, safe to remove if no need
      "".concat(prefixCls, "-").concat(internalMode, "-panel-container"),
      classNames === null || classNames === void 0 || (_classNames$popup = classNames.popup) === null || _classNames$popup === void 0 ? void 0 : _classNames$popup.container
    ),
    style: _objectSpread13(_defineProperty21(_defineProperty21({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"), styles === null || styles === void 0 || (_styles$popup = styles.popup) === null || _styles$popup === void 0 ? void 0 : _styles$popup.container),
    onFocus,
    onBlur
  }, mergedNodes);
  if (range3) {
    renderNode = React283.createElement("div", {
      onMouseDown: onPanelMouseDown,
      ref: wrapperRef,
      className: clsx("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
    }, React283.createElement("div", {
      ref: arrowRef,
      className: "".concat(prefixCls, "-range-arrow"),
      style: {
        left: arrowOffset
      }
    }), React283.createElement(es_default, {
      onResize: onResize2
    }, renderNode));
  }
  return renderNode;
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/RangeSelector.js
var React288 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useInputProps.js
var React284 = __toESM(require_react());
function _typeof24(o3) {
  "@babel/helpers - typeof";
  return _typeof24 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof24(o3);
}
function ownKeys14(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread14(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys14(Object(t2), true).forEach(function(r3) {
      _defineProperty22(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys14(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty22(obj, key, value) {
  key = _toPropertyKey21(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey21(t2) {
  var i = _toPrimitive21(t2, "string");
  return "symbol" == _typeof24(i) ? i : String(i);
}
function _toPrimitive21(t2, r2) {
  if ("object" != _typeof24(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof24(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useInputProps(props, postProps) {
  var format3 = props.format, maskFormat = props.maskFormat, generateConfig2 = props.generateConfig, locale6 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required5 = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open3 = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
  var parseDate = function parseDate2(str, formatStr) {
    var parsed = generateConfig2.locale.parse(locale6.locale, str, [formatStr]);
    return parsed && generateConfig2.isValidate(parsed) ? parsed : null;
  };
  var firstFormat = format3[0];
  var getText = React284.useCallback(function(date4) {
    return formatValue(date4, {
      locale: locale6,
      format: firstFormat,
      generateConfig: generateConfig2
    });
  }, [locale6, generateConfig2, firstFormat]);
  var valueTexts = React284.useMemo(function() {
    return value.map(getText);
  }, [value, getText]);
  var size = React284.useMemo(function() {
    var defaultSize = picker === "time" ? 8 : 10;
    var length2 = typeof firstFormat === "function" ? firstFormat(generateConfig2.getNow()).length : firstFormat.length;
    return Math.max(defaultSize, length2) + 2;
  }, [firstFormat, picker, generateConfig2]);
  var _validateFormat = function validateFormat(text) {
    for (var i = 0; i < format3.length; i += 1) {
      var singleFormat = format3[i];
      if (typeof singleFormat === "string") {
        var parsed = parseDate(text, singleFormat);
        if (parsed) {
          return parsed;
        }
      }
    }
    return false;
  };
  var getInputProps = function getInputProps2(index2) {
    function getProp(propValue) {
      return index2 !== void 0 ? propValue[index2] : propValue;
    }
    var pickedAttrs = pickAttrs(props, {
      aria: true,
      data: true
    });
    var inputProps = _objectSpread14(_objectSpread14({}, pickedAttrs), {}, {
      // ============== Shared ==============
      format: maskFormat,
      validateFormat: function validateFormat(text) {
        return !!_validateFormat(text);
      },
      preserveInvalidOnBlur,
      readOnly: inputReadOnly,
      required: required5,
      "aria-required": ariaRequired,
      name,
      autoComplete,
      size,
      // ============= By Index =============
      id: getProp(id),
      value: getProp(valueTexts) || "",
      invalid: getProp(invalid),
      placeholder: getProp(placeholder),
      active: activeIndex === index2,
      helped: allHelp || activeHelp && activeIndex === index2,
      disabled: getProp(disabled),
      onFocus: function onFocus(event) {
        _onFocus(event, index2);
      },
      onBlur: function onBlur(event) {
        _onBlur(event, index2);
      },
      onSubmit,
      // Get validate text value
      onChange: function onChange(text) {
        onInputChange();
        var parsed = _validateFormat(text);
        if (parsed) {
          onInvalid(false, index2);
          _onChange(parsed, index2);
          return;
        }
        onInvalid(!!text, index2);
      },
      onHelp: function onHelp() {
        onOpenChange(true, {
          index: index2
        });
      },
      onKeyDown: function onKeyDown2(event) {
        var prevented = false;
        _onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
          if (true) {
            warning_default(false, "`preventDefault` callback is deprecated. Please call `event.preventDefault` directly.");
          }
          prevented = true;
        });
        if (!event.defaultPrevented && !prevented) {
          switch (event.key) {
            case "Escape":
              onOpenChange(false, {
                index: index2
              });
              break;
            case "Enter":
              if (!open3) {
                onOpenChange(true);
              }
              break;
          }
        }
      }
    }, postProps === null || postProps === void 0 ? void 0 : postProps({
      valueTexts
    }));
    Object.keys(inputProps).forEach(function(key) {
      if (inputProps[key] === void 0) {
        delete inputProps[key];
      }
    });
    return inputProps;
  };
  return [getInputProps, getText];
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/hooks/useRootProps.js
var React285 = __toESM(require_react());
var propNames = ["onMouseEnter", "onMouseLeave"];
function useRootProps(props) {
  return React285.useMemo(function() {
    return pickProps(props, propNames);
  }, [props]);
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Icon.js
var React286 = __toESM(require_react());
var _excluded = ["icon", "type"];
var _excluded2 = ["onClear"];
function _extends44() {
  _extends44 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends44.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function Icon2(props) {
  var icon = props.icon, type5 = props.type, restProps = _objectWithoutProperties(props, _excluded);
  var _React$useContext = React286.useContext(context_default7), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  return icon ? React286.createElement("span", _extends44({
    className: clsx("".concat(prefixCls, "-").concat(type5), classNames.suffix),
    style: styles.suffix
  }, restProps), icon) : null;
}
function ClearIcon(_ref) {
  var onClear = _ref.onClear, restProps = _objectWithoutProperties(_ref, _excluded2);
  return React286.createElement(Icon2, _extends44({}, restProps, {
    type: "clear",
    role: "button",
    onMouseDown: function onMouseDown(e3) {
      e3.preventDefault();
    },
    onClick: function onClick(e3) {
      e3.stopPropagation();
      onClear();
    }
  }));
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Input.js
var React287 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/MaskFormat.js
function _typeof25(o3) {
  "@babel/helpers - typeof";
  return _typeof25 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof25(o3);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey22(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty23(obj, key, value) {
  key = _toPropertyKey22(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey22(t2) {
  var i = _toPrimitive22(t2, "string");
  return "symbol" == _typeof25(i) ? i : String(i);
}
function _toPrimitive22(t2, r2) {
  if ("object" != _typeof25(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof25(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var FORMAT_KEYS = ["YYYY", "MM", "DD", "HH", "mm", "ss", "SSS"];
var REPLACE_KEY = "";
var MaskFormat = function() {
  function MaskFormat2(format3) {
    _classCallCheck2(this, MaskFormat2);
    _defineProperty23(this, "format", void 0);
    _defineProperty23(this, "maskFormat", void 0);
    _defineProperty23(this, "cells", void 0);
    _defineProperty23(this, "maskCells", void 0);
    this.format = format3;
    var replaceKeys = FORMAT_KEYS.map(function(key) {
      return "(".concat(key, ")");
    }).join("|");
    var replaceReg = new RegExp(replaceKeys, "g");
    this.maskFormat = format3.replace(
      replaceReg,
      // Use Chinese character to avoid user use it in format
      function(key) {
        return REPLACE_KEY.repeat(key.length);
      }
    );
    var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
    var strCells = (format3.split(cellReg) || []).filter(function(str) {
      return str;
    });
    var offset3 = 0;
    this.cells = strCells.map(function(text) {
      var mask = FORMAT_KEYS.includes(text);
      var start = offset3;
      var end = offset3 + text.length;
      offset3 = end;
      return {
        text,
        mask,
        start,
        end
      };
    });
    this.maskCells = this.cells.filter(function(cell) {
      return cell.mask;
    });
  }
  _createClass2(MaskFormat2, [{
    key: "getSelection",
    value: function getSelection(maskCellIndex) {
      var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
      return [start || 0, end || 0];
    }
    /** Check given text match format */
  }, {
    key: "match",
    value: function match3(text) {
      for (var i = 0; i < this.maskFormat.length; i += 1) {
        var maskChar = this.maskFormat[i];
        var textChar = text[i];
        if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {
          return false;
        }
      }
      return true;
    }
    /** Get mask cell count */
  }, {
    key: "size",
    value: function size() {
      return this.maskCells.length;
    }
  }, {
    key: "getMaskCellIndex",
    value: function getMaskCellIndex(anchorIndex) {
      var closetDist = Number.MAX_SAFE_INTEGER;
      var closetIndex = 0;
      for (var i = 0; i < this.maskCells.length; i += 1) {
        var _this$maskCells$i = this.maskCells[i], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
        if (anchorIndex >= start && anchorIndex <= end) {
          return i;
        }
        var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
        if (dist < closetDist) {
          closetDist = dist;
          closetIndex = i;
        }
      }
      return closetIndex;
    }
  }]);
  return MaskFormat2;
}();

// node_modules/@rc-component/picker/es/PickerInput/Selector/util.js
function getMaskRange(key) {
  var PresetRange = {
    YYYY: [0, 9999, (/* @__PURE__ */ new Date()).getFullYear()],
    MM: [1, 12],
    DD: [1, 31],
    HH: [0, 23],
    mm: [0, 59],
    ss: [0, 59],
    SSS: [0, 999]
  };
  return PresetRange[key];
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/Input.js
function _typeof26(o3) {
  "@babel/helpers - typeof";
  return _typeof26 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof26(o3);
}
var _excluded3 = ["className", "active", "showActiveCls", "suffixIcon", "format", "validateFormat", "onChange", "onInput", "helped", "onHelp", "onSubmit", "onKeyDown", "preserveInvalidOnBlur", "invalid", "clearIcon"];
function _extends45() {
  _extends45 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends45.apply(this, arguments);
}
function _defineProperty24(obj, key, value) {
  key = _toPropertyKey23(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey23(t2) {
  var i = _toPrimitive23(t2, "string");
  return "symbol" == _typeof26(i) ? i : String(i);
}
function _toPrimitive23(t2, r2) {
  if ("object" != _typeof26(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof26(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray28(arr, i) {
  return _arrayWithHoles28(arr) || _iterableToArrayLimit28(arr, i) || _unsupportedIterableToArray31(arr, i) || _nonIterableRest28();
}
function _nonIterableRest28() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray31(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray31(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray31(o3, minLen);
}
function _arrayLikeToArray31(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit28(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles28(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Input2 = React287.forwardRef(function(props, ref) {
  var className = props.className, active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format3 = props.format, validateFormat = props.validateFormat, onChange = props.onChange, onInput = props.onInput, helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown2 = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties2(props, _excluded3);
  var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
  var _React$useContext = React287.useContext(context_default7), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component8 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var inputPrefixCls = "".concat(prefixCls, "-input");
  var _React$useState = React287.useState(false), _React$useState2 = _slicedToArray28(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
  var _React$useState3 = React287.useState(value), _React$useState4 = _slicedToArray28(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
  var _React$useState5 = React287.useState(""), _React$useState6 = _slicedToArray28(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
  var _React$useState7 = React287.useState(null), _React$useState8 = _slicedToArray28(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
  var _React$useState9 = React287.useState(null), _React$useState10 = _slicedToArray28(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
  var inputValue = internalInputValue || "";
  React287.useEffect(function() {
    setInputValue(value);
  }, [value]);
  var holderRef = React287.useRef(null);
  var inputRef = React287.useRef(null);
  React287.useImperativeHandle(ref, function() {
    return {
      nativeElement: holderRef.current,
      inputElement: inputRef.current,
      focus: function focus(options) {
        inputRef.current.focus(options);
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  });
  var maskFormat = React287.useMemo(function() {
    return new MaskFormat(format3 || "");
  }, [format3]);
  var _React$useMemo = React287.useMemo(function() {
    if (helped) {
      return [0, 0];
    }
    return maskFormat.getSelection(focusCellIndex);
  }, [maskFormat, focusCellIndex, helped]), _React$useMemo2 = _slicedToArray28(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
  var onModify = function onModify2(text) {
    if (text && text !== format3 && text !== value) {
      onHelp();
    }
  };
  var triggerInputChange = useEvent_default(function(text) {
    if (validateFormat(text)) {
      onChange(text);
    }
    setInputValue(text);
    onModify(text);
  });
  var onInternalChange = function onInternalChange2(event) {
    if (!format3) {
      var text = event.target.value;
      onModify(text);
      setInputValue(text);
      onChange(text);
    }
  };
  var onFormatPaste = function onFormatPaste2(event) {
    var pasteText = event.clipboardData.getData("text");
    if (validateFormat(pasteText)) {
      triggerInputChange(pasteText);
    }
  };
  var mouseDownRef = React287.useRef(false);
  var onFormatMouseDown = function onFormatMouseDown2() {
    mouseDownRef.current = true;
  };
  var onFormatMouseUp = function onFormatMouseUp2(event) {
    var _ref = event.target, start = _ref.selectionStart;
    var closeMaskIndex = maskFormat.getMaskCellIndex(start);
    setFocusCellIndex(closeMaskIndex);
    forceSelectionSync({});
    onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
    mouseDownRef.current = false;
  };
  var onFormatFocus = function onFormatFocus2(event) {
    setFocused(true);
    setFocusCellIndex(0);
    setFocusCellText("");
    onFocus(event);
  };
  var onSharedBlur = function onSharedBlur2(event) {
    onBlur(event);
  };
  var onFormatBlur = function onFormatBlur2(event) {
    setFocused(false);
    onSharedBlur(event);
  };
  useLockEffect(active, function() {
    if (!active && !preserveInvalidOnBlur) {
      setInputValue(value);
    }
  });
  var onSharedKeyDown = function onSharedKeyDown2(event) {
    if (event.key === "Enter" && validateFormat(inputValue)) {
      onSubmit();
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event);
  };
  var onFormatKeyDown = function onFormatKeyDown2(event) {
    onSharedKeyDown(event);
    var key = event.key;
    var nextCellText = null;
    var nextFillText = null;
    var maskCellLen = selectionEnd - selectionStart;
    var cellFormat = format3.slice(selectionStart, selectionEnd);
    var offsetCellIndex = function offsetCellIndex2(offset3) {
      setFocusCellIndex(function(idx) {
        var nextIndex = idx + offset3;
        nextIndex = Math.max(nextIndex, 0);
        nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
        return nextIndex;
      });
    };
    var offsetCellValue = function offsetCellValue2(offset3) {
      var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray28(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
      var currentText = inputValue.slice(selectionStart, selectionEnd);
      var currentTextNum = Number(currentText);
      if (isNaN(currentTextNum)) {
        return String(rangeDefault ? rangeDefault : offset3 > 0 ? rangeStart : rangeEnd);
      }
      var num = currentTextNum + offset3;
      var range3 = rangeEnd - rangeStart + 1;
      return String(rangeStart + (range3 + num - rangeStart) % range3);
    };
    switch (key) {
      case "Backspace":
      case "Delete":
        nextCellText = "";
        nextFillText = cellFormat;
        break;
      case "ArrowLeft":
        nextCellText = "";
        offsetCellIndex(-1);
        break;
      case "ArrowRight":
        nextCellText = "";
        offsetCellIndex(1);
        break;
      case "ArrowUp":
        nextCellText = "";
        nextFillText = offsetCellValue(1);
        break;
      case "ArrowDown":
        nextCellText = "";
        nextFillText = offsetCellValue(-1);
        break;
      default:
        if (!isNaN(Number(key))) {
          nextCellText = focusCellText + key;
          nextFillText = nextCellText;
        }
        break;
    }
    if (nextCellText !== null) {
      setFocusCellText(nextCellText);
      if (nextCellText.length >= maskCellLen) {
        offsetCellIndex(1);
        setFocusCellText("");
      }
    }
    if (nextFillText !== null) {
      var nextFocusValue = (
        // before
        inputValue.slice(0, selectionStart) + // replace
        leftPad(nextFillText, maskCellLen) + // after
        inputValue.slice(selectionEnd)
      );
      triggerInputChange(nextFocusValue.slice(0, format3.length));
    }
    forceSelectionSync({});
  };
  var rafRef = React287.useRef();
  useLayoutEffect_default(function() {
    if (!focused || !format3 || mouseDownRef.current) {
      return;
    }
    if (!maskFormat.match(inputValue)) {
      triggerInputChange(format3);
      return;
    }
    inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    rafRef.current = raf_default(function() {
      inputRef.current.setSelectionRange(selectionStart, selectionEnd);
    });
    return function() {
      raf_default.cancel(rafRef.current);
    };
  }, [maskFormat, format3, focused, inputValue, focusCellIndex, selectionStart, selectionEnd, forceSelectionSyncMark, triggerInputChange]);
  var inputProps = format3 ? {
    onFocus: onFormatFocus,
    onBlur: onFormatBlur,
    onKeyDown: onFormatKeyDown,
    onMouseDown: onFormatMouseDown,
    onMouseUp: onFormatMouseUp,
    onPaste: onFormatPaste
  } : {};
  return React287.createElement("div", {
    ref: holderRef,
    className: clsx(inputPrefixCls, _defineProperty24(_defineProperty24({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped), className)
  }, React287.createElement(Component8, _extends45({
    ref: inputRef,
    "aria-invalid": invalid,
    autoComplete: "off"
  }, restProps, {
    onKeyDown: onSharedKeyDown,
    onBlur: onSharedBlur
    // Replace with format
  }, inputProps, {
    // Value
    value: inputValue,
    onChange: onInternalChange,
    className: classNames.input,
    style: styles.input
  })), React287.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), clearIcon);
});
if (true) {
  Input2.displayName = "Input";
}
var Input_default3 = Input2;

// node_modules/@rc-component/picker/es/PickerInput/Selector/RangeSelector.js
var _excluded4 = ["id", "prefix", "clearIcon", "suffixIcon", "separator", "activeIndex", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "value", "onChange", "onSubmit", "onInputChange", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onActiveInfo", "placement", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex"];
var _excluded22 = ["index"];
function _extends46() {
  _extends46 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends46.apply(this, arguments);
}
function ownKeys15(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread15(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys15(Object(t2), true).forEach(function(r3) {
      _defineProperty25(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys15(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty25(obj, key, value) {
  key = _toPropertyKey24(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey24(t2) {
  var i = _toPrimitive24(t2, "string");
  return "symbol" == _typeof27(i) ? i : String(i);
}
function _toPrimitive24(t2, r2) {
  if ("object" != _typeof27(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof27(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray29(arr, i) {
  return _arrayWithHoles29(arr) || _iterableToArrayLimit29(arr, i) || _unsupportedIterableToArray32(arr, i) || _nonIterableRest29();
}
function _nonIterableRest29() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray32(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray32(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray32(o3, minLen);
}
function _arrayLikeToArray32(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit29(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles29(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof27(o3) {
  "@babel/helpers - typeof";
  return _typeof27 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof27(o3);
}
function _objectWithoutProperties3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function RangeSelector(props, ref) {
  var id = props.id, prefix2 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex, activeHelp = props.activeHelp, allHelp = props.allHelp, focused = props.focused, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown2 = props.onKeyDown, locale6 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit, onInputChange = props.onInputChange, format3 = props.format, maskFormat = props.maskFormat, preserveInvalidOnBlur = props.preserveInvalidOnBlur, onInvalid = props.onInvalid, disabled = props.disabled, invalid = props.invalid, inputReadOnly = props.inputReadOnly, direction = props.direction, onOpenChange = props.onOpenChange, onActiveInfo = props.onActiveInfo, placement = props.placement, _onMouseDown = props.onMouseDown, required5 = props.required, ariaRequired = props["aria-required"], autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties3(props, _excluded4);
  var rtl = direction === "rtl";
  var _React$useContext = React288.useContext(context_default7), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var ids = React288.useMemo(function() {
    if (typeof id === "string") {
      return [id];
    }
    var mergedId = id || {};
    return [mergedId.start, mergedId.end];
  }, [id]);
  var rootRef = React288.useRef();
  var inputStartRef = React288.useRef();
  var inputEndRef = React288.useRef();
  var getInput = function getInput2(index2) {
    var _index;
    return (_index = [inputStartRef, inputEndRef][index2]) === null || _index === void 0 ? void 0 : _index.current;
  };
  React288.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: function focus(options) {
        if (_typeof27(options) === "object") {
          var _getInput;
          var _ref = options || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties3(_ref, _excluded22);
          (_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
        } else {
          var _getInput2;
          (_getInput2 = getInput(options !== null && options !== void 0 ? options : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
        }
      },
      blur: function blur() {
        var _getInput3, _getInput4;
        (_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
        (_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
      }
    };
  });
  var rootProps = useRootProps(restProps);
  var mergedPlaceholder = React288.useMemo(function() {
    return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
  }, [placeholder]);
  var _useInputProps = useInputProps(_objectSpread15(_objectSpread15({}, props), {}, {
    id: ids,
    placeholder: mergedPlaceholder
  })), _useInputProps2 = _slicedToArray29(_useInputProps, 1), getInputProps = _useInputProps2[0];
  var _React$useState = React288.useState({
    position: "absolute",
    width: 0
  }), _React$useState2 = _slicedToArray29(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
  var syncActiveOffset = useEvent_default(function() {
    var input = getInput(activeIndex);
    if (input) {
      var inputRect = input.nativeElement.getBoundingClientRect();
      var parentRect = rootRef.current.getBoundingClientRect();
      var rectOffset = inputRect.left - parentRect.left;
      setActiveBarStyle(function(ori) {
        return _objectSpread15(_objectSpread15({}, ori), {}, {
          width: inputRect.width,
          left: rectOffset
        });
      });
      onActiveInfo([inputRect.left, inputRect.right, parentRect.width]);
    }
  });
  React288.useEffect(function() {
    syncActiveOffset();
  }, [activeIndex]);
  var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
  var startAutoFocus = autoFocus && !disabled[0];
  var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
  return React288.createElement(es_default, {
    onResize: syncActiveOffset
  }, React288.createElement("div", _extends46({}, rootProps, {
    className: clsx(prefixCls, "".concat(prefixCls, "-range"), _defineProperty25(_defineProperty25(_defineProperty25(_defineProperty25({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i) {
      return i;
    })), "".concat(prefixCls, "-invalid"), invalid.some(function(i) {
      return i;
    })), "".concat(prefixCls, "-rtl"), rtl), className),
    style: style2,
    ref: rootRef,
    onClick,
    onMouseDown: function onMouseDown(e3) {
      var target = e3.target;
      if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) {
        e3.preventDefault();
      }
      _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e3);
    }
  }), prefix2 && React288.createElement("div", {
    className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
    style: styles.prefix
  }, prefix2), React288.createElement(Input_default3, _extends46({
    ref: inputStartRef
  }, getInputProps(0), {
    className: "".concat(prefixCls, "-input-start"),
    autoFocus: startAutoFocus,
    tabIndex,
    "date-range": "start"
  })), React288.createElement("div", {
    className: "".concat(prefixCls, "-range-separator")
  }, separator), React288.createElement(Input_default3, _extends46({
    ref: inputEndRef
  }, getInputProps(1), {
    className: "".concat(prefixCls, "-input-end"),
    autoFocus: endAutoFocus,
    tabIndex,
    "date-range": "end"
  })), React288.createElement("div", {
    className: "".concat(prefixCls, "-active-bar"),
    style: activeBarStyle
  }), React288.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && React288.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })));
}
var RefRangeSelector = React288.forwardRef(RangeSelector);
if (true) {
  RefRangeSelector.displayName = "RangeSelector";
}
var RangeSelector_default = RefRangeSelector;

// node_modules/@rc-component/picker/es/hooks/useSemantic.js
var import_react106 = __toESM(require_react());
function _typeof28(o3) {
  "@babel/helpers - typeof";
  return _typeof28 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof28(o3);
}
function ownKeys16(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread16(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys16(Object(t2), true).forEach(function(r3) {
      _defineProperty26(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys16(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty26(obj, key, value) {
  key = _toPropertyKey25(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey25(t2) {
  var i = _toPrimitive25(t2, "string");
  return "symbol" == _typeof28(i) ? i : String(i);
}
function _toPrimitive25(t2, r2) {
  if ("object" != _typeof28(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof28(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function useSemantic(classNames, styles) {
  return (0, import_react106.useMemo)(function() {
    var mergedClassNames = _objectSpread16(_objectSpread16({}, classNames), {}, {
      popup: (classNames === null || classNames === void 0 ? void 0 : classNames.popup) || {}
    });
    var mergedStyles = _objectSpread16(_objectSpread16({}, styles), {}, {
      popup: (styles === null || styles === void 0 ? void 0 : styles.popup) || {}
    });
    return [mergedClassNames, mergedStyles];
  }, [classNames, styles]);
}

// node_modules/@rc-component/picker/es/PickerInput/RangePicker.js
function _typeof29(o3) {
  "@babel/helpers - typeof";
  return _typeof29 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof29(o3);
}
function _extends47() {
  _extends47 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends47.apply(this, arguments);
}
function _toConsumableArray8(arr) {
  return _arrayWithoutHoles8(arr) || _iterableToArray8(arr) || _unsupportedIterableToArray33(arr) || _nonIterableSpread8();
}
function _nonIterableSpread8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles8(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray33(arr);
}
function ownKeys17(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread17(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys17(Object(t2), true).forEach(function(r3) {
      _defineProperty27(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys17(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty27(obj, key, value) {
  key = _toPropertyKey26(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey26(t2) {
  var i = _toPrimitive26(t2, "string");
  return "symbol" == _typeof29(i) ? i : String(i);
}
function _toPrimitive26(t2, r2) {
  if ("object" != _typeof29(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof29(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray30(arr, i) {
  return _arrayWithHoles30(arr) || _iterableToArrayLimit30(arr, i) || _unsupportedIterableToArray33(arr, i) || _nonIterableRest30();
}
function _nonIterableRest30() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray33(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray33(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray33(o3, minLen);
}
function _arrayLikeToArray33(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit30(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles30(arr) {
  if (Array.isArray(arr))
    return arr;
}
function separateConfig(config, defaultConfig2) {
  var singleConfig = config !== null && config !== void 0 ? config : defaultConfig2;
  if (Array.isArray(singleConfig)) {
    return singleConfig;
  }
  return [singleConfig, singleConfig];
}
function getActiveRange(activeIndex) {
  return activeIndex === 1 ? "end" : "start";
}
function RangePicker(props, ref) {
  var _useFilledProps = useFilledProps(props, function() {
    var disabled2 = props.disabled, allowEmpty2 = props.allowEmpty;
    var mergedDisabled = separateConfig(disabled2, false);
    var mergedAllowEmpty = separateConfig(allowEmpty2, false);
    return {
      disabled: mergedDisabled,
      allowEmpty: mergedAllowEmpty
    };
  }), _useFilledProps2 = _slicedToArray30(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
  var prefixCls = filledProps.prefixCls, rootClassName = filledProps.rootClassName, propStyles = filledProps.styles, propClassNames = filledProps.classNames, previewValue = filledProps.previewValue, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown2 = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open3 = filledProps.open, onOpenChange = filledProps.onOpenChange, locale6 = filledProps.locale, generateConfig2 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components2 = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
  var selectorRef = usePickerRef(ref);
  var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray30(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
  var _useOpen = useOpen2(open3, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray30(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
  var triggerOpen = function triggerOpen2(nextOpen, config) {
    if (disabled.some(function(fieldDisabled) {
      return !fieldDisabled;
    }) || !nextOpen) {
      setMergeOpen(nextOpen, config);
    }
  };
  var _useInnerValue = useInnerValue(generateConfig2, locale6, formatList, true, false, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray30(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
  var calendarValue = getCalendarValue();
  var _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray30(_useRangeActive, 9), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
  var onSharedFocus = function onSharedFocus2(event, index2) {
    triggerFocus2(true);
    onFocus === null || onFocus === void 0 || onFocus(event, {
      range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
    });
  };
  var onSharedBlur = function onSharedBlur2(event, index2) {
    triggerFocus2(false);
    onBlur === null || onBlur === void 0 || onBlur(event, {
      range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
    });
  };
  var mergedShowTime = React289.useMemo(function() {
    if (!showTime) {
      return null;
    }
    var disabledTime = showTime.disabledTime;
    var proxyDisabledTime = disabledTime ? function(date4) {
      var range3 = getActiveRange(activeIndex);
      var fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
      return disabledTime(date4, range3, {
        from: fromDate
      });
    } : void 0;
    return _objectSpread17(_objectSpread17({}, showTime), {}, {
      disabledTime: proxyDisabledTime
    });
  }, [showTime, activeIndex, calendarValue, activeIndexList]);
  var _useControlledState = useControlledState([picker, picker], mode), _useControlledState2 = _slicedToArray30(_useControlledState, 2), modes = _useControlledState2[0], setModes = _useControlledState2[1];
  var mergedMode = modes[activeIndex] || picker;
  var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
  var multiplePanel = internalMode === picker && internalMode !== "time";
  var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
  var _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray30(_useRangeValue, 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
  var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig2, locale6, disabledDate);
  var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray30(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
  var _useRangePickerValue = useRangePickerValue(generateConfig2, locale6, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray30(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
  var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
    var clone = fillIndex(modes, activeIndex, nextMode);
    if (clone[0] !== modes[0] || clone[1] !== modes[1]) {
      setModes(clone);
    }
    if (onPanelChange && triggerEvent !== false) {
      var clonePickerValue = _toConsumableArray8(calendarValue);
      if (nextPickerValue) {
        clonePickerValue[activeIndex] = nextPickerValue;
      }
      onPanelChange(clonePickerValue, clone);
    }
  });
  var fillCalendarValue = function fillCalendarValue2(date4, index2) {
    return (
      // Trigger change only when date changed
      fillIndex(calendarValue, index2, date4)
    );
  };
  var triggerPartConfirm = function triggerPartConfirm2(date4, skipFocus) {
    var nextValue = calendarValue;
    if (date4) {
      nextValue = fillCalendarValue(date4, activeIndex);
    }
    updateSubmitIndex(activeIndex);
    var nextIndex = nextActiveIndex(nextValue);
    triggerCalendarChange(nextValue);
    flushSubmit(activeIndex, nextIndex === null);
    if (nextIndex === null) {
      triggerOpen(false, {
        force: true
      });
    } else if (!skipFocus) {
      selectorRef.current.focus({
        index: nextIndex
      });
    }
  };
  var onSelectorClick = function onSelectorClick2(event) {
    var _activeElement;
    var rootNode = event.target.getRootNode();
    if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
      var enabledIndex = disabled.findIndex(function(d) {
        return !d;
      });
      if (enabledIndex >= 0) {
        selectorRef.current.focus({
          index: enabledIndex
        });
      }
    }
    triggerOpen(true);
    onClick === null || onClick === void 0 || onClick(event);
  };
  var onSelectorClear = function onSelectorClear2() {
    triggerSubmitChange(null);
    triggerOpen(false, {
      force: true
    });
  };
  var _React$useState = React289.useState(null), _React$useState2 = _slicedToArray30(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
  var _React$useState3 = React289.useState(null), _React$useState4 = _slicedToArray30(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
  var hoverValues = React289.useMemo(function() {
    return internalHoverValues || calendarValue;
  }, [calendarValue, internalHoverValues]);
  React289.useEffect(function() {
    if (!mergedOpen) {
      setInternalHoverValues(null);
    }
  }, [mergedOpen]);
  var _React$useState5 = React289.useState([0, 0, 0]), _React$useState6 = _slicedToArray30(_React$useState5, 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
  var onSetHover = function onSetHover2(date4, source) {
    if (previewValue !== "hover") {
      return;
    }
    setInternalHoverValues(date4);
    setHoverSource(source);
  };
  var presetList = usePresets(presets, ranges);
  var onPresetHover = function onPresetHover2(nextValues) {
    onSetHover(nextValues, "preset");
  };
  var onPresetSubmit = function onPresetSubmit2(nextValues) {
    var passed = triggerSubmitChange(nextValues);
    if (passed) {
      triggerOpen(false, {
        force: true
      });
    }
  };
  var onNow = function onNow2(now2) {
    triggerPartConfirm(now2);
  };
  var onPanelHover = function onPanelHover2(date4) {
    onSetHover(date4 ? fillCalendarValue(date4, activeIndex) : null, "cell");
  };
  var onPanelFocus = function onPanelFocus2(event) {
    triggerOpen(true);
    onSharedFocus(event);
  };
  var onPanelMouseDown = function onPanelMouseDown2() {
    lastOperation("panel");
  };
  var onPanelSelect = function onPanelSelect2(date4) {
    var clone = fillIndex(calendarValue, activeIndex, date4);
    triggerCalendarChange(clone);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerPartConfirm(date4);
    }
  };
  var onPopupClose = function onPopupClose2() {
    triggerOpen(false);
  };
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
  var panelValue = calendarValue[activeIndex] || null;
  var isPopupInvalidateDate = useEvent_default(function(date4) {
    return isInvalidateDate(date4, {
      activeIndex
    });
  });
  var panelProps = React289.useMemo(function() {
    var domProps = pickAttrs(filledProps, false);
    var restProps = omit(filledProps, [].concat(_toConsumableArray8(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "disabledTime", "classNames", "styles"]));
    return restProps;
  }, [filledProps]);
  var panel = React289.createElement(Popup3, _extends47({}, panelProps, {
    showNow: mergedShowNow,
    showTime: mergedShowTime,
    range: true,
    multiplePanel,
    activeInfo,
    disabledDate: mergedDisabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    onPanelMouseDown,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: panelValue,
    isInvalid: isPopupInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: toArray5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerPartConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  var onSelectorChange = function onSelectorChange2(date4, index2) {
    var clone = fillCalendarValue(date4, index2);
    triggerCalendarChange(clone);
  };
  var onSelectorInputChange = function onSelectorInputChange2() {
    lastOperation("input");
  };
  var onSelectorFocus = function onSelectorFocus2(event, index2) {
    var activeListLen = activeIndexList.length;
    var lastActiveIndex = activeIndexList[activeListLen - 1];
    if (activeListLen && lastActiveIndex !== index2 && needConfirm && // Not change index if is not filled
    !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
      selectorRef.current.focus({
        index: lastActiveIndex
      });
      return;
    }
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    if (activeIndex !== index2 && mergedOpen && !needConfirm && complexPicker) {
      triggerPartConfirm(null, true);
    }
    setActiveIndex(index2);
    onSharedFocus(event, index2);
  };
  var onSelectorBlur = function onSelectorBlur2(event, index2) {
    triggerOpen(false);
    if (!needConfirm && lastOperation() === "input") {
      var nextIndex = nextActiveIndex(calendarValue);
      flushSubmit(activeIndex, nextIndex === null);
    }
    onSharedBlur(event, index2);
  };
  var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
    if (event.key === "Tab") {
      triggerPartConfirm(null, true);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event, preventDefault);
  };
  var context = React289.useMemo(function() {
    return {
      prefixCls,
      locale: locale6,
      generateConfig: generateConfig2,
      button: components2.button,
      input: components2.input,
      classNames: mergedClassNames,
      styles: mergedStyles
    };
  }, [prefixCls, locale6, generateConfig2, components2.button, components2.input, mergedClassNames, mergedStyles]);
  useLayoutEffect_default(function() {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(function() {
    var lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerPartConfirm(null, true);
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerOpen(true);
      triggerPartConfirm();
    }
  }, [mergedOpen]);
  if (true) {
    var isIndexEmpty = function isIndexEmpty2(index2) {
      return (
        // Value is empty
        !(value !== null && value !== void 0 && value[index2]) && // DefaultValue is empty
        !(defaultValue !== null && defaultValue !== void 0 && defaultValue[index2])
      );
    };
    if (disabled.some(function(fieldDisabled, index2) {
      return fieldDisabled && isIndexEmpty(index2) && !allowEmpty[index2];
    })) {
      warning_default(false, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
    }
  }
  return React289.createElement(context_default7.Provider, {
    value: context
  }, React289.createElement(PickerTrigger_default, _extends47({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: mergedStyles.popup.root,
    popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
    visible: mergedOpen,
    onClose: onPopupClose,
    range: true
  }), React289.createElement(
    RangeSelector_default,
    _extends47({}, filledProps, {
      // Ref
      ref: selectorRef,
      className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
      style: _objectSpread17(_objectSpread17({}, mergedStyles.root), filledProps.style),
      suffixIcon,
      activeIndex: focused || mergedOpen ? activeIndex : null,
      activeHelp: !!internalHoverValues,
      allHelp: !!internalHoverValues && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerPartConfirm,
      value: hoverValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidates,
      onInvalid: onSelectorInvalid,
      onActiveInfo: setActiveInfo
    })
  )));
}
var RefRangePicker = React289.forwardRef(RangePicker);
if (true) {
  RefRangePicker.displayName = "RefRangePicker";
}
var RangePicker_default = RefRangePicker;

// node_modules/@rc-component/picker/es/PickerInput/SinglePicker.js
var React292 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/index.js
var React291 = __toESM(require_react());

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/MultipleDates.js
var React290 = __toESM(require_react());
function MultipleDates(props) {
  var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
  var selectorCls = "".concat(prefixCls, "-selector");
  var selectionCls = "".concat(prefixCls, "-selection");
  var overflowCls = "".concat(selectionCls, "-overflow");
  function renderSelector(content, onClose) {
    return React290.createElement("span", {
      className: clsx("".concat(selectionCls, "-item")),
      title: typeof content === "string" ? content : null
    }, React290.createElement("span", {
      className: "".concat(selectionCls, "-item-content")
    }, content), !disabled && onClose && React290.createElement("span", {
      onMouseDown: function onMouseDown(e3) {
        e3.preventDefault();
      },
      onClick: onClose,
      className: "".concat(selectionCls, "-item-remove")
    }, removeIcon));
  }
  function renderItem2(date4) {
    var displayLabel = formatDate(date4);
    var onClose = function onClose2(event) {
      if (event)
        event.stopPropagation();
      onRemove(date4);
    };
    return renderSelector(displayLabel, onClose);
  }
  function renderRest(omittedValues) {
    var content = "+ ".concat(omittedValues.length, " ...");
    return renderSelector(content);
  }
  return React290.createElement("div", {
    className: selectorCls
  }, React290.createElement(es_default10, {
    prefixCls: overflowCls,
    data: value,
    renderItem: renderItem2,
    renderRest,
    itemKey: function itemKey3(date4) {
      return formatDate(date4);
    },
    maxCount: maxTagCount
  }), !value.length && React290.createElement("span", {
    className: "".concat(prefixCls, "-selection-placeholder")
  }, placeholder));
}

// node_modules/@rc-component/picker/es/PickerInput/Selector/SingleSelector/index.js
function _typeof30(o3) {
  "@babel/helpers - typeof";
  return _typeof30 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof30(o3);
}
var _excluded5 = ["id", "open", "prefix", "clearIcon", "suffixIcon", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "internalPicker", "value", "onChange", "onSubmit", "onInputChange", "multiple", "maxTagCount", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex", "removeIcon"];
function _extends48() {
  _extends48 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends48.apply(this, arguments);
}
function ownKeys18(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread18(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys18(Object(t2), true).forEach(function(r3) {
      _defineProperty28(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys18(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty28(obj, key, value) {
  key = _toPropertyKey27(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey27(t2) {
  var i = _toPrimitive27(t2, "string");
  return "symbol" == _typeof30(i) ? i : String(i);
}
function _toPrimitive27(t2, r2) {
  if ("object" != _typeof30(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof30(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray31(arr, i) {
  return _arrayWithHoles31(arr) || _iterableToArrayLimit31(arr, i) || _unsupportedIterableToArray34(arr, i) || _nonIterableRest31();
}
function _nonIterableRest31() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray34(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray34(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray34(o3, minLen);
}
function _arrayLikeToArray34(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit31(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles31(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function SingleSelector(props, ref) {
  var id = props.id, open3 = props.open, prefix2 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, activeHelp = props.activeHelp, allHelp = props.allHelp, focused = props.focused, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown2 = props.onKeyDown, locale6 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit, onInputChange = props.onInputChange, multiple = props.multiple, maxTagCount = props.maxTagCount, format3 = props.format, maskFormat = props.maskFormat, preserveInvalidOnBlur = props.preserveInvalidOnBlur, onInvalid = props.onInvalid, disabled = props.disabled, invalid = props.invalid, inputReadOnly = props.inputReadOnly, direction = props.direction, onOpenChange = props.onOpenChange, _onMouseDown = props.onMouseDown, required5 = props.required, ariaRequired = props["aria-required"], autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties4(props, _excluded5);
  var rtl = direction === "rtl";
  var _React$useContext = React291.useContext(context_default7), prefixCls = _React$useContext.prefixCls, classNames = _React$useContext.classNames, styles = _React$useContext.styles;
  var rootRef = React291.useRef();
  var inputRef = React291.useRef();
  React291.useImperativeHandle(ref, function() {
    return {
      nativeElement: rootRef.current,
      focus: function focus(options) {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options);
      },
      blur: function blur() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
      }
    };
  });
  var rootProps = useRootProps(restProps);
  var onSingleChange = function onSingleChange2(date4) {
    onChange([date4]);
  };
  var onMultipleRemove = function onMultipleRemove2(date4) {
    var nextValues = value.filter(function(oriDate) {
      return oriDate && !isSame(generateConfig2, locale6, oriDate, date4, internalPicker);
    });
    onChange(nextValues);
    if (!open3) {
      onSubmit();
    }
  };
  var _useInputProps = useInputProps(_objectSpread18(_objectSpread18({}, props), {}, {
    onChange: onSingleChange
  }), function(_ref) {
    var valueTexts = _ref.valueTexts;
    return {
      value: valueTexts[0] || "",
      active: focused
    };
  }), _useInputProps2 = _slicedToArray31(_useInputProps, 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
  var showClear = !!(clearIcon && value.length && !disabled);
  var selectorNode = multiple ? React291.createElement(React291.Fragment, null, React291.createElement(MultipleDates, {
    prefixCls,
    value,
    onRemove: onMultipleRemove,
    formatDate: getText,
    maxTagCount,
    disabled,
    removeIcon,
    placeholder
  }), React291.createElement("input", {
    className: "".concat(prefixCls, "-multiple-input"),
    value: value.map(getText).join(","),
    ref: inputRef,
    readOnly: true,
    autoFocus,
    tabIndex
  }), React291.createElement(Icon2, {
    type: "suffix",
    icon: suffixIcon
  }), showClear && React291.createElement(ClearIcon, {
    icon: clearIcon,
    onClear
  })) : React291.createElement(Input_default3, _extends48({
    ref: inputRef
  }, getInputProps(), {
    autoFocus,
    tabIndex,
    suffixIcon,
    clearIcon: showClear && React291.createElement(ClearIcon, {
      icon: clearIcon,
      onClear
    }),
    showActiveCls: false
  }));
  return React291.createElement("div", _extends48({}, rootProps, {
    className: clsx(prefixCls, _defineProperty28(_defineProperty28(_defineProperty28(_defineProperty28(_defineProperty28({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
    style: style2,
    ref: rootRef,
    onClick,
    onMouseDown: function onMouseDown(e3) {
      var _inputRef$current3;
      var target = e3.target;
      if (target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) {
        e3.preventDefault();
      }
      _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e3);
    }
  }), prefix2 && React291.createElement("div", {
    className: clsx("".concat(prefixCls, "-prefix"), classNames.prefix),
    style: styles.prefix
  }, prefix2), selectorNode);
}
var RefSingleSelector = React291.forwardRef(SingleSelector);
if (true) {
  RefSingleSelector.displayName = "SingleSelector";
}
var SingleSelector_default = RefSingleSelector;

// node_modules/@rc-component/picker/es/PickerInput/SinglePicker.js
function _typeof31(o3) {
  "@babel/helpers - typeof";
  return _typeof31 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o4) {
    return typeof o4;
  } : function(o4) {
    return o4 && "function" == typeof Symbol && o4.constructor === Symbol && o4 !== Symbol.prototype ? "symbol" : typeof o4;
  }, _typeof31(o3);
}
function _extends49() {
  _extends49 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends49.apply(this, arguments);
}
function _toConsumableArray9(arr) {
  return _arrayWithoutHoles9(arr) || _iterableToArray9(arr) || _unsupportedIterableToArray35(arr) || _nonIterableSpread9();
}
function _nonIterableSpread9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles9(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray35(arr);
}
function ownKeys19(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e3);
    r2 && (o3 = o3.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o3);
  }
  return t2;
}
function _objectSpread19(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys19(Object(t2), true).forEach(function(r3) {
      _defineProperty29(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys19(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
function _defineProperty29(obj, key, value) {
  key = _toPropertyKey28(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey28(t2) {
  var i = _toPrimitive28(t2, "string");
  return "symbol" == _typeof31(i) ? i : String(i);
}
function _toPrimitive28(t2, r2) {
  if ("object" != _typeof31(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof31(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray32(arr, i) {
  return _arrayWithHoles32(arr) || _iterableToArrayLimit32(arr, i) || _unsupportedIterableToArray35(arr, i) || _nonIterableRest32();
}
function _nonIterableRest32() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray35(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray35(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray35(o3, minLen);
}
function _arrayLikeToArray35(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit32(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f = false;
      } else
        for (; !(f = (e3 = i.call(t2)).done) && (a.push(e3.value), a.length !== l2); f = true)
          ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t2.return && (u = t2.return(), Object(u) !== u))
          return;
      } finally {
        if (o3)
          throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles32(arr) {
  if (Array.isArray(arr))
    return arr;
}
function Picker2(props, ref) {
  var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray32(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
  var _ref = filledProps, prefixCls = _ref.prefixCls, rootClassName = _ref.rootClassName, propStyles = _ref.styles, propClassNames = _ref.classNames, previewValue = _ref.previewValue, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown2 = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open3 = _ref.open, onOpenChange = _ref.onOpenChange, locale6 = _ref.locale, generateConfig2 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components2 = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
  var selectorRef = usePickerRef(ref);
  function pickerParam(values) {
    if (values === null) {
      return null;
    }
    return multiple ? values : values[0];
  }
  var toggleDates = useToggleDates(generateConfig2, locale6, internalPicker);
  var _useSemantic = useSemantic(propClassNames, propStyles), _useSemantic2 = _slicedToArray32(_useSemantic, 2), mergedClassNames = _useSemantic2[0], mergedStyles = _useSemantic2[1];
  var _useOpen = useOpen2(open3, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray32(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
  var onInternalCalendarChange = function onInternalCalendarChange2(dates, dateStrings, info) {
    if (onCalendarChange) {
      var filteredInfo = _objectSpread19({}, info);
      delete filteredInfo.range;
      onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
    }
  };
  var onInternalOk = function onInternalOk2(dates) {
    onOk === null || onOk === void 0 || onOk(pickerParam(dates));
  };
  var _useInnerValue = useInnerValue(generateConfig2, locale6, formatList, false, order, defaultValue, value, onInternalCalendarChange, onInternalOk), _useInnerValue2 = _slicedToArray32(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
  var calendarValue = getCalendarValue();
  var _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray32(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
  var onSharedFocus = function onSharedFocus2(event) {
    triggerFocus2(true);
    onFocus === null || onFocus === void 0 || onFocus(event, {});
  };
  var onSharedBlur = function onSharedBlur2(event) {
    triggerFocus2(false);
    onBlur === null || onBlur === void 0 || onBlur(event, {});
  };
  var _useControlledState = useControlledState(picker, mode), _useControlledState2 = _slicedToArray32(_useControlledState, 2), mergedMode = _useControlledState2[0], setMode = _useControlledState2[1];
  var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
  var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
  var onInternalChange = onChange && function(dates, dateStrings) {
    onChange(pickerParam(dates), pickerParam(dateStrings));
  };
  var _useRangeValue = useRangeValue(
    _objectSpread19(_objectSpread19({}, filledProps), {}, {
      onChange: onInternalChange
    }),
    mergedValue,
    setInnerValue,
    getCalendarValue,
    triggerCalendarChange,
    [],
    //disabled,
    formatList,
    focused,
    mergedOpen,
    isInvalidateDate
  ), _useRangeValue2 = _slicedToArray32(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1];
  var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray32(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
  var submitInvalidate = React292.useMemo(function() {
    return submitInvalidates.some(function(invalidated) {
      return invalidated;
    });
  }, [submitInvalidates]);
  var onInternalPickerValueChange = function onInternalPickerValueChange2(dates, info) {
    if (onPickerValueChange) {
      var cleanInfo = _objectSpread19(_objectSpread19({}, info), {}, {
        mode: info.mode[0]
      });
      delete cleanInfo.range;
      onPickerValueChange(dates[0], cleanInfo);
    }
  };
  var _useRangePickerValue = useRangePickerValue(
    generateConfig2,
    locale6,
    calendarValue,
    [mergedMode],
    mergedOpen,
    activeIndex,
    internalPicker,
    false,
    // multiplePanel,
    defaultPickerValue,
    pickerValue,
    toArray5(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue),
    onInternalPickerValueChange,
    minDate,
    maxDate
  ), _useRangePickerValue2 = _slicedToArray32(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
  var triggerModeChange = useEvent_default(function(nextPickerValue, nextMode, triggerEvent) {
    setMode(nextMode);
    if (onPanelChange && triggerEvent !== false) {
      var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
      onPanelChange(lastPickerValue, nextMode);
    }
  });
  var triggerConfirm = function triggerConfirm2() {
    triggerSubmitChange(getCalendarValue());
    triggerOpen(false, {
      force: true
    });
  };
  var onSelectorClick = function onSelectorClick2(event) {
    if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) {
      selectorRef.current.focus();
    }
    triggerOpen(true);
    onClick === null || onClick === void 0 || onClick(event);
  };
  var onSelectorClear = function onSelectorClear2() {
    triggerSubmitChange(null);
    triggerOpen(false, {
      force: true
    });
  };
  var _React$useState = React292.useState(null), _React$useState2 = _slicedToArray32(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
  var _React$useState3 = React292.useState(null), _React$useState4 = _slicedToArray32(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
  var hoverValues = React292.useMemo(function() {
    var values = [internalHoverValue].concat(_toConsumableArray9(calendarValue)).filter(function(date4) {
      return date4;
    });
    return multiple ? values : values.slice(0, 1);
  }, [calendarValue, internalHoverValue, multiple]);
  var selectorValues = React292.useMemo(function() {
    if (!multiple && internalHoverValue) {
      return [internalHoverValue];
    }
    return calendarValue.filter(function(date4) {
      return date4;
    });
  }, [calendarValue, internalHoverValue, multiple]);
  React292.useEffect(function() {
    if (!mergedOpen) {
      setInternalHoverValue(null);
    }
  }, [mergedOpen]);
  var onSetHover = function onSetHover2(date4, source) {
    if (previewValue !== "hover") {
      return;
    }
    setInternalHoverValue(date4);
    setHoverSource(source);
  };
  var presetList = usePresets(presets);
  var onPresetHover = function onPresetHover2(nextValue) {
    onSetHover(nextValue, "preset");
  };
  var onPresetSubmit = function onPresetSubmit2(nextValue) {
    var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
    var passed = triggerSubmitChange(nextCalendarValues);
    if (passed && !multiple) {
      triggerOpen(false, {
        force: true
      });
    }
  };
  var onNow = function onNow2(now2) {
    onPresetSubmit(now2);
  };
  var onPanelHover = function onPanelHover2(date4) {
    onSetHover(date4, "cell");
  };
  var onPanelFocus = function onPanelFocus2(event) {
    triggerOpen(true);
    onSharedFocus(event);
  };
  var onPanelSelect = function onPanelSelect2(date4) {
    lastOperation("panel");
    if (multiple && internalMode !== picker) {
      return;
    }
    var nextValues = multiple ? toggleDates(getCalendarValue(), date4) : [date4];
    triggerCalendarChange(nextValues);
    if (!needConfirm && !complexPicker && internalPicker === internalMode) {
      triggerConfirm();
    }
  };
  var onPopupClose = function onPopupClose2() {
    triggerOpen(false);
  };
  var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
  var panelProps = React292.useMemo(function() {
    var domProps = pickAttrs(filledProps, false);
    var restProps = omit(filledProps, [].concat(_toConsumableArray9(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "classNames", "styles"]));
    return _objectSpread19(_objectSpread19({}, restProps), {}, {
      multiple: filledProps.multiple
    });
  }, [filledProps]);
  var panel = React292.createElement(Popup3, _extends49({}, panelProps, {
    showNow: mergedShowNow,
    showTime,
    disabledDate,
    onFocus: onPanelFocus,
    onBlur: onSharedBlur,
    picker,
    mode: mergedMode,
    internalMode,
    onPanelChange: triggerModeChange,
    format: maskFormat,
    value: calendarValue,
    isInvalid: isInvalidateDate,
    onChange: null,
    onSelect: onPanelSelect,
    pickerValue: currentPickerValue,
    defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
    onPickerValueChange: setCurrentPickerValue,
    hoverValue: hoverValues,
    onHover: onPanelHover,
    needConfirm,
    onSubmit: triggerConfirm,
    onOk: triggerOk,
    presets: presetList,
    onPresetHover,
    onPresetSubmit,
    onNow,
    cellRender: onInternalCellRender,
    classNames: mergedClassNames,
    styles: mergedStyles
  }));
  var onSelectorChange = function onSelectorChange2(date4) {
    triggerCalendarChange(date4);
  };
  var onSelectorInputChange = function onSelectorInputChange2() {
    lastOperation("input");
  };
  var onSelectorFocus = function onSelectorFocus2(event) {
    lastOperation("input");
    triggerOpen(true, {
      inherit: true
    });
    onSharedFocus(event);
  };
  var onSelectorBlur = function onSelectorBlur2(event) {
    triggerOpen(false);
    onSharedBlur(event);
  };
  var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
    if (event.key === "Tab") {
      triggerConfirm();
    }
    onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(event, preventDefault);
  };
  var context = React292.useMemo(function() {
    return {
      prefixCls,
      locale: locale6,
      generateConfig: generateConfig2,
      button: components2.button,
      input: components2.input,
      classNames: mergedClassNames,
      styles: mergedStyles
    };
  }, [prefixCls, locale6, generateConfig2, components2.button, components2.input, mergedClassNames, mergedStyles]);
  useLayoutEffect_default(function() {
    if (mergedOpen && activeIndex !== void 0) {
      triggerModeChange(null, picker, false);
    }
  }, [mergedOpen, activeIndex, picker]);
  useLayoutEffect_default(function() {
    var lastOp = lastOperation();
    if (!mergedOpen && lastOp === "input") {
      triggerOpen(false);
      triggerConfirm();
    }
    if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
      triggerConfirm();
    }
  }, [mergedOpen]);
  return React292.createElement(context_default7.Provider, {
    value: context
  }, React292.createElement(PickerTrigger_default, _extends49({}, pickTriggerProps(filledProps), {
    popupElement: panel,
    popupStyle: mergedStyles.popup.root,
    popupClassName: clsx(rootClassName, mergedClassNames.popup.root),
    visible: mergedOpen,
    onClose: onPopupClose
  }), React292.createElement(
    SingleSelector_default,
    _extends49({}, filledProps, {
      // Ref
      ref: selectorRef,
      className: clsx(filledProps.className, rootClassName, mergedClassNames.root),
      style: _objectSpread19(_objectSpread19({}, mergedStyles.root), filledProps.style),
      suffixIcon,
      removeIcon,
      activeHelp: !!internalHoverValue,
      allHelp: !!internalHoverValue && hoverSource === "preset",
      focused,
      onFocus: onSelectorFocus,
      onBlur: onSelectorBlur,
      onKeyDown: onSelectorKeyDown,
      onSubmit: triggerConfirm,
      value: selectorValues,
      maskFormat,
      onChange: onSelectorChange,
      onInputChange: onSelectorInputChange,
      internalPicker,
      format: formatList,
      inputReadOnly,
      disabled,
      open: mergedOpen,
      onOpenChange: triggerOpen,
      onClick: onSelectorClick,
      onClear: onSelectorClear,
      invalid: submitInvalidate,
      onInvalid: function onInvalid(invalid) {
        onSelectorInvalid(invalid, 0);
      }
    })
  )));
}
var RefPicker = React292.forwardRef(Picker2);
if (true) {
  RefPicker.displayName = "RefPicker";
}
var SinglePicker_default = RefPicker;

// node_modules/@rc-component/picker/es/index.js
var es_default16 = SinglePicker_default;

// node_modules/antd/es/calendar/Header.js
var React300 = __toESM(require_react());
var import_react109 = __toESM(require_react());

// node_modules/antd/es/radio/group.js
var React298 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useForm.js
var React293 = __toESM(require_react());

// node_modules/antd/es/form/util.js
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray6(candidate) {
  if (candidate === void 0 || candidate === false) {
    return [];
  }
  return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
  if (!namePath.length) {
    return void 0;
  }
  const mergedId = namePath.join("_");
  if (formName) {
    return `${formName}_${mergedId}`;
  }
  const isIllegalName = formItemNameBlackList.includes(mergedId);
  return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
  let status = defaultValidateStatus;
  if (validateStatus !== void 0) {
    status = validateStatus;
  } else if (meta.validating) {
    status = "validating";
  } else if (errors.length) {
    status = "error";
  } else if (warnings.length) {
    status = "warning";
  } else if (meta.touched || hasFeedback && meta.validated) {
    status = "success";
  }
  return status;
}

// node_modules/antd/es/form/hooks/useForm.js
function toNamePathStr(name) {
  const namePath = toArray6(name);
  return namePath.join("_");
}
function getFieldDOMNode(name, wrapForm) {
  const field = wrapForm.getFieldInstance(name);
  const fieldDom = getDOM(field);
  if (fieldDom) {
    return fieldDom;
  }
  const fieldId = getFieldId(toArray6(name), wrapForm.__INTERNAL__.name);
  if (fieldId) {
    return document.getElementById(fieldId);
  }
}
function useForm2(form) {
  const [rcForm] = useForm_default();
  const itemsRef = React293.useRef({});
  const wrapForm = React293.useMemo(() => form ?? {
    ...rcForm,
    __INTERNAL__: {
      itemRef: (name) => (node2) => {
        const namePathStr = toNamePathStr(name);
        if (node2) {
          itemsRef.current[namePathStr] = node2;
        } else {
          delete itemsRef.current[namePathStr];
        }
      }
    },
    scrollToField: (name, options = {}) => {
      const {
        focus,
        ...restOpt
      } = options;
      const node2 = getFieldDOMNode(name, wrapForm);
      if (node2) {
        e2(node2, {
          scrollMode: "if-needed",
          block: "nearest",
          ...restOpt
        });
        if (focus) {
          wrapForm.focusField(name);
        }
      }
    },
    focusField: (name) => {
      var _a, _b;
      const itemRef = wrapForm.getFieldInstance(name);
      if (typeof (itemRef == null ? void 0 : itemRef.focus) === "function") {
        itemRef.focus();
      } else {
        (_b = (_a = getFieldDOMNode(name, wrapForm)) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
      }
    },
    getFieldInstance: (name) => {
      const namePathStr = toNamePathStr(name);
      return itemsRef.current[namePathStr];
    }
  }, [form, rcForm]);
  return [wrapForm];
}

// node_modules/antd/es/radio/context.js
var React294 = __toESM(require_react());
var RadioGroupContext = React294.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var context_default8 = RadioGroupContext;
var RadioOptionTypeContext = React294.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

// node_modules/antd/es/radio/radio.js
var React297 = __toESM(require_react());

// node_modules/@rc-component/checkbox/es/index.js
var React295 = __toESM(require_react());
var import_react107 = __toESM(require_react());
function _extends50() {
  _extends50 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends50.apply(this, arguments);
}
var Checkbox = (0, import_react107.forwardRef)((props, ref) => {
  const {
    prefixCls = "rc-checkbox",
    className,
    style: style2,
    checked,
    disabled,
    defaultChecked = false,
    type: type5 = "checkbox",
    title,
    onChange,
    ...inputProps
  } = props;
  const inputRef = (0, import_react107.useRef)(null);
  const holderRef = (0, import_react107.useRef)(null);
  const [rawValue, setRawValue] = useControlledState(defaultChecked, checked);
  (0, import_react107.useImperativeHandle)(ref, () => ({
    focus: (options) => {
      var _a;
      (_a = inputRef.current) == null ? void 0 : _a.focus(options);
    },
    blur: () => {
      var _a;
      (_a = inputRef.current) == null ? void 0 : _a.blur();
    },
    input: inputRef.current,
    nativeElement: holderRef.current
  }));
  const classString = clsx(prefixCls, className, {
    [`${prefixCls}-checked`]: rawValue,
    [`${prefixCls}-disabled`]: disabled
  });
  const handleChange = (e3) => {
    if (disabled) {
      return;
    }
    if (!("checked" in props)) {
      setRawValue(e3.target.checked);
    }
    onChange == null ? void 0 : onChange({
      target: {
        ...props,
        type: type5,
        checked: e3.target.checked
      },
      stopPropagation() {
        e3.stopPropagation();
      },
      preventDefault() {
        e3.preventDefault();
      },
      nativeEvent: e3.nativeEvent
    });
  };
  return React295.createElement("span", {
    className: classString,
    title,
    style: style2,
    ref: holderRef
  }, React295.createElement("input", _extends50({}, inputProps, {
    className: `${prefixCls}-input`,
    ref: inputRef,
    onChange: handleChange,
    disabled,
    checked: !!rawValue,
    type: type5
  })), React295.createElement("span", {
    className: `${prefixCls}-inner`
  }));
});
var es_default17 = Checkbox;

// node_modules/antd/es/checkbox/useBubbleLock.js
var import_react108 = __toESM(require_react());
function useBubbleLock(onOriginInputClick) {
  const labelClickLockRef = import_react108.default.useRef(null);
  const clearLock = () => {
    raf_default.cancel(labelClickLockRef.current);
    labelClickLockRef.current = null;
  };
  const onLabelClick = () => {
    clearLock();
    labelClickLockRef.current = raf_default(() => {
      labelClickLockRef.current = null;
    });
  };
  const onInputClick = (e3) => {
    if (labelClickLockRef.current) {
      e3.stopPropagation();
      clearLock();
    }
    onOriginInputClick == null ? void 0 : onOriginInputClick(e3);
  };
  return [onLabelClick, onInputClick];
}

// node_modules/antd/es/radio/style/index.js
var getGroupRadioStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${groupPrefixCls}-block`]: {
        display: "flex"
      },
      [`${antCls}-badge ${antCls}-badge-count`]: {
        zIndex: 1
      },
      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
        borderInlineStart: "none"
      },
      "&-vertical": {
        display: "flex",
        flexDirection: "column",
        rowGap: token2.marginXS
      }
    }
  };
};
var getRadioBasicStyle = (token2) => {
  const {
    componentCls,
    wrapperMarginInlineEnd,
    colorPrimary,
    radioSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOutCirc,
    colorBgContainer,
    colorBorder,
    lineWidth,
    colorBgContainerDisabled,
    colorTextDisabled,
    paddingXS,
    dotColorDisabled,
    lineType,
    radioColor,
    radioBgColor,
    calc
  } = token2;
  const radioInnerPrefixCls = `${componentCls}-inner`;
  const dotPadding = 4;
  const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
  const radioSizeCalc = calc(1).mul(radioSize).equal({
    unit: true
  });
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token2),
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: wrapperMarginInlineEnd,
      cursor: "pointer",
      "&:last-child": {
        marginInlineEnd: 0
      },
      // RTL
      [`&${componentCls}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      "&-block": {
        flex: 1,
        justifyContent: "center"
      },
      // hashId  wrapper 
      [`${componentCls}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: "50%",
        visibility: "hidden",
        opacity: 0,
        content: '""'
      },
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center",
        borderRadius: "50%"
      },
      [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
        borderColor: colorPrimary
      },
      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: genFocusOutline(token2),
      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${componentCls}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: radioSizeCalc,
          height: radioSizeCalc,
          marginBlockStart: calc(1).mul(radioSize).div(-2).equal({
            unit: true
          }),
          marginInlineStart: calc(1).mul(radioSize).div(-2).equal({
            unit: true
          }),
          backgroundColor: radioColor,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: radioSizeCalc,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: radioSizeCalc,
        height: radioSizeCalc,
        backgroundColor: colorBgContainer,
        borderColor: colorBorder,
        borderStyle: "solid",
        borderWidth: lineWidth,
        borderRadius: "50%",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-input`]: {
        position: "absolute",
        inset: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 
      [`${componentCls}-checked`]: {
        [radioInnerPrefixCls]: {
          borderColor: colorPrimary,
          backgroundColor: radioBgColor,
          "&::after": {
            transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
            opacity: 1,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          }
        }
      },
      [`${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [radioInnerPrefixCls]: {
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: dotColorDisabled
          }
        },
        [`${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            "&::after": {
              transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})`
            }
          }
        }
      },
      [`span${componentCls} + *`]: {
        paddingInlineStart: paddingXS,
        paddingInlineEnd: paddingXS
      }
    }
  };
};
var getRadioButtonStyle = (token2) => {
  const {
    buttonColor,
    controlHeight,
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    motionDurationMid,
    buttonPaddingInline,
    fontSize,
    buttonBg,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    paddingXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusLG,
    buttonCheckedBg,
    buttonSolidCheckedColor,
    colorTextDisabled,
    colorBgContainerDisabled,
    buttonCheckedBgDisabled,
    buttonCheckedColorDisabled,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    buttonSolidCheckedBg,
    buttonSolidCheckedHoverBg,
    buttonSolidCheckedActiveBg,
    calc
  } = token2;
  return {
    [`${componentCls}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: controlHeight,
      margin: 0,
      paddingInline: buttonPaddingInline,
      paddingBlock: 0,
      color: buttonColor,
      fontSize,
      lineHeight: unit(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
      background: buttonBg,
      border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
      borderInlineEndWidth: lineWidth,
      cursor: "pointer",
      transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
      a: {
        color: buttonColor
      },
      [`> ${componentCls}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:last-child)": {
        marginInlineEnd: calc(lineWidth).mul(-1).equal()
      },
      "&:first-child": {
        borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
        borderStartStartRadius: borderRadius,
        borderEndStartRadius: borderRadius
      },
      "&:last-child": {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      "&:first-child:last-child": {
        borderRadius
      },
      [`${componentCls}-group-large &`]: {
        height: controlHeightLG,
        fontSize: fontSizeLG,
        lineHeight: unit(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderEndStartRadius: borderRadiusLG
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        }
      },
      [`${componentCls}-group-small &`]: {
        height: controlHeightSM,
        paddingInline: calc(paddingXS).sub(lineWidth).equal(),
        paddingBlock: 0,
        lineHeight: unit(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
        "&:first-child": {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        }
      },
      "&:hover": {
        position: "relative",
        color: colorPrimary
      },
      "&:has(:focus-visible)": genFocusOutline(token2),
      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: colorPrimary,
        background: buttonCheckedBg,
        borderColor: colorPrimary,
        "&::before": {
          backgroundColor: colorPrimary
        },
        "&:first-child": {
          borderColor: colorPrimary
        },
        "&:hover": {
          color: colorPrimaryHover,
          borderColor: colorPrimaryHover,
          "&::before": {
            backgroundColor: colorPrimaryHover
          }
        },
        "&:active": {
          color: colorPrimaryActive,
          borderColor: colorPrimaryActive,
          "&::before": {
            backgroundColor: colorPrimaryActive
          }
        }
      },
      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        color: buttonSolidCheckedColor,
        background: buttonSolidCheckedBg,
        borderColor: buttonSolidCheckedBg,
        "&:hover": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedHoverBg,
          borderColor: buttonSolidCheckedHoverBg
        },
        "&:active": {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedActiveBg,
          borderColor: buttonSolidCheckedActiveBg
        }
      },
      "&-disabled": {
        color: colorTextDisabled,
        backgroundColor: colorBgContainerDisabled,
        borderColor: colorBorder,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder
        }
      },
      [`&-disabled${componentCls}-button-wrapper-checked`]: {
        color: buttonCheckedColorDisabled,
        backgroundColor: buttonCheckedBgDisabled,
        borderColor: colorBorder,
        boxShadow: "none"
      },
      "&-block": {
        flex: 1,
        textAlign: "center"
      }
    }
  };
};
var prepareComponentToken21 = (token2) => {
  const {
    wireframe,
    padding,
    marginXS,
    lineWidth,
    fontSizeLG,
    colorText,
    colorBgContainer,
    colorTextDisabled,
    controlItemBgActiveDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorPrimaryHover,
    colorPrimaryActive,
    colorWhite
  } = token2;
  const dotPadding = 4;
  const radioSize = fontSizeLG;
  const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
  return {
    // Radio
    radioSize,
    dotSize: radioDotSize,
    dotColorDisabled: colorTextDisabled,
    // Radio buttons
    buttonSolidCheckedColor: colorTextLightSolid,
    buttonSolidCheckedBg: colorPrimary,
    buttonSolidCheckedHoverBg: colorPrimaryHover,
    buttonSolidCheckedActiveBg: colorPrimaryActive,
    buttonBg: colorBgContainer,
    buttonCheckedBg: colorBgContainer,
    buttonColor: colorText,
    buttonCheckedBgDisabled: controlItemBgActiveDisabled,
    buttonCheckedColorDisabled: colorTextDisabled,
    buttonPaddingInline: padding - lineWidth,
    wrapperMarginInlineEnd: marginXS,
    // internal
    radioColor: wireframe ? colorPrimary : colorWhite,
    radioBgColor: wireframe ? colorBgContainer : colorPrimary
  };
};
var style_default23 = genStyleHooks("Radio", (token2) => {
  const {
    controlOutline,
    controlOutlineWidth
  } = token2;
  const radioFocusShadow = `0 0 0 ${unit(controlOutlineWidth)} ${controlOutline}`;
  const radioButtonFocusShadow = radioFocusShadow;
  const radioToken = merge2(token2, {
    radioFocusShadow,
    radioButtonFocusShadow
  });
  return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
}, prepareComponentToken21, {
  unitless: {
    radioSize: true,
    dotSize: true
  }
});

// node_modules/antd/es/radio/radio.js
var InternalRadio = (props, ref) => {
  const groupContext = React297.useContext(context_default8);
  const radioOptionTypeContext = React297.useContext(RadioOptionTypeContext);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("radio");
  const innerRef = React297.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  const {
    isFormItemInput
  } = React297.useContext(FormItemInputContext);
  if (true) {
    const warning5 = devUseWarning("Radio");
    true ? warning5(!("optionType" in props), "usage", "`optionType` is only support in Radio.Group.") : void 0;
  }
  const onChange = (e3) => {
    var _a, _b;
    (_a = props.onChange) == null ? void 0 : _a.call(props, e3);
    (_b = groupContext == null ? void 0 : groupContext.onChange) == null ? void 0 : _b.call(groupContext, e3);
  };
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    style: style2,
    title,
    classNames,
    styles,
    ...restProps
  } = props;
  const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
  const isButtonType = ((groupContext == null ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button";
  const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
  const rootCls = useCSSVarCls_default(radioPrefixCls);
  const [hashId, cssVarCls] = style_default23(radioPrefixCls, rootCls);
  const radioProps = {
    ...restProps
  };
  const disabled = React297.useContext(DisabledContext_default);
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled ?? groupContext.disabled;
  }
  radioProps.disabled = radioProps.disabled ?? disabled;
  const mergedProps = {
    ...props,
    ...radioProps
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const wrapperClassString = clsx(`${prefixCls}-wrapper`, {
    [`${prefixCls}-wrapper-checked`]: radioProps.checked,
    [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
    [`${prefixCls}-wrapper-block`]: !!(groupContext == null ? void 0 : groupContext.block)
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls);
  const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
  return React297.createElement(wave_default, {
    component: "Radio",
    disabled: radioProps.disabled
  }, React297.createElement("label", {
    className: wrapperClassString,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    title,
    onClick: onLabelClick
  }, React297.createElement(es_default17, {
    ...radioProps,
    className: clsx(mergedClassNames.icon, {
      [TARGET_CLS]: !isButtonType
    }),
    style: mergedStyles.icon,
    type: "radio",
    prefixCls,
    ref: mergedRef,
    onClick: onInputClick
  }), children !== void 0 ? React297.createElement("span", {
    className: clsx(`${prefixCls}-label`, mergedClassNames.label),
    style: mergedStyles.label
  }, children) : null));
};
var Radio = React297.forwardRef(InternalRadio);
if (true) {
  Radio.displayName = "Radio";
}
var radio_default = Radio;

// node_modules/antd/es/radio/group.js
var RadioGroup = React298.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React298.useContext(ConfigContext);
  const {
    name: formItemName
  } = React298.useContext(FormItemInputContext);
  const defaultName = useId_default(toNamePathStr(formItemName));
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    options,
    buttonStyle = "outline",
    disabled,
    children,
    size: customizeSize,
    style: style2,
    id,
    optionType,
    name = defaultName,
    defaultValue,
    value: customizedValue,
    block = false,
    onChange,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    orientation,
    vertical
  } = props;
  const [value, setValue] = useControlledState(defaultValue, customizedValue);
  const onRadioChange = React298.useCallback((event) => {
    const lastValue = value;
    const val = event.target.value;
    if (!("value" in props)) {
      setValue(val);
    }
    if (val !== lastValue) {
      onChange == null ? void 0 : onChange(event);
    }
  }, [value, setValue, onChange]);
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default23(prefixCls, rootCls);
  let childrenToRender = children;
  if (options && options.length > 0) {
    childrenToRender = options.map((option) => {
      if (typeof option === "string" || typeof option === "number") {
        return React298.createElement(radio_default, {
          key: option.toString(),
          prefixCls,
          disabled,
          value: option,
          checked: value === option
        }, option);
      }
      return React298.createElement(radio_default, {
        key: `radio-group-value-options-${option.value}`,
        prefixCls,
        disabled: option.disabled || disabled,
        value: option.value,
        checked: value === option.value,
        title: option.title,
        style: option.style,
        className: option.className,
        id: option.id,
        required: option.required
      }, option.label);
    });
  }
  const mergedSize = useSize_default(customizeSize);
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const classString = clsx(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
    [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
    [`${groupPrefixCls}-rtl`]: direction === "rtl",
    [`${groupPrefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls, rootCls);
  const memoizedValue = React298.useMemo(() => ({
    onChange: onRadioChange,
    value,
    disabled,
    name,
    optionType,
    block
  }), [onRadioChange, value, disabled, name, optionType, block]);
  return React298.createElement("div", {
    ...pickAttrs(props, {
      aria: true,
      data: true
    }),
    className: clsx(classString, {
      [`${prefixCls}-group-vertical`]: mergedVertical
    }),
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    id,
    ref
  }, React298.createElement(RadioGroupContextProvider, {
    value: memoizedValue
  }, childrenToRender));
});
var group_default2 = React298.memo(RadioGroup);

// node_modules/antd/es/radio/radioButton.js
var React299 = __toESM(require_react());
var RadioButton = (props, ref) => {
  const {
    getPrefixCls
  } = React299.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    ...radioProps
  } = props;
  const prefixCls = getPrefixCls("radio", customizePrefixCls);
  return React299.createElement(RadioOptionTypeContextProvider, {
    value: "button"
  }, React299.createElement(radio_default, {
    prefixCls,
    ...radioProps,
    type: "radio",
    ref
  }));
};
var radioButton_default = React299.forwardRef(RadioButton);

// node_modules/antd/es/radio/index.js
var Radio2 = radio_default;
Radio2.Button = radioButton_default;
Radio2.Group = group_default2;
Radio2.__ANT_RADIO = true;
var radio_default2 = Radio2;

// node_modules/antd/es/calendar/Header.js
var YEAR_SELECT_OFFSET = 10;
var YEAR_SELECT_TOTAL = 20;
function YearSelect(props) {
  const {
    fullscreen,
    validRange,
    generateConfig: generateConfig2,
    locale: locale6,
    prefixCls,
    value,
    onChange,
    divRef
  } = props;
  const year = generateConfig2.getYear(value || generateConfig2.getNow());
  let start = year - YEAR_SELECT_OFFSET;
  let end = start + YEAR_SELECT_TOTAL;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  const suffix = locale6 && locale6.year === "" ? "" : "";
  const options = [];
  for (let index2 = start; index2 < end; index2++) {
    options.push({
      label: `${index2}${suffix}`,
      value: index2
    });
  }
  return React300.createElement(select_default, {
    size: fullscreen ? void 0 : "small",
    options,
    value: year,
    className: `${prefixCls}-year-select`,
    onChange: (numYear) => {
      let newDate = generateConfig2.setYear(value, numYear);
      if (validRange) {
        const [startDate, endDate] = validRange;
        const newYear = generateConfig2.getYear(newDate);
        const newMonth = generateConfig2.getMonth(newDate);
        if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
        }
        if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
        }
      }
      onChange(newDate);
    },
    getPopupContainer: () => divRef.current
  });
}
function MonthSelect(props) {
  const {
    prefixCls,
    fullscreen,
    validRange,
    value,
    generateConfig: generateConfig2,
    locale: locale6,
    onChange,
    divRef
  } = props;
  const month = generateConfig2.getMonth(value || generateConfig2.getNow());
  let start = 0;
  let end = 11;
  if (validRange) {
    const [rangeStart, rangeEnd] = validRange;
    const currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  const months = locale6.shortMonths || generateConfig2.locale.getShortMonths(locale6.locale);
  const options = [];
  for (let index2 = start; index2 <= end; index2 += 1) {
    options.push({
      label: months[index2],
      value: index2
    });
  }
  return React300.createElement(select_default, {
    size: fullscreen ? void 0 : "small",
    className: `${prefixCls}-month-select`,
    value: month,
    options,
    onChange: (newMonth) => {
      onChange(generateConfig2.setMonth(value, newMonth));
    },
    getPopupContainer: () => divRef.current
  });
}
function ModeSwitch(props) {
  const {
    prefixCls,
    locale: locale6,
    mode,
    fullscreen,
    onModeChange
  } = props;
  return React300.createElement(group_default2, {
    onChange: ({
      target: {
        value
      }
    }) => {
      onModeChange(value);
    },
    value: mode,
    size: fullscreen ? void 0 : "small",
    className: `${prefixCls}-mode-switch`
  }, React300.createElement(radioButton_default, {
    value: "month"
  }, locale6.month), React300.createElement(radioButton_default, {
    value: "year"
  }, locale6.year));
}
function CalendarHeader(props) {
  const {
    prefixCls,
    fullscreen,
    mode,
    onChange,
    onModeChange,
    className,
    style: style2
  } = props;
  const divRef = React300.useRef(null);
  const formItemInputContext = (0, import_react109.useContext)(FormItemInputContext);
  const mergedFormItemInputContext = (0, import_react109.useMemo)(() => ({
    ...formItemInputContext,
    isFormItemInput: false
  }), [formItemInputContext]);
  const sharedProps = {
    ...props,
    fullscreen,
    divRef
  };
  return React300.createElement("div", {
    className: clsx(`${prefixCls}-header`, className),
    style: style2,
    ref: divRef
  }, React300.createElement(FormItemInputContext.Provider, {
    value: mergedFormItemInputContext
  }, React300.createElement(YearSelect, {
    ...sharedProps,
    onChange: (v) => {
      onChange(v, "year");
    }
  }), mode === "month" && React300.createElement(MonthSelect, {
    ...sharedProps,
    onChange: (v) => {
      onChange(v, "month");
    }
  })), React300.createElement(ModeSwitch, {
    ...sharedProps,
    onModeChange
  }));
}
var Header_default = CalendarHeader;

// node_modules/antd/es/input/style/token.js
function initInputToken(token2) {
  return merge2(token2, {
    inputAffixPadding: token2.paddingXXS
  });
}
var initComponentToken = (token2) => {
  const {
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightSM,
    controlHeightLG,
    fontSizeLG,
    lineHeightLG,
    paddingSM,
    controlPaddingHorizontalSM,
    controlPaddingHorizontal,
    colorFillAlter,
    colorPrimaryHover,
    colorPrimary,
    controlOutlineWidth,
    controlOutline,
    colorErrorOutline,
    colorWarningOutline,
    colorBgContainer,
    inputFontSize,
    inputFontSizeLG,
    inputFontSizeSM
  } = token2;
  const mergedFontSize = inputFontSize || fontSize;
  const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
  const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
  const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
  const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
  const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
  return {
    paddingBlock: Math.max(paddingBlock, 0),
    paddingBlockSM: Math.max(paddingBlockSM, 0),
    paddingBlockLG: Math.max(paddingBlockLG, 0),
    paddingInline: paddingSM - lineWidth,
    paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
    paddingInlineLG: controlPaddingHorizontal - lineWidth,
    addonBg: colorFillAlter,
    activeBorderColor: colorPrimary,
    hoverBorderColor: colorPrimaryHover,
    activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
    errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
    warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
    hoverBg: colorBgContainer,
    activeBg: colorBgContainer,
    inputFontSize: mergedFontSize,
    inputFontSizeLG: mergedFontSizeLG,
    inputFontSizeSM: mergedFontSizeSM
  };
};

// node_modules/antd/es/input/style/variants.js
var genHoverStyle = (token2) => ({
  borderColor: token2.hoverBorderColor,
  backgroundColor: token2.hoverBg
});
var genDisabledStyle = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": {
    ...genHoverStyle(merge2(token2, {
      hoverBorderColor: token2.colorBorder,
      hoverBg: token2.colorBgContainerDisabled
    }))
  }
});
var genBaseOutlinedStyle = (token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: options.borderColor,
  "&:hover": {
    borderColor: options.hoverBorderColor,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: options.activeBorderColor,
    boxShadow: options.activeShadow,
    outline: 0,
    backgroundColor: token2.activeBg
  }
});
var genOutlinedStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseOutlinedStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  },
  [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
    borderColor: options.borderColor
  }
});
var genOutlinedStyle = (token2, extraStyles) => ({
  "&-outlined": {
    ...genBaseOutlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle(token2)
    },
    ...genOutlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    }),
    ...genOutlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});
var genOutlinedGroupStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      borderColor: options.addonBorderColor,
      color: options.addonColor
    }
  }
});
var genOutlinedGroupStyle = (token2) => ({
  "&-outlined": {
    [`${token2.componentCls}-group`]: {
      "&-addon": {
        background: token2.addonBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    ...genOutlinedGroupStatusStyle(token2, {
      status: "error",
      addonBorderColor: token2.colorError,
      addonColor: token2.colorErrorText
    }),
    ...genOutlinedGroupStatusStyle(token2, {
      status: "warning",
      addonBorderColor: token2.colorWarning,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group-addon`]: {
        ...genDisabledStyle(token2)
      }
    }
  }
});
var genBorderlessStyle2 = (token2, extraStyles) => {
  const {
    componentCls
  } = token2;
  return {
    "&-borderless": {
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${componentCls}-disabled, &[disabled]`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      // >>>>> Status
      [`&${componentCls}-status-error`]: {
        "&, & input, & textarea": {
          color: token2.colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        "&, & input, & textarea": {
          color: token2.colorWarning
        }
      },
      ...extraStyles
    }
  };
};
var genBaseFilledStyle = (token2, options) => ({
  background: options.bg,
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: (options == null ? void 0 : options.inputColor) ?? "unset"
  },
  "&:hover": {
    background: options.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: options.activeBorderColor,
    backgroundColor: token2.activeBg
  }
});
var genFilledStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseFilledStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  }
});
var genFilledStyle = (token2, extraStyles) => ({
  "&-filled": {
    ...genBaseFilledStyle(token2, {
      bg: token2.colorFillTertiary,
      hoverBg: token2.colorFillSecondary,
      activeBorderColor: token2.activeBorderColor,
      inputColor: token2.colorText
    }),
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      ...genDisabledStyle(token2)
    },
    ...genFilledStatusStyle(token2, {
      status: "error",
      bg: token2.colorErrorBg,
      hoverBg: token2.colorErrorBgHover,
      activeBorderColor: token2.colorError,
      inputColor: token2.colorErrorText,
      affixColor: token2.colorError
    }),
    ...genFilledStatusStyle(token2, {
      status: "warning",
      bg: token2.colorWarningBg,
      hoverBg: token2.colorWarningBgHover,
      activeBorderColor: token2.colorWarning,
      inputColor: token2.colorWarningText,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});
var genFilledGroupStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token2.componentCls}-group-addon`]: {
      background: options.addonBg,
      color: options.addonColor
    }
  }
});
var genFilledGroupStyle = (token2) => ({
  "&-filled": {
    [`${token2.componentCls}-group-addon`]: {
      background: token2.colorFillTertiary,
      "&:last-child": {
        position: "static"
      }
    },
    ...genFilledGroupStatusStyle(token2, {
      status: "error",
      addonBg: token2.colorErrorBg,
      addonColor: token2.colorErrorText
    }),
    ...genFilledGroupStatusStyle(token2, {
      status: "warning",
      addonBg: token2.colorWarningBg,
      addonColor: token2.colorWarningText
    }),
    [`&${token2.componentCls}-group-wrapper-disabled`]: {
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.colorFillTertiary,
          color: token2.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        }
      }
    }
  }
});
var genBaseUnderlinedStyle = (token2, options) => ({
  background: token2.colorBgContainer,
  borderWidth: `${unit(token2.lineWidth)} 0`,
  borderStyle: `${token2.lineType} none`,
  borderColor: `transparent transparent ${options.borderColor} transparent`,
  borderRadius: 0,
  "&:hover": {
    borderColor: `transparent transparent ${options.hoverBorderColor} transparent`,
    backgroundColor: token2.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
    outline: 0,
    backgroundColor: token2.activeBg
  }
});
var genUnderlinedStatusStyle = (token2, options) => ({
  [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
    ...genBaseUnderlinedStyle(token2, options),
    [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
      color: options.affixColor
    }
  },
  [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
    borderColor: `transparent transparent ${options.borderColor} transparent`
  }
});
var genUnderlinedStyle = (token2, extraStyles) => ({
  "&-underlined": {
    ...genBaseUnderlinedStyle(token2, {
      borderColor: token2.colorBorder,
      hoverBorderColor: token2.hoverBorderColor,
      activeBorderColor: token2.activeBorderColor,
      activeShadow: token2.activeShadow
    }),
    // >>>>> Disabled
    [`&${token2.componentCls}-disabled, &[disabled]`]: {
      color: token2.colorTextDisabled,
      boxShadow: "none",
      cursor: "not-allowed",
      "&:hover": {
        borderColor: `transparent transparent ${token2.colorBorder} transparent`
      }
    },
    "input[disabled], textarea[disabled]": {
      cursor: "not-allowed"
    },
    ...genUnderlinedStatusStyle(token2, {
      status: "error",
      borderColor: token2.colorError,
      hoverBorderColor: token2.colorErrorBorderHover,
      activeBorderColor: token2.colorError,
      activeShadow: token2.errorActiveShadow,
      affixColor: token2.colorError
    }),
    ...genUnderlinedStatusStyle(token2, {
      status: "warning",
      borderColor: token2.colorWarning,
      hoverBorderColor: token2.colorWarningBorderHover,
      activeBorderColor: token2.colorWarning,
      activeShadow: token2.warningActiveShadow,
      affixColor: token2.colorWarning
    }),
    ...extraStyles
  }
});

// node_modules/antd/es/input/style/index.js
var genPlaceholderStyle = (color) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
var genInputLargeStyle = (token2) => {
  const {
    paddingBlockLG,
    lineHeightLG,
    borderRadiusLG,
    paddingInlineLG
  } = token2;
  return {
    padding: `${unit(paddingBlockLG)} ${unit(paddingInlineLG)}`,
    fontSize: token2.inputFontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
var genInputSmallStyle = (token2) => ({
  padding: `${unit(token2.paddingBlockSM)} ${unit(token2.paddingInlineSM)}`,
  fontSize: token2.inputFontSizeSM,
  borderRadius: token2.borderRadiusSM
});
var genBasicInputStyle = (token2, option = {}) => ({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${unit(token2.paddingBlock)} ${unit(token2.paddingInline)}`,
  color: token2.colorText,
  fontSize: token2.inputFontSize,
  lineHeight: token2.lineHeight,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`,
  ...genPlaceholderStyle(token2.colorTextPlaceholder),
  // Size
  "&-lg": {
    ...genInputLargeStyle(token2),
    ...option.largeStyle
  },
  "&-sm": {
    ...genInputSmallStyle(token2),
    ...option.smallStyle
  },
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
});
var genInputGroupStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: {
      ...genInputLargeStyle(token2)
    },
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: {
      ...genInputSmallStyle(token2)
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${antCls}-select-single`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${unit(token2.paddingInline)}`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.inputFontSize,
        textAlign: "center",
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `${unit(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
            backgroundColor: "inherit",
            border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
            boxShadow: "none"
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px ${unit(token2.calc(token2.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [componentCls]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      },
      "&:not(:first-child)": {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: {
      display: "block",
      ...clearFix(),
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: token2.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [componentCls]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        [`${componentCls}-affix-wrapper`]: {
          // borderRadius: 0,
        }
      }
    }
  };
};
var genInputStyle = (token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth,
    calc
  } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBasicInputStyle(token2),
      // Variants
      ...genOutlinedStyle(token2),
      ...genFilledStyle(token2),
      ...genBorderlessStyle2(token2),
      ...genUnderlinedStyle(token2),
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        appearance: "none"
      }
    }
  };
};
var genAllowClearStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      padding: 0,
      lineHeight: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      border: "none",
      outline: "none",
      backgroundColor: "transparent",
      "&:hover": {
        color: token2.colorIcon
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${unit(token2.inputAffixPadding)}`
      }
    }
  };
};
var genAffixStyle = (token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  const affixCls = `${componentCls}-affix-wrapper`;
  const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
  return {
    [affixCls]: {
      ...genBasicInputStyle(token2),
      display: "inline-flex",
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${componentCls}`]: {
        padding: 0
      },
      [`> input${componentCls}, > textarea${componentCls}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [componentCls]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription,
          direction: "ltr"
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      },
      ...genAllowClearStyle(token2),
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    },
    //  affix-wrapper borderRadius
    [`${componentCls}-underlined`]: {
      borderRadius: 0
    },
    [affixClsDisabled]: {
      // password disabled
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "not-allowed",
        "&:hover": {
          color: colorIcon
        }
      }
    }
  };
};
var genGroupStyle3 = (token2) => {
  const {
    componentCls,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: {
      // Style for input-group: input with label, with button or dropdown...
      ...resetComponent(token2),
      ...genInputGroupStyle(token2),
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design/issues/6403
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG,
            fontSize: token2.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        // Variants
        ...genOutlinedGroupStyle(token2),
        ...genFilledGroupStyle(token2),
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        // Fix the issue of input use `addonAfter` param in space compact mode
        // https://github.com/ant-design/ant-design/issues/52483
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      }
    }
  };
};
var genRangeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-out-of-range`]: {
      [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
        color: token2.colorError
      }
    }
  };
};
var useSharedStyle = genStyleHooks(["Input", "Shared"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return [genInputStyle(inputToken), genAffixStyle(inputToken)];
}, initComponentToken, {
  resetFont: false
});
var style_default24 = genStyleHooks(["Input", "Component"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return [
    genGroupStyle3(inputToken),
    genRangeStyle(inputToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputToken)
  ];
}, initComponentToken, {
  resetFont: false
});

// node_modules/antd/es/date-picker/style/util.js
var getMultipleSelectorUnit = (token2) => {
  const {
    multipleSelectItemHeight,
    paddingXXS,
    lineWidth,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2;
  const basePadding = token2.max(token2.calc(paddingXXS).sub(lineWidth).equal(), 0);
  const containerPadding = token2.max(token2.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
  return {
    basePadding,
    containerPadding,
    itemHeight: unit(multipleSelectItemHeight),
    itemLineHeight: unit(token2.calc(multipleSelectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal())
  };
};
var genOverflowStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    borderRadiusSM,
    motionDurationSlow,
    paddingXS,
    multipleItemColorDisabled,
    multipleItemBorderColorDisabled,
    colorIcon,
    colorIconHover,
    INTERNAL_FIXED_ITEM_MARGIN
  } = token2;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [selectOverflowPrefixCls]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        // https://github.com/ant-design/ant-design/issues/54179
        maxWidth: "calc(100% - 4px)",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${componentCls}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
        borderRadius: borderRadiusSM,
        cursor: "default",
        transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
        marginInlineEnd: token2.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
        paddingInlineStart: paddingXS,
        paddingInlineEnd: token2.calc(paddingXS).div(2).equal(),
        [`${componentCls}-disabled&`]: {
          color: multipleItemColorDisabled,
          borderColor: multipleItemBorderColorDisabled,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token2.calc(paddingXS).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": {
          ...resetIcon(),
          display: "inline-flex",
          alignItems: "center",
          color: colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: colorIconHover
          }
        }
      }
    }
  };
};

// node_modules/antd/es/date-picker/style/multiple.js
var genSize = (token2, suffix) => {
  const {
    componentCls,
    controlHeight
  } = token2;
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  const multipleSelectorUnit = getMultipleSelectorUnit(token2);
  return [
    // genSelectionStyle(token, suffix),
    {
      [`${componentCls}-multiple${suffixCls}`]: {
        paddingBlock: multipleSelectorUnit.containerPadding,
        paddingInlineStart: multipleSelectorUnit.basePadding,
        minHeight: controlHeight,
        // ======================== Selections ========================
        [`${componentCls}-selection-item`]: {
          height: multipleSelectorUnit.itemHeight,
          lineHeight: unit(multipleSelectorUnit.itemLineHeight)
        }
      }
    }
  ];
};
var genPickerMultipleStyle = (token2) => {
  const {
    componentCls,
    calc,
    lineWidth
  } = token2;
  const smallToken = merge2(token2, {
    fontHeight: token2.fontSize,
    selectHeight: token2.controlHeightSM,
    multipleSelectItemHeight: token2.multipleItemHeightSM,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS,
    controlHeight: token2.controlHeightSM
  });
  const largeToken = merge2(token2, {
    fontHeight: calc(token2.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
    fontSize: token2.fontSizeLG,
    selectHeight: token2.controlHeightLG,
    multipleSelectItemHeight: token2.multipleItemHeightLG,
    borderRadius: token2.borderRadiusLG,
    borderRadiusSM: token2.borderRadius,
    controlHeight: token2.controlHeightLG
  });
  return [
    // ======================== Size ========================
    genSize(smallToken, "small"),
    genSize(token2),
    genSize(largeToken, "large"),
    // ====================== Selection ======================
    {
      [`${componentCls}${componentCls}-multiple`]: {
        width: "100%",
        cursor: "text",
        // ==================== Selector =====================
        [`${componentCls}-selector`]: {
          flex: "auto",
          padding: 0,
          position: "relative",
          "&:after": {
            margin: 0
          },
          // ================== placeholder ==================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.inputPaddingHorizontalBase,
            insetInlineEnd: 0,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }
        },
        // ===================== Overflow ====================
        ...genOverflowStyle(token2),
        // ====================== Input ======================
        // Input is `readonly`, which is used for a11y only
        [`${componentCls}-multiple-input`]: {
          width: 0,
          height: 0,
          border: 0,
          visibility: "hidden",
          position: "absolute",
          zIndex: -1
        }
      }
    }
  ];
};
var multiple_default = genPickerMultipleStyle;

// node_modules/antd/es/date-picker/style/panel.js
var genPickerCellInnerStyle = (token2) => {
  const {
    pickerCellCls,
    pickerCellInnerCls,
    cellHeight,
    borderRadiusSM,
    motionDurationMid,
    cellHoverBg,
    lineWidth,
    lineType,
    colorPrimary,
    cellActiveWithRangeBg,
    colorTextLightSolid,
    colorTextDisabled,
    cellBgDisabled,
    colorFillSecondary
  } = token2;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: cellHeight,
      transform: "translateY(-50%)",
      content: '""',
      pointerEvents: "none"
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: cellHeight,
      height: cellHeight,
      lineHeight: unit(cellHeight),
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: {
      [pickerCellInnerCls]: {
        background: cellHoverBg
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${unit(lineWidth)} ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      position: "relative",
      [`&:not(${pickerCellCls}-disabled):before`]: {
        background: cellActiveWithRangeBg
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
      [`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
        color: colorTextLightSolid,
        background: colorPrimary
      },
      [`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: {
        background: colorFillSecondary
      }
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: {
      insetInlineEnd: "50%"
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      cursor: "not-allowed",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: cellBgDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
};
var genPanelStyle = (token2) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    cellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    textHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    cellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    motionDurationSlow,
    withoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    borderRadiusSM,
    colorTextLightSolid,
    cellHoverBg,
    timeColumnHeight,
    timeColumnWidth,
    timeCellHeight,
    controlItemBgActive,
    marginXXS,
    pickerDatePanelPaddingHorizontal,
    pickerControlIconMargin
  } = token2;
  const pickerPanelWidth = token2.calc(cellWidth).mul(7).add(token2.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          },
          [`${componentCls}-time-panel`]: {
            [`${componentCls}-content`]: {
              direction: "ltr",
              "> *": {
                direction: "rtl"
              }
            }
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${unit(paddingXS)}`,
        color: colorTextHeading,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: unit(textHeight),
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          fontSize: "inherit",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          "&:empty": {
            display: "none"
          }
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          },
          "&:disabled": {
            opacity: 0.25,
            pointerEvents: "none"
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: unit(textHeight),
          "> button": {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
        position: "relative",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: `0 solid currentcolor`,
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          content: '""'
        }
      },
      [`&-super-prev-icon,
        &-super-next-icon`]: {
        "&::after": {
          position: "absolute",
          top: pickerControlIconMargin,
          insetInlineStart: pickerControlIconMargin,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          content: '""'
        }
      },
      "&-prev-icon, &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon, &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: cellHeight,
          fontWeight: "normal"
        },
        th: {
          height: token2.calc(cellHeight).add(token2.calc(pickerCellPaddingVertical).mul(2)).equal(),
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": {
        padding: `${unit(pickerCellPaddingVertical)} 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        },
        ...genPickerCellInnerStyle(token2)
      },
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-content`]: {
          height: token2.calc(withoutTimeCellHeight).mul(4).equal()
        },
        [pickerCellInnerCls]: {
          padding: `0 ${unit(paddingXS)}`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${unit(token2.calc(paddingXS).div(2).equal())}`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-body`]: {
          padding: `0 ${unit(paddingXS)}`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(pickerDatePanelPaddingHorizontal)}`
        },
        [`${componentCls}-content th`]: {
          boxSizing: "border-box",
          padding: 0
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel-row": {
        td: {
          "&:before": {
            transition: `background ${motionDurationMid}`
          },
          "&:first-child:before": {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM
          },
          "&:last-child:before": {
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          }
        },
        "&:hover td:before": {
          background: cellHoverBg
        },
        "&-range-start td, &-range-end td, &-selected td, &-hover td": {
          // Rise priority to override hover style
          [`&${pickerCellCls}`]: {
            "&:before": {
              background: colorPrimary
            },
            [`&${componentCls}-cell-week`]: {
              color: new FastColor(colorTextLightSolid).setA(0.5).toHexString()
            },
            [pickerCellInnerCls]: {
              color: colorTextLightSolid
            }
          }
        },
        "&-range-hover td:before": {
          background: controlItemBgActive
        }
      },
      // >>> ShowWeek
      "&-week-panel, &-date-panel-show-week": {
        [`${componentCls}-body`]: {
          padding: `${unit(paddingXS)} ${unit(paddingSM)}`
        },
        [`${componentCls}-content th`]: {
          width: "auto"
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: timeColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: timeColumnWidth,
          margin: `${unit(paddingXXS)} 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::-webkit-scrollbar": {
            width: 8,
            backgroundColor: "transparent"
          },
          "&::-webkit-scrollbar-thumb": {
            backgroundColor: token2.colorTextTertiary,
            borderRadius: token2.borderRadiusSM
          },
          // For Firefox
          "&": {
            scrollbarWidth: "thin",
            scrollbarColor: `${token2.colorTextTertiary} transparent`
          },
          "&::after": {
            display: "block",
            height: `calc(100% - ${unit(timeCellHeight)})`,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new FastColor(controlItemBgActive).setA(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: token2.calc(timeColumnWidth).sub(token2.calc(marginXXS).mul(2)).equal(),
                height: timeCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: token2.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                color: colorText,
                lineHeight: unit(timeCellHeight),
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: cellHoverBg
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      }
    }
  };
};
var genPickerPanelStyle = (token2) => {
  const {
    componentCls,
    textHeight,
    lineWidth,
    paddingSM,
    antCls,
    colorPrimary,
    cellActiveWithRangeBg,
    colorPrimaryBorder,
    lineType,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-dropdown`]: {
      // ======================== Footer ========================
      [`${componentCls}-footer`]: {
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-extra": {
          padding: `0 ${unit(paddingSM)}`,
          lineHeight: unit(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`
          }
        }
      },
      // ==================== Footer > Ranges ===================
      [`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: {
        justifyContent: "space-between"
      },
      [`${componentCls}-ranges`]: {
        marginBlock: 0,
        paddingInline: unit(paddingSM),
        overflow: "hidden",
        textAlign: "start",
        listStyle: "none",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        "> li": {
          lineHeight: unit(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
          display: "inline-block"
        },
        [`${componentCls}-now-btn-disabled`]: {
          pointerEvents: "none",
          color: token2.colorTextDisabled
        },
        // https://github.com/ant-design/ant-design/issues/23687
        [`${componentCls}-preset > ${antCls}-tag-blue`]: {
          color: colorPrimary,
          background: cellActiveWithRangeBg,
          borderColor: colorPrimaryBorder,
          cursor: "pointer"
        },
        [`${componentCls}-ok`]: {
          paddingBlock: token2.calc(lineWidth).mul(2).equal(),
          marginInlineStart: "auto"
        }
      }
    }
  };
};
var panel_default = genPickerPanelStyle;

// node_modules/antd/es/date-picker/style/token.js
var initPickerPanelToken = (token2) => {
  const {
    componentCls,
    controlHeightLG,
    paddingXXS,
    padding
  } = token2;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerYearMonthCellWidth: token2.calc(controlHeightLG).mul(1.5).equal(),
    pickerQuarterPanelContentHeight: token2.calc(controlHeightLG).mul(1.4).equal(),
    pickerCellPaddingVertical: token2.calc(paddingXXS).add(token2.calc(paddingXXS).div(2)).equal(),
    pickerCellBorderGap: 2,
    // Magic for gap between cells
    pickerControlIconSize: 7,
    pickerControlIconMargin: 4,
    pickerControlIconBorderWidth: 1.5,
    pickerDatePanelPaddingHorizontal: token2.calc(padding).add(token2.calc(paddingXXS).div(2)).equal()
    // 18 in normal
  };
};
var initPanelComponentToken = (token2) => {
  const {
    colorBgContainerDisabled,
    controlHeight,
    controlHeightSM,
    controlHeightLG,
    paddingXXS,
    lineWidth
  } = token2;
  const dblPaddingXXS = paddingXXS * 2;
  const dblLineWidth = lineWidth * 2;
  const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
  const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
  const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
  const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
  const filledToken = {
    INTERNAL_FIXED_ITEM_MARGIN,
    cellHoverBg: token2.controlItemBgHover,
    cellActiveWithRangeBg: token2.controlItemBgActive,
    cellHoverWithRangeBg: new FastColor(token2.colorPrimary).lighten(35).toHexString(),
    cellRangeBorderColor: new FastColor(token2.colorPrimary).lighten(20).toHexString(),
    cellBgDisabled: colorBgContainerDisabled,
    timeColumnWidth: controlHeightLG * 1.4,
    timeColumnHeight: 28 * 8,
    timeCellHeight: 28,
    cellWidth: controlHeightSM * 1.5,
    cellHeight: controlHeightSM,
    textHeight: controlHeightLG,
    withoutTimeCellHeight: controlHeightLG * 1.65,
    multipleItemBg: token2.colorFillSecondary,
    multipleItemBorderColor: "transparent",
    multipleItemHeight,
    multipleItemHeightSM,
    multipleItemHeightLG,
    multipleSelectorBgDisabled: colorBgContainerDisabled,
    multipleItemColorDisabled: token2.colorTextDisabled,
    multipleItemBorderColorDisabled: "transparent"
  };
  return filledToken;
};
var prepareComponentToken22 = (token2) => ({
  ...initComponentToken(token2),
  ...initPanelComponentToken(token2),
  ...getArrowToken(token2),
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token2.zIndexPopupBase + 50
});

// node_modules/antd/es/date-picker/style/variants.js
var genVariantsStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: [
      {
        ...genOutlinedStyle(token2),
        ...genUnderlinedStyle(token2),
        ...genFilledStyle(token2),
        ...genBorderlessStyle2(token2)
      },
      // ========================= Multiple =========================
      {
        "&-outlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        },
        "&-filled": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.colorBgContainer,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          }
        },
        "&-borderless": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        },
        "&-underlined": {
          [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
            background: token2.multipleItemBg,
            border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
          }
        }
      }
    ]
  };
};
var variants_default = genVariantsStyle;

// node_modules/antd/es/date-picker/style/index.js
var genPickerPadding = (paddingBlock, paddingInline) => {
  return {
    padding: `${unit(paddingBlock)} ${unit(paddingInline)}`
  };
};
var genPickerStatusStyle = (token2) => {
  const {
    componentCls,
    colorError,
    colorWarning
  } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
      [`&${componentCls}-status-error`]: {
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&${componentCls}-status-warning`]: {
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
};
var genPickerStyle = (token2) => {
  const {
    componentCls,
    antCls,
    paddingInline,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorTextDisabled,
    colorTextPlaceholder,
    colorTextQuaternary,
    fontSizeLG,
    inputFontSizeLG,
    fontSizeSM,
    inputFontSizeSM,
    controlHeightSM,
    paddingInlineSM,
    paddingXS,
    marginXS,
    colorIcon,
    lineWidthBold,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    sizePopupArrow,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    cellHoverBg,
    presetsWidth,
    presetsMaxWidth,
    boxShadowPopoverArrow,
    fontHeight,
    lineHeightLG
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...genPickerPadding(token2.paddingBlock, token2.paddingInline),
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        lineHeight: 1,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
        [`${componentCls}-prefix`]: {
          flex: "0 0 auto",
          marginInlineEnd: token2.inputAffixPadding
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": {
            position: "relative",
            display: "inline-block",
            width: "100%",
            color: "inherit",
            fontSize: token2.inputFontSize ?? token2.fontSize,
            lineHeight: token2.lineHeight,
            transition: `all ${motionDurationMid}`,
            ...genPlaceholderStyle(colorTextPlaceholder),
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            fontFamily: "inherit",
            "&:focus": {
              boxShadow: "none",
              outline: 0
            },
            "&[disabled]": {
              background: "transparent",
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": {
          ...genPickerPadding(token2.paddingBlockLG, token2.paddingInlineLG),
          borderRadius: token2.borderRadiusLG,
          [`${componentCls}-input > input`]: {
            fontSize: inputFontSizeLG ?? fontSizeLG,
            lineHeight: lineHeightLG
          }
        },
        "&-small": {
          ...genPickerPadding(token2.paddingBlockSM, token2.paddingInlineSM),
          borderRadius: token2.borderRadiusSM,
          [`${componentCls}-input > input`]: {
            fontSize: inputFontSizeSM ?? fontSizeSM
          }
        },
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: token2.calc(paddingXS).div(2).equal(),
          color: colorTextQuaternary,
          lineHeight: 1,
          pointerEvents: "none",
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextQuaternary,
          lineHeight: 1,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorIcon
          }
        },
        "&:hover": {
          [`${componentCls}-clear`]: {
            opacity: 1
          },
          // Should use the following selector, but since `:has` has poor compatibility,
          // we use `:not(:last-child)` instead, which may cause some problems in some cases.
          // [`${componentCls}-suffix:has(+ ${componentCls}-clear)`]: {
          [`${componentCls}-suffix:not(:last-child)`]: {
            opacity: 0
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextQuaternary,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorIcon
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: token2.calc(lineWidth).mul(-1).equal(),
            height: lineWidthBold,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${unit(paddingXS)}`,
            lineHeight: 1
          }
        },
        // ======================== Clear =========================
        "&-range, &-multiple": {
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: paddingInline
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: paddingInlineSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": {
          ...resetComponent(token2),
          ...genPanelStyle(token2),
          pointerEvents: "none",
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          "&-rtl": {
            direction: "rtl"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: {
            [`${componentCls}-range-arrow${componentCls}-range-arrow`]: {
              transition: "none"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          // https://github.com/ant-design/ant-design/issues/48727
          [`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: {
            pointerEvents: "none"
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: {
            position: "absolute",
            zIndex: 1,
            display: "none",
            paddingInline: token2.calc(paddingInline).mul(1.5).equal(),
            boxSizing: "content-box",
            transition: `all ${motionDurationSlow} ease-out`,
            ...genRoundedArrow(token2, colorBgElevated, boxShadowPopoverArrow),
            "&:before": {
              insetInlineStart: token2.calc(paddingInline).mul(1.5).equal()
            }
          },
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            display: "inline-block",
            pointerEvents: "auto",
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
                li: {
                  ...textEllipsis,
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: token2.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: cellHoverBg
                  }
                }
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              // [`${componentCls}-panel`]: {
              //   borderWidth: `0 0 ${unit(lineWidth)}`,
              // },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content, table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        },
        "&-dropdown-range": {
          padding: `${unit(token2.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "scale(-1, 1)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
var style_default25 = genStyleHooks("DatePicker", (token2) => {
  const pickerToken = merge2(initInputToken(token2), initPickerPanelToken(token2), {
    inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: token2.multipleItemHeight,
    selectHeight: token2.controlHeight
  });
  return [
    panel_default(pickerToken),
    genPickerStyle(pickerToken),
    variants_default(pickerToken),
    genPickerStatusStyle(pickerToken),
    multiple_default(pickerToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      focusElCls: `${token2.componentCls}-focused`
    })
  ];
}, prepareComponentToken22);

// node_modules/antd/es/calendar/style/index.js
var genCalendarStyles = (token2) => {
  const {
    calendarCls,
    componentCls,
    fullBg,
    fullPanelBg,
    itemActiveBg
  } = token2;
  return {
    [calendarCls]: {
      ...genPanelStyle(token2),
      ...resetComponent(token2),
      background: fullBg,
      "&-rtl": {
        direction: "rtl"
      },
      [`${calendarCls}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${unit(token2.paddingSM)} 0`,
        [`${calendarCls}-year-select`]: {
          minWidth: token2.yearControlWidth
        },
        [`${calendarCls}-month-select`]: {
          minWidth: token2.monthControlWidth,
          marginInlineStart: token2.marginXS
        },
        [`${calendarCls}-mode-switch`]: {
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${calendarCls} ${componentCls}-panel`]: {
      background: fullPanelBg,
      border: 0,
      borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
      borderRadius: 0,
      [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
        width: "auto"
      },
      [`${componentCls}-body`]: {
        padding: `${unit(token2.paddingXS)} 0`
      },
      [`${componentCls}-content`]: {
        width: "100%"
      }
    },
    [`${calendarCls}-mini`]: {
      borderRadius: token2.borderRadiusLG,
      [`${calendarCls}-header`]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS
      },
      [`${componentCls}-panel`]: {
        borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
      },
      [`${componentCls}-content`]: {
        height: token2.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: unit(token2.weekHeight)
        }
      },
      [`${componentCls}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${calendarCls}${calendarCls}-full`]: {
      [`${componentCls}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: fullBg,
        border: 0,
        [`${componentCls}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: token2.paddingSM,
            paddingBottom: token2.paddingXXS,
            lineHeight: unit(token2.weekHeight)
          }
        }
      },
      [`${componentCls}-cell-week ${componentCls}-cell-inner`]: {
        display: "block",
        borderRadius: 0,
        borderTop: `${unit(token2.lineWidthBold)} ${token2.lineType} ${token2.colorSplit}`,
        width: "100%",
        height: token2.calc(token2.dateValueHeight).add(token2.dateContentHeight).add(token2.calc(token2.paddingXS).div(2)).add(token2.lineWidthBold).equal()
      },
      [`${componentCls}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${calendarCls}-date`]: {
            background: token2.controlItemBgHover
          }
        },
        [`${calendarCls}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${componentCls}-cell-selected`]: {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            background: itemActiveBg
          }
        },
        "&-selected, &-selected:hover": {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            [`${calendarCls}-date-value`]: {
              color: token2.colorPrimary
            }
          }
        }
      },
      [`${calendarCls}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${unit(token2.calc(token2.marginXS).div(2).equal())}`,
        padding: `${unit(token2.calc(token2.paddingXS).div(2).equal())} ${unit(token2.paddingXS)} 0`,
        border: 0,
        borderTop: `${unit(token2.lineWidthBold)} ${token2.lineType} ${token2.colorSplit}`,
        borderRadius: 0,
        transition: `background ${token2.motionDurationSlow}`,
        "&-value": {
          lineHeight: unit(token2.dateValueHeight),
          transition: `color ${token2.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: token2.dateContentHeight,
          overflowY: "auto",
          color: token2.colorText,
          lineHeight: token2.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: token2.colorPrimary,
          [`${calendarCls}-date-value`]: {
            color: token2.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${unit(token2.screenXS)}) `]: {
      [calendarCls]: {
        [`${calendarCls}-header`]: {
          display: "block",
          [`${calendarCls}-year-select`]: {
            width: "50%"
          },
          [`${calendarCls}-month-select`]: {
            width: `calc(50% - ${unit(token2.paddingXS)})`
          },
          [`${calendarCls}-mode-switch`]: {
            width: "100%",
            marginTop: token2.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
};
var prepareComponentToken23 = (token2) => ({
  fullBg: token2.colorBgContainer,
  fullPanelBg: token2.colorBgContainer,
  itemActiveBg: token2.controlItemBgActive,
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256,
  ...initPanelComponentToken(token2)
});
var style_default26 = genStyleHooks("Calendar", (token2) => {
  const calendarCls = `${token2.componentCls}-calendar`;
  const calendarToken = merge2(token2, initPickerPanelToken(token2), {
    calendarCls,
    pickerCellInnerCls: `${token2.componentCls}-cell-inner`,
    dateValueHeight: token2.controlHeightSM,
    weekHeight: token2.calc(token2.controlHeightSM).mul(0.75).equal(),
    dateContentHeight: token2.calc(token2.calc(token2.fontHeightSM).add(token2.marginXS)).mul(3).add(token2.calc(token2.lineWidth).mul(2)).equal()
  });
  return genCalendarStyles(calendarToken);
}, prepareComponentToken23);

// node_modules/antd/es/calendar/generateCalendar.js
var isSameYear2 = (date1, date22, config) => {
  const {
    getYear: getYear2
  } = config;
  return date1 && date22 && getYear2(date1) === getYear2(date22);
};
var isSameMonth2 = (date1, date22, config) => {
  const {
    getMonth: getMonth2
  } = config;
  return isSameYear2(date1, date22, config) && getMonth2(date1) === getMonth2(date22);
};
var isSameDate2 = (date1, date22, config) => {
  const {
    getDate: getDate2
  } = config;
  return isSameMonth2(date1, date22, config) && getDate2(date1) === getDate2(date22);
};
var generateCalendar = (generateConfig2) => {
  const Calendar2 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      dateFullCellRender,
      dateCellRender,
      monthFullCellRender,
      monthCellRender,
      cellRender,
      fullCellRender,
      headerRender,
      value,
      defaultValue,
      disabledDate,
      mode,
      validRange,
      fullscreen = true,
      showWeek,
      onChange,
      onPanelChange,
      onSelect,
      styles,
      classNames
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("calendar");
    const mergedProps = {
      ...props,
      mode,
      fullscreen,
      showWeek
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const [rootCls, headerCls, panelClassNames, rootStyle, headerStyle, panelStyles] = React301.useMemo(() => {
      const {
        root: nextRootClassName,
        header: nextHeaderClassName,
        ...nextPanelClassNames
      } = mergedClassNames;
      const {
        root: nextRootStyle,
        header: nextHeaderStyle,
        ...nextPanelStyles
      } = mergedStyles;
      return [nextRootClassName, nextHeaderClassName, nextPanelClassNames, nextRootStyle, nextHeaderStyle, nextPanelStyles];
    }, [mergedClassNames, mergedStyles]);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const calendarPrefixCls = `${prefixCls}-calendar`;
    const [hashId, cssVarCls] = style_default26(prefixCls, calendarPrefixCls);
    const today = generateConfig2.getNow();
    if (true) {
      const warning5 = devUseWarning("Calendar");
      [["dateFullCellRender", "fullCellRender"], ["dateCellRender", "cellRender"], ["monthFullCellRender", "fullCellRender"], ["monthCellRender", "cellRender"]].forEach(([deprecatedName, newName]) => {
        warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
      });
    }
    const [mergedValue, setMergedValue] = useControlledState(() => defaultValue || generateConfig2.getNow(), value);
    const [mergedMode, setMergedMode] = useControlledState("month", mode);
    const panelMode = React301.useMemo(() => mergedMode === "year" ? "month" : "date", [mergedMode]);
    const mergedDisabledDate = React301.useCallback((date4) => {
      const notInRange = validRange ? generateConfig2.isAfter(validRange[0], date4) || generateConfig2.isAfter(date4, validRange[1]) : false;
      return notInRange || !!(disabledDate == null ? void 0 : disabledDate(date4));
    }, [disabledDate, validRange]);
    const triggerPanelChange = (date4, newMode) => {
      onPanelChange == null ? void 0 : onPanelChange(date4, newMode);
    };
    const triggerChange = (date4) => {
      setMergedValue(date4);
      if (!isSameDate2(date4, mergedValue, generateConfig2)) {
        if (panelMode === "date" && !isSameMonth2(date4, mergedValue, generateConfig2) || panelMode === "month" && !isSameYear2(date4, mergedValue, generateConfig2)) {
          triggerPanelChange(date4, mergedMode);
        }
        onChange == null ? void 0 : onChange(date4);
      }
    };
    const triggerModeChange = (newMode) => {
      setMergedMode(newMode);
      triggerPanelChange(mergedValue, newMode);
    };
    const onInternalSelect = (date4, source) => {
      triggerChange(date4);
      onSelect == null ? void 0 : onSelect(date4, {
        source
      });
    };
    const dateRender = React301.useCallback((date4, info) => {
      if (fullCellRender) {
        return fullCellRender(date4, info);
      }
      if (dateFullCellRender) {
        return dateFullCellRender(date4);
      }
      return React301.createElement("div", {
        className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
          [`${calendarPrefixCls}-date-today`]: isSameDate2(today, date4, generateConfig2)
        })
      }, React301.createElement("div", {
        className: `${calendarPrefixCls}-date-value`
      }, String(generateConfig2.getDate(date4)).padStart(2, "0")), React301.createElement("div", {
        className: `${calendarPrefixCls}-date-content`
      }, typeof cellRender === "function" ? cellRender(date4, info) : dateCellRender == null ? void 0 : dateCellRender(date4)));
    }, [today, prefixCls, calendarPrefixCls, fullCellRender, dateFullCellRender, cellRender, dateCellRender]);
    const monthRender = React301.useCallback((date4, info) => {
      if (fullCellRender) {
        return fullCellRender(date4, info);
      }
      if (monthFullCellRender) {
        return monthFullCellRender(date4);
      }
      const months = info.locale.shortMonths || generateConfig2.locale.getShortMonths(info.locale.locale);
      return React301.createElement("div", {
        className: clsx(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
          [`${calendarPrefixCls}-date-today`]: isSameMonth2(today, date4, generateConfig2)
        })
      }, React301.createElement("div", {
        className: `${calendarPrefixCls}-date-value`
      }, months[generateConfig2.getMonth(date4)]), React301.createElement("div", {
        className: `${calendarPrefixCls}-date-content`
      }, typeof cellRender === "function" ? cellRender(date4, info) : monthCellRender == null ? void 0 : monthCellRender(date4)));
    }, [today, prefixCls, calendarPrefixCls, fullCellRender, monthFullCellRender, cellRender, monthCellRender]);
    const [contextLocale] = useLocale_default("Calendar", en_US_default5);
    const locale6 = {
      ...contextLocale,
      ...props.locale
    };
    const mergedCellRender = (current, info) => {
      if (info.type === "date") {
        return dateRender(current, info);
      }
      if (info.type === "month") {
        return monthRender(current, {
          ...info,
          locale: locale6 == null ? void 0 : locale6.lang
        });
      }
    };
    return React301.createElement("div", {
      className: clsx(calendarPrefixCls, {
        [`${calendarPrefixCls}-full`]: fullscreen,
        [`${calendarPrefixCls}-mini`]: !fullscreen,
        [`${calendarPrefixCls}-rtl`]: direction === "rtl"
      }, contextClassName, className, rootClassName, rootCls, hashId, cssVarCls),
      style: {
        ...rootStyle,
        ...contextStyle,
        ...style2
      }
    }, headerRender ? headerRender({
      value: mergedValue,
      type: mergedMode,
      onChange: (nextDate) => {
        onInternalSelect(nextDate, "customize");
      },
      onTypeChange: triggerModeChange
    }) : React301.createElement(Header_default, {
      className: headerCls,
      style: headerStyle,
      prefixCls: calendarPrefixCls,
      value: mergedValue,
      generateConfig: generateConfig2,
      mode: mergedMode,
      fullscreen,
      locale: locale6 == null ? void 0 : locale6.lang,
      validRange,
      onChange: onInternalSelect,
      onModeChange: triggerModeChange
    }), React301.createElement(PickerPanel_default, {
      classNames: panelClassNames,
      styles: panelStyles,
      value: mergedValue,
      prefixCls,
      locale: locale6 == null ? void 0 : locale6.lang,
      generateConfig: generateConfig2,
      cellRender: mergedCellRender,
      onSelect: (nextDate) => {
        onInternalSelect(nextDate, panelMode);
      },
      mode: panelMode,
      picker: panelMode,
      disabledDate: mergedDisabledDate,
      hideHeader: true,
      showWeek
    }));
  };
  if (true) {
    Calendar2.displayName = "Calendar";
  }
  return Calendar2;
};
var generateCalendar_default = generateCalendar;

// node_modules/antd/es/calendar/index.js
var Calendar = generateCalendar_default(dayjs_default);
Calendar.generateCalendar = generateCalendar_default;
var calendar_default = Calendar;

// node_modules/antd/es/card/Card.js
var React317 = __toESM(require_react());

// node_modules/antd/es/tabs/index.js
var React315 = __toESM(require_react());

// node_modules/@rc-component/util/es/isMobile.js
var import_is_mobile = __toESM(require_is_mobile());
var cached2;
var isMobile_default = () => {
  if (typeof cached2 === "undefined") {
    cached2 = (0, import_is_mobile.default)();
  }
  return cached2;
};

// node_modules/@rc-component/tabs/es/Tabs.js
var React313 = __toESM(require_react());
var import_react118 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabContext.js
var import_react110 = __toESM(require_react());
var TabContext_default = (0, import_react110.createContext)(null);

// node_modules/@rc-component/tabs/es/TabNavList/Wrapper.js
var React310 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabNavList/index.js
var React309 = __toESM(require_react());
var import_react117 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/hooks/useIndicator.js
var import_react111 = __toESM(require_react());
var useIndicator = (options) => {
  const {
    activeTabOffset,
    horizontal,
    rtl,
    indicator = {}
  } = options;
  const {
    size,
    align = "center"
  } = indicator;
  const [inkStyle, setInkStyle] = (0, import_react111.useState)();
  const inkBarRafRef = (0, import_react111.useRef)();
  const getLength = import_react111.default.useCallback((origin) => {
    if (typeof size === "function") {
      return size(origin);
    }
    if (typeof size === "number") {
      return size;
    }
    return origin;
  }, [size]);
  function cleanInkBarRaf() {
    raf_default.cancel(inkBarRafRef.current);
  }
  (0, import_react111.useEffect)(() => {
    const newInkStyle = {};
    if (activeTabOffset) {
      if (horizontal) {
        newInkStyle.width = getLength(activeTabOffset.width);
        const key = rtl ? "right" : "left";
        if (align === "start") {
          newInkStyle[key] = activeTabOffset[key];
        }
        if (align === "center") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
          newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
        }
        if (align === "end") {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
          newInkStyle.transform = "translateX(-100%)";
        }
      } else {
        newInkStyle.height = getLength(activeTabOffset.height);
        if (align === "start") {
          newInkStyle.top = activeTabOffset.top;
        }
        if (align === "center") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
          newInkStyle.transform = "translateY(-50%)";
        }
        if (align === "end") {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
          newInkStyle.transform = "translateY(-100%)";
        }
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = raf_default(() => {
      const isEqual2 = inkStyle && newInkStyle && Object.keys(newInkStyle).every((key) => {
        const newValue = newInkStyle[key];
        const oldValue = inkStyle[key];
        return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
      });
      if (!isEqual2) {
        setInkStyle(newInkStyle);
      }
    });
    return cleanInkBarRaf;
  }, [JSON.stringify(activeTabOffset), horizontal, rtl, align, getLength]);
  return {
    style: inkStyle
  };
};
var useIndicator_default = useIndicator;

// node_modules/@rc-component/tabs/es/hooks/useOffsets.js
var import_react112 = __toESM(require_react());
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return (0, import_react112.useMemo)(() => {
    var _a, _b;
    const map = /* @__PURE__ */ new Map();
    const lastOffset = tabSizes.get((_a = tabs[0]) == null ? void 0 : _a.key) || DEFAULT_SIZE;
    const rightOffset = lastOffset.left + lastOffset.width;
    for (let i = 0; i < tabs.length; i += 1) {
      const {
        key
      } = tabs[i];
      let data = tabSizes.get(key);
      if (!data) {
        data = tabSizes.get((_b = tabs[i - 1]) == null ? void 0 : _b.key) || DEFAULT_SIZE;
      }
      const entity = map.get(key) || {
        ...data
      };
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    return map;
  }, [tabs.map((tab) => tab.key).join("_"), tabSizes, holderScrollWidth]);
}

// node_modules/@rc-component/tabs/es/hooks/useSyncState.js
var React303 = __toESM(require_react());
function useSyncState4(defaultState, onChange) {
  const stateRef = React303.useRef(defaultState);
  const [, forceUpdate] = React303.useState({});
  function setState(updater) {
    const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  return [stateRef.current, setState];
}

// node_modules/@rc-component/tabs/es/hooks/useTouchMove.js
var React304 = __toESM(require_react());
var import_react113 = __toESM(require_react());
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
function useTouchMove(ref, onOffset) {
  const [touchPosition, setTouchPosition] = (0, import_react113.useState)();
  const [lastTimestamp, setLastTimestamp] = (0, import_react113.useState)(0);
  const [lastTimeDiff, setLastTimeDiff] = (0, import_react113.useState)(0);
  const [lastOffset, setLastOffset] = (0, import_react113.useState)();
  const motionRef = (0, import_react113.useRef)();
  function onTouchStart(e3) {
    const {
      screenX,
      screenY
    } = e3.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }
  function onTouchMove(e3) {
    if (!touchPosition)
      return;
    const {
      screenX,
      screenY
    } = e3.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    const offsetX = screenX - touchPosition.x;
    const offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    const now2 = Date.now();
    setLastTimestamp(now2);
    setLastTimeDiff(now2 - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition)
      return;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffset) {
      const distanceX = lastOffset.x / lastTimeDiff;
      const distanceY = lastOffset.y / lastTimeDiff;
      const absX = Math.abs(distanceX);
      const absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      let currentX = distanceX;
      let currentY = distanceY;
      motionRef.current = window.setInterval(() => {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  const lastWheelDirectionRef = (0, import_react113.useRef)();
  function onWheel(e3) {
    const {
      deltaX,
      deltaY
    } = e3;
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e3.preventDefault();
    }
  }
  const touchEventsRef = (0, import_react113.useRef)(null);
  touchEventsRef.current = {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  };
  React304.useEffect(() => {
    function onProxyTouchStart(e3) {
      touchEventsRef.current.onTouchStart(e3);
    }
    function onProxyTouchMove(e3) {
      touchEventsRef.current.onTouchMove(e3);
    }
    function onProxyTouchEnd(e3) {
      touchEventsRef.current.onTouchEnd(e3);
    }
    function onProxyWheel(e3) {
      touchEventsRef.current.onWheel(e3);
    }
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: true
    });
    ref.current.addEventListener("touchstart", onProxyTouchStart, {
      passive: true
    });
    ref.current.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", onProxyTouchMove);
      document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}

// node_modules/@rc-component/tabs/es/hooks/useUpdate.js
var import_react114 = __toESM(require_react());
function useUpdate(callback) {
  const [count, setCount] = (0, import_react114.useState)(0);
  const effectRef = (0, import_react114.useRef)(0);
  const callbackRef = (0, import_react114.useRef)();
  callbackRef.current = callback;
  useLayoutUpdateEffect(() => {
    var _a;
    (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef);
  }, [count]);
  return () => {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
function useUpdateState(defaultState) {
  const batchRef = (0, import_react114.useRef)([]);
  const [, forceUpdate] = (0, import_react114.useState)({});
  const state = (0, import_react114.useRef)(typeof defaultState === "function" ? defaultState() : defaultState);
  const flushUpdate = useUpdate(() => {
    let current = state.current;
    batchRef.current.forEach((callback) => {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  return [state.current, updater];
}

// node_modules/@rc-component/tabs/es/hooks/useVisibleRange.js
var import_react115 = __toESM(require_react());
var DEFAULT_SIZE2 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, {
  tabs,
  tabPosition,
  rtl
}) {
  let charUnit;
  let position3;
  let transformSize;
  if (["top", "bottom"].includes(tabPosition)) {
    charUnit = "width";
    position3 = rtl ? "right" : "left";
    transformSize = Math.abs(transform);
  } else {
    charUnit = "height";
    position3 = "top";
    transformSize = -transform;
  }
  return (0, import_react115.useMemo)(() => {
    if (!tabs.length) {
      return [0, 0];
    }
    const len = tabs.length;
    let endIndex = len;
    for (let i = 0; i < len; i += 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (Math.floor(offset3[position3] + offset3[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
        endIndex = i - 1;
        break;
      }
    }
    let startIndex = 0;
    for (let i = len - 1; i >= 0; i -= 1) {
      const offset3 = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE2;
      if (offset3[position3] < transformSize) {
        startIndex = i + 1;
        break;
      }
    }
    return startIndex > endIndex ? [0, -1] : [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map((tab) => tab.key).join("_"), rtl]);
}

// node_modules/@rc-component/tabs/es/util.js
function stringify3(obj) {
  let tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach((v, k) => {
      tgt[k] = v;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function getRemovable(closable, closeIcon, editable, disabled) {
  if (
    // Only editable tabs can be removed
    !editable || // Tabs cannot be removed when disabled
    disabled || // closable is false
    closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    closable === void 0 && (closeIcon === false || closeIcon === null)
  ) {
    return false;
  }
  return true;
}

// node_modules/@rc-component/tabs/es/TabNavList/AddButton.js
var React305 = __toESM(require_react());
var AddButton = React305.forwardRef((props, ref) => {
  const {
    prefixCls,
    editable,
    locale: locale6,
    style: style2
  } = props;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return React305.createElement("button", {
    ref,
    type: "button",
    className: `${prefixCls}-nav-add`,
    style: style2,
    "aria-label": (locale6 == null ? void 0 : locale6.addAriaLabel) || "Add tab",
    onClick: (event) => {
      editable.onEdit("add", {
        event
      });
    }
  }, editable.addIcon || "+");
});
var AddButton_default = AddButton;

// node_modules/@rc-component/tabs/es/TabNavList/ExtraContent.js
var React306 = __toESM(require_react());
var ExtraContent = React306.forwardRef((props, ref) => {
  const {
    position: position3,
    prefixCls,
    extra
  } = props;
  if (!extra) {
    return null;
  }
  let content;
  let assertExtra = {};
  if (typeof extra === "object" && !React306.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position3 === "right") {
    content = assertExtra.right;
  }
  if (position3 === "left") {
    content = assertExtra.left;
  }
  return content ? React306.createElement("div", {
    className: `${prefixCls}-extra-content`,
    ref
  }, content) : null;
});
if (true) {
  ExtraContent.displayName = "ExtraContent";
}
var ExtraContent_default = ExtraContent;

// node_modules/@rc-component/tabs/es/TabNavList/OperationNode.js
var React307 = __toESM(require_react());
var import_react116 = __toESM(require_react());
function _extends51() {
  _extends51 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends51.apply(this, arguments);
}
var OperationNode = React307.forwardRef((props, ref) => {
  const {
    prefixCls,
    id,
    tabs,
    locale: locale6,
    mobile,
    more: moreProps = {},
    style: style2,
    className,
    editable,
    tabBarGutter,
    rtl,
    removeAriaLabel,
    onTabClick,
    getPopupContainer,
    popupClassName,
    popupStyle
  } = props;
  const [open3, setOpen] = (0, import_react116.useState)(false);
  const [selectedKey, setSelectedKey] = (0, import_react116.useState)(null);
  const {
    icon: moreIcon = "More"
  } = moreProps;
  const popupId = `${id}-more-popup`;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const selectedItemId = selectedKey !== null ? `${popupId}-${selectedKey}` : null;
  const dropdownAriaLabel = locale6 == null ? void 0 : locale6.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  const menu = React307.createElement(es_default15, {
    onClick: ({
      key,
      domEvent
    }) => {
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: `${dropdownPrefix}-menu`,
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
  }, tabs.map((tab) => {
    const {
      closable,
      disabled,
      closeIcon,
      key,
      label
    } = tab;
    const removable = getRemovable(closable, closeIcon, editable, disabled);
    return React307.createElement(MenuItem_default, {
      key,
      id: `${popupId}-${key}`,
      role: "option",
      "aria-controls": id && `${id}-panel-${key}`,
      disabled
    }, React307.createElement("span", null, label), removable && React307.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: `${dropdownPrefix}-menu-item-remove`,
      onClick: (e3) => {
        e3.stopPropagation();
        onRemoveTab(e3, key);
      }
    }, closeIcon || editable.removeIcon || ""));
  }));
  function selectOffset(offset3) {
    const enabledTabs = tabs.filter((tab) => !tab.disabled);
    let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey) || 0;
    const len = enabledTabs.length;
    for (let i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset3 + len) % len;
      const tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  function onKeyDown2(e3) {
    const {
      which
    } = e3;
    if (!open3) {
      if ([KeyCode_default.DOWN, KeyCode_default.SPACE, KeyCode_default.ENTER].includes(which)) {
        setOpen(true);
        e3.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode_default.UP:
        selectOffset(-1);
        e3.preventDefault();
        break;
      case KeyCode_default.DOWN:
        selectOffset(1);
        e3.preventDefault();
        break;
      case KeyCode_default.ESC:
        setOpen(false);
        break;
      case KeyCode_default.SPACE:
      case KeyCode_default.ENTER:
        if (selectedKey !== null) {
          onTabClick(selectedKey, e3);
        }
        break;
    }
  }
  (0, import_react116.useEffect)(() => {
    const ele = document.getElementById(selectedItemId);
    if (ele == null ? void 0 : ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedItemId, selectedKey]);
  (0, import_react116.useEffect)(() => {
    if (!open3) {
      setSelectedKey(null);
    }
  }, [open3]);
  const moreStyle = {
    marginInlineStart: tabBarGutter
  };
  if (!tabs.length) {
    moreStyle.visibility = "hidden";
    moreStyle.order = 1;
  }
  const overlayClassName = clsx(popupClassName, {
    [`${dropdownPrefix}-rtl`]: rtl
  });
  const moreNode = mobile ? null : React307.createElement(es_default14, _extends51({
    prefixCls: dropdownPrefix,
    overlay: menu,
    visible: tabs.length ? open3 : false,
    onVisibleChange: setOpen,
    overlayClassName,
    overlayStyle: popupStyle,
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer
  }, moreProps), React307.createElement("button", {
    type: "button",
    className: `${prefixCls}-nav-more`,
    style: moreStyle,
    "aria-haspopup": "listbox",
    "aria-controls": popupId,
    id: `${id}-more`,
    "aria-expanded": open3,
    onKeyDown: onKeyDown2
  }, moreIcon));
  return React307.createElement("div", {
    className: clsx(`${prefixCls}-nav-operations`, className),
    style: style2,
    ref
  }, moreNode, React307.createElement(AddButton_default, {
    prefixCls,
    locale: locale6,
    editable
  }));
});
var OperationNode_default = React307.memo(OperationNode, (_, next2) => (
  // https://github.com/ant-design/ant-design/issues/32544
  // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
  next2.tabMoving
));

// node_modules/@rc-component/tabs/es/TabNavList/TabNode.js
var React308 = __toESM(require_react());
var TabNode = (props) => {
  const {
    prefixCls,
    id,
    active,
    focus,
    tab: {
      key,
      label,
      disabled,
      closeIcon,
      icon
    },
    closable,
    renderWrapper,
    removeAriaLabel,
    editable,
    onClick,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onMouseDown,
    onMouseUp,
    style: style2,
    className,
    tabCount,
    currentPosition
  } = props;
  const tabPrefix = `${prefixCls}-tab`;
  const removable = getRemovable(closable, closeIcon, editable, disabled);
  function onInternalClick(e3) {
    if (disabled) {
      return;
    }
    onClick(e3);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  const labelNode = React308.useMemo(() => icon && typeof label === "string" ? React308.createElement("span", null, label) : label, [label, icon]);
  const btnRef = React308.useRef(null);
  React308.useEffect(() => {
    if (focus && btnRef.current) {
      btnRef.current.focus();
    }
  }, [focus]);
  const node2 = React308.createElement("div", {
    key,
    "data-node-key": genDataNodeKey(key),
    className: clsx(tabPrefix, className, {
      [`${tabPrefix}-with-remove`]: removable,
      [`${tabPrefix}-active`]: active,
      [`${tabPrefix}-disabled`]: disabled,
      [`${tabPrefix}-focus`]: focus
    }),
    style: style2,
    onClick: onInternalClick
  }, React308.createElement("div", {
    ref: btnRef,
    role: "tab",
    "aria-selected": active,
    id: id && `${id}-tab-${key}`,
    className: `${tabPrefix}-btn`,
    "aria-controls": id && `${id}-panel-${key}`,
    "aria-disabled": disabled,
    tabIndex: disabled ? null : active ? 0 : -1,
    onClick: (e3) => {
      e3.stopPropagation();
      onInternalClick(e3);
    },
    onKeyDown: onKeyDown2,
    onMouseDown,
    onMouseUp,
    onFocus,
    onBlur
  }, focus && React308.createElement("div", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, `Tab ${currentPosition} of ${tabCount}`), icon && React308.createElement("span", {
    className: `${tabPrefix}-icon`
  }, icon), label && labelNode), removable && React308.createElement("button", {
    type: "button",
    "aria-label": removeAriaLabel || "remove",
    tabIndex: active ? 0 : -1,
    className: `${tabPrefix}-remove`,
    onClick: (e3) => {
      e3.stopPropagation();
      onRemoveTab(e3);
    }
  }, closeIcon || editable.removeIcon || ""));
  return renderWrapper ? renderWrapper(node2) : node2;
};
var TabNode_default = TabNode;

// node_modules/@rc-component/tabs/es/TabNavList/index.js
function _extends52() {
  _extends52 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends52.apply(this, arguments);
}
var getTabSize = (tab, containerRect) => {
  const {
    offsetWidth,
    offsetHeight,
    offsetTop,
    offsetLeft
  } = tab;
  const {
    width,
    height,
    left,
    top
  } = tab.getBoundingClientRect();
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, left - containerRect.left, top - containerRect.top];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
};
var getSize = (refObj) => {
  const {
    offsetWidth = 0,
    offsetHeight = 0
  } = refObj.current || {};
  if (refObj.current) {
    const {
      width,
      height
    } = refObj.current.getBoundingClientRect();
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height];
    }
  }
  return [offsetWidth, offsetHeight];
};
var getUnitValue = (size, tabPositionTopOrBottom) => {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
var TabNavList = React309.forwardRef((props, ref) => {
  const {
    className,
    style: style2,
    id,
    animated,
    activeKey,
    rtl,
    extra,
    editable,
    locale: locale6,
    tabPosition,
    tabBarGutter,
    children,
    onTabClick,
    onTabScroll,
    indicator,
    classNames: tabsClassNames,
    styles
  } = props;
  const {
    prefixCls,
    tabs
  } = React309.useContext(TabContext_default);
  const containerRef = (0, import_react117.useRef)(null);
  const extraLeftRef = (0, import_react117.useRef)(null);
  const extraRightRef = (0, import_react117.useRef)(null);
  const tabsWrapperRef = (0, import_react117.useRef)(null);
  const tabListRef = (0, import_react117.useRef)(null);
  const operationsRef = (0, import_react117.useRef)(null);
  const innerAddButtonRef = (0, import_react117.useRef)(null);
  const tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
  const [transformLeft, setTransformLeft] = useSyncState4(0, (next2, prev2) => {
    if (tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "left" : "right"
      });
    }
  });
  const [transformTop, setTransformTop] = useSyncState4(0, (next2, prev2) => {
    if (!tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "top" : "bottom"
      });
    }
  });
  const [containerExcludeExtraSize, setContainerExcludeExtraSize] = (0, import_react117.useState)([0, 0]);
  const [tabContentSize, setTabContentSize] = (0, import_react117.useState)([0, 0]);
  const [addSize, setAddSize] = (0, import_react117.useState)([0, 0]);
  const [operationSize, setOperationSize] = (0, import_react117.useState)([0, 0]);
  const [tabSizes, setTabSizes] = useUpdateState(/* @__PURE__ */ new Map());
  const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
  const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
  const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
  const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;
  let transformMin = 0;
  let transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
  const touchMovingRef = (0, import_react117.useRef)(null);
  const [lockAnimation, setLockAnimation] = (0, import_react117.useState)();
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    if (touchMovingRef.current) {
      clearTimeout(touchMovingRef.current);
    }
  }
  useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
    function doMove(setState, offset3) {
      setState((value) => {
        const newValue = alignInRange(value + offset3);
        return newValue;
      });
    }
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  (0, import_react117.useEffect)(() => {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = setTimeout(() => {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);
  const [visibleStart, visibleEnd] = useVisibleRange(
    tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue,
    {
      ...props,
      tabs
    }
  );
  const scrollToTab = useEvent_default((key = activeKey) => {
    const tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      let newTransform = transformLeft;
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      let newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(newTransform));
    }
  });
  const [focusKey, setFocusKey] = (0, import_react117.useState)();
  const [isMouse, setIsMouse] = (0, import_react117.useState)(false);
  const enabledTabs = tabs.filter((tab) => !tab.disabled).map((tab) => tab.key);
  const onOffset = (offset3) => {
    const currentIndex = enabledTabs.indexOf(focusKey || activeKey);
    const len = enabledTabs.length;
    const nextIndex = (currentIndex + offset3 + len) % len;
    const newKey = enabledTabs[nextIndex];
    setFocusKey(newKey);
  };
  const handleRemoveTab = (removalTabKey, e3) => {
    const removeIndex = enabledTabs.indexOf(removalTabKey);
    const removeTab = tabs.find((tab) => tab.key === removalTabKey);
    const removable = getRemovable(removeTab == null ? void 0 : removeTab.closable, removeTab == null ? void 0 : removeTab.closeIcon, editable, removeTab == null ? void 0 : removeTab.disabled);
    if (removable) {
      e3.preventDefault();
      e3.stopPropagation();
      editable.onEdit("remove", {
        key: removalTabKey,
        event: e3
      });
      if (removeIndex === enabledTabs.length - 1) {
        onOffset(-1);
      } else {
        onOffset(1);
      }
    }
  };
  const handleMouseDown = (key, e3) => {
    setIsMouse(true);
    if (e3.button === 1) {
      handleRemoveTab(key, e3);
    }
  };
  const handleKeyDown = (e3) => {
    const {
      code
    } = e3;
    const isRTL = rtl && tabPositionTopOrBottom;
    const firstEnabledTab = enabledTabs[0];
    const lastEnabledTab = enabledTabs[enabledTabs.length - 1];
    switch (code) {
      case "ArrowLeft": {
        if (tabPositionTopOrBottom) {
          onOffset(isRTL ? 1 : -1);
        }
        break;
      }
      case "ArrowRight": {
        if (tabPositionTopOrBottom) {
          onOffset(isRTL ? -1 : 1);
        }
        break;
      }
      case "ArrowUp": {
        e3.preventDefault();
        if (!tabPositionTopOrBottom) {
          onOffset(-1);
        }
        break;
      }
      case "ArrowDown": {
        e3.preventDefault();
        if (!tabPositionTopOrBottom) {
          onOffset(1);
        }
        break;
      }
      case "Home": {
        e3.preventDefault();
        setFocusKey(firstEnabledTab);
        break;
      }
      case "End": {
        e3.preventDefault();
        setFocusKey(lastEnabledTab);
        break;
      }
      case "Enter":
      case "Space": {
        e3.preventDefault();
        onTabClick(focusKey ?? activeKey, e3);
        break;
      }
      case "Backspace":
      case "Delete": {
        handleRemoveTab(focusKey, e3);
        break;
      }
    }
  };
  const tabNodeStyle = {};
  if (tabPositionTopOrBottom) {
    tabNodeStyle.marginInlineStart = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  const tabNodes = tabs.map((tab, i) => {
    const {
      key
    } = tab;
    return React309.createElement(TabNode_default, {
      id,
      prefixCls,
      key,
      tab,
      className: tabsClassNames == null ? void 0 : tabsClassNames.item,
      style: i === 0 ? styles == null ? void 0 : styles.item : {
        ...tabNodeStyle,
        ...styles == null ? void 0 : styles.item
      },
      closable: tab.closable,
      editable,
      active: key === activeKey,
      focus: key === focusKey,
      renderWrapper: children,
      removeAriaLabel: locale6 == null ? void 0 : locale6.removeAriaLabel,
      tabCount: enabledTabs.length,
      currentPosition: i + 1,
      onClick: (e3) => {
        onTabClick(key, e3);
      },
      onKeyDown: handleKeyDown,
      onFocus: () => {
        if (!isMouse) {
          setFocusKey(key);
        }
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      },
      onBlur: () => {
        setFocusKey(void 0);
      },
      onMouseDown: (e3) => handleMouseDown(key, e3),
      onMouseUp: () => {
        setIsMouse(false);
      }
    });
  });
  const updateTabSizes = () => setTabSizes(() => {
    var _a;
    const newSizes = /* @__PURE__ */ new Map();
    const listRect = (_a = tabListRef.current) == null ? void 0 : _a.getBoundingClientRect();
    tabs.forEach(({
      key
    }) => {
      var _a2;
      const btnNode = (_a2 = tabListRef.current) == null ? void 0 : _a2.querySelector(`[data-node-key="${genDataNodeKey(key)}"]`);
      if (btnNode) {
        const [width, height, left, top] = getTabSize(btnNode, listRect);
        newSizes.set(key, {
          width,
          height,
          left,
          top
        });
      }
    });
    return newSizes;
  });
  (0, import_react117.useEffect)(() => {
    updateTabSizes();
  }, [tabs.map((tab) => tab.key).join("_")]);
  const onListHolderResize = useUpdate(() => {
    const containerSize = getSize(containerRef);
    const extraLeftSize = getSize(extraLeftRef);
    const extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    const newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    const newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);
    const tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
    updateTabSizes();
  });
  const startHiddenTabs = tabs.slice(0, visibleStart);
  const endHiddenTabs = tabs.slice(visibleEnd + 1);
  const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];
  const activeTabOffset = tabOffsets.get(activeKey);
  const {
    style: indicatorStyle
  } = useIndicator_default({
    activeTabOffset,
    horizontal: tabPositionTopOrBottom,
    indicator,
    rtl
  });
  (0, import_react117.useEffect)(() => {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify3(activeTabOffset), stringify3(tabOffsets), tabPositionTopOrBottom]);
  (0, import_react117.useEffect)(() => {
    onListHolderResize();
  }, [rtl]);
  const hasDropdown = !!hiddenTabs.length;
  const wrapPrefix = `${prefixCls}-nav-wrap`;
  let pingLeft;
  let pingRight;
  let pingTop;
  let pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return React309.createElement(es_default, {
    onResize: onListHolderResize
  }, React309.createElement("div", {
    ref: useComposeRef(ref, containerRef),
    role: "tablist",
    "aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
    className: clsx(`${prefixCls}-nav`, className, tabsClassNames == null ? void 0 : tabsClassNames.header),
    style: {
      ...styles == null ? void 0 : styles.header,
      ...style2
    },
    onKeyDown: () => {
      doLockAnimation();
    }
  }, React309.createElement(ExtraContent_default, {
    ref: extraLeftRef,
    position: "left",
    extra,
    prefixCls
  }), React309.createElement(es_default, {
    onResize: onListHolderResize
  }, React309.createElement("div", {
    className: clsx(wrapPrefix, {
      [`${wrapPrefix}-ping-left`]: pingLeft,
      [`${wrapPrefix}-ping-right`]: pingRight,
      [`${wrapPrefix}-ping-top`]: pingTop,
      [`${wrapPrefix}-ping-bottom`]: pingBottom
    }),
    ref: tabsWrapperRef
  }, React309.createElement(es_default, {
    onResize: onListHolderResize
  }, React309.createElement("div", {
    ref: tabListRef,
    className: `${prefixCls}-nav-list`,
    style: {
      transform: `translate(${transformLeft}px, ${transformTop}px)`,
      transition: lockAnimation ? "none" : void 0
    }
  }, tabNodes, React309.createElement(AddButton_default, {
    ref: innerAddButtonRef,
    prefixCls,
    locale: locale6,
    editable,
    style: {
      ...tabNodes.length === 0 ? void 0 : tabNodeStyle,
      visibility: hasDropdown ? "hidden" : null
    }
  }), React309.createElement("div", {
    className: clsx(`${prefixCls}-ink-bar`, tabsClassNames == null ? void 0 : tabsClassNames.indicator, {
      [`${prefixCls}-ink-bar-animated`]: animated.inkBar
    }),
    style: {
      ...indicatorStyle,
      ...styles == null ? void 0 : styles.indicator
    }
  }))))), React309.createElement(OperationNode_default, _extends52({}, props, {
    removeAriaLabel: locale6 == null ? void 0 : locale6.removeAriaLabel,
    ref: operationsRef,
    prefixCls,
    tabs: hiddenTabs,
    className: !hasDropdown && operationsHiddenClassName,
    popupStyle: styles == null ? void 0 : styles.popup,
    tabMoving: !!lockAnimation
  })), React309.createElement(ExtraContent_default, {
    ref: extraRightRef,
    position: "right",
    extra,
    prefixCls
  })));
});
var TabNavList_default = TabNavList;

// node_modules/@rc-component/tabs/es/TabNavList/Wrapper.js
var TabNavListWrapper = ({
  renderTabBar,
  ...restProps
}) => {
  if (renderTabBar) {
    return renderTabBar(restProps, TabNavList_default);
  }
  return React310.createElement(TabNavList_default, restProps);
};
if (true) {
  TabNavListWrapper.displayName = "TabNavListWrapper";
}
var Wrapper_default = TabNavListWrapper;

// node_modules/@rc-component/tabs/es/TabPanelList/index.js
var React312 = __toESM(require_react());

// node_modules/@rc-component/tabs/es/TabPanelList/TabPane.js
var React311 = __toESM(require_react());
var TabPane = React311.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    style: style2,
    id,
    active,
    tabKey,
    children
  } = props;
  const hasContent2 = React311.Children.count(children) > 0;
  return React311.createElement("div", {
    id: id && `${id}-panel-${tabKey}`,
    role: "tabpanel",
    tabIndex: active && hasContent2 ? 0 : -1,
    "aria-labelledby": id && `${id}-tab-${tabKey}`,
    "aria-hidden": !active,
    style: style2,
    className: clsx(prefixCls, active && `${prefixCls}-active`, className),
    ref
  }, children);
});
if (true) {
  TabPane.displayName = "TabPane";
}
var TabPane_default = TabPane;

// node_modules/@rc-component/tabs/es/TabPanelList/index.js
function _extends53() {
  _extends53 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends53.apply(this, arguments);
}
var TabPanelList = (props) => {
  const {
    id,
    activeKey,
    animated,
    tabPosition,
    destroyOnHidden,
    contentStyle,
    contentClassName
  } = props;
  const {
    prefixCls,
    tabs
  } = React312.useContext(TabContext_default);
  const tabPaneAnimated = animated.tabPane;
  const tabPanePrefixCls = `${prefixCls}-tabpane`;
  return React312.createElement("div", {
    className: clsx(`${prefixCls}-content-holder`)
  }, React312.createElement("div", {
    className: clsx(`${prefixCls}-content`, `${prefixCls}-content-${tabPosition}`, {
      [`${prefixCls}-content-animated`]: tabPaneAnimated
    })
  }, tabs.map((item) => {
    const {
      key,
      forceRender,
      style: paneStyle,
      className: paneClassName,
      destroyOnHidden: itemDestroyOnHidden,
      ...restTabProps
    } = item;
    const active = key === activeKey;
    return React312.createElement(es_default2, _extends53({
      key,
      visible: active,
      forceRender,
      removeOnLeave: !!(destroyOnHidden ?? itemDestroyOnHidden),
      leavedClassName: `${tabPanePrefixCls}-hidden`
    }, animated.tabPaneMotion), ({
      style: motionStyle,
      className: motionClassName
    }, ref) => React312.createElement(TabPane_default, _extends53({}, restTabProps, {
      prefixCls: tabPanePrefixCls,
      id,
      tabKey: key,
      animated: tabPaneAnimated,
      active,
      style: {
        ...contentStyle,
        ...paneStyle,
        ...motionStyle
      },
      className: clsx(contentClassName, paneClassName, motionClassName),
      ref
    })));
  })));
};
var TabPanelList_default = TabPanelList;

// node_modules/@rc-component/tabs/es/hooks/useAnimateConfig.js
function useAnimateConfig(animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    if (true) {
      warning_default(false, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work.");
    }
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}

// node_modules/@rc-component/tabs/es/Tabs.js
function _extends54() {
  _extends54 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends54.apply(this, arguments);
}
var uuid5 = 0;
var Tabs = React313.forwardRef((props, ref) => {
  var _a;
  const {
    id,
    prefixCls = "rc-tabs",
    className,
    items,
    direction,
    activeKey,
    defaultActiveKey,
    editable,
    animated,
    tabPosition = "top",
    tabBarGutter,
    tabBarStyle,
    tabBarExtraContent,
    locale: locale6,
    more,
    destroyOnHidden,
    renderTabBar,
    onChange,
    onTabClick,
    onTabScroll,
    getPopupContainer,
    popupClassName,
    indicator,
    classNames: tabsClassNames,
    styles,
    ...restProps
  } = props;
  const tabs = React313.useMemo(() => (items || []).filter((item) => item && typeof item === "object" && "key" in item), [items]);
  const rtl = direction === "rtl";
  const mergedAnimated = useAnimateConfig(animated);
  const [mobile, setMobile] = (0, import_react118.useState)(false);
  (0, import_react118.useEffect)(() => {
    setMobile(isMobile_default());
  }, []);
  const [mergedActiveKey, setMergedActiveKey] = useControlledState(defaultActiveKey ?? ((_a = tabs[0]) == null ? void 0 : _a.key), activeKey);
  const [activeIndex, setActiveIndex] = (0, import_react118.useState)(() => tabs.findIndex((tab) => tab.key === mergedActiveKey));
  (0, import_react118.useEffect)(() => {
    var _a2;
    let newActiveIndex = tabs.findIndex((tab) => tab.key === mergedActiveKey);
    if (newActiveIndex === -1) {
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_a2 = tabs[newActiveIndex]) == null ? void 0 : _a2.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map((tab) => tab.key).join("_"), mergedActiveKey, activeIndex]);
  const [mergedId, setMergedId] = useControlledState(null, id);
  (0, import_react118.useEffect)(() => {
    if (!id) {
      setMergedId(`rc-tabs-${false ? "test" : uuid5}`);
      uuid5 += 1;
    }
  }, []);
  function onInternalTabClick(key, e3) {
    onTabClick == null ? void 0 : onTabClick(key, e3);
    const isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange == null ? void 0 : onChange(key);
    }
  }
  const sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  };
  const tabNavBarProps = {
    ...sharedProps,
    editable,
    locale: locale6,
    more,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    getPopupContainer,
    popupClassName: clsx(popupClassName, tabsClassNames == null ? void 0 : tabsClassNames.popup),
    indicator,
    styles,
    classNames: tabsClassNames
  };
  const memoizedValue = React313.useMemo(() => {
    return {
      tabs,
      prefixCls
    };
  }, [tabs, prefixCls]);
  return React313.createElement(TabContext_default.Provider, {
    value: memoizedValue
  }, React313.createElement("div", _extends54({
    ref,
    id,
    className: clsx(prefixCls, `${prefixCls}-${tabPosition}`, {
      [`${prefixCls}-mobile`]: mobile,
      [`${prefixCls}-editable`]: editable,
      [`${prefixCls}-rtl`]: rtl
    }, className)
  }, restProps), React313.createElement(Wrapper_default, _extends54({}, tabNavBarProps, {
    renderTabBar
  })), React313.createElement(TabPanelList_default, _extends54({
    destroyOnHidden
  }, sharedProps, {
    contentStyle: styles == null ? void 0 : styles.content,
    contentClassName: tabsClassNames == null ? void 0 : tabsClassNames.content,
    animated: mergedAnimated
  }))));
});
if (true) {
  Tabs.displayName = "Tabs";
}
var Tabs_default = Tabs;

// node_modules/@rc-component/tabs/es/index.js
var es_default18 = Tabs_default;

// node_modules/antd/es/tabs/hooks/useAnimateConfig.js
var motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig2(prefixCls, animated = {
  inkBar: true,
  tabPane: false
}) {
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = {
      inkBar: true,
      ...typeof animated === "object" ? animated : {}
    };
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = {
      ...motion,
      motionName: getTransitionName2(prefixCls, "switch")
    };
  }
  return mergedAnimated;
}

// node_modules/antd/es/tabs/hooks/useLegacyItems.js
var React314 = __toESM(require_react());
function filter2(items) {
  return items.filter((item) => item);
}
function useLegacyItems(items, children) {
  if (true) {
    const warning5 = devUseWarning("Tabs");
    warning5.deprecated(!children, "Tabs.TabPane", "items");
  }
  if (items) {
    return items.map((item) => ({
      ...item,
      destroyOnHidden: item.destroyOnHidden ?? item.destroyInactiveTabPane
    }));
  }
  const childrenItems = toArray(children).map((node2) => {
    if (React314.isValidElement(node2)) {
      const {
        key,
        props
      } = node2;
      const {
        tab,
        ...restProps
      } = props || {};
      const item = {
        key: String(key),
        ...restProps,
        label: tab
      };
      return item;
    }
    return null;
  });
  return filter2(childrenItems);
}
var useLegacyItems_default = useLegacyItems;

// node_modules/antd/es/tabs/style/motion.js
var genMotionStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
};
var motion_default2 = genMotionStyle;

// node_modules/antd/es/tabs/style/index.js
var genCardStyle = (token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardBg,
    cardGutter,
    colorBorderSecondary,
    itemSelectedColor
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardPadding,
          background: cardBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: itemSelectedColor,
          background: token2.colorBgContainer
        },
        [`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token2, -3),
        [`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: {
          outline: "none"
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: unit(cardGutter)
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: unit(cardGutter)
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token2.borderRadiusLG)} 0 0 ${unit(token2.borderRadiusLG)}`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
};
var genDropdownStyle = (token2) => {
  const {
    componentCls,
    itemHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token2;
  return {
    [`${componentCls}-dropdown`]: {
      ...resetComponent(token2),
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${unit(dropdownEdgeChildVerticalPadding)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": {
          ...textEllipsis,
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${unit(token2.paddingXXS)} ${unit(token2.paddingSM)}`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token2.marginSM
            },
            color: token2.colorIcon,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: itemHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        }
      }
    }
  };
};
var genPositionStyle = (token2) => {
  const {
    componentCls,
    margin,
    colorBorderSecondary,
    horizontalMargin,
    verticalItemPadding,
    verticalItemMargin,
    calc
  } = token2;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: horizontalMargin,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: margin,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: calc(token2.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: verticalItemPadding,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: verticalItemMargin
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: unit(calc(token2.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: true,
          value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: calc(token2.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: true,
          value: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    }
  };
};
var genSizeStyle = (token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardPaddingLG,
    cardHeightSM,
    cardHeightLG,
    horizontalItemPaddingSM,
    horizontalItemPaddingLG
  } = token2;
  return {
    // >>>>> shared
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingSM,
            fontSize: token2.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingLG,
            fontSize: token2.titleFontSizeLG,
            lineHeight: token2.lineHeightLG
          }
        }
      }
    },
    // >>>>> card
    [`${componentCls}-card`]: {
      // Small
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingSM
          },
          [`${componentCls}-nav-add`]: {
            minWidth: cardHeightSM,
            minHeight: cardHeightSM
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)}`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${unit(token2.borderRadius)} ${unit(token2.borderRadius)} 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${unit(token2.borderRadius)} 0 0 ${unit(token2.borderRadius)}`
            }
          }
        }
      },
      // Large
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingLG
          },
          [`${componentCls}-nav-add`]: {
            minWidth: cardHeightLG,
            minHeight: cardHeightLG
          }
        }
      }
    }
  };
};
var genTabStyle = (token2) => {
  const {
    componentCls,
    itemActiveColor,
    itemHoverColor,
    iconCls,
    tabsHorizontalItemMargin,
    horizontalItemPadding,
    itemSelectedColor,
    itemColor
  } = token2;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: horizontalItemPadding,
      fontSize: token2.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: itemColor,
      "&-btn, &-remove": {
        "&:focus:not(:focus-visible), &:active": {
          color: itemActiveColor
        }
      },
      "&-btn": {
        outline: "none",
        transition: `all ${token2.motionDurationSlow}`,
        [`${tabCls}-icon:not(:last-child)`]: {
          marginInlineEnd: token2.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        lineHeight: 1,
        marginRight: {
          _skip_check_: true,
          value: token2.calc(token2.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: true,
          value: token2.marginXS
        },
        color: token2.colorIcon,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        },
        ...genFocusStyle(token2)
      },
      "&:hover": {
        color: itemHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: itemSelectedColor
      },
      [`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token2),
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0,
        verticalAlign: "middle"
      },
      [`${iconCls}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: true,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: tabsHorizontalItemMargin
      }
    }
  };
};
var genRtlStyle = (token2) => {
  const {
    componentCls,
    tabsHorizontalItemMarginRTL,
    iconCls,
    cardGutter,
    calc
  } = token2;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: tabsHorizontalItemMarginRTL
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(token2.marginSM)
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: unit(token2.marginXS)
            },
            marginLeft: {
              _skip_check_: true,
              value: unit(calc(token2.marginXXS).mul(-1).equal())
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: cardGutter
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
var genTabsStyle = (token2) => {
  const {
    componentCls,
    tabsCardPadding,
    cardHeight,
    cardGutter,
    itemHoverColor,
    itemActiveColor,
    colorBorderSecondary
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardPadding,
          background: "transparent",
          border: 0,
          color: token2.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.calc(token2.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: {
          minWidth: cardHeight,
          minHeight: cardHeight,
          marginLeft: {
            _skip_check_: true,
            value: cardGutter
          },
          background: "transparent",
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: itemHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: itemActiveColor
          },
          ...genFocusStyle(token2, -3)
        }
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.inkBarColor,
        pointerEvents: "none"
      },
      // ============================= Tabs =============================
      ...genTabStyle(token2),
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        ...genFocusStyle(token2),
        "&-hidden": {
          display: "none"
        }
      }
    },
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
            margin: "auto"
          }
        }
      }
    }
  };
};
var prepareComponentToken24 = (token2) => {
  const {
    cardHeight,
    cardHeightSM,
    cardHeightLG,
    controlHeight,
    controlHeightLG
  } = token2;
  const mergedCardHeight = cardHeight || controlHeightLG;
  const mergedCardHeightSM = cardHeightSM || controlHeight;
  const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
  return {
    zIndexPopup: token2.zIndexPopupBase + 50,
    cardBg: token2.colorFillAlter,
    // We can not pass this as valid value,
    // Since `cardHeight` will lock nav add button height.
    cardHeight: mergedCardHeight,
    cardHeightSM: mergedCardHeightSM,
    cardHeightLG: mergedCardHeightLG,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(mergedCardHeight - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.padding}px`,
    cardPaddingSM: `${(mergedCardHeightSM - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.paddingXS}px`,
    cardPaddingLG: `${(mergedCardHeightLG - token2.fontHeightLG) / 2 - token2.lineWidth}px ${token2.padding}px`,
    titleFontSize: token2.fontSize,
    titleFontSizeLG: token2.fontSizeLG,
    titleFontSizeSM: token2.fontSize,
    inkBarColor: token2.colorPrimary,
    horizontalMargin: `0 0 ${token2.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: ``,
    horizontalItemMarginRTL: ``,
    horizontalItemPadding: `${token2.paddingSM}px 0`,
    horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
    horizontalItemPaddingLG: `${token2.padding}px 0`,
    verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
    verticalItemMargin: `${token2.margin}px 0 0 0`,
    itemColor: token2.colorText,
    itemSelectedColor: token2.colorPrimary,
    itemHoverColor: token2.colorPrimaryHover,
    itemActiveColor: token2.colorPrimaryActive,
    cardGutter: token2.marginXXS / 2
  };
};
var style_default27 = genStyleHooks("Tabs", (token2) => {
  const tabsToken = merge2(token2, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: token2.cardPadding,
    dropdownEdgeChildVerticalPadding: token2.paddingXXS,
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${unit(token2.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${unit(token2.horizontalItemGutter)}`
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), motion_default2(tabsToken)];
}, prepareComponentToken24);

// node_modules/antd/es/tabs/TabPane.js
var TabPane2 = () => null;
if (true) {
  TabPane2.displayName = "DeprecatedTabPane";
}
var TabPane_default2 = TabPane2;

// node_modules/antd/es/tabs/index.js
var InternalTabs = React315.forwardRef((props, ref) => {
  var _a, _b, _c, _d;
  const {
    type: type5,
    className,
    rootClassName,
    size: customSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    removeIcon,
    moreIcon,
    more,
    popupClassName,
    children,
    items,
    animated,
    style: style2,
    indicatorSize,
    indicator,
    classNames,
    styles,
    destroyInactiveTabPane,
    destroyOnHidden,
    tabPlacement,
    tabPosition,
    ...restProps
  } = props;
  const {
    prefixCls: customizePrefixCls
  } = restProps;
  const {
    getPrefixCls,
    direction,
    getPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tabs");
  const {
    tabs
  } = React315.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tabs", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default27(prefixCls, rootCls);
  const tabsRef = React315.useRef(null);
  React315.useImperativeHandle(ref, () => ({
    nativeElement: tabsRef.current
  }));
  let editable;
  if (type5 === "editable-card") {
    editable = {
      onEdit: (editType, {
        key,
        event
      }) => {
        onEdit == null ? void 0 : onEdit(editType === "add" ? event : key, editType);
      },
      removeIcon: removeIcon ?? (tabs == null ? void 0 : tabs.removeIcon) ?? React315.createElement(CloseOutlined_default, null),
      addIcon: (addIcon ?? (tabs == null ? void 0 : tabs.addIcon)) || React315.createElement(PlusOutlined_default, null),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  if (true) {
    const warning5 = devUseWarning("Tabs");
    [["popupClassName", "classNames.popup"], ["tabPosition", "tabPlacement"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    true ? warning5(!("onPrevClick" in props) && !("onNextClick" in props), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead.") : void 0;
    true ? warning5(!(indicatorSize || (tabs == null ? void 0 : tabs.indicatorSize)), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.") : void 0;
    warning5.deprecated(!("destroyInactiveTabPane" in props || (items == null ? void 0 : items.some((item) => "destroyInactiveTabPane" in item))), "destroyInactiveTabPane", "destroyOnHidden");
  }
  const size = useSize_default(customSize);
  const mergedItems = useLegacyItems_default(items, children);
  const mergedAnimated = useAnimateConfig2(prefixCls, animated);
  const mergedIndicator = {
    align: (indicator == null ? void 0 : indicator.align) ?? ((_a = tabs == null ? void 0 : tabs.indicator) == null ? void 0 : _a.align),
    size: (indicator == null ? void 0 : indicator.size) ?? indicatorSize ?? ((_b = tabs == null ? void 0 : tabs.indicator) == null ? void 0 : _b.size) ?? (tabs == null ? void 0 : tabs.indicatorSize)
  };
  const mergedPlacement = React315.useMemo(() => {
    const placement = tabPlacement ?? tabPosition ?? void 0;
    const isRTL = direction === "rtl";
    switch (placement) {
      case "start":
        return isRTL ? "right" : "left";
      case "end":
        return isRTL ? "left" : "right";
      default:
        return placement;
    }
  }, [tabPlacement, tabPosition, direction]);
  const mergedProps = {
    ...props,
    size,
    tabPlacement: mergedPlacement,
    items: mergedItems
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React315.createElement(es_default18, {
    ref: tabsRef,
    direction,
    getPopupContainer,
    ...restProps,
    items: mergedItems,
    className: clsx({
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-card`]: ["card", "editable-card"].includes(type5),
      [`${prefixCls}-editable-card`]: type5 === "editable-card",
      [`${prefixCls}-centered`]: centered
    }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls),
    classNames: {
      ...mergedClassNames,
      popup: clsx(popupClassName, hashId, cssVarCls, rootCls, (_c = mergedClassNames.popup) == null ? void 0 : _c.root)
    },
    styles: mergedStyles,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    editable,
    more: {
      icon: ((_d = tabs == null ? void 0 : tabs.more) == null ? void 0 : _d.icon) ?? (tabs == null ? void 0 : tabs.moreIcon) ?? moreIcon ?? React315.createElement(EllipsisOutlined_default, null),
      transitionName: `${rootPrefixCls}-slide-up`,
      ...more
    },
    prefixCls,
    animated: mergedAnimated,
    indicator: mergedIndicator,
    destroyOnHidden: destroyOnHidden ?? destroyInactiveTabPane,
    tabPosition: mergedPlacement
  });
});
var Tabs2 = InternalTabs;
Tabs2.TabPane = TabPane_default2;
if (true) {
  Tabs2.displayName = "Tabs";
}
var tabs_default = Tabs2;

// node_modules/antd/es/card/CardGrid.js
var React316 = __toESM(require_react());
var CardGrid = ({
  prefixCls,
  className,
  hoverable = true,
  ...props
}) => {
  const {
    getPrefixCls
  } = React316.useContext(ConfigContext);
  const prefix2 = getPrefixCls("card", prefixCls);
  const classString = clsx(`${prefix2}-grid`, className, {
    [`${prefix2}-grid-hoverable`]: hoverable
  });
  return React316.createElement("div", {
    ...props,
    className: classString
  });
};
if (true) {
  CardGrid.displayName = "CardGrid";
}
var CardGrid_default = CardGrid;

// node_modules/antd/es/card/style/index.js
var genCardHeadStyle = (token2) => {
  const {
    antCls,
    componentCls,
    headerHeight,
    headerPadding,
    tabsMarginBottom
  } = token2;
  return {
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: headerHeight,
    marginBottom: -1,
    // Fix card grid overflow bug: https://gw.alipayobjects.com/zos/rmsportal/XonYxBikwpgbqIQBeuhk.png
    padding: `0 ${unit(headerPadding)}`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.headerFontSize,
    background: token2.headerBg,
    borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`,
    ...clearFix(),
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": {
      display: "inline-block",
      flex: 1,
      ...textEllipsis,
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    },
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: tabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  };
};
var genCardGridStyle = (token2) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} ${unit(lineWidth)} 0 0 ${colorBorderSecondary},
      ${unit(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${unit(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
var genCardActionsStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    actionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary,
    actionsBg
  } = token2;
  return {
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: actionsBg,
    borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`,
    ...clearFix(),
    "& > li": {
      margin: actionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.calc(token2.cardActionsIconSize).mul(2).equal(),
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorIcon,
          lineHeight: unit(token2.fontHeight),
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: unit(token2.calc(cardActionsIconSize).mul(token2.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  };
};
var genCardMetaStyle = (token2) => ({
  margin: `${unit(token2.calc(token2.marginXXS).mul(-1).equal())} 0`,
  display: "flex",
  ...clearFix(),
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-section": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": {
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG,
    ...textEllipsis
  },
  "&-description": {
    color: token2.colorTextDescription
  }
});
var genCardTypeInnerStyle = (token2) => {
  const {
    componentCls,
    colorFillAlter,
    headerPadding,
    bodyPadding
  } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${unit(headerPadding)}`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${unit(token2.padding)} ${unit(bodyPadding)}`
    }
  };
};
var genCardLoadingStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
var genCardStyle2 = (token2) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    bodyPadding,
    extraColor
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: extraColor,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: {
        padding: bodyPadding,
        borderRadius: `0 0 ${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)}`
      },
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%",
          borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    },
    [`${componentCls}-bordered`]: {
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      borderRadius: `${unit(token2.borderRadiusLG)} ${unit(token2.borderRadiusLG)} 0 0 `,
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> div${componentCls}-head`]: {
        minHeight: 0,
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var genCardSizeStyle = (token2) => {
  const {
    componentCls,
    bodyPaddingSM,
    headerPaddingSM,
    headerHeightSM,
    headerFontSizeSM
  } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: headerHeightSM,
        padding: `0 ${unit(headerPaddingSM)}`,
        fontSize: headerFontSizeSM,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: bodyPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
var prepareComponentToken25 = (token2) => ({
  headerBg: "transparent",
  headerFontSize: token2.fontSizeLG,
  headerFontSizeSM: token2.fontSize,
  headerHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
  headerHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
  actionsBg: token2.colorBgContainer,
  actionsLiMargin: `${token2.paddingSM}px 0`,
  tabsMarginBottom: -token2.padding - token2.lineWidth,
  extraColor: token2.colorText,
  bodyPaddingSM: 12,
  // Fixed padding.
  headerPaddingSM: 12,
  bodyPadding: token2.bodyPadding ?? token2.paddingLG,
  headerPadding: token2.headerPadding ?? token2.paddingLG
});
var style_default28 = genStyleHooks("Card", (token2) => {
  const cardToken = merge2(token2, {
    cardShadow: token2.boxShadowCard,
    cardHeadPadding: token2.padding,
    cardPaddingBase: token2.paddingLG,
    cardActionsIconSize: token2.fontSize
  });
  return [
    // Style
    genCardStyle2(cardToken),
    // Size
    genCardSizeStyle(cardToken)
  ];
}, prepareComponentToken25);

// node_modules/antd/es/card/Card.js
var ActionNode = (props) => {
  const {
    actionClasses,
    actions = [],
    actionStyle
  } = props;
  return React317.createElement("ul", {
    className: actionClasses,
    style: actionStyle
  }, actions.map((action, index2) => {
    const key = `action-${index2}`;
    return React317.createElement("li", {
      style: {
        width: `${100 / actions.length}%`
      },
      key
    }, React317.createElement("span", null, action));
  }));
};
var Card = React317.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    extra,
    headStyle = {},
    bodyStyle = {},
    title,
    loading,
    bordered,
    variant: customVariant,
    size: customizeSize,
    type: type5,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {},
    classNames,
    styles,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("card");
  const [variant] = useVariants_default("card", customVariant, bordered);
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    variant,
    loading
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning5 = devUseWarning("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"], ["bordered", "variant"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const onTabChange = (key) => {
    var _a;
    (_a = props.onTabChange) == null ? void 0 : _a.call(props, key);
  };
  const isContainGrid = React317.useMemo(() => {
    const childNodes = toArray(children);
    return childNodes.some((child) => React317.isValidElement(child) && child.type === CardGrid_default);
  }, [children]);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const [hashId, cssVarCls] = style_default28(prefixCls);
  const loadingBlock = React317.createElement(skeleton_default, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false
  }, children);
  const hasActiveTabKey = activeTabKey !== void 0;
  const extraProps = {
    ...tabProps,
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  };
  let head;
  const tabSize = !mergedSize || mergedSize === "default" ? "large" : mergedSize;
  const tabs = tabList ? React317.createElement(tabs_default, {
    size: tabSize,
    ...extraProps,
    className: `${prefixCls}-head-tabs`,
    onChange: onTabChange,
    items: tabList.map(({
      tab,
      ...item
    }) => ({
      label: tab,
      ...item
    }))
  }) : null;
  if (title || extra || tabs) {
    const headClasses = clsx(`${prefixCls}-head`, mergedClassNames.header);
    const titleClasses = clsx(`${prefixCls}-head-title`, mergedClassNames.title);
    const extraClasses = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
    const mergedHeadStyle = {
      ...headStyle,
      ...mergedStyles.header
    };
    head = React317.createElement("div", {
      className: headClasses,
      style: mergedHeadStyle
    }, React317.createElement("div", {
      className: `${prefixCls}-head-wrapper`
    }, title && React317.createElement("div", {
      className: titleClasses,
      style: mergedStyles.title
    }, title), extra && React317.createElement("div", {
      className: extraClasses,
      style: mergedStyles.extra
    }, extra)), tabs);
  }
  const coverClasses = clsx(`${prefixCls}-cover`, mergedClassNames.cover);
  const coverDom = cover ? React317.createElement("div", {
    className: coverClasses,
    style: mergedStyles.cover
  }, cover) : null;
  const bodyClasses = clsx(`${prefixCls}-body`, mergedClassNames.body);
  const mergedBodyStyle = {
    ...bodyStyle,
    ...mergedStyles.body
  };
  const body = React317.createElement("div", {
    className: bodyClasses,
    style: mergedBodyStyle
  }, loading ? loadingBlock : children);
  const actionClasses = clsx(`${prefixCls}-actions`, mergedClassNames.actions);
  const actionDom = (actions == null ? void 0 : actions.length) ? React317.createElement(ActionNode, {
    actionClasses,
    actionStyle: mergedStyles.actions,
    actions
  }) : null;
  const divProps = omit(rest, ["onTabChange"]);
  const classString = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: variant !== "borderless",
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid,
    [`${prefixCls}-contain-tabs`]: tabList == null ? void 0 : tabList.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type5}`]: !!type5,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return React317.createElement("div", {
    ref,
    ...divProps,
    className: classString,
    style: mergedStyle
  }, head, coverDom, body, actionDom);
});
if (true) {
  Card.displayName = "Card";
}
var Card_default = Card;

// node_modules/antd/es/card/CardMeta.js
var React318 = __toESM(require_react());
var CardMeta = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title,
    description,
    style: style2,
    classNames: cardMetaClassNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("cardMeta");
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const metaPrefixCls = `${prefixCls}-meta`;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, cardMetaClassNames], [contextStyles, styles], {
    props
  });
  const rootClassNames = clsx(metaPrefixCls, className, contextClassName, mergedClassNames.root);
  const rootStyles = {
    ...contextStyle,
    ...mergedStyles.root,
    ...style2
  };
  const avatarClassNames = clsx(`${metaPrefixCls}-avatar`, mergedClassNames.avatar);
  const titleClassNames = clsx(`${metaPrefixCls}-title`, mergedClassNames.title);
  const descriptionClassNames = clsx(`${metaPrefixCls}-description`, mergedClassNames.description);
  const sectionClassNames = clsx(`${metaPrefixCls}-section`, mergedClassNames.section);
  const avatarDom = avatar ? React318.createElement("div", {
    className: avatarClassNames,
    style: mergedStyles.avatar
  }, avatar) : null;
  const titleDom = title ? React318.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title) : null;
  const descriptionDom = description ? React318.createElement("div", {
    className: descriptionClassNames,
    style: mergedStyles.description
  }, description) : null;
  const MetaDetail = titleDom || descriptionDom ? React318.createElement("div", {
    className: sectionClassNames,
    style: mergedStyles.section
  }, titleDom, descriptionDom) : null;
  return React318.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: rootStyles
  }, avatarDom, MetaDetail);
};
if (true) {
  CardMeta.displayName = "CardMeta";
}
var CardMeta_default = CardMeta;

// node_modules/antd/es/card/index.js
var Card2 = Card_default;
Card2.Grid = CardGrid_default;
Card2.Meta = CardMeta_default;
var card_default = Card2;

// node_modules/antd/es/carousel/index.js
var React326 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/slider.js
var import_react125 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose5(r2, e3) {
  if (null == r2)
    return {};
  var t2 = {};
  for (var n2 in r2)
    if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e3.indexOf(n2))
        continue;
      t2[n2] = r2[n2];
    }
  return t2;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties5(e3, t2) {
  if (null == e3)
    return {};
  var o3, r2, i = _objectWithoutPropertiesLoose5(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    for (r2 = 0; r2 < n2.length; r2++)
      o3 = n2[r2], -1 === t2.indexOf(o3) && {}.propertyIsEnumerable.call(e3, o3) && (i[o3] = e3[o3]);
  }
  return i;
}

// node_modules/@ant-design/react-slick/es/inner-slider.js
var import_react124 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/initial-state.js
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  // used by swipeEvent. differentites between touch and swipe.
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
var initial_state_default = initialState;

// node_modules/throttle-debounce/esm/index.js
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}

// node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
var import_react120 = __toESM(require_react());

// node_modules/@ant-design/react-slick/es/default-props.js
var import_react119 = __toESM(require_react());
var defaultProps = {
  accessibility: true,
  adaptiveHeight: false,
  afterChange: null,
  appendDots: function appendDots(dots) {
    return import_react119.default.createElement("ul", {
      style: {
        display: "block"
      }
    }, dots);
  },
  arrows: true,
  autoplay: false,
  autoplaySpeed: 3e3,
  beforeChange: null,
  centerMode: false,
  centerPadding: "50px",
  className: "",
  cssEase: "ease",
  customPaging: function customPaging(i) {
    return import_react119.default.createElement("button", null, i + 1);
  },
  dots: false,
  dotsClass: "slick-dots",
  draggable: true,
  easing: "linear",
  edgeFriction: 0.35,
  fade: false,
  focusOnSelect: false,
  infinite: true,
  initialSlide: 0,
  lazyLoad: null,
  nextArrow: null,
  onEdge: null,
  onInit: null,
  onLazyLoadError: null,
  onReInit: null,
  pauseOnDotsHover: false,
  pauseOnFocus: false,
  pauseOnHover: true,
  prevArrow: null,
  responsive: null,
  rows: 1,
  rtl: false,
  slide: "div",
  slidesPerRow: 1,
  slidesToScroll: 1,
  slidesToShow: 1,
  speed: 500,
  swipe: true,
  swipeEvent: null,
  swipeToSlide: false,
  touchMove: true,
  touchThreshold: 5,
  useCSS: true,
  useTransform: true,
  variableWidth: false,
  vertical: false,
  verticalSwiping: false,
  waitForAnimate: true,
  asNavFor: null,
  unslick: false
};
var default_props_default = defaultProps;

// node_modules/@ant-design/react-slick/es/utils/innerSliderUtils.js
function clamp(number4, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number4, upperBound));
}
var safePreventDefault = function safePreventDefault2(event) {
  var passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
};
var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth2 = function getWidth3(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = function extractObject2(spec, keys2) {
  var newObject = {};
  keys2.forEach(function(key) {
    return newObject[key] = spec[key];
  });
  return newObject;
};
var initializedState = function initializedState2(spec) {
  var slideCount = import_react120.default.Children.count(spec.children);
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth2(listNode));
  var trackNode = spec.trackRef && spec.trackRef.node;
  var trackWidth = Math.ceil(getWidth2(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = function slideHandler2(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating)
    return {};
  var animationSlide = index2, finalSlide, animationLeft, finalLeft;
  var state = {}, nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread2(_objectSpread2({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = function changeSlide2(spec, options) {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread2(_objectSpread2({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = function keyHandler2(e3, accessibility, rtl) {
  if (e3.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility)
    return "";
  if (e3.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e3.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
};
var swipeStart = function swipeStart2(e3, swipe, draggable) {
  e3.target.tagName === "IMG" && safePreventDefault(e3);
  if (!swipe || !draggable && e3.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      startY: e3.touches ? e3.touches[0].pageY : e3.clientY,
      curX: e3.touches ? e3.touches[0].pageX : e3.clientX,
      curY: e3.touches ? e3.touches[0].pageY : e3.clientY
    }
  };
};
var swipeMove = function swipeMove2(e3, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e3);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e3);
  var swipeLeft, state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e3.touches ? e3.touches[0].pageX : e3.clientX;
  touchObject.curY = e3.touches ? e3.touches[0].pageY : e3.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping)
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread2(_objectSpread2({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e3);
  }
  return state;
};
var swipeEnd = function swipeEnd2(e3, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e3);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e3);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread2(_objectSpread2({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = function getNavigableIndexes2(spec) {
  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
};
var getSlideCount = function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth2(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    keysArray.reduce(function(value, key) {
      return value && spec.hasOwnProperty(key);
    }, true) ? null : console.error("Keys Missing:", spec)
  );
};
var getTrackCSS = function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    var trackChildren = spec.unslick ? spec.slideCount : spec.slideCount + 2 * spec.slidesToShow;
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = _objectSpread2(_objectSpread2({}, style2), {}, {
      WebkitTransform,
      transform,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = {
      opacity: 1
    };
  if (trackWidth)
    style2.width = trackWidth;
  if (trackHeight)
    style2.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
};
var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getTrackLeft = function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getTotalSlides = function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = function slidesOnRight2(_ref) {
  var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var validSettings = Object.keys(default_props_default);
function filterSettings(settings) {
  return validSettings.reduce(function(acc, settingName) {
    if (settings.hasOwnProperty(settingName)) {
      acc[settingName] = settings[settingName];
    }
    return acc;
  }, {});
}

// node_modules/@ant-design/react-slick/es/track.js
var import_react121 = __toESM(require_react());
function _callSuper2(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var getSlideClasses = function getSlideClasses2(spec) {
  var slickActive, slickCenter, slickCloned;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
    // dubious in case of RTL
  };
};
var getSlideStyle = function getSlideStyle2(spec) {
  var style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth;
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical && spec.slideHeight) {
      style2.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth);
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    style2.zIndex = spec.currentSlide === spec.index ? 999 : 998;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getKey2 = function getKey3(child, fallbackKey) {
  return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides2(spec) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = import_react121.default.Children.count(spec.children);
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  import_react121.default.Children.forEach(spec.children, function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = import_react121.default.createElement("div", null);
    }
    var childStyle = getSlideStyle(_objectSpread2(_objectSpread2({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.className || "";
    var slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
      index: index2
    }));
    slides.push(import_react121.default.cloneElement(child, {
      key: "original" + getKey2(child, index2),
      "data-index": index2,
      className: clsx(slideClasses, slideClass),
      tabIndex: "-1",
      "aria-hidden": !slideClasses["slick-active"],
      style: _objectSpread2(_objectSpread2({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: function onClick(e3) {
        child.props && child.props.onClick && child.props.onClick(e3);
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && childrenCount > 1 && spec.fade === false && !spec.unslick) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec)) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
          index: key
        }));
        preCloneSlides.push(import_react121.default.cloneElement(child, {
          key: "precloned" + getKey2(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: clsx(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
          onClick: function onClick(e3) {
            child.props && child.props.onClick && child.props.onClick(e3);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (index2 < getPostClones(spec)) {
        key = childrenCount + index2;
        if (key < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2(_objectSpread2({}, spec), {}, {
          index: key
        }));
        postCloneSlides.push(import_react121.default.cloneElement(child, {
          key: "postcloned" + getKey2(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: clsx(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2(_objectSpread2({}, child.props.style || {}), childStyle),
          onClick: function onClick(e3) {
            child.props && child.props.onClick && child.props.onClick(e3);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track = function(_React$PureComponent) {
  function Track3() {
    var _this;
    _classCallCheck(this, Track3);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper2(this, Track3, [].concat(args));
    _defineProperty(_this, "node", null);
    _defineProperty(_this, "handleRef", function(ref) {
      _this.node = ref;
    });
    return _this;
  }
  _inherits(Track3, _React$PureComponent);
  return _createClass(Track3, [{
    key: "render",
    value: function render2() {
      var slides = renderSlides(this.props);
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      return import_react121.default.createElement("div", _extends9({
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle
      }, mouseEvents), slides);
    }
  }]);
}(import_react121.default.PureComponent);

// node_modules/@ant-design/react-slick/es/dots.js
var import_react122 = __toESM(require_react());
function _callSuper3(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var getDotCount = function getDotCount2(spec) {
  var dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = function(_React$PureComponent) {
  function Dots2() {
    _classCallCheck(this, Dots2);
    return _callSuper3(this, Dots2, arguments);
  }
  _inherits(Dots2, _React$PureComponent);
  return _createClass(Dots2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      e3.preventDefault();
      this.props.clickHandler(options);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
      var dotCount = getDotCount({
        slideCount,
        slidesToScroll,
        slidesToShow,
        infinite
      });
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      var dots = [];
      for (var i = 0; i < dotCount; i++) {
        var _rightBound = (i + 1) * slidesToScroll - 1;
        var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
        var _leftBound = rightBound - (slidesToScroll - 1);
        var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
        var className = clsx({
          "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
        });
        var dotOptions = {
          message: "dots",
          index: i,
          slidesToScroll,
          currentSlide
        };
        var onClick = this.clickHandler.bind(this, dotOptions);
        dots = dots.concat(import_react122.default.createElement("li", {
          key: i,
          className
        }, import_react122.default.cloneElement(this.props.customPaging(i), {
          onClick
        })));
      }
      return import_react122.default.cloneElement(this.props.appendDots(dots), _objectSpread2({
        className: this.props.dotsClass
      }, mouseEvents));
    }
  }]);
}(import_react122.default.PureComponent);

// node_modules/@ant-design/react-slick/es/arrows.js
var import_react123 = __toESM(require_react());
function _callSuper4(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var PrevArrow = function(_React$PureComponent) {
  function PrevArrow2() {
    _classCallCheck(this, PrevArrow2);
    return _callSuper4(this, PrevArrow2, arguments);
  }
  _inherits(PrevArrow2, _React$PureComponent);
  return _createClass(PrevArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      if (e3) {
        e3.preventDefault();
      }
      this.props.clickHandler(options, e3);
    }
  }, {
    key: "render",
    value: function render2() {
      var prevClasses = {
        "slick-arrow": true,
        "slick-prev": true
      };
      var prevHandler = this.clickHandler.bind(this, {
        message: "previous"
      });
      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
        prevClasses["slick-disabled"] = true;
        prevHandler = null;
      }
      var prevArrowProps = {
        key: "0",
        "data-role": "none",
        className: clsx(prevClasses),
        style: {
          display: "block"
        },
        onClick: prevHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var prevArrow;
      if (this.props.prevArrow) {
        prevArrow = import_react123.default.cloneElement(this.props.prevArrow, _objectSpread2(_objectSpread2({}, prevArrowProps), customProps));
      } else {
        prevArrow = import_react123.default.createElement("button", _extends9({
          key: "0",
          type: "button"
        }, prevArrowProps), " ", "Previous");
      }
      return prevArrow;
    }
  }]);
}(import_react123.default.PureComponent);
var NextArrow = function(_React$PureComponent2) {
  function NextArrow2() {
    _classCallCheck(this, NextArrow2);
    return _callSuper4(this, NextArrow2, arguments);
  }
  _inherits(NextArrow2, _React$PureComponent2);
  return _createClass(NextArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e3) {
      if (e3) {
        e3.preventDefault();
      }
      this.props.clickHandler(options, e3);
    }
  }, {
    key: "render",
    value: function render2() {
      var nextClasses = {
        "slick-arrow": true,
        "slick-next": true
      };
      var nextHandler = this.clickHandler.bind(this, {
        message: "next"
      });
      if (!canGoNext(this.props)) {
        nextClasses["slick-disabled"] = true;
        nextHandler = null;
      }
      var nextArrowProps = {
        key: "1",
        "data-role": "none",
        className: clsx(nextClasses),
        style: {
          display: "block"
        },
        onClick: nextHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var nextArrow;
      if (this.props.nextArrow) {
        nextArrow = import_react123.default.cloneElement(this.props.nextArrow, _objectSpread2(_objectSpread2({}, nextArrowProps), customProps));
      } else {
        nextArrow = import_react123.default.createElement("button", _extends9({
          key: "1",
          type: "button"
        }, nextArrowProps), " ", "Next");
      }
      return nextArrow;
    }
  }]);
}(import_react123.default.PureComponent);

// node_modules/@ant-design/react-slick/es/inner-slider.js
var _excluded6 = ["animating"];
function _callSuper5(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var InnerSlider = function(_React$Component) {
  function InnerSlider2(props) {
    var _this;
    _classCallCheck(this, InnerSlider2);
    _this = _callSuper5(this, InnerSlider2, [props]);
    _defineProperty(_this, "listRefHandler", function(ref) {
      return _this.list = ref;
    });
    _defineProperty(_this, "trackRefHandler", function(ref) {
      return _this.track = ref;
    });
    _defineProperty(_this, "adaptHeight", function() {
      if (_this.props.adaptiveHeight && _this.list) {
        var elem = _this.list.querySelector('[data-index="'.concat(_this.state.currentSlide, '"]'));
        _this.list.style.height = getHeight(elem) + "px";
      }
    });
    _defineProperty(_this, "componentDidMount", function() {
      _this.props.onInit && _this.props.onInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      var spec = _objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props);
      _this.updateState(spec, true, function() {
        _this.adaptHeight();
        _this.props.autoplay && _this.autoPlay("playing");
      });
      if (_this.props.lazyLoad === "progressive") {
        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
      }
      if (typeof ResizeObserver !== "undefined") {
        _this.ro = new ResizeObserver(function() {
          if (_this.state.animating) {
            _this.onWindowResized(false);
            _this.callbackTimers.push(setTimeout(function() {
              return _this.onWindowResized();
            }, _this.props.speed));
          } else {
            _this.onWindowResized();
          }
        });
        _this.ro.observe(_this.list);
      }
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this.onWindowResized);
      } else {
        window.attachEvent("onresize", _this.onWindowResized);
      }
    });
    _defineProperty(_this, "componentWillUnmount", function() {
      var _this$ro;
      if (_this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
      }
      if (_this.lazyLoadTimer) {
        clearInterval(_this.lazyLoadTimer);
      }
      if (_this.callbackTimers.length) {
        _this.callbackTimers.forEach(function(timer) {
          return clearTimeout(timer);
        });
        _this.callbackTimers = [];
      }
      if (window.addEventListener) {
        window.removeEventListener("resize", _this.onWindowResized);
      } else {
        window.detachEvent("onresize", _this.onWindowResized);
      }
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      (_this$ro = _this.ro) === null || _this$ro === void 0 || _this$ro.disconnect();
    });
    _defineProperty(_this, "componentDidUpdate", function(prevProps) {
      _this.checkImagesLoad();
      _this.props.onReInit && _this.props.onReInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2(_objectSpread2({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      _this.adaptHeight();
      var spec = _objectSpread2(_objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      var setTrackStyle = _this.didPropsChange(prevProps);
      setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
        if (_this.state.currentSlide >= import_react124.default.Children.count(_this.props.children)) {
          _this.changeSlide({
            message: "index",
            index: import_react124.default.Children.count(_this.props.children) - _this.props.slidesToShow,
            currentSlide: _this.state.currentSlide
          });
        }
        if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) {
          if (!prevProps.autoplay && _this.props.autoplay) {
            _this.autoPlay("playing");
          } else if (_this.props.autoplay) {
            _this.autoPlay("update");
          } else {
            _this.pause("paused");
          }
        }
      });
    });
    _defineProperty(_this, "onWindowResized", function(setTrackStyle) {
      if (_this.debouncedResize)
        _this.debouncedResize.cancel();
      _this.debouncedResize = debounce(50, function() {
        return _this.resizeWindow(setTrackStyle);
      });
      _this.debouncedResize();
    });
    _defineProperty(_this, "resizeWindow", function() {
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(_this.track && _this.track.node);
      if (!isTrackMounted)
        return;
      var spec = _objectSpread2(_objectSpread2({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      _this.updateState(spec, setTrackStyle, function() {
        if (_this.props.autoplay)
          _this.autoPlay("update");
        else
          _this.pause("paused");
      });
      _this.setState({
        animating: false
      });
      clearTimeout(_this.animationEndCallback);
      delete _this.animationEndCallback;
    });
    _defineProperty(_this, "updateState", function(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = _objectSpread2(_objectSpread2(_objectSpread2({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = _objectSpread2(_objectSpread2({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);
      if (setTrackStyle || import_react124.default.Children.count(_this.props.children) !== import_react124.default.Children.count(spec.children)) {
        updatedState["trackStyle"] = trackStyle;
      }
      _this.setState(updatedState, callback);
    });
    _defineProperty(_this, "ssrInit", function() {
      if (_this.props.variableWidth) {
        var _trackWidth = 0, _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        var postClones = getPostClones(_objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        _this.props.children.forEach(function(child) {
          childrenWidths.push(child.props.style.width);
          _trackWidth += child.props.style.width;
        });
        for (var i = 0; i < preClones; i++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i];
        }
        for (var _i = 0; _i < postClones; _i++) {
          _trackWidth += childrenWidths[_i];
        }
        for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {
          _trackLeft += childrenWidths[_i2];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (_this.props.centerMode) {
          var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = import_react124.default.Children.count(_this.props.children);
      var spec = _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        slideCount: childrenCount
      });
      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / _this.props.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
      if (_this.props.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    });
    _defineProperty(_this, "checkImagesLoad", function() {
      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length, loadedCount = 0;
      Array.prototype.forEach.call(images, function(image) {
        var handler = function handler2() {
          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
        };
        if (!image.onclick) {
          image.onclick = function() {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;
          image.onclick = function(e3) {
            prevClickHandler(e3);
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (_this.props.lazyLoad) {
            image.onload = function() {
              _this.adaptHeight();
              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
            };
          } else {
            image.onload = handler;
            image.onerror = function() {
              handler();
              _this.props.onLazyLoadError && _this.props.onLazyLoadError();
            };
          }
        }
      });
    });
    _defineProperty(_this, "progressiveLazyLoad", function() {
      var slidesToLoad = [];
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + getPostClones(spec); index2++) {
        if (_this.state.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index = _this.state.currentSlide - 1; _index >= -getPreClones(spec); _index--) {
        if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        _this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        if (_this.props.onLazyLoad) {
          _this.props.onLazyLoad(slidesToLoad);
        }
      } else {
        if (_this.lazyLoadTimer) {
          clearInterval(_this.lazyLoadTimer);
          delete _this.lazyLoadTimer;
        }
      }
    });
    _defineProperty(_this, "slideHandler", function(index2) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
      var currentSlide = _this.state.currentSlide;
      var _slideHandler = slideHandler(_objectSpread2(_objectSpread2(_objectSpread2({
        index: index2
      }, _this.props), _this.state), {}, {
        trackRef: _this.track,
        useCSS: _this.props.useCSS && !dontAnimate
      })), state = _slideHandler.state, nextState = _slideHandler.nextState;
      if (!state)
        return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this.state.lazyLoadedList.indexOf(value) < 0;
      });
      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
      if (!_this.props.waitForAnimate && _this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete _this.animationEndCallback;
      }
      _this.setState(state, function() {
        if (asNavFor && _this.asNavForIndex !== index2) {
          _this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        _this.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties5(nextState, _excluded6);
          _this.setState(firstBatch, function() {
            _this.callbackTimers.push(setTimeout(function() {
              return _this.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this.animationEndCallback;
          });
        }, speed);
      });
    });
    _defineProperty(_this, "changeSlide", function(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      var targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        _this.slideHandler(targetSlide, dontAnimate);
      } else {
        _this.slideHandler(targetSlide);
      }
      _this.props.autoplay && _this.autoPlay("update");
      if (_this.props.focusOnSelect) {
        var nodes = _this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    });
    _defineProperty(_this, "clickHandler", function(e3) {
      if (_this.clickable === false) {
        e3.stopPropagation();
        e3.preventDefault();
      }
      _this.clickable = true;
    });
    _defineProperty(_this, "keyHandler", function(e3) {
      var dir = keyHandler(e3, _this.props.accessibility, _this.props.rtl);
      dir !== "" && _this.changeSlide({
        message: dir
      });
    });
    _defineProperty(_this, "selectHandler", function(options) {
      _this.changeSlide(options);
    });
    _defineProperty(_this, "disableBodyScroll", function() {
      var preventDefault = function preventDefault2(e3) {
        e3 = e3 || window.event;
        if (e3.preventDefault)
          e3.preventDefault();
        e3.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    });
    _defineProperty(_this, "enableBodyScroll", function() {
      window.ontouchmove = null;
    });
    _defineProperty(_this, "swipeStart", function(e3) {
      if (_this.props.verticalSwiping) {
        _this.disableBodyScroll();
      }
      var state = swipeStart(e3, _this.props.swipe, _this.props.draggable);
      state !== "" && _this.setState(state);
    });
    _defineProperty(_this, "swipeMove", function(e3) {
      var state = swipeMove(e3, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        _this.clickable = false;
      }
      _this.setState(state);
    });
    _defineProperty(_this, "swipeEnd", function(e3) {
      var state = swipeEnd(e3, _objectSpread2(_objectSpread2(_objectSpread2({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      _this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      _this.slideHandler(triggerSlideHandler);
      if (_this.props.verticalSwiping) {
        _this.enableBodyScroll();
      }
    });
    _defineProperty(_this, "touchEnd", function(e3) {
      _this.swipeEnd(e3);
      _this.clickable = true;
    });
    _defineProperty(_this, "slickPrev", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "previous"
        });
      }, 0));
    });
    _defineProperty(_this, "slickNext", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "next"
        });
      }, 0));
    });
    _defineProperty(_this, "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this.state.currentSlide
        }, dontAnimate);
      }, 0));
    });
    _defineProperty(_this, "play", function() {
      var nextIndex;
      if (_this.props.rtl) {
        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
      } else {
        if (canGoNext(_objectSpread2(_objectSpread2({}, _this.props), _this.state))) {
          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
        } else {
          return false;
        }
      }
      _this.slideHandler(nextIndex);
    });
    _defineProperty(_this, "autoPlay", function(playType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      var autoplaying = _this.state.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
      _this.setState({
        autoplaying: "playing"
      });
    });
    _defineProperty(_this, "pause", function(pauseType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
        _this.autoplayTimer = null;
      }
      var autoplaying = _this.state.autoplaying;
      if (pauseType === "paused") {
        _this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          _this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          _this.setState({
            autoplaying: "hovered"
          });
        }
      }
    });
    _defineProperty(_this, "onDotsOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_this, "onDotsLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_this, "onTrackOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty(_this, "onTrackLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty(_this, "onSlideFocus", function() {
      return _this.props.autoplay && _this.pause("focused");
    });
    _defineProperty(_this, "onSlideBlur", function() {
      return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
    });
    _defineProperty(_this, "render", function() {
      var className = clsx("slick-slider", _this.props.className, {
        "slick-vertical": _this.props.vertical,
        "slick-initialized": true
      });
      var spec = _objectSpread2(_objectSpread2({}, _this.props), _this.state);
      var trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
      var pauseOnHover = _this.props.pauseOnHover;
      trackProps = _objectSpread2(_objectSpread2({}, trackProps), {}, {
        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
        onMouseOver: pauseOnHover ? _this.onTrackOver : null,
        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
      });
      var dots;
      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
        var dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]);
        var pauseOnDotsHover = _this.props.pauseOnDotsHover;
        dotProps = _objectSpread2(_objectSpread2({}, dotProps), {}, {
          clickHandler: _this.changeSlide,
          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
        });
        dots = import_react124.default.createElement(Dots, dotProps);
      }
      var prevArrow, nextArrow;
      var arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      arrowProps.clickHandler = _this.changeSlide;
      if (_this.props.arrows) {
        prevArrow = import_react124.default.createElement(PrevArrow, arrowProps);
        nextArrow = import_react124.default.createElement(NextArrow, arrowProps);
      }
      var verticalHeightStyle = null;
      if (_this.props.vertical) {
        verticalHeightStyle = {
          height: _this.state.listHeight
        };
      }
      var centerPaddingStyle = null;
      if (_this.props.vertical === false) {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: "0px " + _this.props.centerPadding
          };
        }
      } else {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: _this.props.centerPadding + " 0px"
          };
        }
      }
      var listStyle = _objectSpread2(_objectSpread2({}, verticalHeightStyle), centerPaddingStyle);
      var touchMove = _this.props.touchMove;
      var listProps = {
        className: "slick-list",
        style: listStyle,
        onClick: _this.clickHandler,
        onMouseDown: touchMove ? _this.swipeStart : null,
        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onMouseUp: touchMove ? _this.swipeEnd : null,
        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onTouchStart: touchMove ? _this.swipeStart : null,
        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onTouchEnd: touchMove ? _this.touchEnd : null,
        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onKeyDown: _this.props.accessibility ? _this.keyHandler : null
      };
      var innerSliderProps = {
        className,
        dir: "ltr",
        style: _this.props.style
      };
      if (_this.props.unslick) {
        listProps = {
          className: "slick-list"
        };
        innerSliderProps = {
          className,
          style: _this.props.style
        };
      }
      return import_react124.default.createElement("div", innerSliderProps, !_this.props.unslick ? prevArrow : "", import_react124.default.createElement("div", _extends9({
        ref: _this.listRefHandler
      }, listProps), import_react124.default.createElement(Track, _extends9({
        ref: _this.trackRefHandler
      }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : "");
    });
    _this.list = null;
    _this.track = null;
    _this.state = _objectSpread2(_objectSpread2({}, initial_state_default), {}, {
      currentSlide: _this.props.initialSlide,
      targetSlide: _this.props.initialSlide ? _this.props.initialSlide : 0,
      slideCount: import_react124.default.Children.count(_this.props.children)
    });
    _this.callbackTimers = [];
    _this.clickable = true;
    _this.debouncedResize = null;
    var ssrState = _this.ssrInit();
    _this.state = _objectSpread2(_objectSpread2({}, _this.state), ssrState);
    return _this;
  }
  _inherits(InnerSlider2, _React$Component);
  return _createClass(InnerSlider2, [{
    key: "didPropsChange",
    value: function didPropsChange(prevProps) {
      var setTrackStyle = false;
      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];
        if (!prevProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof(prevProps[key]) === "object" || typeof prevProps[key] === "function" || isNaN(prevProps[key])) {
          continue;
        }
        if (prevProps[key] !== this.props[key]) {
          setTrackStyle = true;
          break;
        }
      }
      return setTrackStyle || import_react124.default.Children.count(this.props.children) !== import_react124.default.Children.count(prevProps.children);
    }
  }]);
}(import_react124.default.Component);

// node_modules/@ant-design/react-slick/es/slider.js
var import_json2mq = __toESM(require_json2mq());
function _callSuper6(t2, o3, e3) {
  return o3 = _getPrototypeOf(o3), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o3, e3 || [], _getPrototypeOf(t2).constructor) : o3.apply(t2, e3));
}
var Slider2 = function(_React$Component) {
  function Slider5(props) {
    var _this;
    _classCallCheck(this, Slider5);
    _this = _callSuper6(this, Slider5, [props]);
    _defineProperty(_this, "innerSliderRefHandler", function(ref) {
      return _this.innerSlider = ref;
    });
    _defineProperty(_this, "slickPrev", function() {
      return _this.innerSlider.slickPrev();
    });
    _defineProperty(_this, "slickNext", function() {
      return _this.innerSlider.slickNext();
    });
    _defineProperty(_this, "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return _this.innerSlider.slickGoTo(slide, dontAnimate);
    });
    _defineProperty(_this, "slickPause", function() {
      return _this.innerSlider.pause("paused");
    });
    _defineProperty(_this, "slickPlay", function() {
      return _this.innerSlider.autoPlay("play");
    });
    _this.state = {
      breakpoint: null
    };
    _this._responsiveMediaHandlers = [];
    return _this;
  }
  _inherits(Slider5, _React$Component);
  return _createClass(Slider5, [{
    key: "media",
    value: function media(query, handler) {
      var mql = window.matchMedia(query);
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        if (matches) {
          handler();
        }
      };
      mql.addListener(listener);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    }
    // handles responsive breakpoints
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.props.responsive) {
        var breakpoints = this.props.responsive.map(function(breakpt) {
          return breakpt.breakpoint;
        });
        breakpoints.sort(function(x, y) {
          return x - y;
        });
        breakpoints.forEach(function(breakpoint, index2) {
          var bQuery;
          if (index2 === 0) {
            bQuery = (0, import_json2mq.default)({
              minWidth: 0,
              maxWidth: breakpoint
            });
          } else {
            bQuery = (0, import_json2mq.default)({
              minWidth: breakpoints[index2 - 1] + 1,
              maxWidth: breakpoint
            });
          }
          canUseDOM() && _this2.media(bQuery, function() {
            _this2.setState({
              breakpoint
            });
          });
        });
        var query = (0, import_json2mq.default)({
          minWidth: breakpoints.slice(-1)[0]
        });
        canUseDOM() && this.media(query, function() {
          _this2.setState({
            breakpoint: null
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._responsiveMediaHandlers.forEach(function(obj) {
        obj.mql.removeListener(obj.listener);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this3 = this;
      var settings;
      var newProps;
      if (this.state.breakpoint) {
        newProps = this.props.responsive.filter(function(resp) {
          return resp.breakpoint === _this3.state.breakpoint;
        });
        settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2(_objectSpread2(_objectSpread2({}, default_props_default), this.props), newProps[0].settings);
      } else {
        settings = _objectSpread2(_objectSpread2({}, default_props_default), this.props);
      }
      if (settings.centerMode) {
        if (settings.slidesToScroll > 1 && true) {
          console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
        }
        settings.slidesToScroll = 1;
      }
      if (settings.fade) {
        if (settings.slidesToShow > 1 && true) {
          console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
        }
        if (settings.slidesToScroll > 1 && true) {
          console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
        }
        settings.slidesToShow = 1;
        settings.slidesToScroll = 1;
      }
      var children = import_react125.default.Children.toArray(this.props.children);
      children = children.filter(function(child) {
        if (typeof child === "string") {
          return !!child.trim();
        }
        return !!child;
      });
      if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
        console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
        settings.variableWidth = false;
      }
      var newChildren = [];
      var currentWidth = null;
      for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {
        var newSlide = [];
        for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {
          var row = [];
          for (var k = j; k < j + settings.slidesPerRow; k += 1) {
            if (settings.variableWidth && children[k].props.style) {
              currentWidth = children[k].props.style.width;
            }
            if (k >= children.length)
              break;
            row.push(import_react125.default.cloneElement(children[k], {
              key: 100 * i + 10 * j + k,
              tabIndex: -1,
              style: {
                width: "".concat(100 / settings.slidesPerRow, "%"),
                display: "inline-block"
              }
            }));
          }
          newSlide.push(import_react125.default.createElement("div", {
            key: 10 * i + j
          }, row));
        }
        if (settings.variableWidth) {
          newChildren.push(import_react125.default.createElement("div", {
            key: i,
            style: {
              width: currentWidth
            }
          }, newSlide));
        } else {
          newChildren.push(import_react125.default.createElement("div", {
            key: i
          }, newSlide));
        }
      }
      if (settings === "unslick") {
        var className = "regular slider " + (this.props.className || "");
        return import_react125.default.createElement("div", {
          className
        }, children);
      } else if (newChildren.length <= settings.slidesToShow) {
        settings.unslick = true;
      }
      return import_react125.default.createElement(InnerSlider, _extends9({
        style: this.props.style,
        ref: this.innerSliderRefHandler
      }, filterSettings(settings)), newChildren);
    }
  }]);
}(import_react125.default.Component);

// node_modules/@ant-design/react-slick/es/index.js
var es_default19 = Slider2;

// node_modules/antd/es/carousel/style/index.js
var DotDuration = "--dot-duration";
var genCarouselStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      }
    }
  };
};
var genArrowsStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    arrowSize,
    arrowOffset
  } = token2;
  const arrowLength = token2.calc(arrowSize).div(Math.SQRT2).equal();
  return {
    [componentCls]: {
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        width: arrowSize,
        height: arrowSize,
        transform: "translateY(-50%)",
        color: "#fff",
        opacity: 0.4,
        background: "transparent",
        padding: 0,
        lineHeight: 0,
        border: 0,
        outline: "none",
        cursor: "pointer",
        zIndex: 1,
        transition: `opacity ${motionDurationSlow}`,
        "&:hover, &:focus": {
          opacity: 1
        },
        "&.slick-disabled": {
          pointerEvents: "none",
          opacity: 0
        },
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          top: token2.calc(arrowSize).sub(arrowLength).div(2).equal(),
          insetInlineStart: token2.calc(arrowSize).sub(arrowLength).div(2).equal(),
          display: "inline-block",
          width: arrowLength,
          height: arrowLength,
          border: `0 solid currentcolor`,
          borderInlineStartWidth: 2,
          borderBlockStartWidth: 2,
          borderRadius: 1,
          content: '""'
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::after": {
          transform: "rotate(-45deg)"
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::after": {
          transform: "rotate(135deg)"
        }
      }
    }
  };
};
var genDotsStyle = (token2) => {
  const {
    componentCls,
    dotOffset,
    dotWidth,
    dotHeight,
    dotGap,
    colorBgContainer,
    motionDurationSlow
  } = token2;
  const animation = new Keyframes_default(`${token2.prefixCls}-dot-animation`, {
    from: {
      width: 0
    },
    to: {
      width: token2.dotActiveWidth
    }
  });
  return {
    [componentCls]: {
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        margin: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: dotOffset
        },
        "&-top": {
          top: dotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: dotWidth,
          height: dotHeight,
          marginInline: dotGap,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${motionDurationSlow}`,
          borderRadius: dotHeight,
          overflow: "hidden",
          "&::after": {
            display: "block",
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: 0,
            height: dotHeight,
            content: '""',
            background: "transparent",
            borderRadius: dotHeight,
            opacity: 1,
            outline: "none",
            cursor: "pointer",
            overflow: "hidden"
          },
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: colorBgContainer,
            border: 0,
            borderRadius: dotHeight,
            outline: "none",
            cursor: "pointer",
            opacity: 0.2,
            transition: `all ${motionDurationSlow}`,
            overflow: "hidden",
            "&:hover": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: token2.calc(dotGap).mul(-1).equal(),
              content: '""'
            }
          },
          "&.slick-active": {
            width: token2.dotActiveWidth,
            position: "relative",
            "&:hover": {
              opacity: 1
            },
            "&::after": {
              background: colorBgContainer,
              animationName: animation,
              animationDuration: `var(${DotDuration})`,
              animationTimingFunction: "ease-out",
              animationFillMode: "forwards"
            }
          }
        }
      }
    }
  };
};
var genCarouselVerticalStyle = (token2) => {
  const {
    componentCls,
    dotOffset,
    arrowOffset,
    marginXXS
  } = token2;
  const animation = new Keyframes_default(`${token2.prefixCls}-dot-vertical-animation`, {
    from: {
      height: 0
    },
    to: {
      height: token2.dotActiveWidth
    }
  });
  const reverseSizeOfDot = {
    width: token2.dotHeight,
    height: token2.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-prev, .slick-next": {
        insetInlineStart: "50%",
        marginBlockStart: "unset",
        transform: "translateX(-50%)"
      },
      ".slick-prev": {
        insetBlockStart: arrowOffset,
        insetInlineStart: "50%",
        "&::after": {
          transform: "rotate(45deg)"
        }
      },
      ".slick-next": {
        insetBlockStart: "auto",
        insetBlockEnd: arrowOffset,
        "&::after": {
          transform: "rotate(-135deg)"
        }
      },
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token2.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-start": {
          insetInlineEnd: "auto",
          insetInlineStart: dotOffset
        },
        "&-end": {
          insetInlineEnd: dotOffset,
          insetInlineStart: "auto"
        },
        li: {
          // reverse width and height in vertical situation
          ...reverseSizeOfDot,
          margin: `${unit(marginXXS)} 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&::after": {
            ...reverseSizeOfDot,
            height: 0
          },
          "&.slick-active": {
            ...reverseSizeOfDot,
            height: token2.dotActiveWidth,
            button: {
              ...reverseSizeOfDot,
              height: token2.dotActiveWidth
            },
            "&::after": {
              ...reverseSizeOfDot,
              animationName: animation,
              animationDuration: `var(${DotDuration})`,
              animationTimingFunction: "ease-out",
              animationFillMode: "forwards"
            }
          }
        }
      }
    }
  };
};
var genCarouselRtlStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [{
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  }, {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
};
var prepareComponentToken26 = (token2) => {
  const dotActiveWidth = 24;
  return {
    arrowSize: 16,
    arrowOffset: token2.marginXS,
    dotWidth: 16,
    dotHeight: 3,
    dotGap: token2.marginXXS,
    dotOffset: 12,
    dotWidthActive: dotActiveWidth,
    dotActiveWidth
  };
};
var style_default29 = genStyleHooks("Carousel", (token2) => [genCarouselStyle(token2), genArrowsStyle(token2), genDotsStyle(token2), genCarouselVerticalStyle(token2), genCarouselRtlStyle(token2)], prepareComponentToken26, {
  deprecatedTokens: [["dotWidthActive", "dotActiveWidth"]]
});

// node_modules/antd/es/carousel/index.js
var dotsClass = "slick-dots";
var ArrowButton = ({
  currentSlide,
  slideCount,
  ...rest
}) => React326.createElement("button", {
  type: "button",
  ...rest
});
var Carousel = React326.forwardRef((props, ref) => {
  const {
    dots = true,
    arrows = false,
    prevArrow,
    nextArrow,
    draggable = false,
    waitForAnimate = false,
    dotPosition,
    dotPlacement,
    vertical,
    rootClassName,
    className: customClassName,
    style: style2,
    id,
    autoplay = false,
    autoplaySpeed = 3e3,
    rtl,
    ...otherProps
  } = props;
  const mergedDotPlacement = React326.useMemo(() => {
    const placement = dotPlacement ?? dotPosition ?? "bottom";
    switch (placement) {
      case "left":
        return "start";
      case "right":
        return "end";
      default:
        return placement;
    }
  }, [dotPosition, dotPlacement]);
  const mergedVertical = vertical ?? (mergedDotPlacement === "start" || mergedDotPlacement === "end");
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("carousel");
  const slickRef = React326.useRef(null);
  const goTo = (slide, dontAnimate = false) => {
    slickRef.current.slickGoTo(slide, dontAnimate);
  };
  React326.useImperativeHandle(ref, () => ({
    goTo,
    autoPlay: slickRef.current.innerSlider.autoPlay,
    innerSlider: slickRef.current.innerSlider,
    prev: slickRef.current.slickPrev,
    next: slickRef.current.slickNext
  }), [slickRef.current]);
  const {
    children,
    initialSlide = 0
  } = props;
  const childNodes = toArray(children);
  const count = childNodes.length;
  const isRTL = (rtl ?? direction === "rtl") && !vertical;
  React326.useEffect(() => {
    if (count > 0) {
      const newIndex = isRTL ? count - initialSlide - 1 : initialSlide;
      goTo(newIndex, false);
    }
  }, [count, initialSlide, isRTL]);
  if (true) {
    const warning5 = devUseWarning("Carousel");
    warning5.deprecated(!dotPosition, "dotPosition", "dotPlacement");
  }
  const newProps = {
    vertical: mergedVertical,
    className: clsx(customClassName, contextClassName),
    style: {
      ...contextStyle,
      ...style2
    },
    autoplay: !!autoplay,
    ...otherProps
  };
  if (newProps.effect === "fade") {
    newProps.fade = true;
  }
  const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
  const enableDots = !!dots;
  const dsClass = clsx(dotsClass, `${dotsClass}-${mergedDotPlacement}`, typeof dots === "boolean" ? false : dots == null ? void 0 : dots.className);
  const [hashId, cssVarCls] = style_default29(prefixCls);
  const className = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: isRTL,
    [`${prefixCls}-vertical`]: newProps.vertical
  }, hashId, cssVarCls, rootClassName);
  const mergedShowDuration = autoplay && (typeof autoplay === "object" ? autoplay.dotDuration : false);
  const dotDurationStyle = mergedShowDuration ? {
    [DotDuration]: `${autoplaySpeed}ms`
  } : {};
  return React326.createElement("div", {
    className,
    id,
    style: dotDurationStyle
  }, React326.createElement(es_default19, {
    ref: slickRef,
    ...newProps,
    dots: enableDots,
    dotsClass: dsClass,
    arrows,
    prevArrow: prevArrow ?? React326.createElement(ArrowButton, {
      "aria-label": isRTL ? "next" : "prev"
    }),
    nextArrow: nextArrow ?? React326.createElement(ArrowButton, {
      "aria-label": isRTL ? "prev" : "next"
    }),
    draggable,
    verticalSwiping: mergedVertical,
    autoplaySpeed,
    waitForAnimate,
    rtl: isRTL
  }));
});
if (true) {
  Carousel.displayName = "Carousel";
}
var carousel_default = Carousel;

// node_modules/antd/es/cascader/index.js
var React348 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/Cascader.js
var React343 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/context.js
var React327 = __toESM(require_react());
var CascaderContext = React327.createContext({});
var context_default9 = CascaderContext;

// node_modules/@rc-component/cascader/es/hooks/useSearchOptions.js
var React328 = __toESM(require_react());
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = (search, options, {
  label = ""
}) => options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
var defaultRender = (inputValue, path2, prefixCls, fieldNames) => path2.map((opt) => opt[fieldNames.label]).join(" / ");
var useSearchOptions = (search, options, fieldNames, prefixCls, config, enableHalfPath) => {
  const {
    filter: filter3 = defaultFilter,
    render: render2 = defaultRender,
    limit = 50,
    sort
  } = config;
  return React328.useMemo(() => {
    const filteredOptions = [];
    if (!search) {
      return [];
    }
    function dig(list, pathOptions, parentDisabled = false) {
      list.forEach((option) => {
        if (!sort && limit !== false && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.children];
        const mergedDisabled = parentDisabled || option.disabled;
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect or multiple
          enableHalfPath
        ) {
          if (filter3(search, connectedPathOptions, {
            label: fieldNames.label
          })) {
            filteredOptions.push({
              ...option,
              disabled: mergedDisabled,
              [fieldNames.label]: render2(search, connectedPathOptions, prefixCls, fieldNames),
              [SEARCH_MARK]: connectedPathOptions,
              [fieldNames.children]: void 0
            });
          }
        }
        if (children) {
          dig(option[fieldNames.children], connectedPathOptions, mergedDisabled);
        }
      });
    }
    dig(options, []);
    if (sort) {
      filteredOptions.sort((a, b) => {
        return sort(a[SEARCH_MARK], b[SEARCH_MARK], search, fieldNames);
      });
    }
    return limit !== false && limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  }, [search, options, fieldNames, prefixCls, render2, enableHalfPath, filter3, sort, limit]);
};
var useSearchOptions_default = useSearchOptions;

// node_modules/@rc-component/cascader/es/utils/commonUtil.js
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey2) {
  return pathKey2.split(VALUE_SPLIT);
}
function fillFieldNames2(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  var _a;
  return option.isLeaf ?? !((_a = option[fieldNames.children]) == null ? void 0 : _a.length);
}
function scrollIntoParentView(element) {
  const parent = element.parentElement;
  if (!parent) {
    return;
  }
  const elementToParent = element.offsetTop - parent.offsetTop;
  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({
      top: elementToParent + element.offsetHeight - parent.offsetHeight
    });
  }
}
function getFullPathKeys(options, fieldNames) {
  return options.map((item) => {
    var _a;
    return (_a = item[SEARCH_MARK]) == null ? void 0 : _a.map((opt) => opt[fieldNames.value]);
  });
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}

// node_modules/@rc-component/cascader/es/utils/treeUtil.js
function formatStrategyValues(pathKeys, getKeyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  const keyPathEntities = getKeyPathEntities();
  return pathKeys.filter((key) => {
    const entity = keyPathEntities[key];
    const parent = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    if (entity && entity.node.disabled) {
      return true;
    }
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent && !parent.node.disabled && valueSet.has(parent.key));
  });
}
function toPathOptions(valueCells, options, fieldNames, stringMode = false) {
  let currentList = options;
  const valueOptions = [];
  for (let i = 0; i < valueCells.length; i += 1) {
    const valueCell = valueCells[i];
    const foundIndex = currentList == null ? void 0 : currentList.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList == null ? void 0 : currentList[foundIndex] : null;
    valueOptions.push({
      value: (foundOption == null ? void 0 : foundOption[fieldNames.value]) ?? valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption == null ? void 0 : foundOption[fieldNames.children];
  }
  return valueOptions;
}

// node_modules/@rc-component/cascader/es/hooks/useDisplayValues.js
var React329 = __toESM(require_react());
var useDisplayValues_default = (rawValues, options, fieldNames, multiple, displayRender) => {
  return React329.useMemo(() => {
    const mergedDisplayRender = displayRender || // Default displayRender
    ((labels) => {
      const mergedLabels = multiple ? labels.slice(-1) : labels;
      const SPLIT3 = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT3);
      }
      return mergedLabels.reduce((list, label, index2) => {
        const keyedLabel = React329.isValidElement(label) ? React329.cloneElement(label, {
          key: index2
        }) : label;
        if (index2 === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT3, keyedLabel];
      }, []);
    });
    return rawValues.map((valueCells) => {
      var _a, _b;
      const valueOptions = toPathOptions(valueCells, options, fieldNames);
      const label = mergedDisplayRender(valueOptions.map(({
        option,
        value: value2
      }) => (option == null ? void 0 : option[fieldNames.label]) ?? value2), valueOptions.map(({
        option
      }) => option));
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells,
        disabled: (_b = (_a = valueOptions[valueOptions.length - 1]) == null ? void 0 : _a.option) == null ? void 0 : _b.disabled
      };
    });
  }, [rawValues, options, fieldNames, displayRender, multiple]);
};

// node_modules/@rc-component/cascader/es/hooks/useMissingValues.js
var React330 = __toESM(require_react());
function useMissingValues(options, fieldNames) {
  return React330.useCallback((rawValues) => {
    const missingValues = [];
    const existsValues = [];
    rawValues.forEach((valueCell) => {
      const pathOptions = toPathOptions(valueCell, options, fieldNames);
      if (pathOptions.every((opt) => opt.option)) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  }, [options, fieldNames]);
}

// node_modules/@rc-component/cascader/es/hooks/useOptions.js
var React332 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/hooks/useEntities.js
var React331 = __toESM(require_react());

// node_modules/@rc-component/tree/es/utils/keyUtil.js
function getEntity(keyEntities, key) {
  return keyEntities[key];
}

// node_modules/@rc-component/tree/es/utils/treeUtil.js
function getPosition2(level, index2) {
  return `${level}-${index2}`;
}
function isTreeNode(node2) {
  return node2 && node2.type && node2.type.isTreeNode;
}
function getKey4(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
function fillFieldNames3(fieldNames) {
  const {
    title,
    _title,
    key,
    children
  } = fieldNames || {};
  const mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || "key",
    children: children || "children"
  };
}
function warningWithoutKey(treeData, fieldNames) {
  const keys2 = /* @__PURE__ */ new Map();
  function dig(list, path2 = "") {
    (list || []).forEach((treeNode) => {
      const key = treeNode[fieldNames.key];
      const children = treeNode[fieldNames.children];
      warning_default(key !== null && key !== void 0, `Tree node must have a certain key: [${path2}${key}]`);
      const recordKey = String(key);
      warning_default(!keys2.has(recordKey) || key === null || key === void 0, `Same 'key' exist in the Tree: ${recordKey}`);
      keys2.set(recordKey, true);
      dig(children, `${path2}${recordKey} > `);
    });
  }
  dig(treeData);
}
function convertTreeToData(rootNodes) {
  function dig(node2) {
    const treeNodes = toArray(node2);
    return treeNodes.map((treeNode) => {
      if (!isTreeNode(treeNode)) {
        warning_default(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      const {
        key
      } = treeNode;
      const {
        children,
        ...rest
      } = treeNode.props;
      const dataNode = {
        key,
        ...rest
      };
      const parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter((dataNode) => dataNode);
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  const {
    _title: fieldTitles,
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames3(fieldNames);
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list, parent = null) {
    return list.map((treeNode, index2) => {
      const pos = getPosition2(parent ? parent.pos : "0", index2);
      const mergedKey = getKey4(treeNode[fieldKey], pos);
      let mergedTitle;
      for (let i = 0; i < fieldTitles.length; i += 1) {
        const fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      const flattenNode = Object.assign(omit(treeNode, [...fieldTitles, fieldKey, fieldChildren]), {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [...parent ? parent.isStart : [], index2 === 0],
        isEnd: [...parent ? parent.isEnd : [], index2 === list.length - 1]
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  let mergedConfig = {};
  if (typeof config === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  const {
    childrenPropName,
    externalGetKey,
    fieldNames
  } = mergedConfig;
  const {
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames3(fieldNames);
  const mergeChildrenPropName = childrenPropName || fieldChildren;
  let syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = (node2) => node2[externalGetKey];
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = (node2) => externalGetKey(node2);
    }
  } else {
    syntheticGetKey = (node2, pos) => getKey4(node2[fieldKey], pos);
  }
  function processNode(node2, index2, parent, pathNodes) {
    const children = node2 ? node2[mergeChildrenPropName] : dataNodes;
    const pos = node2 ? getPosition2(parent.pos, index2) : "0";
    const connectNodes = node2 ? [...pathNodes, node2] : [];
    if (node2) {
      const key = syntheticGetKey(node2, pos);
      const data = {
        node: node2,
        index: index2,
        pos,
        key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    if (children) {
      children.forEach((subNode, subIndex) => {
        processNode(subNode, subIndex, {
          node: node2,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes, {
  initWrapper,
  processEntity,
  onProcessFinished,
  externalGetKey,
  childrenPropName,
  fieldNames
} = {}, legacyExternalGetKey) {
  const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  const posEntities = {};
  const keyEntities = {};
  let wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, (item) => {
    const {
      node: node2,
      index: index2,
      pos,
      key,
      parentPos,
      level,
      nodes
    } = item;
    const entity = {
      node: node2,
      nodes,
      index: index2,
      key,
      pos,
      level
    };
    const mergedKey = getKey4(key, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key, {
  expandedKeys,
  selectedKeys,
  loadedKeys,
  loadingKeys,
  checkedKeys,
  halfCheckedKeys,
  dragOverNodeKey,
  dropPosition,
  keyEntities
}) {
  const entity = getEntity(keyEntities, key);
  const treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ""),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  const {
    data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey
  } = props;
  const eventData = {
    ...data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  };
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get() {
        warning_default(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
        return props;
      }
    });
  }
  return eventData;
}

// node_modules/@rc-component/cascader/es/hooks/useEntities.js
var useEntities_default = (options, fieldNames) => {
  const cacheRef = React331.useRef({
    options: [],
    info: {
      keyEntities: {},
      pathKeyEntities: {}
    }
  });
  const getEntities = React331.useCallback(() => {
    if (cacheRef.current.options !== options) {
      cacheRef.current.options = options;
      cacheRef.current.info = convertDataToEntities(options, {
        fieldNames,
        initWrapper: (wrapper) => ({
          ...wrapper,
          pathKeyEntities: {}
        }),
        processEntity: (entity, wrapper) => {
          const pathKey2 = entity.nodes.map((node2) => node2[fieldNames.value]).join(VALUE_SPLIT);
          wrapper.pathKeyEntities[pathKey2] = entity;
          entity.key = pathKey2;
        }
      });
    }
    return cacheRef.current.info.pathKeyEntities;
  }, [fieldNames, options]);
  return getEntities;
};

// node_modules/@rc-component/cascader/es/hooks/useOptions.js
function useOptions2(mergedFieldNames, options) {
  const mergedOptions = React332.useMemo(() => options || [], [options]);
  const getPathKeyEntities = useEntities_default(mergedOptions, mergedFieldNames);
  const getValueByKeyPath = React332.useCallback((pathKeys) => {
    const keyPathEntities = getPathKeyEntities();
    return pathKeys.map((pathKey2) => {
      const {
        nodes
      } = keyPathEntities[pathKey2];
      return nodes.map((node2) => node2[mergedFieldNames.value]);
    });
  }, [getPathKeyEntities, mergedFieldNames]);
  return [mergedOptions, getPathKeyEntities, getValueByKeyPath];
}

// node_modules/@rc-component/cascader/es/hooks/useSearchConfig.js
var React333 = __toESM(require_react());
function useSearchConfig2(showSearch, props) {
  const {
    autoClearSearchValue,
    searchValue,
    onSearch
  } = props;
  return React333.useMemo(() => {
    if (!showSearch) {
      return [false, {}];
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50,
      autoClearSearchValue,
      searchValue,
      onSearch
    };
    if (showSearch && typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    if (searchConfig.limit <= 0) {
      searchConfig.limit = false;
      if (true) {
        warning_default(false, "'limit' of showSearch should be positive number or false.");
      }
    }
    return [true, searchConfig];
  }, [showSearch, autoClearSearchValue, searchValue, onSearch]);
}

// node_modules/@rc-component/tree/es/utils/conductUtil.js
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  const filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach((key) => {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node2) {
  const {
    disabled,
    disableCheckbox,
    checkable
  } = node2 || {};
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  const halfCheckedKeys = /* @__PURE__ */ new Set();
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key,
        node: node2,
        children = []
      } = entity;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent,
        node: node2
      } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({
        key
      }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  let halfCheckedKeys = new Set(halfKeys);
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key,
        node: node2,
        children = []
      } = entity;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent,
        node: node2
      } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach(({
        key
      }) => {
        const checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  const warningMissKeys = [];
  let syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  const keys2 = new Set(keyList.filter((key) => {
    const hasEntity = !!getEntity(keyEntities, key);
    if (!hasEntity) {
      warningMissKeys.push(key);
    }
    return hasEntity;
  }));
  const levelEntities = /* @__PURE__ */ new Map();
  let maxLevel = 0;
  Object.keys(keyEntities).forEach((key) => {
    const entity = keyEntities[key];
    const {
      level
    } = entity;
    let levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warning_default(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map((key) => `'${key}'`).join(", ")}`);
  let result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}

// node_modules/@rc-component/cascader/es/hooks/useSelect.js
function useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy) {
  return (valuePath) => {
    if (!multiple) {
      triggerChange(valuePath);
    } else {
      const pathKey2 = toPathKey(valuePath);
      const checkedPathKeys = toPathKeys(checkedValues);
      const halfCheckedPathKeys = toPathKeys(halfCheckedValues);
      const existInChecked = checkedPathKeys.includes(pathKey2);
      const existInMissing = missingCheckedValues.some((valueCells) => toPathKey(valueCells) === pathKey2);
      let nextCheckedValues = checkedValues;
      let nextMissingValues = missingCheckedValues;
      if (existInMissing && !existInChecked) {
        nextMissingValues = missingCheckedValues.filter((valueCells) => toPathKey(valueCells) !== pathKey2);
      } else {
        const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key) => key !== pathKey2) : [...checkedPathKeys, pathKey2];
        const pathKeyEntities = getPathKeyEntities();
        let checkedKeys;
        if (existInChecked) {
          ({
            checkedKeys
          } = conductCheck(nextRawCheckedKeys, {
            checked: false,
            halfCheckedKeys: halfCheckedPathKeys
          }, pathKeyEntities));
        } else {
          ({
            checkedKeys
          } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities));
        }
        const deDuplicatedKeys = formatStrategyValues(checkedKeys, getPathKeyEntities, showCheckedStrategy);
        nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
      }
      triggerChange([...nextMissingValues, ...nextCheckedValues]);
    }
  };
}

// node_modules/@rc-component/cascader/es/hooks/useValues.js
var React334 = __toESM(require_react());
function useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues) {
  return React334.useMemo(() => {
    const [existValues, missingValues] = getMissingValues(rawValues);
    if (!multiple || !rawValues.length) {
      return [existValues, [], missingValues];
    }
    const keyPathValues = toPathKeys(existValues);
    const keyPathEntities = getPathKeyEntities();
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(keyPathValues, true, keyPathEntities);
    return [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
  }, [multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues]);
}

// node_modules/@rc-component/cascader/es/OptionList/index.js
var React341 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/List.js
var React340 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/CacheContent.js
var React335 = __toESM(require_react());
var CacheContent = React335.memo(({
  children
}) => children, (_, next2) => !next2.open);
if (true) {
  CacheContent.displayName = "CacheContent";
}
var CacheContent_default = CacheContent;

// node_modules/@rc-component/cascader/es/OptionList/Column.js
var React337 = __toESM(require_react());

// node_modules/@rc-component/cascader/es/OptionList/Checkbox.js
var React336 = __toESM(require_react());
function Checkbox2({
  prefixCls,
  checked,
  halfChecked,
  disabled,
  onClick,
  disableCheckbox
}) {
  const {
    checkable
  } = React336.useContext(context_default9);
  const customCheckbox = typeof checkable !== "boolean" ? checkable : null;
  return React336.createElement("span", {
    className: clsx(`${prefixCls}`, {
      [`${prefixCls}-checked`]: checked,
      [`${prefixCls}-indeterminate`]: !checked && halfChecked,
      [`${prefixCls}-disabled`]: disabled || disableCheckbox
    }),
    onClick
  }, customCheckbox);
}

// node_modules/@rc-component/cascader/es/OptionList/Column.js
function _extends55() {
  _extends55 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends55.apply(this, arguments);
}
var FIX_LABEL = "__cascader_fix_label__";
function Column({
  prefixCls,
  multiple,
  options,
  activeValue,
  prevValuePath,
  onToggleOpen,
  onSelect,
  onActive,
  checkedSet,
  halfCheckedSet,
  loadingKeys,
  isSelectable,
  disabled: propsDisabled
}) {
  var _a, _b;
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const menuRef = React337.useRef(null);
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle,
    optionRender,
    classNames,
    styles
  } = React337.useContext(context_default9);
  const hoverOpen = expandTrigger === "hover";
  const isOptionDisabled = (disabled) => propsDisabled || disabled;
  const optionInfoList = React337.useMemo(() => options.map((option) => {
    const {
      disabled,
      disableCheckbox
    } = option;
    const searchOptions = option[SEARCH_MARK];
    const label = option[FIX_LABEL] ?? option[fieldNames.label];
    const value = option[fieldNames.value];
    const isMergedLeaf = isLeaf(option, fieldNames);
    const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value]) : [...prevValuePath, value];
    const fullPathKey = toPathKey(fullPath);
    const isLoading = loadingKeys.includes(fullPathKey);
    const checked = checkedSet.has(fullPathKey);
    const halfChecked = halfCheckedSet.has(fullPathKey);
    return {
      disabled,
      label,
      value,
      isLeaf: isMergedLeaf,
      isLoading,
      checked,
      halfChecked,
      option,
      disableCheckbox,
      fullPath,
      fullPathKey
    };
  }), [options, checkedSet, fieldNames, halfCheckedSet, loadingKeys, prevValuePath]);
  React337.useEffect(() => {
    if (menuRef.current) {
      const selector = `.${menuItemPrefixCls}-active`;
      const activeElement = menuRef.current.querySelector(selector);
      if (activeElement) {
        scrollIntoParentView(activeElement);
      }
    }
  }, [activeValue, menuItemPrefixCls]);
  return React337.createElement("ul", {
    className: clsx(menuPrefixCls, (_a = classNames == null ? void 0 : classNames.popup) == null ? void 0 : _a.list),
    style: (_b = styles == null ? void 0 : styles.popup) == null ? void 0 : _b.list,
    ref: menuRef,
    role: "menu"
  }, optionInfoList.map(({
    disabled,
    label,
    value,
    isLeaf: isMergedLeaf,
    isLoading,
    checked,
    halfChecked,
    option,
    fullPath,
    fullPathKey,
    disableCheckbox
  }) => {
    var _a2, _b2;
    const ariaProps = pickAttrs(option, {
      aria: true,
      data: true
    });
    const triggerOpenPath = () => {
      if (isOptionDisabled(disabled)) {
        return;
      }
      const nextValueCells = [...fullPath];
      if (hoverOpen && isMergedLeaf) {
        nextValueCells.pop();
      }
      onActive(nextValueCells);
    };
    const triggerSelect = () => {
      if (isSelectable(option) && !isOptionDisabled(disabled)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    let title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return React337.createElement("li", _extends55({
      key: fullPathKey
    }, ariaProps, {
      className: clsx(menuItemPrefixCls, (_a2 = classNames == null ? void 0 : classNames.popup) == null ? void 0 : _a2.listItem, {
        [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
        [`${menuItemPrefixCls}-active`]: activeValue === value || activeValue === fullPathKey,
        [`${menuItemPrefixCls}-disabled`]: isOptionDisabled(disabled),
        [`${menuItemPrefixCls}-loading`]: isLoading
      }),
      style: {
        ...popupMenuColumnStyle,
        ...(_b2 = styles == null ? void 0 : styles.popup) == null ? void 0 : _b2.listItem
      },
      role: "menuitemcheckbox",
      title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      onClick: () => {
        triggerOpenPath();
        if (disableCheckbox) {
          return;
        }
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      onDoubleClick: () => {
        if (changeOnSelect) {
          onToggleOpen(false);
        }
      },
      onMouseEnter: () => {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      onMouseDown: (e3) => {
        e3.preventDefault();
      }
    }), multiple && React337.createElement(Checkbox2, {
      prefixCls: `${prefixCls}-checkbox`,
      checked,
      halfChecked,
      disabled: isOptionDisabled(disabled) || disableCheckbox,
      disableCheckbox,
      onClick: (e3) => {
        if (disableCheckbox) {
          return;
        }
        e3.stopPropagation();
        triggerSelect();
      }
    }), React337.createElement("div", {
      className: `${menuItemPrefixCls}-content`
    }, optionRender ? optionRender(option) : label), !isLoading && expandIcon && !isMergedLeaf && React337.createElement("div", {
      className: `${menuItemPrefixCls}-expand-icon`
    }, expandIcon), isLoading && loadingIcon && React337.createElement("div", {
      className: `${menuItemPrefixCls}-loading-icon`
    }, loadingIcon));
  }));
}

// node_modules/@rc-component/cascader/es/OptionList/useActive.js
var React338 = __toESM(require_react());
var useActive2 = (multiple, open3) => {
  const {
    values
  } = React338.useContext(context_default9);
  const firstValueCells = values[0];
  const [activeValueCells, setActiveValueCells] = React338.useState([]);
  React338.useEffect(
    () => {
      if (!multiple) {
        setActiveValueCells(firstValueCells || []);
      }
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [open3, firstValueCells]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  return [activeValueCells, setActiveValueCells];
};
var useActive_default = useActive2;

// node_modules/@rc-component/cascader/es/OptionList/useKeyboard.js
var React339 = __toESM(require_react());
var useKeyboard_default = (ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {
  const {
    direction,
    searchValue,
    toggleOpen,
    open: open3
  } = contextProps;
  const rtl = direction === "rtl";
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = React339.useMemo(() => {
    let activeIndex = -1;
    let currentOptions = options;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.length;
    const pathKeys = getFullPathKeys(options, fieldNames);
    for (let i = 0; i < len && currentOptions; i += 1) {
      const nextActiveIndex = currentOptions.findIndex((option, index2) => (pathKeys[index2] ? toPathKey(pathKeys[index2]) : option[fieldNames.value]) === activeValueCells[i]);
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells[i]);
      currentOptions = currentOptions[activeIndex][fieldNames.children];
    }
    let activeOptions = options;
    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];
    }
    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];
  }, [activeValueCells, fieldNames, options]);
  const internalSetActiveValueCells = (next2) => {
    setActiveValueCells(next2);
  };
  const offsetActiveOption = (offset3) => {
    const len = lastActiveOptions.length;
    let currentIndex = lastActiveIndex;
    if (currentIndex === -1 && offset3 < 0) {
      currentIndex = len;
    }
    for (let i = 0; i < len; i += 1) {
      currentIndex = (currentIndex + offset3 + len) % len;
      const option = lastActiveOptions[currentIndex];
      if (option && !option.disabled) {
        const nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  const prevColumn = () => {
    if (validActiveValueCells.length > 1) {
      const nextActiveCells = validActiveValueCells.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      toggleOpen(false);
    }
  };
  const nextColumn = () => {
    var _a;
    const nextOptions = ((_a = lastActiveOptions[lastActiveIndex]) == null ? void 0 : _a[fieldNames.children]) || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells, nextOption[fieldNames.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  React339.useImperativeHandle(ref, () => ({
    // scrollTo: treeRef.current?.scrollTo,
    onKeyDown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        case KeyCode_default.UP:
        case KeyCode_default.DOWN: {
          let offset3 = 0;
          if (which === KeyCode_default.UP) {
            offset3 = -1;
          } else if (which === KeyCode_default.DOWN) {
            offset3 = 1;
          }
          if (offset3 !== 0) {
            offsetActiveOption(offset3);
          }
          break;
        }
        case KeyCode_default.LEFT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.RIGHT: {
          if (searchValue) {
            break;
          }
          if (rtl) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode_default.BACKSPACE: {
          if (!searchValue) {
            prevColumn();
          }
          break;
        }
        case KeyCode_default.ENTER: {
          if (validActiveValueCells.length) {
            const option = lastActiveOptions[lastActiveIndex];
            const originOptions = (option == null ? void 0 : option[SEARCH_MARK]) || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value]), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);
            }
          }
          break;
        }
        case KeyCode_default.ESC: {
          toggleOpen(false);
          if (open3) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyUp: () => {
    }
  }));
};

// node_modules/@rc-component/cascader/es/OptionList/List.js
function _extends56() {
  _extends56 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends56.apply(this, arguments);
}
var RawOptionList = React340.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls,
    multiple,
    searchValue,
    toggleOpen,
    notFoundContent,
    direction,
    open: open3,
    disabled
  } = props;
  const containerRef = React340.useRef(null);
  const rtl = direction === "rtl";
  const {
    options,
    values,
    halfValues,
    fieldNames,
    changeOnSelect,
    onSelect,
    searchOptions,
    popupPrefixCls,
    loadData,
    expandTrigger
  } = React340.useContext(context_default9);
  const mergedPrefixCls = popupPrefixCls || prefixCls;
  const [loadingKeys, setLoadingKeys] = React340.useState([]);
  const internalLoadData = (valueCells) => {
    if (!loadData || searchValue) {
      return;
    }
    const optionList = toPathOptions(valueCells, options, fieldNames);
    const rawOptions = optionList.map(({
      option
    }) => option);
    const lastOption = rawOptions[rawOptions.length - 1];
    if (lastOption && !isLeaf(lastOption, fieldNames)) {
      const pathKey2 = toPathKey(valueCells);
      setLoadingKeys((keys2) => [...keys2, pathKey2]);
      loadData(rawOptions);
    }
  };
  React340.useEffect(() => {
    if (loadingKeys.length) {
      loadingKeys.forEach((loadingKey) => {
        const valueStrCells = toPathValueStr(loadingKey);
        const optionList = toPathOptions(valueStrCells, options, fieldNames, true).map(({
          option
        }) => option);
        const lastOption = optionList[optionList.length - 1];
        if (!lastOption || lastOption[fieldNames.children] || isLeaf(lastOption, fieldNames)) {
          setLoadingKeys((keys2) => keys2.filter((key) => key !== loadingKey));
        }
      });
    }
  }, [options, loadingKeys, fieldNames]);
  const checkedSet = React340.useMemo(() => new Set(toPathKeys(values)), [values]);
  const halfCheckedSet = React340.useMemo(() => new Set(toPathKeys(halfValues)), [halfValues]);
  const [activeValueCells, setActiveValueCells] = useActive_default(multiple, open3);
  const onPathOpen = (nextValueCells) => {
    setActiveValueCells(nextValueCells);
    internalLoadData(nextValueCells);
  };
  const isSelectable = (option) => {
    if (disabled) {
      return false;
    }
    const {
      disabled: optionDisabled
    } = option;
    const isMergedLeaf = isLeaf(option, fieldNames);
    return !optionDisabled && (isMergedLeaf || changeOnSelect || multiple);
  };
  const onPathSelect = (valuePath, leaf, fromKeyboard = false) => {
    onSelect(valuePath);
    if (!multiple && (leaf || changeOnSelect && (expandTrigger === "hover" || fromKeyboard))) {
      toggleOpen(false);
    }
  };
  const mergedOptions = React340.useMemo(() => {
    if (searchValue) {
      return searchOptions;
    }
    return options;
  }, [searchValue, searchOptions, options]);
  const optionColumns = React340.useMemo(() => {
    const optionList = [{
      options: mergedOptions
    }];
    let currentList = mergedOptions;
    const fullPathKeys = getFullPathKeys(currentList, fieldNames);
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const activeValueCell = activeValueCells[i];
      const currentOption = currentList.find((option, index2) => (fullPathKeys[index2] ? toPathKey(fullPathKeys[index2]) : option[fieldNames.value]) === activeValueCell);
      const subOptions = currentOption == null ? void 0 : currentOption[fieldNames.children];
      if (!(subOptions == null ? void 0 : subOptions.length)) {
        break;
      }
      currentList = subOptions;
      optionList.push({
        options: subOptions
      });
    }
    return optionList;
  }, [mergedOptions, activeValueCells, fieldNames]);
  const onKeyboardSelect = (selectValueCells, option) => {
    if (isSelectable(option)) {
      onPathSelect(selectValueCells, isLeaf(option, fieldNames), true);
    }
  };
  useKeyboard_default(ref, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect, {
    direction,
    searchValue,
    toggleOpen,
    open: open3
  });
  React340.useEffect(() => {
    var _a2;
    if (searchValue) {
      return;
    }
    for (let i = 0; i < activeValueCells.length; i += 1) {
      const cellPath = activeValueCells.slice(0, i + 1);
      const cellKeyPath = toPathKey(cellPath);
      const ele = (_a2 = containerRef.current) == null ? void 0 : _a2.querySelector(
        `li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`
      );
      if (ele) {
        scrollIntoParentView(ele);
      }
    }
  }, [activeValueCells, searchValue]);
  const isEmpty2 = !((_b = (_a = optionColumns[0]) == null ? void 0 : _a.options) == null ? void 0 : _b.length);
  const emptyList = [{
    [fieldNames.value]: "__EMPTY__",
    [FIX_LABEL]: notFoundContent,
    disabled: true
  }];
  const columnProps = {
    ...props,
    multiple: !isEmpty2 && multiple,
    onSelect: onPathSelect,
    onActive: onPathOpen,
    onToggleOpen: toggleOpen,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  };
  const mergedOptionColumns = isEmpty2 ? [{
    options: emptyList
  }] : optionColumns;
  const columnNodes = mergedOptionColumns.map((col, index2) => {
    const prevValuePath = activeValueCells.slice(0, index2);
    const activeValue = activeValueCells[index2];
    return React340.createElement(Column, _extends56({
      key: index2
    }, columnProps, {
      prefixCls: mergedPrefixCls,
      options: col.options,
      prevValuePath,
      activeValue
    }));
  });
  return React340.createElement(CacheContent_default, {
    open: open3
  }, React340.createElement("div", {
    className: clsx(`${mergedPrefixCls}-menus`, {
      [`${mergedPrefixCls}-menu-empty`]: isEmpty2,
      [`${mergedPrefixCls}-rtl`]: rtl
    }),
    ref: containerRef
  }, columnNodes));
});
if (true) {
  RawOptionList.displayName = "RawOptionList";
}
var List_default3 = RawOptionList;

// node_modules/@rc-component/cascader/es/OptionList/index.js
function _extends57() {
  _extends57 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends57.apply(this, arguments);
}
var RefOptionList2 = React341.forwardRef((props, ref) => {
  const baseProps = useBaseProps();
  return React341.createElement(List_default3, _extends57({}, props, baseProps, {
    ref
  }));
});
var OptionList_default2 = RefOptionList2;

// node_modules/@rc-component/cascader/es/Panel.js
var React342 = __toESM(require_react());
function noop3() {
}
function Panel3(props) {
  const {
    prefixCls = "rc-cascader",
    style: style2,
    className,
    options,
    checkable,
    defaultValue,
    value,
    fieldNames,
    changeOnSelect,
    onChange,
    showCheckedStrategy,
    loadData,
    expandTrigger,
    expandIcon = ">",
    loadingIcon,
    direction,
    notFoundContent = "Not Found",
    disabled,
    optionRender
  } = props;
  const multiple = !!checkable;
  const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
  const rawValues = toRawValues(interanlRawValues);
  const mergedFieldNames = React342.useMemo(
    () => fillFieldNames2(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions2(mergedFieldNames, options);
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues);
  const triggerChange = useEvent_default((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
  const onInternalSelect = useEvent_default((valuePath) => {
    handleSelection(valuePath);
  });
  const cascaderContext = React342.useMemo(() => ({
    options: mergedOptions,
    fieldNames: mergedFieldNames,
    values: checkedValues,
    halfValues: halfCheckedValues,
    changeOnSelect,
    onSelect: onInternalSelect,
    checkable,
    searchOptions: [],
    popupPrefixCls: void 0,
    loadData,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle: void 0,
    optionRender
  }), [mergedOptions, mergedFieldNames, checkedValues, halfCheckedValues, changeOnSelect, onInternalSelect, checkable, loadData, expandTrigger, expandIcon, loadingIcon, optionRender]);
  const panelPrefixCls = `${prefixCls}-panel`;
  const isEmpty2 = !mergedOptions.length;
  return React342.createElement(context_default9.Provider, {
    value: cascaderContext
  }, React342.createElement("div", {
    className: clsx(panelPrefixCls, {
      [`${panelPrefixCls}-rtl`]: direction === "rtl",
      [`${panelPrefixCls}-empty`]: isEmpty2
    }, className),
    style: style2
  }, isEmpty2 ? notFoundContent : React342.createElement(List_default3, {
    prefixCls,
    searchValue: "",
    multiple,
    toggleOpen: noop3,
    open: true,
    direction,
    disabled
  })));
}

// node_modules/@rc-component/cascader/es/utils/warningPropsUtil.js
function warningNullOptions2(options, fieldNames) {
  if (options) {
    const recursiveOptions = (optionsList) => {
      for (let i = 0; i < optionsList.length; i++) {
        const option = optionsList[i];
        if (option[fieldNames == null ? void 0 : fieldNames.value] === null) {
          warning_default(false, "`value` in Cascader options should not be `null`.");
          return true;
        }
        if (Array.isArray(option[fieldNames == null ? void 0 : fieldNames.children]) && recursiveOptions(option[fieldNames == null ? void 0 : fieldNames.children])) {
          return true;
        }
      }
    };
    recursiveOptions(options);
  }
}

// node_modules/@rc-component/cascader/es/Cascader.js
function _extends58() {
  _extends58 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends58.apply(this, arguments);
}
var Cascader = React343.forwardRef((props, ref) => {
  const {
    // MISC
    id,
    prefixCls = "rc-cascader",
    fieldNames,
    // Value
    defaultValue,
    value,
    changeOnSelect,
    onChange,
    displayRender,
    checkable,
    // Search
    showSearch,
    // Trigger
    expandTrigger,
    // Options
    options,
    popupPrefixCls,
    loadData,
    open: open3,
    popupClassName,
    popupMenuColumnStyle,
    popupStyle: customPopupStyle,
    classNames,
    styles,
    placement,
    onPopupVisibleChange,
    // Icon
    expandIcon = ">",
    loadingIcon,
    // Children
    children,
    popupMatchSelectWidth = false,
    showCheckedStrategy = SHOW_PARENT,
    optionRender,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const multiple = !!checkable;
  const [interanlRawValues, setRawValues] = useControlledState(defaultValue, value);
  const rawValues = toRawValues(interanlRawValues);
  const mergedFieldNames = React343.useMemo(
    () => fillFieldNames2(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [mergedOptions, getPathKeyEntities, getValueByKeyPath] = useOptions2(mergedFieldNames, options);
  const [mergedShowSearch, searchConfig] = useSearchConfig2(showSearch, props);
  const {
    autoClearSearchValue = true,
    searchValue,
    onSearch
  } = searchConfig;
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const onInternalSearch = (searchText, info) => {
    setSearchValue(searchText);
    if (info.source !== "blur" && onSearch) {
      onSearch(searchText);
    }
  };
  const searchOptions = useSearchOptions_default(mergedSearchValue, mergedOptions, mergedFieldNames, popupPrefixCls || prefixCls, searchConfig, changeOnSelect || multiple);
  const getMissingValues = useMissingValues(mergedOptions, mergedFieldNames);
  const [checkedValues, halfCheckedValues, missingCheckedValues] = useValues(multiple, rawValues, getPathKeyEntities, getValueByKeyPath, getMissingValues);
  const deDuplicatedValues = React343.useMemo(() => {
    const checkedKeys = toPathKeys(checkedValues);
    const deduplicateKeys = formatStrategyValues(checkedKeys, getPathKeyEntities, showCheckedStrategy);
    return [...missingCheckedValues, ...getValueByKeyPath(deduplicateKeys)];
  }, [checkedValues, getPathKeyEntities, getValueByKeyPath, missingCheckedValues, showCheckedStrategy]);
  const displayValues = useDisplayValues_default(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, displayRender);
  const triggerChange = useEvent_default((nextValues) => {
    setRawValues(nextValues);
    if (onChange) {
      const nextRawValues = toRawValues(nextValues);
      const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions, mergedFieldNames).map((valueOpt) => valueOpt.option));
      const triggerValues = multiple ? nextRawValues : nextRawValues[0];
      const triggerOptions = multiple ? valueOptions : valueOptions[0];
      onChange(triggerValues, triggerOptions);
    }
  });
  const handleSelection = useSelect(multiple, triggerChange, checkedValues, halfCheckedValues, missingCheckedValues, getPathKeyEntities, getValueByKeyPath, showCheckedStrategy);
  const onInternalSelect = useEvent_default((valuePath) => {
    if (!multiple || autoClearSearchValue) {
      setSearchValue("");
    }
    handleSelection(valuePath);
  });
  const onDisplayValuesChange = (_, info) => {
    if (info.type === "clear") {
      triggerChange([]);
      return;
    }
    const {
      valueCells
    } = info.values[0];
    onInternalSelect(valueCells);
  };
  const onInternalPopupVisibleChange = (nextVisible) => {
    onPopupVisibleChange == null ? void 0 : onPopupVisibleChange(nextVisible);
  };
  if (true) {
    warningNullOptions2(mergedOptions, mergedFieldNames);
  }
  const cascaderContext = React343.useMemo(() => ({
    classNames,
    styles,
    options: mergedOptions,
    fieldNames: mergedFieldNames,
    values: checkedValues,
    halfValues: halfCheckedValues,
    changeOnSelect,
    onSelect: onInternalSelect,
    checkable,
    searchOptions,
    popupPrefixCls,
    loadData,
    expandTrigger,
    expandIcon,
    loadingIcon,
    popupMenuColumnStyle,
    optionRender
  }), [classNames, styles, mergedOptions, mergedFieldNames, checkedValues, halfCheckedValues, changeOnSelect, onInternalSelect, checkable, searchOptions, popupPrefixCls, loadData, expandTrigger, expandIcon, loadingIcon, popupMenuColumnStyle, optionRender]);
  const emptyOptions = !(mergedSearchValue ? searchOptions : mergedOptions).length;
  const popupStyle = (
    // Search to match width
    mergedSearchValue && searchConfig.matchInputWidth || // Empty keep the width
    emptyOptions ? {} : {
      minWidth: "auto"
    }
  );
  return React343.createElement(context_default9.Provider, {
    value: cascaderContext
  }, React343.createElement(BaseSelect_default, _extends58({}, restProps, {
    // MISC
    ref,
    id: mergedId,
    prefixCls,
    autoClearSearchValue,
    popupMatchSelectWidth,
    classNames,
    styles,
    popupStyle: {
      ...popupStyle,
      ...customPopupStyle
    },
    displayValues,
    onDisplayValuesChange,
    mode: multiple ? "multiple" : void 0,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    showSearch: mergedShowSearch,
    OptionList: OptionList_default2,
    emptyOptions,
    open: open3,
    popupClassName,
    placement,
    onPopupVisibleChange: onInternalPopupVisibleChange,
    getRawInputElement: () => children
  })));
});
if (true) {
  Cascader.displayName = "Cascader";
}
Cascader.SHOW_PARENT = SHOW_PARENT;
Cascader.SHOW_CHILD = SHOW_CHILD;
Cascader.Panel = Panel3;
var Cascader_default = Cascader;

// node_modules/@rc-component/cascader/es/index.js
var es_default20 = Cascader_default;

// node_modules/antd/es/cascader/hooks/useBase.js
var React344 = __toESM(require_react());
function useBase(customizePrefixCls, direction) {
  const {
    getPrefixCls,
    direction: rootDirection,
    renderEmpty
  } = React344.useContext(ConfigContext);
  const mergedDirection = direction || rootDirection;
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const cascaderPrefixCls = getPrefixCls("cascader", customizePrefixCls);
  return [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty];
}
var useBase_default = useBase;

// node_modules/antd/es/cascader/hooks/useCheckable.js
var React345 = __toESM(require_react());
function useCheckable(cascaderPrefixCls, multiple) {
  return React345.useMemo(() => multiple ? React345.createElement("span", {
    className: `${cascaderPrefixCls}-checkbox-inner`
  }) : false, [cascaderPrefixCls, multiple]);
}

// node_modules/antd/es/cascader/hooks/useColumnIcons.js
var React346 = __toESM(require_react());
var useColumnIcons = (prefixCls, rtl, expandIcon) => {
  let mergedExpandIcon = expandIcon;
  if (!expandIcon) {
    mergedExpandIcon = rtl ? React346.createElement(LeftOutlined_default, null) : React346.createElement(RightOutlined_default, null);
  }
  const loadingIcon = React346.useMemo(() => React346.createElement("span", {
    className: `${prefixCls}-menu-item-loading-icon`
  }, React346.createElement(LoadingOutlined_default, {
    spin: true
  })), [prefixCls]);
  return React346.useMemo(() => [mergedExpandIcon, loadingIcon], [mergedExpandIcon, loadingIcon]);
};
var useColumnIcons_default = useColumnIcons;

// node_modules/antd/es/cascader/Panel.js
var React347 = __toESM(require_react());

// node_modules/antd/es/checkbox/style/index.js
var genCheckboxStyle = (token2) => {
  const {
    checkboxCls
  } = token2;
  const wrapperCls = `${checkboxCls}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${checkboxCls}-group`]: {
        ...resetComponent(token2),
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: token2.marginXS,
        // Group > Grid
        [`> ${token2.antCls}-row`]: {
          flex: 1
        }
      },
      // Wrapper
      [wrapperCls]: {
        ...resetComponent(token2),
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${wrapperCls}`]: {
          marginInlineStart: 0
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            // FIXME: magic
            height: 14
            // FIXME: magic
          }
        }
      },
      // Wrapper > Checkbox
      [checkboxCls]: {
        ...resetComponent(token2),
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        borderRadius: token2.borderRadiusSM,
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${checkboxCls}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: genFocusOutline(token2)
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          display: "block",
          width: token2.checkboxSize,
          height: token2.checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "25%",
            display: "table",
            width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
            height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
            border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper & Wrapper > Checkbox
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
          }
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        }
      }
    },
    // ================= Indeterminate =================
    {
      [checkboxCls]: {
        "&-indeterminate": {
          "&": {
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              backgroundColor: `${token2.colorBgContainer}`,
              borderColor: `${token2.colorBorder}`,
              "&:after": {
                top: "50%",
                insetInlineStart: "50%",
                width: token2.calc(token2.fontSizeLG).div(2).equal(),
                height: token2.calc(token2.fontSizeLG).div(2).equal(),
                backgroundColor: token2.colorPrimary,
                border: 0,
                transform: "translate(-50%, -50%) scale(1)",
                opacity: 1,
                content: '""'
              }
            },
            // https://github.com/ant-design/ant-design/issues/50074
            [`&:hover ${checkboxCls}-inner`]: {
              backgroundColor: `${token2.colorBgContainer}`,
              borderColor: `${token2.colorPrimary}`
            }
          }
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${checkboxCls}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token2.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token2.colorTextDisabled
        }
      }
    }
  ];
};
function getStyle(prefixCls, token2) {
  const checkboxToken = merge2(token2, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token2.controlInteractiveSize
  });
  return genCheckboxStyle(checkboxToken);
}
var style_default30 = genStyleHooks("Checkbox", (token2, {
  prefixCls
}) => [getStyle(prefixCls, token2)]);

// node_modules/antd/es/cascader/style/columns.js
var getColumnsStyle = (token2) => {
  const {
    prefixCls,
    componentCls
  } = token2;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
  &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
  ${cascaderMenuItemCls}-loading-icon
`;
  return [
    // ==================== Checkbox ====================
    getStyle(`${prefixCls}-checkbox`, token2),
    {
      [componentCls]: {
        // ================== Checkbox ==================
        "&-checkbox": {
          top: 0,
          marginInlineEnd: token2.paddingXS,
          pointerEvents: "unset"
        },
        // ==================== Menu ====================
        // >>> Menus
        "&-menus": {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          [`&${componentCls}-menu-empty`]: {
            [`${componentCls}-menu`]: {
              width: "100%",
              height: "auto",
              [cascaderMenuItemCls]: {
                color: token2.colorTextDisabled
              }
            }
          }
        },
        // >>> Menu
        "&-menu": {
          flexGrow: 1,
          flexShrink: 0,
          minWidth: token2.controlItemWidth,
          height: token2.dropdownHeight,
          margin: 0,
          padding: token2.menuPadding,
          overflow: "auto",
          verticalAlign: "top",
          listStyle: "none",
          "-ms-overflow-style": "-ms-autohiding-scrollbar",
          // https://github.com/ant-design/ant-design/issues/11857
          "&:not(:last-child)": {
            borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
          },
          "&-item": {
            ...textEllipsis,
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "center",
            padding: token2.optionPadding,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            "&:hover": {
              background: token2.controlItemBgHover
            },
            "&-disabled": {
              color: token2.colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                background: "transparent"
              },
              [iconCls]: {
                color: token2.colorTextDisabled
              }
            },
            [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
              "&, &:hover": {
                color: token2.optionSelectedColor,
                fontWeight: token2.optionSelectedFontWeight,
                backgroundColor: token2.optionSelectedBg
              }
            },
            "&-content": {
              flex: "auto"
            },
            [iconCls]: {
              marginInlineStart: token2.paddingXXS,
              color: token2.colorIcon,
              fontSize: token2.fontSizeIcon
            },
            "&-keyword": {
              color: token2.colorHighlight
            }
          }
        }
      }
    }
  ];
};
var columns_default = getColumnsStyle;

// node_modules/antd/es/cascader/style/index.js
var genBaseStyle9 = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token2.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [{
        [`&${antCls}-select-dropdown`]: {
          padding: 0
        }
      }, columns_default(token2)]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2)
  ];
};
var prepareComponentToken27 = (token2) => {
  const itemPaddingVertical = Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2);
  return {
    controlWidth: 184,
    controlItemWidth: 111,
    dropdownHeight: 180,
    optionSelectedBg: token2.controlItemBgActive,
    optionSelectedFontWeight: token2.fontWeightStrong,
    optionPadding: `${itemPaddingVertical}px ${token2.paddingSM}px`,
    menuPadding: token2.paddingXXS,
    optionSelectedColor: token2.colorText
  };
};
var style_default31 = genStyleHooks("Cascader", genBaseStyle9, prepareComponentToken27, {
  resetFont: false,
  unitless: {
    optionSelectedFontWeight: true
  }
});

// node_modules/antd/es/cascader/style/panel.js
var genPanelStyle2 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-panel`]: [columns_default(token2), {
      display: "inline-flex",
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
      borderRadius: token2.borderRadiusLG,
      overflowX: "auto",
      maxWidth: "100%",
      [`${componentCls}-menus`]: {
        alignItems: "stretch"
      },
      [`${componentCls}-menu`]: {
        height: "auto"
      },
      "&-empty": {
        padding: token2.paddingXXS
      }
    }]
  };
};
var panel_default2 = genComponentStyleHook(["Cascader", "Panel"], genPanelStyle2, prepareComponentToken27, {
  resetFont: false
});

// node_modules/antd/es/cascader/Panel.js
function CascaderPanel(props) {
  const {
    prefixCls: customizePrefixCls,
    className,
    multiple,
    rootClassName,
    notFoundContent,
    direction,
    expandIcon,
    disabled: customDisabled
  } = props;
  const disabled = React347.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
  const rootCls = useCSSVarCls_default(cascaderPrefixCls);
  const [hashId, cssVarCls] = style_default31(cascaderPrefixCls, rootCls);
  panel_default2(cascaderPrefixCls);
  const isRtl = mergedDirection === "rtl";
  const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
  const mergedNotFoundContent = notFoundContent || (renderEmpty == null ? void 0 : renderEmpty("Cascader")) || React347.createElement(defaultRenderEmpty_default, {
    componentName: "Cascader"
  });
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  return React347.createElement(Panel3, {
    ...props,
    checkable,
    prefixCls: cascaderPrefixCls,
    className: clsx(className, hashId, rootClassName, cssVarCls, rootCls),
    notFoundContent: mergedNotFoundContent,
    direction: mergedDirection,
    expandIcon: mergedExpandIcon,
    loadingIcon,
    disabled: mergedDisabled
  });
}
var Panel_default3 = CascaderPanel;

// node_modules/antd/es/cascader/index.js
var {
  SHOW_CHILD: SHOW_CHILD2,
  SHOW_PARENT: SHOW_PARENT2
} = es_default20;
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index2) => index2 === 0 ? [cur] : [].concat(_toConsumableArray(list), [lowerKeyword, cur]), []);
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index2) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index2 % 2 === 1) {
      originWorld = // eslint-disable-next-line react/no-array-index-key
      React348.createElement("span", {
        className: `${prefixCls}-menu-item-keyword`,
        key: `separator-${index2}`
      }, originWorld);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
var defaultSearchRender = (inputValue, path2, prefixCls, fieldNames) => {
  const optionList = [];
  const lower2 = inputValue.toLowerCase();
  path2.forEach((node2, index2) => {
    if (index2 !== 0) {
      optionList.push(" / ");
    }
    let label = node2[fieldNames.label];
    const type5 = typeof label;
    if (type5 === "string" || type5 === "number") {
      label = highlightKeyword(String(label), lower2, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
var Cascader2 = React348.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    multiple,
    bordered = true,
    transitionName,
    choiceTransitionName = "",
    popupClassName,
    expandIcon,
    placement,
    showSearch,
    allowClear = true,
    notFoundContent,
    direction,
    getPopupContainer,
    status: customStatus,
    showArrow,
    builtinPlacements,
    style: style2,
    variant: customVariant,
    dropdownClassName,
    dropdownRender,
    onDropdownVisibleChange,
    onPopupVisibleChange,
    dropdownMenuColumnStyle,
    popupRender,
    dropdownStyle,
    popupMenuColumnStyle,
    onOpenChange,
    styles,
    classNames,
    ...rest
  } = props;
  const restProps = omit(rest, ["suffixIcon"]);
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("cascader");
  const {
    popupOverflow
  } = React348.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React348.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  if (true) {
    const warning5 = devUseWarning("Cascader");
    const deprecatedProps = {
      dropdownClassName: "classNames.popup.root",
      dropdownStyle: "styles.popup.root",
      dropdownRender: "popupRender",
      dropdownMenuColumnStyle: "popupMenuColumnStyle",
      onDropdownVisibleChange: "onOpenChange",
      onPopupVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning5.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning5(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
  }
  const [prefixCls, cascaderPrefixCls, mergedDirection, renderEmpty] = useBase_default(customizePrefixCls, direction);
  const isRtl = mergedDirection === "rtl";
  const rootPrefixCls = getPrefixCls();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  const cascaderRootCls = useCSSVarCls_default(cascaderPrefixCls);
  style_default31(cascaderPrefixCls, cascaderRootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const [variant, enableVariantCls] = useVariants_default("cascader", customVariant, bordered);
  const mergedNotFoundContent = notFoundContent || (renderEmpty == null ? void 0 : renderEmpty("Cascader")) || React348.createElement(defaultRenderEmpty_default, {
    componentName: "Cascader"
  });
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedPopupMenuColumnStyle = popupMenuColumnStyle || dropdownMenuColumnStyle;
  const mergedOnOpenChange = onOpenChange || onPopupVisibleChange || onDropdownVisibleChange;
  const mergedShowSearch = React348.useMemo(() => {
    if (!showSearch) {
      return showSearch;
    }
    let searchConfig = {
      render: defaultSearchRender
    };
    if (typeof showSearch === "object") {
      searchConfig = {
        ...searchConfig,
        ...showSearch
      };
    }
    return searchConfig;
  }, [showSearch]);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React348.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [mergedExpandIcon, loadingIcon] = useColumnIcons_default(prefixCls, isRtl, expandIcon);
  const checkable = useCheckable(cascaderPrefixCls, multiple);
  const showSuffixIcon = useShowArrow(props.suffixIcon, showArrow);
  const {
    suffixIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...props,
    hasFeedback,
    feedbackIcon,
    showSuffixIcon,
    multiple,
    prefixCls,
    componentName: "Cascader"
  });
  const memoPlacement = React348.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return isRtl ? "bottomRight" : "bottomLeft";
  }, [placement, isRtl]);
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  const mergedProps = {
    ...props,
    variant,
    size: mergedSize,
    status: mergedStatus,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupStyle = {
    ...(_a = mergedStyles.popup) == null ? void 0 : _a.root,
    ...dropdownStyle
  };
  const [zIndex] = useZIndex("SelectLike", mergedPopupStyle == null ? void 0 : mergedPopupStyle.zIndex);
  const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${cascaderPrefixCls}-dropdown`, {
    [`${cascaderPrefixCls}-dropdown-rtl`]: mergedDirection === "rtl"
  }, rootClassName, rootCls, (_b = mergedClassNames.popup) == null ? void 0 : _b.root, cascaderRootCls, hashId, cssVarCls);
  return React348.createElement(es_default20, {
    prefixCls,
    className: clsx(!customizePrefixCls && cascaderPrefixCls, {
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: isRtl,
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, rootClassName, mergedClassNames.root, rootCls, cascaderRootCls, hashId, cssVarCls),
    disabled: mergedDisabled,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    classNames: mergedClassNames,
    styles: mergedStyles,
    ...restProps,
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    direction: mergedDirection,
    placement: memoPlacement,
    notFoundContent: mergedNotFoundContent,
    allowClear: mergedAllowClear,
    showSearch: mergedShowSearch,
    expandIcon: mergedExpandIcon,
    suffixIcon,
    removeIcon,
    loadingIcon,
    checkable,
    popupClassName: mergedPopupClassName,
    popupPrefixCls: customizePrefixCls || cascaderPrefixCls,
    popupStyle: {
      ...mergedPopupStyle,
      zIndex
    },
    popupRender: mergedPopupRender,
    popupMenuColumnStyle: mergedPopupMenuColumnStyle,
    onPopupVisibleChange: mergedOnOpenChange,
    choiceTransitionName: getTransitionName2(rootPrefixCls, "", choiceTransitionName),
    transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    ref
  });
});
if (true) {
  Cascader2.displayName = "Cascader";
}
var PurePanel8 = PurePanel_default3(Cascader2, "popupAlign", (props) => omit(props, ["visible"]));
Cascader2.SHOW_PARENT = SHOW_PARENT2;
Cascader2.SHOW_CHILD = SHOW_CHILD2;
Cascader2.Panel = Panel_default3;
Cascader2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel8;
var cascader_default = Cascader2;

// node_modules/antd/es/checkbox/Checkbox.js
var React350 = __toESM(require_react());

// node_modules/antd/es/checkbox/GroupContext.js
var import_react126 = __toESM(require_react());
var GroupContext = import_react126.default.createContext(null);
var GroupContext_default = GroupContext;

// node_modules/antd/es/checkbox/Checkbox.js
var InternalCheckbox = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    indeterminate = false,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    skipGroup = false,
    disabled,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("checkbox");
  const checkboxGroup = React350.useContext(GroupContext_default);
  const {
    isFormItemInput
  } = React350.useContext(FormItemInputContext);
  const contextDisabled = React350.useContext(DisabledContext_default);
  const mergedDisabled = ((checkboxGroup == null ? void 0 : checkboxGroup.disabled) || disabled) ?? contextDisabled;
  const mergedProps = {
    ...props,
    indeterminate,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prevValue = React350.useRef(restProps.value);
  const checkboxRef = React350.useRef(null);
  const mergedRef = composeRef(ref, checkboxRef);
  if (true) {
    const warning5 = devUseWarning("Checkbox");
    true ? warning5("checked" in restProps || !!checkboxGroup || !("value" in restProps), "usage", "`value` is not a valid prop, do you mean `checked`?") : void 0;
  }
  React350.useEffect(() => {
    checkboxGroup == null ? void 0 : checkboxGroup.registerValue(restProps.value);
  }, []);
  React350.useEffect(() => {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup == null ? void 0 : checkboxGroup.cancelValue(prevValue.current);
      checkboxGroup == null ? void 0 : checkboxGroup.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return () => checkboxGroup == null ? void 0 : checkboxGroup.cancelValue(restProps.value);
  }, [restProps.value]);
  React350.useEffect(() => {
    var _a;
    if ((_a = checkboxRef.current) == null ? void 0 : _a.input) {
      checkboxRef.current.input.indeterminate = indeterminate;
    }
  }, [indeterminate]);
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default30(prefixCls, rootCls);
  const checkboxProps = {
    ...restProps
  };
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = (...args) => {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, args);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
  }
  const classString = clsx(`${prefixCls}-wrapper`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
    [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
  }, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
  const checkboxClass = clsx(mergedClassNames.icon, {
    [`${prefixCls}-indeterminate`]: indeterminate
  }, TARGET_CLS, hashId);
  const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
  return React350.createElement(wave_default, {
    component: "Checkbox",
    disabled: mergedDisabled
  }, React350.createElement("label", {
    className: classString,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    onMouseEnter,
    onMouseLeave,
    onClick: onLabelClick
  }, React350.createElement(es_default17, {
    ...checkboxProps,
    onClick: onInputClick,
    prefixCls,
    className: checkboxClass,
    style: mergedStyles.icon,
    disabled: mergedDisabled,
    ref: mergedRef
  }), isNonNullable_default(children) && React350.createElement("span", {
    className: clsx(`${prefixCls}-label`, mergedClassNames.label),
    style: mergedStyles.label
  }, children)));
};
var Checkbox3 = React350.forwardRef(InternalCheckbox);
if (true) {
  Checkbox3.displayName = "Checkbox";
}
var Checkbox_default = Checkbox3;

// node_modules/antd/es/checkbox/Group.js
var React351 = __toESM(require_react());
var CheckboxGroup = React351.forwardRef((props, ref) => {
  const {
    defaultValue,
    children,
    options = [],
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    onChange,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = React351.useContext(ConfigContext);
  const [value, setValue] = React351.useState(restProps.value || defaultValue || []);
  const [registeredValues, setRegisteredValues] = React351.useState([]);
  React351.useEffect(() => {
    if ("value" in restProps) {
      setValue(restProps.value || []);
    }
  }, [restProps.value]);
  const memoizedOptions = React351.useMemo(() => options.map((option) => {
    if (typeof option === "string" || typeof option === "number") {
      return {
        label: option,
        value: option
      };
    }
    return option;
  }), [options]);
  const cancelValue = (val) => {
    setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
  };
  const registerValue = (val) => {
    setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
  };
  const toggleOption = (option) => {
    const optionIndex = value.indexOf(option.value);
    const newValue = _toConsumableArray(value);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue(newValue);
    }
    onChange == null ? void 0 : onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b) => {
      const indexA = memoizedOptions.findIndex((opt) => opt.value === a);
      const indexB = memoizedOptions.findIndex((opt) => opt.value === b);
      return indexA - indexB;
    }));
  };
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default30(prefixCls, rootCls);
  const domProps = omit(restProps, ["value", "disabled"]);
  const childrenNode = options.length ? memoizedOptions.map((option) => React351.createElement(Checkbox_default, {
    prefixCls,
    key: option.value.toString(),
    disabled: "disabled" in option ? option.disabled : restProps.disabled,
    value: option.value,
    checked: value.includes(option.value),
    onChange: option.onChange,
    className: clsx(`${groupPrefixCls}-item`, option.className),
    style: option.style,
    title: option.title,
    id: option.id,
    required: option.required
  }, option.label)) : children;
  const memoizedContext = React351.useMemo(() => ({
    toggleOption,
    value,
    disabled: restProps.disabled,
    name: restProps.name,
    // https://github.com/ant-design/ant-design/issues/16376
    registerValue,
    cancelValue
  }), [toggleOption, value, restProps.disabled, restProps.name, registerValue, cancelValue]);
  const classString = clsx(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, cssVarCls, rootCls, hashId);
  return React351.createElement("div", {
    className: classString,
    style: style2,
    ...domProps,
    ref
  }, React351.createElement(GroupContext_default.Provider, {
    value: memoizedContext
  }, childrenNode));
});
var Group_default = CheckboxGroup;

// node_modules/antd/es/checkbox/index.js
var Checkbox4 = Checkbox_default;
Checkbox4.Group = Group_default;
Checkbox4.__ANT_CHECKBOX = true;
if (true) {
  Checkbox4.displayName = "Checkbox";
}
var checkbox_default = Checkbox4;

// node_modules/antd/es/grid/col.js
var React352 = __toESM(require_react());

// node_modules/antd/es/grid/RowContext.js
var import_react127 = __toESM(require_react());
var RowContext = (0, import_react127.createContext)({});
var RowContext_default = RowContext;

// node_modules/antd/es/grid/col.js
function parseFlex(flex) {
  if (flex === "auto") {
    return "1 1 auto";
  }
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Col = React352.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = React352.useContext(ConfigContext);
  const {
    gutter,
    wrap
  } = React352.useContext(RowContext_default);
  const {
    prefixCls: customizePrefixCls,
    span,
    order,
    offset: offset3,
    push,
    pull,
    className,
    children,
    flex,
    style: style2,
    ...others
  } = props;
  const prefixCls = getPrefixCls("col", customizePrefixCls);
  const [hashId, cssVarCls] = useColStyle(prefixCls);
  const sizeStyle = {};
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (typeof propSize === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = {
      ...sizeClassObj,
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    };
    if (sizeProps.flex) {
      sizeClassObj[`${prefixCls}-${size}-flex`] = true;
      sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
    }
  });
  const classes = clsx(prefixCls, {
    [`${prefixCls}-${span}`]: span !== void 0,
    [`${prefixCls}-order-${order}`]: order,
    [`${prefixCls}-offset-${offset3}`]: offset3,
    [`${prefixCls}-push-${push}`]: push,
    [`${prefixCls}-pull-${pull}`]: pull
  }, className, sizeClassObj, hashId, cssVarCls);
  const mergedStyle = {};
  if (gutter == null ? void 0 : gutter[0]) {
    const horizontalGutter = typeof gutter[0] === "number" ? `${gutter[0] / 2}px` : `calc(${gutter[0]} / 2)`;
    mergedStyle.paddingInline = horizontalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return React352.createElement("div", {
    ...others,
    style: {
      ...mergedStyle,
      ...style2,
      ...sizeStyle
    },
    className: classes,
    ref
  }, children);
});
if (true) {
  Col.displayName = "Col";
}
var col_default = Col;

// node_modules/antd/es/grid/row.js
var React353 = __toESM(require_react());

// node_modules/antd/es/grid/hooks/useGutter.js
function useGutter(gutter, screens) {
  const results = [void 0, void 0];
  const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
  const mergedScreens = screens || {
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  };
  normalizedGutter.forEach((g, index2) => {
    if (typeof g === "object" && g !== null) {
      for (let i = 0; i < responsiveArray.length; i++) {
        const breakpoint = responsiveArray[i];
        if (mergedScreens[breakpoint] && g[breakpoint] !== void 0) {
          results[index2] = g[breakpoint];
          break;
        }
      }
    } else {
      results[index2] = g;
    }
  });
  return results;
}

// node_modules/antd/es/grid/row.js
function useMergedPropByScreen(oriProp, screen) {
  const [prop, setProp] = React353.useState(typeof oriProp === "string" ? oriProp : "");
  const calcMergedAlignOrJustify = () => {
    if (typeof oriProp === "string") {
      setProp(oriProp);
    }
    if (typeof oriProp !== "object") {
      return;
    }
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (!screen || !screen[breakpoint]) {
        continue;
      }
      const curVal = oriProp[breakpoint];
      if (curVal !== void 0) {
        setProp(curVal);
        return;
      }
    }
  };
  React353.useEffect(() => {
    calcMergedAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
var Row = React353.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style: style2,
    children,
    gutter = 0,
    wrap,
    ...others
  } = props;
  const {
    getPrefixCls,
    direction
  } = React353.useContext(ConfigContext);
  const screens = useBreakpoint_default(true, null);
  const mergedAlign = useMergedPropByScreen(align, screens);
  const mergedJustify = useMergedPropByScreen(justify, screens);
  const prefixCls = getPrefixCls("row", customizePrefixCls);
  const [hashId, cssVarCls] = useRowStyle(prefixCls);
  const gutters = useGutter(gutter, screens);
  const classes = clsx(prefixCls, {
    [`${prefixCls}-no-wrap`]: wrap === false,
    [`${prefixCls}-${mergedJustify}`]: mergedJustify,
    [`${prefixCls}-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId, cssVarCls);
  const rowStyle = {};
  if (gutters == null ? void 0 : gutters[0]) {
    const horizontalGutter = typeof gutters[0] === "number" ? `${gutters[0] / -2}px` : `calc(${gutters[0]} / -2)`;
    rowStyle.marginInline = horizontalGutter;
  }
  const [gutterH, gutterV] = gutters;
  rowStyle.rowGap = gutterV;
  const rowContext = React353.useMemo(() => ({
    gutter: [gutterH, gutterV],
    wrap
  }), [gutterH, gutterV, wrap]);
  return React353.createElement(RowContext_default.Provider, {
    value: rowContext
  }, React353.createElement("div", {
    ...others,
    className: classes,
    style: {
      ...rowStyle,
      ...style2
    },
    ref
  }, children));
});
if (true) {
  Row.displayName = "Row";
}
var row_default = Row;

// node_modules/antd/es/grid/index.js
function useBreakpoint2() {
  return useBreakpoint_default();
}
var grid_default = {
  useBreakpoint: useBreakpoint2
};

// node_modules/antd/es/col/index.js
var col_default2 = col_default;

// node_modules/antd/es/color-picker/ColorPicker.js
var import_react152 = __toESM(require_react());

// node_modules/antd/es/color-picker/ColorPickerPanel.js
var import_react150 = __toESM(require_react());

// node_modules/antd/es/divider/index.js
var React354 = __toESM(require_react());

// node_modules/antd/es/divider/style/index.js
var genSizeDividerStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-horizontal": {
        [`&${componentCls}`]: {
          "&-sm": {
            marginBlock: token2.marginXS
          },
          "&-md": {
            marginBlock: token2.margin
          }
        }
      }
    }
  };
};
var genSharedDividerStyle = (token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth,
    textPaddingInline,
    orientationMargin,
    verticalMarginInline
  } = token2;
  const railCls = `${componentCls}-rail`;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`,
      [railCls]: {
        borderBlockStart: `${unit(lineWidth)} solid ${colorSplit}`
      },
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: verticalMarginInline,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${unit(lineWidth)} solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${unit(token2.marginLG)} 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${unit(token2.dividerHorizontalWithTextGutterMargin)} 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        [`${railCls}-start, ${railCls}-end`]: {
          width: "50%",
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-start`]: {
        [`${railCls}-start`]: {
          width: `calc(${orientationMargin} * 100%)`
        },
        [`${railCls}-end`]: {
          width: `calc(100% - ${orientationMargin} * 100%)`
        }
      },
      [`&-horizontal${componentCls}-with-text-end`]: {
        [`${railCls}-start`]: {
          width: `calc(100% - ${orientationMargin} * 100%)`
        },
        [`${railCls}-end`]: {
          width: `calc(${orientationMargin} * 100%)`
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: textPaddingInline
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${unit(lineWidth)} 0 0`,
        [railCls]: {
          borderBlockStart: `${unit(lineWidth)} dashed ${colorSplit}`
        }
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        [`${railCls}-start, ${railCls}-end`]: {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      "&-dotted": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dotted",
        borderWidth: `${unit(lineWidth)} 0 0`,
        [railCls]: {
          borderBlockStart: `${unit(lineWidth)} dotted ${colorSplit}`
        }
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: {
        "&::before, &::after": {
          borderStyle: "dotted none none"
        }
      },
      [`&-vertical${componentCls}-dotted`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
        [`${railCls}-start`]: {
          width: 0
        },
        [`${railCls}-end`]: {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
        [`${railCls}-start`]: {
          width: "100%"
        },
        [`${railCls}-end`]: {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    }
  };
};
var prepareComponentToken28 = (token2) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: token2.marginXS
});
var style_default32 = genStyleHooks("Divider", (token2) => {
  const dividerToken = merge2(token2, {
    dividerHorizontalWithTextGutterMargin: token2.margin,
    sizePaddingEdgeHorizontal: 0
  });
  return [genSharedDividerStyle(dividerToken), genSizeDividerStyle(dividerToken)];
}, prepareComponentToken28, {
  unitless: {
    orientationMargin: true
  }
});

// node_modules/antd/es/divider/index.js
var titlePlacementList = ["left", "right", "center", "start", "end"];
var sizeClassNameMap = {
  small: "sm",
  middle: "md"
};
var Divider2 = (props) => {
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("divider");
  const {
    prefixCls: customizePrefixCls,
    type: type5,
    orientation,
    vertical,
    titlePlacement,
    orientationMargin,
    className,
    rootClassName,
    children,
    dashed,
    variant = "solid",
    plain,
    style: style2,
    size: customSize,
    classNames,
    styles,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("divider", customizePrefixCls);
  const railCls = `${prefixCls}-rail`;
  const [hashId, cssVarCls] = style_default32(prefixCls);
  const sizeFullName = useSize_default(customSize);
  const sizeCls = sizeClassNameMap[sizeFullName];
  const hasChildren = !!children;
  const validTitlePlacement = titlePlacementList.includes(orientation || "");
  const mergedTitlePlacement = React354.useMemo(() => {
    const placement = titlePlacement ?? (validTitlePlacement ? orientation : "center");
    if (placement === "left") {
      return direction === "rtl" ? "end" : "start";
    }
    if (placement === "right") {
      return direction === "rtl" ? "start" : "end";
    }
    return placement;
  }, [direction, orientation, titlePlacement, validTitlePlacement]);
  const hasMarginStart = mergedTitlePlacement === "start" && orientationMargin != null;
  const hasMarginEnd = mergedTitlePlacement === "end" && orientationMargin != null;
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, type5);
  const mergedProps = {
    ...props,
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    size: sizeFullName
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const classString = clsx(prefixCls, contextClassName, hashId, cssVarCls, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-with-text`]: hasChildren,
    [`${prefixCls}-with-text-${mergedTitlePlacement}`]: hasChildren,
    [`${prefixCls}-dashed`]: !!dashed,
    [`${prefixCls}-${variant}`]: variant !== "solid",
    [`${prefixCls}-plain`]: !!plain,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
    [`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd,
    [`${prefixCls}-${sizeCls}`]: !!sizeCls,
    [railCls]: !children,
    [mergedClassNames.rail]: mergedClassNames.rail && !children
  }, className, rootClassName, mergedClassNames.root);
  const memoizedPlacementMargin = React354.useMemo(() => {
    if (typeof orientationMargin === "number") {
      return orientationMargin;
    }
    if (/^\d+$/.test(orientationMargin)) {
      return Number(orientationMargin);
    }
    return orientationMargin;
  }, [orientationMargin]);
  const innerStyle = {
    marginInlineStart: hasMarginStart ? memoizedPlacementMargin : void 0,
    marginInlineEnd: hasMarginEnd ? memoizedPlacementMargin : void 0
  };
  if (true) {
    const warning5 = devUseWarning("Divider");
    true ? warning5(!children || !mergedVertical, "usage", "`children` not working in `vertical` mode.") : void 0;
    true ? warning5(!validTitlePlacement, "usage", "`orientation` is used for direction, please use `titlePlacement` replace this") : void 0;
    [["type", "orientation"], ["orientationMargin", "styles.content.margin"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return React354.createElement("div", {
    className: classString,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...children ? {} : mergedStyles.rail,
      ...style2
    },
    ...restProps,
    role: "separator"
  }, children && !mergedVertical && React354.createElement(React354.Fragment, null, React354.createElement("div", {
    className: clsx(railCls, `${railCls}-start`, mergedClassNames.rail),
    style: mergedStyles.rail
  }), React354.createElement("span", {
    className: clsx(`${prefixCls}-inner-text`, mergedClassNames.content),
    style: {
      ...innerStyle,
      ...mergedStyles.content
    }
  }, children), React354.createElement("div", {
    className: clsx(railCls, `${railCls}-end`, mergedClassNames.rail),
    style: mergedStyles.rail
  })));
};
if (true) {
  Divider2.displayName = "Divider";
}
var divider_default = Divider2;

// node_modules/antd/es/color-picker/components/PanelPicker/index.js
var import_react148 = __toESM(require_react());

// node_modules/antd/es/segmented/index.js
var React357 = __toESM(require_react());

// node_modules/@rc-component/segmented/es/index.js
var React356 = __toESM(require_react());

// node_modules/@rc-component/segmented/es/MotionThumb.js
var React355 = __toESM(require_react());
var calcThumbStyle = (targetElement, vertical) => {
  if (!targetElement)
    return null;
  const style2 = {
    left: targetElement.offsetLeft,
    right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
    width: targetElement.clientWidth,
    top: targetElement.offsetTop,
    bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
    height: targetElement.clientHeight
  };
  if (vertical) {
    return {
      left: 0,
      right: 0,
      width: 0,
      top: style2.top,
      bottom: style2.bottom,
      height: style2.height
    };
  }
  return {
    left: style2.left,
    right: style2.right,
    width: style2.width,
    top: 0,
    bottom: 0,
    height: 0
  };
};
var toPX = (value) => value !== void 0 ? `${value}px` : void 0;
function MotionThumb(props) {
  const {
    prefixCls,
    containerRef,
    value,
    getValueIndex,
    motionName,
    onMotionStart,
    onMotionEnd,
    direction,
    vertical = false
  } = props;
  const thumbRef = React355.useRef(null);
  const [prevValue, setPrevValue] = React355.useState(value);
  const findValueElement = (val) => {
    var _a;
    const index2 = getValueIndex(val);
    const ele = (_a = containerRef.current) == null ? void 0 : _a.querySelectorAll(`.${prefixCls}-item`)[index2];
    return (ele == null ? void 0 : ele.offsetParent) && ele;
  };
  const [prevStyle, setPrevStyle] = React355.useState(null);
  const [nextStyle, setNextStyle] = React355.useState(null);
  useLayoutEffect_default(() => {
    if (prevValue !== value) {
      const prev2 = findValueElement(prevValue);
      const next2 = findValueElement(value);
      const calcPrevStyle = calcThumbStyle(prev2, vertical);
      const calcNextStyle = calcThumbStyle(next2, vertical);
      setPrevValue(value);
      setPrevStyle(calcPrevStyle);
      setNextStyle(calcNextStyle);
      if (prev2 && next2) {
        onMotionStart();
      } else {
        onMotionEnd();
      }
    }
  }, [value]);
  const thumbStart = React355.useMemo(() => {
    if (vertical) {
      return toPX((prevStyle == null ? void 0 : prevStyle.top) ?? 0);
    }
    if (direction === "rtl") {
      return toPX(-(prevStyle == null ? void 0 : prevStyle.right));
    }
    return toPX(prevStyle == null ? void 0 : prevStyle.left);
  }, [vertical, direction, prevStyle]);
  const thumbActive = React355.useMemo(() => {
    if (vertical) {
      return toPX((nextStyle == null ? void 0 : nextStyle.top) ?? 0);
    }
    if (direction === "rtl") {
      return toPX(-(nextStyle == null ? void 0 : nextStyle.right));
    }
    return toPX(nextStyle == null ? void 0 : nextStyle.left);
  }, [vertical, direction, nextStyle]);
  const onAppearStart = () => {
    if (vertical) {
      return {
        transform: "translateY(var(--thumb-start-top))",
        height: "var(--thumb-start-height)"
      };
    }
    return {
      transform: "translateX(var(--thumb-start-left))",
      width: "var(--thumb-start-width)"
    };
  };
  const onAppearActive = () => {
    if (vertical) {
      return {
        transform: "translateY(var(--thumb-active-top))",
        height: "var(--thumb-active-height)"
      };
    }
    return {
      transform: "translateX(var(--thumb-active-left))",
      width: "var(--thumb-active-width)"
    };
  };
  const onVisibleChanged = () => {
    setPrevStyle(null);
    setNextStyle(null);
    onMotionEnd();
  };
  if (!prevStyle || !nextStyle) {
    return null;
  }
  return React355.createElement(es_default2, {
    visible: true,
    motionName,
    motionAppear: true,
    onAppearStart,
    onAppearActive,
    onVisibleChanged
  }, ({
    className: motionClassName,
    style: motionStyle
  }, ref) => {
    const mergedStyle = {
      ...motionStyle,
      "--thumb-start-left": thumbStart,
      "--thumb-start-width": toPX(prevStyle == null ? void 0 : prevStyle.width),
      "--thumb-active-left": thumbActive,
      "--thumb-active-width": toPX(nextStyle == null ? void 0 : nextStyle.width),
      "--thumb-start-top": thumbStart,
      "--thumb-start-height": toPX(prevStyle == null ? void 0 : prevStyle.height),
      "--thumb-active-top": thumbActive,
      "--thumb-active-height": toPX(nextStyle == null ? void 0 : nextStyle.height)
    };
    const motionProps = {
      ref: composeRef(thumbRef, ref),
      style: mergedStyle,
      className: clsx(`${prefixCls}-thumb`, motionClassName)
    };
    if (false) {
      motionProps["data-test-style"] = JSON.stringify(mergedStyle);
    }
    return React355.createElement("div", motionProps);
  });
}

// node_modules/@rc-component/segmented/es/index.js
function getValidTitle(option) {
  var _a;
  if (typeof option.title !== "undefined") {
    return option.title;
  }
  if (typeof option.label !== "object") {
    return (_a = option.label) == null ? void 0 : _a.toString();
  }
}
function normalizeOptions(options) {
  return options.map((option) => {
    if (typeof option === "object" && option !== null) {
      const validTitle = getValidTitle(option);
      return {
        ...option,
        title: validTitle
      };
    }
    return {
      label: option == null ? void 0 : option.toString(),
      title: option == null ? void 0 : option.toString(),
      value: option
    };
  });
}
var InternalSegmentedOption = ({
  prefixCls,
  className,
  style: style2,
  styles,
  classNames: segmentedClassNames,
  data,
  disabled,
  checked,
  label,
  title,
  value,
  name,
  onChange,
  onFocus,
  onBlur,
  onKeyDown: onKeyDown2,
  onKeyUp,
  onMouseDown,
  itemRender = (node2) => node2
}) => {
  const handleChange = (event) => {
    if (disabled) {
      return;
    }
    onChange(event, value);
  };
  const itemContent = React356.createElement("label", {
    className: clsx(className, {
      [`${prefixCls}-item-disabled`]: disabled
    }),
    style: style2,
    onMouseDown
  }, React356.createElement("input", {
    name,
    className: `${prefixCls}-item-input`,
    type: "radio",
    disabled,
    checked,
    onChange: handleChange,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onKeyUp
  }), React356.createElement("div", {
    className: clsx(`${prefixCls}-item-label`, segmentedClassNames == null ? void 0 : segmentedClassNames.label),
    title,
    role: "radio",
    "aria-checked": checked,
    style: styles == null ? void 0 : styles.label
  }, label));
  return itemRender(itemContent, {
    item: data
  });
};
var Segmented = React356.forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls = "rc-segmented",
    direction,
    vertical,
    options = [],
    disabled,
    defaultValue,
    value,
    name,
    onChange,
    className = "",
    style: style2,
    styles,
    classNames: segmentedClassNames,
    motionName = "thumb-motion",
    itemRender,
    ...restProps
  } = props;
  const containerRef = React356.useRef(null);
  const mergedRef = React356.useMemo(() => composeRef(containerRef, ref), [containerRef, ref]);
  const segmentedOptions = React356.useMemo(() => {
    return normalizeOptions(options);
  }, [options]);
  const [rawValue, setRawValue] = useControlledState(defaultValue ?? ((_a = segmentedOptions[0]) == null ? void 0 : _a.value), value);
  const [thumbShow, setThumbShow] = React356.useState(false);
  const handleChange = (event, val) => {
    setRawValue(val);
    onChange == null ? void 0 : onChange(val);
  };
  const divProps = omit(restProps, ["children"]);
  const [isKeyboard, setIsKeyboard] = React356.useState(false);
  const [isFocused, setIsFocused] = React356.useState(false);
  const handleFocus = () => {
    setIsFocused(true);
  };
  const handleBlur = () => {
    setIsFocused(false);
  };
  const handleMouseDown = () => {
    setIsKeyboard(false);
  };
  const handleKeyUp = (event) => {
    if (event.key === "Tab") {
      setIsKeyboard(true);
    }
  };
  const onOffset = (offset3) => {
    const currentIndex = segmentedOptions.findIndex((option) => option.value === rawValue);
    const total = segmentedOptions.length;
    const nextIndex = (currentIndex + offset3 + total) % total;
    const nextOption = segmentedOptions[nextIndex];
    if (nextOption) {
      setRawValue(nextOption.value);
      onChange == null ? void 0 : onChange(nextOption.value);
    }
  };
  const handleKeyDown = (event) => {
    switch (event.key) {
      case "ArrowLeft":
      case "ArrowUp":
        onOffset(-1);
        break;
      case "ArrowRight":
      case "ArrowDown":
        onOffset(1);
        break;
    }
  };
  const renderOption = (segmentedOption) => {
    const {
      value: optionValue,
      disabled: optionDisabled
    } = segmentedOption;
    return React356.createElement(InternalSegmentedOption, _extends9({}, segmentedOption, {
      name,
      data: segmentedOption,
      itemRender,
      key: optionValue,
      prefixCls,
      className: clsx(segmentedOption.className, `${prefixCls}-item`, segmentedClassNames == null ? void 0 : segmentedClassNames.item, {
        [`${prefixCls}-item-selected`]: optionValue === rawValue && !thumbShow,
        [`${prefixCls}-item-focused`]: isFocused && isKeyboard && optionValue === rawValue
      }),
      style: styles == null ? void 0 : styles.item,
      classNames: segmentedClassNames,
      styles,
      checked: optionValue === rawValue,
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      disabled: !!disabled || !!optionDisabled
    }));
  };
  return React356.createElement("div", _extends9({
    role: "radiogroup",
    "aria-label": "segmented control",
    tabIndex: disabled ? void 0 : 0,
    style: style2
  }, divProps, {
    className: clsx(prefixCls, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-vertical`]: vertical
    }, className),
    ref: mergedRef
  }), React356.createElement("div", {
    className: `${prefixCls}-group`
  }, React356.createElement(MotionThumb, {
    vertical,
    prefixCls,
    value: rawValue,
    containerRef,
    motionName: `${prefixCls}-${motionName}`,
    direction,
    getValueIndex: (val) => segmentedOptions.findIndex((n2) => n2.value === val),
    onMotionStart: () => {
      setThumbShow(true);
    },
    onMotionEnd: () => {
      setThumbShow(false);
    }
  }), segmentedOptions.map(renderOption)));
});
if (true) {
  Segmented.displayName = "Segmented";
}
var TypedSegmented = Segmented;
var es_default21 = TypedSegmented;

// node_modules/antd/es/segmented/style/index.js
function getItemDisabledStyle(cls, token2) {
  return {
    [`${cls}, ${cls}:hover, ${cls}:focus`]: {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
function getItemSelectedStyle(token2) {
  return {
    background: token2.itemSelectedBg,
    boxShadow: token2.boxShadowTertiary
  };
}
var segmentedTextEllipsisCss = {
  overflow: "hidden",
  // handle text ellipsis
  ...textEllipsis
};
var genSegmentedStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const labelHeight = token2.calc(token2.controlHeight).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightLG = token2.calc(token2.controlHeightLG).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  const labelHeightSM = token2.calc(token2.controlHeightSM).sub(token2.calc(token2.trackPadding).mul(2)).equal();
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      padding: token2.trackPadding,
      color: token2.itemColor,
      background: token2.trackBg,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`,
      ...genFocusStyle(token2),
      [`${componentCls}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        flexDirection: "row",
        width: "100%"
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`&${componentCls}-vertical`]: {
        [`${componentCls}-group`]: {
          flexDirection: "column"
        },
        [`${componentCls}-thumb`]: {
          width: "100%",
          height: 0,
          padding: `0 ${unit(token2.paddingXXS)}`
        }
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: "flex"
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${token2.motionDurationMid}`,
        borderRadius: token2.borderRadiusSM,
        // Fix Safari render bug
        // https://github.com/ant-design/ant-design/issues/45250
        transform: "translateZ(0)",
        "&-selected": {
          ...getItemSelectedStyle(token2),
          color: token2.itemSelectedColor
        },
        "&-focused": genFocusOutline(token2),
        "&::after": {
          content: '""',
          position: "absolute",
          zIndex: -1,
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          opacity: 0,
          transition: `opacity ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          // This is mandatory to make it not clickable or hoverable
          // Ref: https://github.com/ant-design/ant-design/issues/40888
          pointerEvents: "none"
        },
        [`&:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          "&:hover, &:active": {
            color: token2.itemHoverColor
          },
          "&:hover::after": {
            opacity: 1,
            backgroundColor: token2.itemHoverBg
          },
          "&:active::after": {
            opacity: 1,
            backgroundColor: token2.itemActiveBg
          }
        },
        "&-label": {
          minHeight: labelHeight,
          lineHeight: unit(labelHeight),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          ...segmentedTextEllipsisCss
        },
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: token2.calc(token2.marginSM).div(2).equal()
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: {
        ...getItemSelectedStyle(token2),
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${unit(token2.paddingXXS)} 0`,
        borderRadius: token2.borderRadiusSM,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      },
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token2.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightLG,
          lineHeight: unit(labelHeightLG),
          padding: `0 ${unit(token2.segmentedPaddingHorizontal)}`,
          fontSize: token2.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token2.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightSM,
          lineHeight: unit(labelHeightSM),
          padding: `0 ${unit(token2.segmentedPaddingHorizontalSM)}`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token2.borderRadiusXS
        }
      },
      // disabled styles
      ...getItemDisabledStyle(`&-disabled ${componentCls}-item`, token2),
      ...getItemDisabledStyle(`${componentCls}-item-disabled`, token2),
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOut}, width ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        willChange: "transform, width"
      },
      [`&${componentCls}-shape-round`]: {
        borderRadius: 9999,
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: 9999
        }
      }
    }
  };
};
var prepareComponentToken29 = (token2) => {
  const {
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgElevated,
    colorFill,
    lineWidthBold,
    colorBgLayout
  } = token2;
  return {
    trackPadding: lineWidthBold,
    trackBg: colorBgLayout,
    itemColor: colorTextLabel,
    itemHoverColor: colorText,
    itemHoverBg: colorFillSecondary,
    itemSelectedBg: colorBgElevated,
    itemActiveBg: colorFill,
    itemSelectedColor: colorText
  };
};
var style_default33 = genStyleHooks("Segmented", (token2) => {
  const {
    lineWidth,
    calc
  } = token2;
  const segmentedToken = merge2(token2, {
    segmentedPaddingHorizontal: calc(token2.controlPaddingHorizontal).sub(lineWidth).equal(),
    segmentedPaddingHorizontalSM: calc(token2.controlPaddingHorizontalSM).sub(lineWidth).equal()
  });
  return genSegmentedStyle(segmentedToken);
}, prepareComponentToken29);

// node_modules/antd/es/segmented/index.js
function isSegmentedLabeledOptionWithIcon(option) {
  return typeof option === "object" && !!(option == null ? void 0 : option.icon);
}
var InternalSegmented = React357.forwardRef((props, ref) => {
  const defaultName = useId_default();
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    block,
    options = [],
    size: customSize = "middle",
    style: style2,
    vertical,
    orientation,
    shape = "default",
    name = defaultName,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("segmented");
  const mergedProps = {
    ...props,
    options,
    size: customSize,
    shape
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("segmented", customizePrefixCls);
  const [hashId, cssVarCls] = style_default33(prefixCls);
  const mergedSize = useSize_default(customSize);
  const extendedOptions = React357.useMemo(() => options.map((option) => {
    if (isSegmentedLabeledOptionWithIcon(option)) {
      const {
        icon,
        label,
        ...restOption
      } = option;
      return {
        ...restOption,
        label: React357.createElement(React357.Fragment, null, React357.createElement("span", {
          className: clsx(`${prefixCls}-item-icon`, mergedClassNames.icon),
          style: mergedStyles.icon
        }, icon), label && React357.createElement("span", null, label))
      };
    }
    return option;
  }), [options, prefixCls, mergedClassNames.icon, mergedStyles.icon]);
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const cls = clsx(className, rootClassName, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-vertical`]: mergedVertical,
    [`${prefixCls}-shape-${shape}`]: shape === "round"
  }, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const itemRender = (node2, {
    item
  }) => {
    if (!item.tooltip) {
      return node2;
    }
    const tooltipProps = typeof item.tooltip === "object" ? item.tooltip : {
      title: item.tooltip
    };
    return React357.createElement(tooltip_default, {
      ...tooltipProps
    }, node2);
  };
  return React357.createElement(es_default21, {
    ...restProps,
    name,
    className: cls,
    style: mergedStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    itemRender,
    options: extendedOptions,
    ref,
    prefixCls,
    direction,
    vertical: mergedVertical
  });
});
var Segmented2 = InternalSegmented;
if (true) {
  Segmented2.displayName = "Segmented";
}
var segmented_default = Segmented2;

// node_modules/antd/es/color-picker/context.js
var import_react128 = __toESM(require_react());
var PanelPickerContext = import_react128.default.createContext({});
var PanelPresetsContext = import_react128.default.createContext({});

// node_modules/antd/es/color-picker/components/ColorClear.js
var import_react129 = __toESM(require_react());
var ColorClear = ({
  prefixCls,
  value,
  onChange
}) => {
  const handleClick = () => {
    if (onChange && value && !value.cleared) {
      const hsba = value.toHsb();
      hsba.a = 0;
      const genColor = generateColor2(hsba);
      genColor.cleared = true;
      onChange(genColor);
    }
  };
  return import_react129.default.createElement("div", {
    className: `${prefixCls}-clear`,
    onClick: handleClick
  });
};
var ColorClear_default = ColorClear;

// node_modules/antd/es/color-picker/components/ColorInput.js
var import_react143 = __toESM(require_react());

// node_modules/antd/es/color-picker/interface.js
var FORMAT_HEX = "hex";
var FORMAT_RGB = "rgb";
var FORMAT_HSB = "hsb";

// node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var import_react134 = __toESM(require_react());

// node_modules/antd/es/color-picker/components/ColorSteppers.js
var import_react133 = __toESM(require_react());

// node_modules/antd/es/input-number/index.js
var React363 = __toESM(require_react());

// node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
  return typeof BigInt === "function";
}

// node_modules/@rc-component/mini-decimal/es/numberUtil.js
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}

// node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js
var BigIntDecimal = function() {
  function BigIntDecimal2(value) {
    _classCallCheck(this, BigIntDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "negative", void 0);
    _defineProperty(this, "integer", void 0);
    _defineProperty(this, "decimal", void 0);
    _defineProperty(this, "decimalLen", void 0);
    _defineProperty(this, "empty", void 0);
    _defineProperty(this, "nan", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-" || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  _createClass(BigIntDecimal2, [{
    key: "getMark",
    value: function getMark() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }
    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone = new BigIntDecimal2(this.toString());
      clone.negative = !clone.negative;
      return clone;
    }
  }, {
    key: "cal",
    value: function cal(offset3, calculator, calDecimalLen) {
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
      var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
      var nextDecimalLength = calDecimalLen(maxDecimalLength);
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value);
      }
      var offset3 = new BigIntDecimal2(value);
      if (offset3.isInvalidate()) {
        return this;
      }
      return this.cal(offset3, function(num1, num2) {
        return num1 + num2;
      }, function(len) {
        return len;
      });
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = new BigIntDecimal2(value);
      if (this.isInvalidate() || target.isInvalidate()) {
        return new BigIntDecimal2(NaN);
      }
      return this.cal(target, function(num1, num2) {
        return num1 * num2;
      }, function(len) {
        return len * 2;
      });
    }
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal2;
}();

// node_modules/@rc-component/mini-decimal/es/NumberDecimal.js
var NumberDecimal = function() {
  function NumberDecimal2(value) {
    _classCallCheck(this, NumberDecimal2);
    _defineProperty(this, "origin", "");
    _defineProperty(this, "number", void 0);
    _defineProperty(this, "empty", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  _createClass(NumberDecimal2, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal2(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = Number(value);
      if (this.isInvalidate() || Number.isNaN(target)) {
        return new NumberDecimal2(NaN);
      }
      var number4 = this.number * target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty2() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal2;
}();

// node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}

// node_modules/@rc-component/mini-decimal/es/index.js
var es_default22 = getMiniDecimal;

// node_modules/@rc-component/util/es/proxyObject.js
function proxyObject(obj, extendProps) {
  if (typeof Proxy !== "undefined" && obj) {
    return new Proxy(obj, {
      get(target, prop) {
        if (extendProps[prop]) {
          return extendProps[prop];
        }
        const originProp = target[prop];
        return typeof originProp === "function" ? originProp.bind(target) : originProp;
      }
    });
  }
  return obj;
}

// node_modules/@rc-component/input-number/es/InputNumber.js
var React361 = __toESM(require_react());

// node_modules/@rc-component/input-number/es/hooks/useCursor.js
var import_react130 = __toESM(require_react());
function useCursor(input, focused) {
  const selectionRef = (0, import_react130.useRef)(null);
  function recordCursor() {
    try {
      const {
        selectionStart: start,
        selectionEnd: end,
        value
      } = input;
      const beforeTxt = value.substring(0, start);
      const afterTxt = value.substring(end);
      selectionRef.current = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e3) {
    }
  }
  function restoreCursor() {
    if (input && selectionRef.current && focused) {
      try {
        const {
          value
        } = input;
        const {
          beforeTxt,
          afterTxt,
          start
        } = selectionRef.current;
        let startPos = value.length;
        if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.current.afterTxt.length;
        } else {
          const beforeLastChar = beforeTxt[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e3) {
        warning_default(false, `Something warning of cursor restore. Please fire issue about this: ${e3.message}`);
      }
    }
  }
  return [recordCursor, restoreCursor];
}

// node_modules/@rc-component/input-number/es/StepHandler.js
var React360 = __toESM(require_react());
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
function StepHandler({
  prefixCls,
  action,
  children,
  disabled,
  className,
  style: style2,
  onStep
}) {
  const isUpAction = action === "up";
  const stepTimeoutRef = React360.useRef();
  const frameIds = React360.useRef([]);
  const onStopStep = () => {
    clearTimeout(stepTimeoutRef.current);
  };
  const onStepMouseDown = (e3) => {
    e3.preventDefault();
    onStopStep();
    onStep(isUpAction, "handler");
    function loopStep() {
      onStep(isUpAction, "handler");
      stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }
    stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  };
  React360.useEffect(() => () => {
    onStopStep();
    frameIds.current.forEach((id) => {
      raf_default.cancel(id);
    });
  }, []);
  const actionClassName = `${prefixCls}-action`;
  const mergedClassName = clsx(actionClassName, `${actionClassName}-${action}`, {
    [`${actionClassName}-${action}-disabled`]: disabled
  }, className);
  const safeOnStopStep = () => frameIds.current.push(raf_default(onStopStep));
  return React360.createElement("span", {
    unselectable: "on",
    role: "button",
    onMouseUp: safeOnStopStep,
    onMouseLeave: safeOnStopStep,
    onMouseDown: (e3) => {
      onStepMouseDown(e3);
    },
    "aria-label": isUpAction ? "Increase Value" : "Decrease Value",
    "aria-disabled": disabled,
    className: mergedClassName,
    style: style2
  }, children || React360.createElement("span", {
    unselectable: "on",
    className: `${prefixCls}-action-${action}-inner`
  }));
}

// node_modules/@rc-component/input-number/es/utils/numberUtil.js
function getDecupleSteps(step) {
  const stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
  const hasPoint = stepStr.includes(".");
  if (!hasPoint) {
    return step + "0";
  }
  return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}

// node_modules/@rc-component/input-number/es/hooks/useFrame.js
var import_react131 = __toESM(require_react());
var useFrame_default = () => {
  const idRef = (0, import_react131.useRef)(0);
  const cleanUp = () => {
    raf_default.cancel(idRef.current);
  };
  (0, import_react131.useEffect)(() => cleanUp, []);
  return (callback) => {
    cleanUp();
    idRef.current = raf_default(() => {
      callback();
    });
  };
};

// node_modules/@rc-component/input-number/es/InputNumber.js
function _extends59() {
  _extends59 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends59.apply(this, arguments);
}
var getDecimalValue = (stringMode, decimalValue) => {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = (value) => {
  const decimal = es_default22(value);
  return decimal.isInvalidate() ? null : decimal;
};
var InputNumber = React361.forwardRef((props, ref) => {
  const {
    mode = "input",
    prefixCls = "rc-input-number",
    className,
    style: style2,
    classNames,
    styles,
    min,
    max,
    step = 1,
    defaultValue,
    value,
    disabled,
    readOnly,
    upHandler,
    downHandler,
    keyboard,
    changeOnWheel = false,
    controls = true,
    prefix: prefix2,
    suffix,
    stringMode,
    parser,
    formatter,
    precision,
    decimalSeparator,
    onChange,
    onInput,
    onPressEnter,
    onStep,
    // Mouse Events
    onMouseDown,
    onClick,
    onMouseUp,
    onMouseLeave,
    onMouseMove,
    onMouseEnter,
    onMouseOut,
    changeOnBlur = true,
    ...restProps
  } = props;
  const [focus, setFocus] = React361.useState(false);
  const userTypingRef = React361.useRef(false);
  const compositionRef = React361.useRef(false);
  const shiftKeyRef = React361.useRef(false);
  const rootRef = React361.useRef(null);
  const inputRef = React361.useRef(null);
  React361.useImperativeHandle(ref, () => proxyObject(inputRef.current, {
    focus: (option) => {
      triggerFocus(inputRef.current, option);
    },
    blur: () => {
      var _a;
      (_a = inputRef.current) == null ? void 0 : _a.blur();
    },
    nativeElement: rootRef.current
  }));
  const [decimalValue, setDecimalValue] = React361.useState(() => es_default22(value ?? defaultValue));
  function setUncontrolledDecimalValue(newDecimal) {
    if (value === void 0) {
      setDecimalValue(newDecimal);
    }
  }
  const getPrecision = React361.useCallback((numStr, userTyping) => {
    if (userTyping) {
      return void 0;
    }
    if (precision >= 0) {
      return precision;
    }
    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
  }, [precision, step]);
  const mergedParser = React361.useCallback((num) => {
    const numStr = String(num);
    if (parser) {
      return parser(numStr);
    }
    let parsedStr = numStr;
    if (decimalSeparator) {
      parsedStr = parsedStr.replace(decimalSeparator, ".");
    }
    return parsedStr.replace(/[^\w.-]+/g, "");
  }, [parser, decimalSeparator]);
  const inputValueRef = React361.useRef("");
  const mergedFormatter = React361.useCallback((number4, userTyping) => {
    if (formatter) {
      return formatter(number4, {
        userTyping,
        input: String(inputValueRef.current)
      });
    }
    let str = typeof number4 === "number" ? num2str(number4) : number4;
    if (!userTyping) {
      const mergedPrecision = getPrecision(str, userTyping);
      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
        const separatorStr = decimalSeparator || ".";
        str = toFixed(str, separatorStr, mergedPrecision);
      }
    }
    return str;
  }, [formatter, getPrecision, decimalSeparator]);
  const [inputValue, setInternalInputValue] = React361.useState(() => {
    const initValue = defaultValue ?? value;
    if (decimalValue.isInvalidate() && ["string", "number"].includes(typeof initValue)) {
      return Number.isNaN(initValue) ? "" : initValue;
    }
    return mergedFormatter(decimalValue.toString(), false);
  });
  inputValueRef.current = inputValue;
  function setInputValue(newValue, userTyping) {
    setInternalInputValue(mergedFormatter(
      // Invalidate number is sometime passed by external control, we should let it go
      // Otherwise is controlled by internal interactive logic which check by userTyping
      // You can ref 'show limited value when input is not focused' test for more info.
      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
      userTyping
    ));
  }
  const maxDecimal = React361.useMemo(() => getDecimalIfValidate(max), [max, precision]);
  const minDecimal = React361.useMemo(() => getDecimalIfValidate(min), [min, precision]);
  const upDisabled = React361.useMemo(() => {
    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return maxDecimal.lessEquals(decimalValue);
  }, [maxDecimal, decimalValue]);
  const downDisabled = React361.useMemo(() => {
    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return decimalValue.lessEquals(minDecimal);
  }, [minDecimal, decimalValue]);
  const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);
  const getRangeValue = (target) => {
    if (maxDecimal && !target.lessEquals(maxDecimal)) {
      return maxDecimal;
    }
    if (minDecimal && !minDecimal.lessEquals(target)) {
      return minDecimal;
    }
    return null;
  };
  const isInRange2 = (target) => !getRangeValue(target);
  const triggerValueUpdate = (newValue, userTyping) => {
    let updateValue = newValue;
    let isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
    if (!updateValue.isEmpty() && !userTyping) {
      updateValue = getRangeValue(updateValue) || updateValue;
      isRangeValidate = true;
    }
    if (!readOnly && !disabled && isRangeValidate) {
      const numStr = updateValue.toString();
      const mergedPrecision = getPrecision(numStr, userTyping);
      if (mergedPrecision >= 0) {
        updateValue = es_default22(toFixed(numStr, ".", mergedPrecision));
        if (!isInRange2(updateValue)) {
          updateValue = es_default22(toFixed(numStr, ".", mergedPrecision, true));
        }
      }
      if (!updateValue.equals(decimalValue)) {
        setUncontrolledDecimalValue(updateValue);
        onChange == null ? void 0 : onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
        if (value === void 0) {
          setInputValue(updateValue, userTyping);
        }
      }
      return updateValue;
    }
    return decimalValue;
  };
  const onNextPromise = useFrame_default();
  const collectInputValue = (inputStr) => {
    recordCursor();
    inputValueRef.current = inputStr;
    setInternalInputValue(inputStr);
    if (!compositionRef.current) {
      const finalValue = mergedParser(inputStr);
      const finalDecimal = es_default22(finalValue);
      if (!finalDecimal.isNaN()) {
        triggerValueUpdate(finalDecimal, true);
      }
    }
    onInput == null ? void 0 : onInput(inputStr);
    onNextPromise(() => {
      let nextInputStr = inputStr;
      if (!parser) {
        nextInputStr = inputStr.replace(//g, ".");
      }
      if (nextInputStr !== inputStr) {
        collectInputValue(nextInputStr);
      }
    });
  };
  const onCompositionStart = () => {
    compositionRef.current = true;
  };
  const onCompositionEnd = () => {
    compositionRef.current = false;
    collectInputValue(inputRef.current.value);
  };
  const onInternalInput = (e3) => {
    collectInputValue(e3.target.value);
  };
  const onInternalStep = useEvent_default((up, emitter) => {
    var _a;
    if (up && upDisabled || !up && downDisabled) {
      return;
    }
    userTypingRef.current = false;
    let stepDecimal = es_default22(shiftKeyRef.current ? getDecupleSteps(step) : step);
    if (!up) {
      stepDecimal = stepDecimal.negate();
    }
    const target = (decimalValue || es_default22(0)).add(stepDecimal.toString());
    const updatedValue = triggerValueUpdate(target, false);
    onStep == null ? void 0 : onStep(getDecimalValue(stringMode, updatedValue), {
      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
      type: up ? "up" : "down",
      emitter
    });
    (_a = inputRef.current) == null ? void 0 : _a.focus();
  });
  const flushInputValue = (userTyping) => {
    const parsedValue = es_default22(mergedParser(inputValue));
    let formatValue2;
    if (!parsedValue.isNaN()) {
      formatValue2 = triggerValueUpdate(parsedValue, userTyping);
    } else {
      formatValue2 = triggerValueUpdate(decimalValue, userTyping);
    }
    if (value !== void 0) {
      setInputValue(decimalValue, false);
    } else if (!formatValue2.isNaN()) {
      setInputValue(formatValue2, false);
    }
  };
  const onBeforeInput = () => {
    userTypingRef.current = true;
  };
  const onKeyDown2 = (event) => {
    const {
      key,
      shiftKey
    } = event;
    userTypingRef.current = true;
    shiftKeyRef.current = shiftKey;
    if (key === "Enter") {
      if (!compositionRef.current) {
        userTypingRef.current = false;
      }
      flushInputValue(false);
      onPressEnter == null ? void 0 : onPressEnter(event);
    }
    if (keyboard === false) {
      return;
    }
    if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
      onInternalStep(key === "Up" || key === "ArrowUp", "keyboard");
      event.preventDefault();
    }
  };
  const onKeyUp = () => {
    userTypingRef.current = false;
    shiftKeyRef.current = false;
  };
  React361.useEffect(() => {
    if (changeOnWheel && focus) {
      const onWheel = (event) => {
        onInternalStep(event.deltaY < 0, "wheel");
        event.preventDefault();
      };
      const input = inputRef.current;
      if (input) {
        input.addEventListener("wheel", onWheel, {
          passive: false
        });
        return () => input.removeEventListener("wheel", onWheel);
      }
    }
  });
  const onBlur = () => {
    if (changeOnBlur) {
      flushInputValue(false);
    }
    setFocus(false);
    userTypingRef.current = false;
  };
  const onInternalMouseDown = (event) => {
    if (inputRef.current && event.target !== inputRef.current) {
      inputRef.current.focus();
      event.preventDefault();
    }
    onMouseDown == null ? void 0 : onMouseDown(event);
  };
  useLayoutUpdateEffect(() => {
    if (!decimalValue.isInvalidate()) {
      setInputValue(decimalValue, false);
    }
  }, [precision, formatter]);
  useLayoutUpdateEffect(() => {
    const newValue = es_default22(value);
    setDecimalValue(newValue);
    const currentParsedValue = es_default22(mergedParser(inputValue));
    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
      setInputValue(newValue, userTypingRef.current);
    }
  }, [value]);
  useLayoutUpdateEffect(() => {
    if (formatter) {
      restoreCursor();
    }
  }, [inputValue]);
  const sharedHandlerProps = {
    prefixCls,
    onStep: onInternalStep,
    className: classNames == null ? void 0 : classNames.action,
    style: styles == null ? void 0 : styles.action
  };
  const upNode = React361.createElement(StepHandler, _extends59({}, sharedHandlerProps, {
    action: "up",
    disabled: upDisabled
  }), upHandler);
  const downNode = React361.createElement(StepHandler, _extends59({}, sharedHandlerProps, {
    action: "down",
    disabled: downDisabled
  }), downHandler);
  return React361.createElement("div", {
    ref: rootRef,
    className: clsx(prefixCls, `${prefixCls}-mode-${mode}`, className, classNames == null ? void 0 : classNames.root, {
      [`${prefixCls}-focused`]: focus,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-readonly`]: readOnly,
      [`${prefixCls}-not-a-number`]: decimalValue.isNaN(),
      [`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange2(decimalValue)
    }),
    style: {
      ...styles == null ? void 0 : styles.root,
      ...style2
    },
    onMouseDown: onInternalMouseDown,
    onMouseUp,
    onMouseLeave,
    onMouseMove,
    onMouseEnter,
    onMouseOut,
    onClick,
    onFocus: () => {
      setFocus(true);
    },
    onBlur,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBeforeInput
  }, mode === "spinner" && controls && downNode, prefix2 !== void 0 && React361.createElement("div", {
    className: clsx(`${prefixCls}-prefix`, classNames == null ? void 0 : classNames.prefix),
    style: styles == null ? void 0 : styles.prefix
  }, prefix2), React361.createElement("input", _extends59({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
    step,
    ref: inputRef,
    className: clsx(`${prefixCls}-input`, classNames == null ? void 0 : classNames.input),
    style: styles == null ? void 0 : styles.input,
    value: inputValue,
    onChange: onInternalInput,
    disabled,
    readOnly
  }, restProps)), suffix !== void 0 && React361.createElement("div", {
    className: clsx(`${prefixCls}-suffix`, classNames == null ? void 0 : classNames.suffix),
    style: styles == null ? void 0 : styles.suffix
  }, suffix), mode === "spinner" && controls && upNode, mode === "input" && controls && React361.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames == null ? void 0 : classNames.actions),
    style: styles == null ? void 0 : styles.actions
  }, upNode, downNode));
});
if (true) {
  InputNumber.displayName = "InputNumber";
}
var InputNumber_default = InputNumber;

// node_modules/@rc-component/input-number/es/index.js
var es_default23 = InputNumber_default;

// node_modules/antd/es/space/Addon.js
var import_react132 = __toESM(require_react());

// node_modules/antd/es/space/style/addon.js
var genSpaceAddonStyle = (token2) => {
  const {
    componentCls,
    borderRadius,
    paddingSM,
    colorBorder,
    paddingXS,
    fontSizeLG,
    fontSizeSM,
    borderRadiusLG,
    borderRadiusSM,
    colorBgContainerDisabled,
    lineWidth
  } = token2;
  return {
    [componentCls]: [
      // ==========================================================
      // ==                         Base                         ==
      // ==========================================================
      {
        display: "inline-flex",
        alignItems: "center",
        gap: 0,
        paddingInline: paddingSM,
        margin: 0,
        borderWidth: lineWidth,
        borderStyle: "solid",
        borderRadius,
        "&:hover": {
          zIndex: 0
        },
        [`&${componentCls}-disabled`]: {
          color: token2.colorTextDisabled
        },
        "&-large": {
          fontSize: fontSizeLG,
          borderRadius: borderRadiusLG
        },
        "&-small": {
          paddingInline: paddingXS,
          borderRadius: borderRadiusSM,
          fontSize: fontSizeSM
        },
        "&-compact-last-item": {
          borderEndStartRadius: 0,
          borderStartStartRadius: 0
        },
        "&-compact-first-item": {
          borderEndEndRadius: 0,
          borderStartEndRadius: 0
        },
        "&-compact-item:not(:first-child):not(:last-child)": {
          borderRadius: 0
        },
        "&-compact-item:not(:last-child)": {
          borderInlineEndWidth: 0
        },
        "&-compact-item:not(:first-child)": {
          borderInlineStartWidth: 0
        }
      },
      // ==========================================================
      // ==                       Variants                       ==
      // ==========================================================
      {
        "--space-addon-border-color": colorBorder,
        "--space-addon-background": colorBgContainerDisabled,
        // Filled
        "--space-addon-border-color-outlined": colorBorder,
        "--space-addon-background-filled": colorBgContainerDisabled,
        borderColor: "var(--space-addon-border-color)",
        background: "var(--space-addon-background)",
        // ======================= Outlined =======================
        "&-variant-outlined": {
          "--space-addon-border-color": "var(--space-addon-border-color-outlined)"
        },
        // ======================== Filled ========================
        "&-variant-filled": {
          "--space-addon-border-color": "transparent",
          "--space-addon-background": "var(--space-addon-background-filled)",
          // Disabled
          [`&${componentCls}-disabled`]: {
            "--space-addon-border-color": colorBorder,
            "--space-addon-background": colorBgContainerDisabled
          }
        },
        // ====================== Borderless ======================
        "&-variant-borderless": {
          border: "none",
          background: "transparent"
        },
        // ====================== Underlined ======================
        "&-variant-underlined": {
          border: "none",
          background: "transparent"
        }
      },
      // ==========================================================
      // ==                        Status                        ==
      // ==========================================================
      {
        "&-status-error": {
          "--space-addon-border-color-outlined": token2.colorError,
          "--space-addon-background-filled": token2.colorErrorBg,
          color: token2.colorError
        },
        "&-status-warning": {
          "--space-addon-border-color-outlined": token2.colorWarning,
          "--space-addon-background-filled": token2.colorWarningBg,
          color: token2.colorWarning
        }
      }
    ]
  };
};
var addon_default = genStyleHooks(["Space", "Addon"], (token2) => [genSpaceAddonStyle(token2), genCompactItemStyle(token2, {
  focus: false
})]);

// node_modules/antd/es/space/Addon.js
var SpaceAddon = import_react132.default.forwardRef((props, ref) => {
  const {
    className,
    children,
    style: style2,
    prefixCls: customizePrefixCls,
    variant = "outlined",
    disabled,
    status,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction: directionConfig
  } = import_react132.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("space-addon", customizePrefixCls);
  const [hashId, cssVarCls] = addon_default(prefixCls);
  const {
    compactItemClassnames,
    compactSize
  } = useCompactItemContext(prefixCls, directionConfig);
  const statusCls = getStatusClassNames(prefixCls, status);
  const classes = clsx(prefixCls, hashId, compactItemClassnames, cssVarCls, `${prefixCls}-variant-${variant}`, statusCls, {
    [`${prefixCls}-${compactSize}`]: compactSize,
    [`${prefixCls}-disabled`]: disabled
  }, className);
  return import_react132.default.createElement("div", {
    ref,
    className: classes,
    style: style2,
    ...restProps
  }, children);
});
var Addon_default = SpaceAddon;

// node_modules/antd/es/input-number/style/token.js
var prepareComponentToken30 = (token2) => {
  const handleVisible = token2.handleVisible ?? "auto";
  const handleWidth = token2.controlHeightSM - token2.lineWidth * 2;
  return {
    ...initComponentToken(token2),
    controlWidth: 90,
    handleWidth,
    handleFontSize: token2.fontSize / 2,
    handleVisible,
    handleActiveBg: token2.colorFillAlter,
    handleBg: token2.colorBgContainer,
    filledHandleBg: new FastColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
    handleHoverColor: token2.colorPrimary,
    handleBorderColor: token2.colorBorder,
    handleOpacity: handleVisible === true ? 1 : 0,
    handleVisibleWidth: handleVisible === true ? handleWidth : 0
  };
};

// node_modules/antd/es/input-number/style/index.js
var genInputNumberStyles = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    borderRadius,
    inputFontSizeSM,
    inputFontSizeLG,
    colorError,
    paddingInlineSM,
    paddingBlockSM,
    paddingBlockLG,
    paddingInlineLG,
    colorIcon,
    motionDurationMid,
    handleHoverColor,
    handleOpacity,
    paddingInline,
    paddingBlock,
    handleBg,
    handleActiveBg,
    inputAffixPadding,
    borderRadiusSM,
    controlWidth,
    handleBorderColor,
    filledHandleBg,
    lineHeightLG
  } = token2;
  const borderStyle = `${unit(lineWidth)} ${lineType} ${handleBorderColor}`;
  return [
    // ==========================================================
    // ==                         Base                         ==
    // ==========================================================
    {
      [componentCls]: {
        ...resetComponent(token2),
        ...genBasicInputStyle(token2),
        "--input-number-input-padding-block": unit(paddingBlock),
        "--input-number-input-padding-inline": unit(paddingInline),
        display: "inline-flex",
        width: controlWidth,
        margin: 0,
        paddingBlock: 0,
        borderRadius,
        // ======================= Variants =======================
        ...genOutlinedStyle(token2, {
          [`${componentCls}-actions`]: {
            background: handleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          }
        }),
        ...genFilledStyle(token2, {
          [`${componentCls}-actions`]: {
            background: filledHandleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          },
          "&:focus-within": {
            [`${componentCls}-actions`]: {
              background: handleBg
            }
          }
        }),
        ...genUnderlinedStyle(token2, {
          [`${componentCls}-actions`]: {
            background: handleBg,
            [`${componentCls}-action-down`]: {
              borderBlockStart: borderStyle
            }
          }
        }),
        ...genBorderlessStyle2(token2),
        // ========================= RTL ==========================
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        // ===================== Out Of Range =====================
        [`&${componentCls}-out-of-range`]: {
          [`${componentCls}-input`]: {
            color: colorError
          }
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          ...resetComponent(token2),
          width: "100%",
          paddingBlock: `var(--input-number-input-padding-block)`,
          textAlign: "start",
          backgroundColor: "transparent",
          border: 0,
          borderRadius,
          outline: 0,
          transition: `all ${motionDurationMid} linear`,
          appearance: "textfield",
          fontSize: "inherit",
          lineHeight: "inherit",
          ...genPlaceholderStyle(token2.colorTextPlaceholder),
          '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
            margin: 0,
            appearance: "none"
          }
        },
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          width: token2.handleWidth,
          opacity: 1
        },
        // ======================= Disabled =======================
        [`&-disabled ${componentCls}-input`]: {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        }
      }
    },
    // ==========================================================
    // ==                        Action                        ==
    // ==========================================================
    {
      [componentCls]: {
        // ======================= Shared =======================
        [`
          ${componentCls}-action-up-disabled,
          ${componentCls}-action-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-action`]: {
          ...resetIcon(),
          userSelect: "none",
          overflow: "hidden",
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: handleActiveBg
          },
          // Hover
          "&:hover": {
            color: handleHoverColor
          }
        },
        // ===================== Input Mode =====================
        "&-mode-input": {
          overflow: "hidden",
          [`${componentCls}-actions`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineEnd: 0,
            width: token2.handleVisibleWidth,
            opacity: handleOpacity,
            height: "100%",
            borderRadius: 0,
            display: "flex",
            flexDirection: "column",
            alignItems: "stretch",
            transition: `all ${motionDurationMid}`,
            overflow: "hidden",
            // Fix input number inside Menu makes icon too large
            // We arise the selector priority by nest selector here
            // https://github.com/ant-design/ant-design/issues/14367
            [`${componentCls}-action`]: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flex: "auto",
              height: "40%",
              marginInlineEnd: 0,
              fontSize: token2.handleFontSize
            }
          },
          [`&:hover ${componentCls}-actions, &-focused ${componentCls}-actions`]: {
            width: token2.handleWidth,
            opacity: 1
          },
          [`${componentCls}-action`]: {
            color: colorIcon,
            height: "50%",
            borderInlineStart: borderStyle,
            // Hover
            "&:hover": {
              height: `60%`
            }
          },
          [`&${componentCls}-disabled, &${componentCls}-readonly`]: {
            [`${componentCls}-actions`]: {
              display: "none"
            }
          }
        },
        // ==================== Spinner Mode ====================
        [`&${componentCls}-mode-spinner`]: {
          padding: 0,
          width: "auto",
          [`${componentCls}-action`]: {
            flex: "none",
            paddingInline: "var(--input-number-input-padding-inline)",
            "&-up": {
              borderInlineStart: borderStyle
            },
            "&-down": {
              borderInlineEnd: borderStyle
            }
          },
          [`${componentCls}-input`]: {
            textAlign: "center",
            paddingInline: "var(--input-number-input-padding-inline)"
          }
        }
      }
    },
    // ==========================================================
    // ==                         Size                         ==
    // ==========================================================
    {
      [componentCls]: {
        "&-lg": {
          "--input-number-input-padding-block": unit(paddingBlockLG),
          "--input-number-input-padding-inline": unit(paddingInlineLG),
          paddingBlock: 0,
          fontSize: inputFontSizeLG,
          lineHeight: lineHeightLG
        },
        "&-sm": {
          "--input-number-input-padding-block": unit(paddingBlockSM),
          "--input-number-input-padding-inline": unit(paddingInlineSM),
          paddingBlock: 0,
          fontSize: inputFontSizeSM,
          borderRadius: borderRadiusSM
        }
      }
    },
    // ==========================================================
    // ==                      Pre/Suffix                      ==
    // ==========================================================
    {
      [componentCls]: {
        [`${componentCls}-prefix, ${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignItems: "center",
          alignSelf: "center",
          pointerEvents: "none"
        },
        [`${componentCls}-prefix`]: {
          marginInlineEnd: inputAffixPadding
        },
        [`${componentCls}-suffix`]: {
          height: "100%",
          marginInlineStart: inputAffixPadding,
          transition: `margin ${motionDurationMid}`
        },
        [`&:hover:not(${componentCls}-without-controls)`]: {
          [`${componentCls}-suffix`]: {
            marginInlineEnd: token2.handleWidth
          }
        }
      }
    }
  ];
};
var genCompatibleStyles = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [`${componentCls}-addon`]: {
      [`&:has(${antCls}-select)`]: {
        border: 0,
        padding: 0
      }
    }
  };
};
var style_default34 = genStyleHooks("InputNumber", (token2) => {
  const inputNumberToken = merge2(token2, initInputToken(token2));
  return [
    genInputNumberStyles(inputNumberToken),
    genCompatibleStyles(inputNumberToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputNumberToken)
  ];
}, prepareComponentToken30, {
  unitless: {
    handleOpacity: true
  },
  resetFont: false
});

// node_modules/antd/es/input-number/index.js
var InternalInputNumber = React363.forwardRef((props, ref) => {
  const inputRef = React363.useRef(null);
  React363.useImperativeHandle(ref, () => inputRef.current);
  const {
    rootClassName,
    size: customizeSize,
    disabled: customDisabled,
    prefixCls,
    addonBefore: _addonBefore,
    addonAfter: _addonAfter,
    prefix: prefix2,
    suffix,
    bordered,
    readOnly,
    status,
    controls = true,
    variant: customVariant,
    className,
    style: style2,
    classNames,
    styles,
    mode,
    ...others
  } = props;
  const {
    direction,
    className: contextClassName,
    style: contextStyle,
    styles: contextStyles,
    classNames: contextClassNames
  } = useComponentConfig("inputNumber");
  const mergedControls = React363.useMemo(() => {
    if (!controls || props.disabled || props.readOnly) {
      return false;
    }
    return controls;
  }, [controls, props.disabled, props.readOnly]);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  let upIcon = mode === "spinner" ? React363.createElement(PlusOutlined_default, null) : React363.createElement(UpOutlined_default, null);
  let downIcon = mode === "spinner" ? React363.createElement(MinusOutlined_default, null) : React363.createElement(DownOutlined_default, null);
  const controlsTemp = typeof mergedControls === "boolean" ? mergedControls : void 0;
  if (typeof mergedControls === "object") {
    upIcon = mergedControls.upIcon || upIcon;
    downIcon = mergedControls.downIcon || downIcon;
  }
  const {
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React363.useContext(FormItemInputContext);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React363.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const [variant, enableVariantCls] = useVariants_default("inputNumber", customVariant, bordered);
  const suffixNode = hasFeedback && React363.createElement(React363.Fragment, null, feedbackIcon);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled,
    controls: mergedControls
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  return React363.createElement(es_default23, {
    ref: inputRef,
    mode,
    disabled: mergedDisabled,
    className: clsx(className, rootClassName, mergedClassNames.root, contextClassName, compactItemClassnames, getStatusClassNames(prefixCls, status, hasFeedback), {
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-in-form-item`]: isFormItemInput,
      [`${prefixCls}-without-controls`]: !mergedControls
    }),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    upHandler: upIcon,
    downHandler: downIcon,
    prefixCls,
    readOnly,
    controls: controlsTemp,
    prefix: prefix2,
    suffix: suffixNode || suffix,
    classNames: mergedClassNames,
    styles: mergedStyles,
    ...others
  });
});
var InputNumber2 = React363.forwardRef((props, ref) => {
  const {
    addonBefore,
    addonAfter,
    prefixCls: customizePrefixCls,
    className,
    status: customStatus,
    rootClassName,
    ...rest
  } = props;
  const {
    getPrefixCls
  } = useComponentConfig("inputNumber");
  const prefixCls = getPrefixCls("input-number", customizePrefixCls);
  const {
    status: contextStatus
  } = React363.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default34(prefixCls, rootCls);
  const hasLegacyAddon = addonBefore || addonAfter;
  if (true) {
    const typeWarning = devUseWarning("InputNumber");
    [["bordered", "variant"], ["addonAfter", "Space.Compact"], ["addonBefore", "Space.Compact"]].forEach(([prop, newProp]) => {
      typeWarning.deprecated(!(prop in props), prop, newProp);
    });
    typeWarning(!(props.type === "number" && props.changeOnWheel), "usage", "When `type=number` is used together with `changeOnWheel`, changeOnWheel may not work properly. Please delete `type=number` if it is not necessary.");
  }
  const inputNumberNode = React363.createElement(InternalInputNumber, {
    ref,
    ...rest,
    prefixCls,
    status: mergedStatus,
    className: clsx(cssVarCls, rootCls, hashId, className),
    rootClassName: !hasLegacyAddon ? rootClassName : void 0
  });
  if (hasLegacyAddon) {
    const renderAddon = (node2) => {
      if (!node2) {
        return null;
      }
      return React363.createElement(Addon_default, {
        className: clsx(`${prefixCls}-addon`, cssVarCls, hashId),
        variant: props.variant,
        disabled: props.disabled,
        status: mergedStatus
      }, React363.createElement(ContextIsolator_default, {
        form: true
      }, node2));
    };
    const addonBeforeNode = renderAddon(addonBefore);
    const addonAfterNode = renderAddon(addonAfter);
    return React363.createElement(Compact_default, {
      rootClassName
    }, addonBeforeNode, inputNumberNode, addonAfterNode);
  }
  return inputNumberNode;
});
var TypedInputNumber = InputNumber2;
var PureInputNumber = (props) => React363.createElement(config_provider_default, {
  theme: {
    components: {
      InputNumber: {
        handleVisible: true
      }
    }
  }
}, React363.createElement(InputNumber2, {
  ...props
}));
if (true) {
  InternalInputNumber.displayName = "InternalInputNumber";
  TypedInputNumber.displayName = "InputNumber";
}
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
var input_number_default = TypedInputNumber;

// node_modules/antd/es/color-picker/components/ColorSteppers.js
var ColorSteppers = ({
  prefixCls,
  min = 0,
  max = 100,
  value,
  onChange,
  className,
  formatter
}) => {
  const colorSteppersPrefixCls = `${prefixCls}-steppers`;
  const [internalValue, setInternalValue] = (0, import_react133.useState)(0);
  const stepValue = !Number.isNaN(value) ? value : internalValue;
  return import_react133.default.createElement(input_number_default, {
    className: clsx(colorSteppersPrefixCls, className),
    min,
    max,
    value: stepValue,
    formatter,
    size: "small",
    onChange: (step) => {
      setInternalValue(step || 0);
      onChange == null ? void 0 : onChange(step);
    }
  });
};
var ColorSteppers_default = ColorSteppers;

// node_modules/antd/es/color-picker/components/ColorAlphaInput.js
var ColorAlphaInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
  const [internalValue, setInternalValue] = (0, import_react134.useState)(() => generateColor2(value || "#000"));
  const alphaValue = value || internalValue;
  const handleAlphaChange = (step) => {
    const hsba = alphaValue.toHsb();
    hsba.a = (step || 0) / 100;
    const genColor = generateColor2(hsba);
    setInternalValue(genColor);
    onChange == null ? void 0 : onChange(genColor);
  };
  return import_react134.default.createElement(ColorSteppers_default, {
    value: getColorAlpha(alphaValue),
    prefixCls,
    formatter: (step) => `${step}%`,
    className: colorAlphaInputPrefixCls,
    onChange: handleAlphaChange
  });
};
var ColorAlphaInput_default = ColorAlphaInput;

// node_modules/antd/es/color-picker/components/ColorHexInput.js
var import_react140 = __toESM(require_react());

// node_modules/antd/es/input/Input.js
var import_react139 = __toESM(require_react());

// node_modules/@rc-component/input/es/BaseInput.js
var import_react135 = __toESM(require_react());

// node_modules/@rc-component/input/es/utils/commonUtils.js
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function cloneEvent(event, target, value) {
  const currentTarget = target.cloneNode(true);
  const newEvent = Object.create(event, {
    target: {
      value: currentTarget
    },
    currentTarget: {
      value: currentTarget
    }
  });
  currentTarget.value = value;
  if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
    currentTarget.selectionStart = target.selectionStart;
    currentTarget.selectionEnd = target.selectionEnd;
  }
  currentTarget.setSelectionRange = (...args) => {
    target.setSelectionRange(...args);
  };
  return newEvent;
}
function resolveOnChange(target, e3, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  let event = e3;
  if (e3.type === "click") {
    event = cloneEvent(e3, target, "");
    onChange(event);
    return;
  }
  if (target.type !== "file" && targetValue !== void 0) {
    event = cloneEvent(e3, target, targetValue);
    onChange(event);
    return;
  }
  onChange(event);
}

// node_modules/@rc-component/input/es/BaseInput.js
function _extends60() {
  _extends60 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends60.apply(this, arguments);
}
var BaseInput = import_react135.default.forwardRef((props, ref) => {
  var _a, _b, _c;
  const {
    inputElement: inputEl,
    children,
    prefixCls,
    prefix: prefix2,
    suffix,
    addonBefore,
    addonAfter,
    className,
    style: style2,
    disabled,
    readOnly,
    focused,
    triggerFocus: triggerFocus2,
    allowClear,
    value,
    handleReset,
    hidden,
    classes,
    classNames,
    dataAttrs,
    styles,
    components: components2,
    onClear
  } = props;
  const inputElement = children ?? inputEl;
  const AffixWrapperComponent = (components2 == null ? void 0 : components2.affixWrapper) || "span";
  const GroupWrapperComponent = (components2 == null ? void 0 : components2.groupWrapper) || "span";
  const WrapperComponent = (components2 == null ? void 0 : components2.wrapper) || "span";
  const GroupAddonComponent = (components2 == null ? void 0 : components2.groupAddon) || "span";
  const containerRef = (0, import_react135.useRef)(null);
  const onInputClick = (e3) => {
    var _a2;
    if ((_a2 = containerRef.current) == null ? void 0 : _a2.contains(e3.target)) {
      triggerFocus2 == null ? void 0 : triggerFocus2();
    }
  };
  const hasAffix = hasPrefixSuffix(props);
  let element = (0, import_react135.cloneElement)(inputElement, {
    value,
    className: clsx((_a = inputElement.props) == null ? void 0 : _a.className, !hasAffix && (classNames == null ? void 0 : classNames.variant)) || null
  });
  const groupRef = (0, import_react135.useRef)(null);
  import_react135.default.useImperativeHandle(ref, () => ({
    nativeElement: groupRef.current || containerRef.current
  }));
  if (hasAffix) {
    let clearIcon = null;
    if (allowClear) {
      const needClear = !disabled && !readOnly && value;
      const clearIconCls = `${prefixCls}-clear-icon`;
      const iconNode = typeof allowClear === "object" && (allowClear == null ? void 0 : allowClear.clearIcon) ? allowClear.clearIcon : "";
      clearIcon = import_react135.default.createElement("button", {
        type: "button",
        tabIndex: -1,
        onClick: (event) => {
          handleReset == null ? void 0 : handleReset(event);
          onClear == null ? void 0 : onClear();
        },
        onMouseDown: (e3) => e3.preventDefault(),
        className: clsx(clearIconCls, {
          [`${clearIconCls}-hidden`]: !needClear,
          [`${clearIconCls}-has-suffix`]: !!suffix
        })
      }, iconNode);
    }
    const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
    const affixWrapperCls = clsx(affixWrapperPrefixCls, {
      [`${prefixCls}-disabled`]: disabled,
      [`${affixWrapperPrefixCls}-disabled`]: disabled,
      // Not used, but keep it
      [`${affixWrapperPrefixCls}-focused`]: focused,
      // Not used, but keep it
      [`${affixWrapperPrefixCls}-readonly`]: readOnly,
      [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
    }, classes == null ? void 0 : classes.affixWrapper, classNames == null ? void 0 : classNames.affixWrapper, classNames == null ? void 0 : classNames.variant);
    const suffixNode = (suffix || allowClear) && import_react135.default.createElement("span", {
      className: clsx(`${prefixCls}-suffix`, classNames == null ? void 0 : classNames.suffix),
      style: styles == null ? void 0 : styles.suffix
    }, clearIcon, suffix);
    element = import_react135.default.createElement(AffixWrapperComponent, _extends60({
      className: affixWrapperCls,
      style: styles == null ? void 0 : styles.affixWrapper,
      onClick: onInputClick
    }, dataAttrs == null ? void 0 : dataAttrs.affixWrapper, {
      ref: containerRef
    }), prefix2 && import_react135.default.createElement("span", {
      className: clsx(`${prefixCls}-prefix`, classNames == null ? void 0 : classNames.prefix),
      style: styles == null ? void 0 : styles.prefix
    }, prefix2), element, suffixNode);
  }
  if (hasAddon(props)) {
    const wrapperCls = `${prefixCls}-group`;
    const addonCls = `${wrapperCls}-addon`;
    const groupWrapperCls = `${wrapperCls}-wrapper`;
    const mergedWrapperClassName = clsx(`${prefixCls}-wrapper`, wrapperCls, classes == null ? void 0 : classes.wrapper, classNames == null ? void 0 : classNames.wrapper);
    const mergedGroupClassName = clsx(groupWrapperCls, {
      [`${groupWrapperCls}-disabled`]: disabled
    }, classes == null ? void 0 : classes.group, classNames == null ? void 0 : classNames.groupWrapper);
    element = import_react135.default.createElement(GroupWrapperComponent, {
      className: mergedGroupClassName,
      ref: groupRef
    }, import_react135.default.createElement(WrapperComponent, {
      className: mergedWrapperClassName
    }, addonBefore && import_react135.default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonBefore), element, addonAfter && import_react135.default.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonAfter)));
  }
  return import_react135.default.cloneElement(element, {
    className: clsx((_b = element.props) == null ? void 0 : _b.className, className) || null,
    style: {
      ...(_c = element.props) == null ? void 0 : _c.style,
      ...style2
    },
    hidden
  });
});
var BaseInput_default = BaseInput;

// node_modules/@rc-component/input/es/Input.js
var import_react136 = __toESM(require_react());

// node_modules/@rc-component/input/es/hooks/useCount.js
var React367 = __toESM(require_react());
function useCount(count, showCount) {
  return React367.useMemo(() => {
    let mergedConfig = {};
    if (showCount) {
      mergedConfig.show = typeof showCount === "object" && showCount.formatter ? showCount.formatter : !!showCount;
    }
    mergedConfig = {
      ...mergedConfig,
      ...count
    };
    const {
      show,
      ...rest
    } = mergedConfig;
    return {
      ...rest,
      show: !!show,
      showFormatter: typeof show === "function" ? show : void 0,
      strategy: rest.strategy || ((value) => value.length)
    };
  }, [count, showCount]);
}

// node_modules/@rc-component/input/es/Input.js
function _extends61() {
  _extends61 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends61.apply(this, arguments);
}
var Input3 = (0, import_react136.forwardRef)((props, ref) => {
  const {
    autoComplete,
    onChange,
    onFocus,
    onBlur,
    onPressEnter,
    onKeyDown: onKeyDown2,
    onKeyUp,
    prefixCls = "rc-input",
    disabled,
    htmlSize,
    className,
    maxLength,
    suffix,
    showCount,
    count,
    type: type5 = "text",
    classes,
    classNames,
    styles,
    onCompositionStart,
    onCompositionEnd,
    ...rest
  } = props;
  const [focused, setFocused] = (0, import_react136.useState)(false);
  const compositionRef = (0, import_react136.useRef)(false);
  const keyLockRef = (0, import_react136.useRef)(false);
  const inputRef = (0, import_react136.useRef)(null);
  const holderRef = (0, import_react136.useRef)(null);
  const focus = (option) => {
    if (inputRef.current) {
      triggerFocus(inputRef.current, option);
    }
  };
  const [value, setValue] = useControlledState(props.defaultValue, props.value);
  const formatValue2 = value === void 0 || value === null ? "" : String(value);
  const [selection, setSelection] = (0, import_react136.useState)(null);
  const countConfig = useCount(count, showCount);
  const mergedMax = countConfig.max || maxLength;
  const valueLength = countConfig.strategy(formatValue2);
  const isOutOfRange = !!mergedMax && valueLength > mergedMax;
  (0, import_react136.useImperativeHandle)(ref, () => {
    var _a;
    return {
      focus,
      blur: () => {
        var _a2;
        (_a2 = inputRef.current) == null ? void 0 : _a2.blur();
      },
      setSelectionRange: (start, end, direction) => {
        var _a2;
        (_a2 = inputRef.current) == null ? void 0 : _a2.setSelectionRange(start, end, direction);
      },
      select: () => {
        var _a2;
        (_a2 = inputRef.current) == null ? void 0 : _a2.select();
      },
      input: inputRef.current,
      nativeElement: ((_a = holderRef.current) == null ? void 0 : _a.nativeElement) || inputRef.current
    };
  });
  (0, import_react136.useEffect)(() => {
    if (keyLockRef.current) {
      keyLockRef.current = false;
    }
    setFocused((prev2) => prev2 && disabled ? false : prev2);
  }, [disabled]);
  const triggerChange = (e3, currentValue, info) => {
    var _a, _b;
    let cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([((_a = inputRef.current) == null ? void 0 : _a.selectionStart) || 0, ((_b = inputRef.current) == null ? void 0 : _b.selectionEnd) || 0]);
      }
    } else if (info.source === "compositionEnd") {
      return;
    }
    setValue(cutValue);
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e3, onChange, cutValue);
    }
  };
  (0, import_react136.useEffect)(() => {
    var _a;
    if (selection) {
      (_a = inputRef.current) == null ? void 0 : _a.setSelectionRange(...selection);
    }
  }, [selection]);
  const onInternalChange = (e3) => {
    triggerChange(e3, e3.target.value, {
      source: "change"
    });
  };
  const onInternalCompositionEnd = (e3) => {
    compositionRef.current = false;
    triggerChange(e3, e3.currentTarget.value, {
      source: "compositionEnd"
    });
    onCompositionEnd == null ? void 0 : onCompositionEnd(e3);
  };
  const handleKeyDown = (e3) => {
    if (onPressEnter && e3.key === "Enter" && !keyLockRef.current && !e3.nativeEvent.isComposing) {
      keyLockRef.current = true;
      onPressEnter(e3);
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(e3);
  };
  const handleKeyUp = (e3) => {
    if (e3.key === "Enter") {
      keyLockRef.current = false;
    }
    onKeyUp == null ? void 0 : onKeyUp(e3);
  };
  const handleFocus = (e3) => {
    setFocused(true);
    onFocus == null ? void 0 : onFocus(e3);
  };
  const handleBlur = (e3) => {
    if (keyLockRef.current) {
      keyLockRef.current = false;
    }
    setFocused(false);
    onBlur == null ? void 0 : onBlur(e3);
  };
  const handleReset = (e3) => {
    setValue("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e3, onChange);
    }
  };
  const outOfRangeCls = isOutOfRange && `${prefixCls}-out-of-range`;
  const getInputElement = () => {
    const otherProps = omit(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames",
      "onClear"
    ]);
    return import_react136.default.createElement("input", _extends61({
      autoComplete
    }, otherProps, {
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      className: clsx(prefixCls, {
        [`${prefixCls}-disabled`]: disabled
      }, classNames == null ? void 0 : classNames.input),
      style: styles == null ? void 0 : styles.input,
      ref: inputRef,
      size: htmlSize,
      type: type5,
      onCompositionStart: (e3) => {
        compositionRef.current = true;
        onCompositionStart == null ? void 0 : onCompositionStart(e3);
      },
      onCompositionEnd: onInternalCompositionEnd
    }));
  };
  const getSuffix = () => {
    const hasMaxLength = Number(mergedMax) > 0;
    if (suffix || countConfig.show) {
      const dataCount = countConfig.showFormatter ? countConfig.showFormatter({
        value: formatValue2,
        count: valueLength,
        maxLength: mergedMax
      }) : `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
      return import_react136.default.createElement(import_react136.default.Fragment, null, countConfig.show && import_react136.default.createElement("span", {
        className: clsx(`${prefixCls}-show-count-suffix`, {
          [`${prefixCls}-show-count-has-suffix`]: !!suffix
        }, classNames == null ? void 0 : classNames.count),
        style: {
          ...styles == null ? void 0 : styles.count
        }
      }, dataCount), suffix);
    }
    return null;
  };
  return import_react136.default.createElement(BaseInput_default, _extends61({}, rest, {
    prefixCls,
    className: clsx(className, outOfRangeCls),
    handleReset,
    value: formatValue2,
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled,
    classes,
    classNames,
    styles,
    ref: holderRef
  }), getInputElement());
});
var Input_default4 = Input3;

// node_modules/@rc-component/input/es/index.js
var es_default24 = Input_default4;

// node_modules/antd/es/_util/getAllowClear.js
var import_react137 = __toESM(require_react());
var getAllowClear = (allowClear) => {
  let mergedAllowClear;
  if (typeof allowClear === "object" && (allowClear == null ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: import_react137.default.createElement(CloseCircleFilled_default, null)
    };
  }
  return mergedAllowClear;
};
var getAllowClear_default = getAllowClear;

// node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js
var import_react138 = __toESM(require_react());
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = (0, import_react138.useRef)([]);
  const removePasswordTimeout = () => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      var _a, _b, _c, _d;
      if (((_a = inputRef.current) == null ? void 0 : _a.input) && ((_b = inputRef.current) == null ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) == null ? void 0 : _c.input.hasAttribute("value"))) {
        (_d = inputRef.current) == null ? void 0 : _d.input.removeAttribute("value");
      }
    }));
  };
  (0, import_react138.useEffect)(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach((timer) => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}

// node_modules/antd/es/input/utils.js
function hasPrefixSuffix2(props) {
  return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}

// node_modules/antd/es/input/Input.js
var Input4 = (0, import_react139.forwardRef)((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur,
    onFocus,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    style: style2,
    styles,
    rootClassName,
    onChange,
    classNames,
    variant: customVariant,
    ...rest
  } = props;
  if (true) {
    const {
      deprecated
    } = devUseWarning("Input");
    [["bordered", "variant"], ["addonAfter", "Space.Compact"], ["addonBefore", "Space.Compact"]].forEach(([prop, newProp]) => {
      deprecated(!(prop in props), prop, newProp);
    });
  }
  const {
    getPrefixCls,
    direction,
    allowClear: contextAllowClear,
    autoComplete: contextAutoComplete,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("input");
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const inputRef = (0, import_react139.useRef)(null);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
  style_default24(prefixCls, rootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customSize ?? compactSize ?? ctx);
  const disabled = import_react139.default.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = (0, import_react139.useContext)(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const inputHasPrefixSuffix = hasPrefixSuffix2(props) || !!hasFeedback;
  const prevHasPrefixSuffix = (0, import_react139.useRef)(inputHasPrefixSuffix);
  if (true) {
    const warning5 = devUseWarning("Input");
    (0, import_react139.useEffect)(() => {
      var _a;
      if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) {
        true ? warning5(document.activeElement === ((_a = inputRef.current) == null ? void 0 : _a.input), "usage", `When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ`) : void 0;
      }
      prevHasPrefixSuffix.current = inputHasPrefixSuffix;
    }, [inputHasPrefixSuffix]);
  }
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  const handleBlur = (e3) => {
    removePasswordTimeout();
    onBlur == null ? void 0 : onBlur(e3);
  };
  const handleFocus = (e3) => {
    removePasswordTimeout();
    onFocus == null ? void 0 : onFocus(e3);
  };
  const handleChange = (e3) => {
    removePasswordTimeout();
    onChange == null ? void 0 : onChange(e3);
  };
  const suffixNode = (hasFeedback || suffix) && import_react139.default.createElement(import_react139.default.Fragment, null, suffix, hasFeedback && feedbackIcon);
  const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
  const [variant, enableVariantCls] = useVariants_default("input", customVariant, bordered);
  return import_react139.default.createElement(es_default24, {
    ref: composeRef(ref, inputRef),
    prefixCls,
    autoComplete: contextAutoComplete,
    ...rest,
    disabled: mergedDisabled,
    onBlur: handleBlur,
    onFocus: handleFocus,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    styles: mergedStyles,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: clsx(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName, mergedClassNames.root),
    onChange: handleChange,
    addonBefore: addonBefore && import_react139.default.createElement(ContextIsolator_default, {
      form: true,
      space: true
    }, addonBefore),
    addonAfter: addonAfter && import_react139.default.createElement(ContextIsolator_default, {
      form: true,
      space: true
    }, addonAfter),
    classNames: {
      ...mergedClassNames,
      input: clsx({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, mergedClassNames.input, hashId),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: clsx({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
      }, hashId),
      wrapper: clsx({
        [`${prefixCls}-group-rtl`]: direction === "rtl"
      }, hashId),
      groupWrapper: clsx({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    }
  });
});
if (true) {
  Input4.displayName = "Input";
}
var Input_default5 = Input4;

// node_modules/antd/es/color-picker/components/ColorHexInput.js
var hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
var isHexString = (hex2) => hexReg.test(`#${hex2}`);
var ColorHexInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
  const [hexValue, setHexValue] = (0, import_react140.useState)(() => value ? toHexFormat(value.toHexString()) : void 0);
  (0, import_react140.useEffect)(() => {
    if (value) {
      setHexValue(toHexFormat(value.toHexString()));
    }
  }, [value]);
  const handleHexChange = (e3) => {
    const originValue = e3.target.value;
    setHexValue(toHexFormat(originValue));
    if (isHexString(toHexFormat(originValue, true))) {
      onChange == null ? void 0 : onChange(generateColor2(originValue));
    }
  };
  return import_react140.default.createElement(Input_default5, {
    className: colorHexInputPrefixCls,
    value: hexValue,
    prefix: "#",
    onChange: handleHexChange,
    size: "small"
  });
};
var ColorHexInput_default = ColorHexInput;

// node_modules/antd/es/color-picker/components/ColorHsbInput.js
var import_react141 = __toESM(require_react());
var ColorHsbInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
  const [internalValue, setInternalValue] = (0, import_react141.useState)(() => generateColor2(value || "#000"));
  const hsbValue = value || internalValue;
  const handleHsbChange = (step, type5) => {
    const hsb = hsbValue.toHsb();
    hsb[type5] = type5 === "h" ? step : (step || 0) / 100;
    const genColor = generateColor2(hsb);
    setInternalValue(genColor);
    onChange == null ? void 0 : onChange(genColor);
  };
  return import_react141.default.createElement("div", {
    className: colorHsbInputPrefixCls
  }, import_react141.default.createElement(ColorSteppers_default, {
    max: 360,
    min: 0,
    value: Number(hsbValue.toHsb().h),
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => getRoundNumber2(step || 0).toString(),
    onChange: (step) => handleHsbChange(Number(step), "h")
  }), import_react141.default.createElement(ColorSteppers_default, {
    max: 100,
    min: 0,
    value: Number(hsbValue.toHsb().s) * 100,
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => `${getRoundNumber2(step || 0)}%`,
    onChange: (step) => handleHsbChange(Number(step), "s")
  }), import_react141.default.createElement(ColorSteppers_default, {
    max: 100,
    min: 0,
    value: Number(hsbValue.toHsb().b) * 100,
    prefixCls,
    className: colorHsbInputPrefixCls,
    formatter: (step) => `${getRoundNumber2(step || 0)}%`,
    onChange: (step) => handleHsbChange(Number(step), "b")
  }));
};
var ColorHsbInput_default = ColorHsbInput;

// node_modules/antd/es/color-picker/components/ColorRgbInput.js
var import_react142 = __toESM(require_react());
var ColorRgbInput = ({
  prefixCls,
  value,
  onChange
}) => {
  const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
  const [internalValue, setInternalValue] = (0, import_react142.useState)(() => generateColor2(value || "#000"));
  const rgbValue = value || internalValue;
  const handleRgbChange = (step, type5) => {
    const rgb = rgbValue.toRgb();
    rgb[type5] = step || 0;
    const genColor = generateColor2(rgb);
    setInternalValue(genColor);
    onChange == null ? void 0 : onChange(genColor);
  };
  return import_react142.default.createElement("div", {
    className: colorRgbInputPrefixCls
  }, import_react142.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().r),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "r")
  }), import_react142.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().g),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "g")
  }), import_react142.default.createElement(ColorSteppers_default, {
    max: 255,
    min: 0,
    value: Number(rgbValue.toRgb().b),
    prefixCls,
    className: colorRgbInputPrefixCls,
    onChange: (step) => handleRgbChange(Number(step), "b")
  }));
};
var ColorRgbInput_default = ColorRgbInput;

// node_modules/antd/es/color-picker/components/ColorInput.js
var selectOptions = [FORMAT_HEX, FORMAT_HSB, FORMAT_RGB].map((format3) => ({
  value: format3,
  label: format3.toUpperCase()
}));
var ColorInput = (props) => {
  const {
    prefixCls,
    format: format3,
    value,
    disabledAlpha,
    onFormatChange,
    onChange,
    disabledFormat
  } = props;
  const [colorFormat, setColorFormat] = useControlledState(FORMAT_HEX, format3);
  const colorInputPrefixCls = `${prefixCls}-input`;
  const triggerFormatChange = (newFormat) => {
    setColorFormat(newFormat);
    onFormatChange == null ? void 0 : onFormatChange(newFormat);
  };
  const steppersNode = (0, import_react143.useMemo)(() => {
    const inputProps = {
      value,
      prefixCls,
      onChange
    };
    switch (colorFormat) {
      case FORMAT_HSB:
        return import_react143.default.createElement(ColorHsbInput_default, {
          ...inputProps
        });
      case FORMAT_RGB:
        return import_react143.default.createElement(ColorRgbInput_default, {
          ...inputProps
        });
      default:
        return import_react143.default.createElement(ColorHexInput_default, {
          ...inputProps
        });
    }
  }, [colorFormat, prefixCls, value, onChange]);
  return import_react143.default.createElement("div", {
    className: `${colorInputPrefixCls}-container`
  }, !disabledFormat && import_react143.default.createElement(select_default, {
    value: colorFormat,
    variant: "borderless",
    getPopupContainer: (current) => current,
    popupMatchSelectWidth: 68,
    placement: "bottomRight",
    onChange: triggerFormatChange,
    className: `${prefixCls}-format-select`,
    size: "small",
    options: selectOptions
  }), import_react143.default.createElement("div", {
    className: colorInputPrefixCls
  }, steppersNode), !disabledAlpha && import_react143.default.createElement(ColorAlphaInput_default, {
    prefixCls,
    value,
    onChange
  }));
};
var ColorInput_default = ColorInput;

// node_modules/antd/es/color-picker/components/ColorSlider.js
var React390 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Slider.js
var React386 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Handles/index.js
var React377 = __toESM(require_react());
var import_react_dom6 = __toESM(require_react_dom());

// node_modules/@rc-component/slider/es/util.js
function getOffset3(value, min, max) {
  return (value - min) / (max - min);
}
function getDirectionStyle(direction, value, min, max) {
  const offset3 = getOffset3(value, min, max);
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offset3 * 100}%`;
      positionStyle.transform = "translateX(50%)";
      break;
    case "btt":
      positionStyle.bottom = `${offset3 * 100}%`;
      positionStyle.transform = "translateY(50%)";
      break;
    case "ttb":
      positionStyle.top = `${offset3 * 100}%`;
      positionStyle.transform = "translateY(-50%)";
      break;
    default:
      positionStyle.left = `${offset3 * 100}%`;
      positionStyle.transform = "translateX(-50%)";
      break;
  }
  return positionStyle;
}
function getIndex(value, index2) {
  return Array.isArray(value) ? value[index2] : value;
}

// node_modules/@rc-component/slider/es/Handles/Handle.js
var React376 = __toESM(require_react());

// node_modules/@rc-component/slider/es/context.js
var React375 = __toESM(require_react());
var SliderContext = React375.createContext({
  min: 0,
  max: 0,
  direction: "ltr",
  step: 1,
  includedStart: 0,
  includedEnd: 0,
  tabIndex: 0,
  keyboard: true,
  styles: {},
  classNames: {}
});
var context_default10 = SliderContext;
var UnstableContext = React375.createContext({});

// node_modules/@rc-component/slider/es/Handles/Handle.js
function _extends62() {
  _extends62 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends62.apply(this, arguments);
}
var Handle = React376.forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls,
    value,
    valueIndex,
    onStartMove,
    onDelete,
    style: style2,
    render: render2,
    dragging,
    draggingDelete,
    onOffsetChange,
    onChangeComplete,
    onFocus,
    onMouseEnter,
    ...restProps
  } = props;
  const {
    min,
    max,
    direction,
    disabled,
    keyboard,
    range: range3,
    tabIndex,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle,
    styles,
    classNames
  } = React376.useContext(context_default10);
  const handlePrefixCls = `${prefixCls}-handle`;
  const onInternalStartMove = (e3) => {
    if (!disabled) {
      onStartMove(e3, valueIndex);
    }
  };
  const onInternalFocus = (e3) => {
    onFocus == null ? void 0 : onFocus(e3, valueIndex);
  };
  const onInternalMouseEnter = (e3) => {
    onMouseEnter(e3, valueIndex);
  };
  const onKeyDown2 = (e3) => {
    if (!disabled && keyboard) {
      let offset3 = null;
      switch (e3.which || e3.keyCode) {
        case KeyCode_default.LEFT:
          offset3 = direction === "ltr" || direction === "btt" ? -1 : 1;
          break;
        case KeyCode_default.RIGHT:
          offset3 = direction === "ltr" || direction === "btt" ? 1 : -1;
          break;
        case KeyCode_default.UP:
          offset3 = direction !== "ttb" ? 1 : -1;
          break;
        case KeyCode_default.DOWN:
          offset3 = direction !== "ttb" ? -1 : 1;
          break;
        case KeyCode_default.HOME:
          offset3 = "min";
          break;
        case KeyCode_default.END:
          offset3 = "max";
          break;
        case KeyCode_default.PAGE_UP:
          offset3 = 2;
          break;
        case KeyCode_default.PAGE_DOWN:
          offset3 = -2;
          break;
        case KeyCode_default.BACKSPACE:
        case KeyCode_default.DELETE:
          onDelete == null ? void 0 : onDelete(valueIndex);
          break;
      }
      if (offset3 !== null) {
        e3.preventDefault();
        onOffsetChange(offset3, valueIndex);
      }
    }
  };
  const handleKeyUp = (e3) => {
    switch (e3.which || e3.keyCode) {
      case KeyCode_default.LEFT:
      case KeyCode_default.RIGHT:
      case KeyCode_default.UP:
      case KeyCode_default.DOWN:
      case KeyCode_default.HOME:
      case KeyCode_default.END:
      case KeyCode_default.PAGE_UP:
      case KeyCode_default.PAGE_DOWN:
        onChangeComplete == null ? void 0 : onChangeComplete();
        break;
    }
  };
  const positionStyle = getDirectionStyle(direction, value, min, max);
  let divProps = {};
  if (valueIndex !== null) {
    divProps = {
      tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
      role: "slider",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value,
      "aria-disabled": disabled,
      "aria-label": getIndex(ariaLabelForHandle, valueIndex),
      "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
      "aria-required": getIndex(ariaRequired, valueIndex),
      "aria-valuetext": (_a = getIndex(ariaValueTextFormatterForHandle, valueIndex)) == null ? void 0 : _a(value),
      "aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
      onMouseDown: onInternalStartMove,
      onTouchStart: onInternalStartMove,
      onFocus: onInternalFocus,
      onMouseEnter: onInternalMouseEnter,
      onKeyDown: onKeyDown2,
      onKeyUp: handleKeyUp
    };
  }
  let handleNode = React376.createElement("div", _extends62({
    ref,
    className: clsx(handlePrefixCls, {
      [`${handlePrefixCls}-${valueIndex + 1}`]: valueIndex !== null && range3,
      [`${handlePrefixCls}-dragging`]: dragging,
      [`${handlePrefixCls}-dragging-delete`]: draggingDelete
    }, classNames.handle),
    style: {
      ...positionStyle,
      ...style2,
      ...styles.handle
    }
  }, divProps, restProps));
  if (render2) {
    handleNode = render2(handleNode, {
      index: valueIndex,
      prefixCls,
      value,
      dragging,
      draggingDelete
    });
  }
  return handleNode;
});
if (true) {
  Handle.displayName = "Handle";
}
var Handle_default = Handle;

// node_modules/@rc-component/slider/es/Handles/index.js
function _extends63() {
  _extends63 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends63.apply(this, arguments);
}
var Handles = React377.forwardRef((props, ref) => {
  const {
    prefixCls,
    style: style2,
    onStartMove,
    onOffsetChange,
    values,
    handleRender,
    activeHandleRender,
    draggingIndex,
    draggingDelete,
    onFocus,
    ...restProps
  } = props;
  const handlesRef = React377.useRef({});
  const [activeVisible, setActiveVisible] = React377.useState(false);
  const [activeIndex, setActiveIndex] = React377.useState(-1);
  const onActive = (index2) => {
    setActiveIndex(index2);
    setActiveVisible(true);
  };
  const onHandleFocus = (e3, index2) => {
    onActive(index2);
    onFocus == null ? void 0 : onFocus(e3);
  };
  const onHandleMouseEnter = (e3, index2) => {
    onActive(index2);
  };
  React377.useImperativeHandle(ref, () => ({
    focus: (index2) => {
      var _a;
      (_a = handlesRef.current[index2]) == null ? void 0 : _a.focus();
    },
    hideHelp: () => {
      (0, import_react_dom6.flushSync)(() => {
        setActiveVisible(false);
      });
    }
  }));
  const handleProps = {
    prefixCls,
    onStartMove,
    onOffsetChange,
    render: handleRender,
    onFocus: onHandleFocus,
    onMouseEnter: onHandleMouseEnter,
    ...restProps
  };
  return React377.createElement(React377.Fragment, null, values.map((value, index2) => {
    const dragging = draggingIndex === index2;
    return React377.createElement(Handle_default, _extends63({
      ref: (node2) => {
        if (!node2) {
          delete handlesRef.current[index2];
        } else {
          handlesRef.current[index2] = node2;
        }
      },
      dragging,
      draggingDelete: dragging && draggingDelete,
      style: getIndex(style2, index2),
      key: index2,
      value,
      valueIndex: index2
    }, handleProps));
  }), activeHandleRender && activeVisible && React377.createElement(Handle_default, _extends63({
    key: "a11y"
  }, handleProps, {
    value: values[activeIndex],
    valueIndex: null,
    dragging: draggingIndex !== -1,
    draggingDelete,
    render: activeHandleRender,
    style: {
      pointerEvents: "none"
    },
    tabIndex: null,
    "aria-hidden": true
  })));
});
if (true) {
  Handles.displayName = "Handles";
}
var Handles_default = Handles;

// node_modules/@rc-component/slider/es/Marks/index.js
var React379 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Marks/Mark.js
var React378 = __toESM(require_react());
var Mark = (props) => {
  const {
    prefixCls,
    style: style2,
    children,
    value,
    onClick
  } = props;
  const {
    min,
    max,
    direction,
    includedStart,
    includedEnd,
    included
  } = React378.useContext(context_default10);
  const textCls = `${prefixCls}-text`;
  const positionStyle = getDirectionStyle(direction, value, min, max);
  return React378.createElement("span", {
    className: clsx(textCls, {
      [`${textCls}-active`]: included && includedStart <= value && value <= includedEnd
    }),
    style: {
      ...positionStyle,
      ...style2
    },
    onMouseDown: (e3) => {
      e3.stopPropagation();
    },
    onClick: () => {
      onClick(value);
    }
  }, children);
};
var Mark_default = Mark;

// node_modules/@rc-component/slider/es/Marks/index.js
var Marks = (props) => {
  const {
    prefixCls,
    marks,
    onClick
  } = props;
  const markPrefixCls = `${prefixCls}-mark`;
  if (!marks.length) {
    return null;
  }
  return React379.createElement("div", {
    className: markPrefixCls
  }, marks.map(({
    value,
    style: style2,
    label
  }) => React379.createElement(Mark_default, {
    key: value,
    prefixCls: markPrefixCls,
    style: style2,
    value,
    onClick
  }, label)));
};
var Marks_default = Marks;

// node_modules/@rc-component/slider/es/Steps/index.js
var React381 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Steps/Dot.js
var React380 = __toESM(require_react());
var Dot = (props) => {
  const {
    prefixCls,
    value,
    style: style2,
    activeStyle
  } = props;
  const {
    min,
    max,
    direction,
    included,
    includedStart,
    includedEnd
  } = React380.useContext(context_default10);
  const dotClassName = `${prefixCls}-dot`;
  const active = included && includedStart <= value && value <= includedEnd;
  let mergedStyle = {
    ...getDirectionStyle(direction, value, min, max),
    ...typeof style2 === "function" ? style2(value) : style2
  };
  if (active) {
    mergedStyle = {
      ...mergedStyle,
      ...typeof activeStyle === "function" ? activeStyle(value) : activeStyle
    };
  }
  return React380.createElement("span", {
    className: clsx(dotClassName, {
      [`${dotClassName}-active`]: active
    }),
    style: mergedStyle
  });
};
var Dot_default = Dot;

// node_modules/@rc-component/slider/es/Steps/index.js
var Steps = (props) => {
  const {
    prefixCls,
    marks,
    dots,
    style: style2,
    activeStyle
  } = props;
  const {
    min,
    max,
    step
  } = React381.useContext(context_default10);
  const stepDots = React381.useMemo(() => {
    const dotSet = /* @__PURE__ */ new Set();
    marks.forEach((mark) => {
      dotSet.add(mark.value);
    });
    if (dots && step !== null) {
      let current = min;
      while (current <= max) {
        dotSet.add(current);
        current += step;
      }
    }
    return Array.from(dotSet);
  }, [min, max, step, dots, marks]);
  return React381.createElement("div", {
    className: `${prefixCls}-step`
  }, stepDots.map((dotValue) => React381.createElement(Dot_default, {
    prefixCls,
    key: dotValue,
    value: dotValue,
    style: style2,
    activeStyle
  })));
};
var Steps_default = Steps;

// node_modules/@rc-component/slider/es/Tracks/index.js
var React383 = __toESM(require_react());

// node_modules/@rc-component/slider/es/Tracks/Track.js
var React382 = __toESM(require_react());
var Track2 = (props) => {
  const {
    prefixCls,
    style: style2,
    start,
    end,
    index: index2,
    onStartMove,
    replaceCls
  } = props;
  const {
    direction,
    min,
    max,
    disabled,
    range: range3,
    classNames
  } = React382.useContext(context_default10);
  const trackPrefixCls = `${prefixCls}-track`;
  const offsetStart = getOffset3(start, min, max);
  const offsetEnd = getOffset3(end, min, max);
  const onInternalStartMove = (e3) => {
    if (!disabled && onStartMove) {
      onStartMove(e3, -1);
    }
  };
  const positionStyle = {};
  switch (direction) {
    case "rtl":
      positionStyle.right = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "btt":
      positionStyle.bottom = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    case "ttb":
      positionStyle.top = `${offsetStart * 100}%`;
      positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
      break;
    default:
      positionStyle.left = `${offsetStart * 100}%`;
      positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
  }
  const className = replaceCls || clsx(trackPrefixCls, {
    [`${trackPrefixCls}-${index2 + 1}`]: index2 !== null && range3,
    [`${prefixCls}-track-draggable`]: onStartMove
  }, classNames.track);
  return React382.createElement("div", {
    className,
    style: {
      ...positionStyle,
      ...style2
    },
    onMouseDown: onInternalStartMove,
    onTouchStart: onInternalStartMove
  });
};
var Track_default = Track2;

// node_modules/@rc-component/slider/es/Tracks/index.js
var Tracks = (props) => {
  const {
    prefixCls,
    style: style2,
    values,
    startPoint,
    onStartMove
  } = props;
  const {
    included,
    range: range3,
    min,
    styles,
    classNames
  } = React383.useContext(context_default10);
  const trackList = React383.useMemo(() => {
    if (!range3) {
      if (values.length === 0) {
        return [];
      }
      const startValue = startPoint ?? min;
      const endValue = values[0];
      return [{
        start: Math.min(startValue, endValue),
        end: Math.max(startValue, endValue)
      }];
    }
    const list = [];
    for (let i = 0; i < values.length - 1; i += 1) {
      list.push({
        start: values[i],
        end: values[i + 1]
      });
    }
    return list;
  }, [values, range3, startPoint, min]);
  if (!included) {
    return null;
  }
  const tracksNode = (trackList == null ? void 0 : trackList.length) && (classNames.tracks || styles.tracks) ? React383.createElement(Track_default, {
    index: null,
    prefixCls,
    start: trackList[0].start,
    end: trackList[trackList.length - 1].end,
    replaceCls: clsx(classNames.tracks, `${prefixCls}-tracks`),
    style: styles.tracks
  }) : null;
  return React383.createElement(React383.Fragment, null, tracksNode, trackList.map(({
    start,
    end
  }, index2) => React383.createElement(Track_default, {
    index: index2,
    prefixCls,
    style: {
      ...getIndex(style2, index2),
      ...styles.track
    },
    start,
    end,
    key: index2,
    onStartMove
  })));
};
var Tracks_default = Tracks;

// node_modules/@rc-component/slider/es/hooks/useDrag.js
var React384 = __toESM(require_react());
var REMOVE_DIST = 130;
function getPosition3(e3) {
  const obj = "targetTouches" in e3 ? e3.targetTouches[0] : e3;
  return {
    pageX: obj.pageX,
    pageY: obj.pageY
  };
}
function useDrag(containerRef, direction, rawValues, min, max, formatValue2, triggerChange, finishChange, offsetValues, editable, minCount) {
  const [draggingValue, setDraggingValue] = React384.useState(null);
  const [draggingIndex, setDraggingIndex] = React384.useState(-1);
  const [draggingDelete, setDraggingDelete] = React384.useState(false);
  const [cacheValues, setCacheValues] = React384.useState(rawValues);
  const [originValues, setOriginValues] = React384.useState(rawValues);
  const mouseMoveEventRef = React384.useRef(null);
  const mouseUpEventRef = React384.useRef(null);
  const touchEventTargetRef = React384.useRef(null);
  const {
    onDragStart,
    onDragChange
  } = React384.useContext(UnstableContext);
  useLayoutEffect_default(() => {
    if (draggingIndex === -1) {
      setCacheValues(rawValues);
    }
  }, [rawValues, draggingIndex]);
  React384.useEffect(() => () => {
    document.removeEventListener("mousemove", mouseMoveEventRef.current);
    document.removeEventListener("mouseup", mouseUpEventRef.current);
    if (touchEventTargetRef.current) {
      touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
      touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
    }
  }, []);
  const flushValues = (nextValues, nextValue, deleteMark) => {
    if (nextValue !== void 0) {
      setDraggingValue(nextValue);
    }
    setCacheValues(nextValues);
    let changeValues = nextValues;
    if (deleteMark) {
      changeValues = nextValues.filter((_, i) => i !== draggingIndex);
    }
    triggerChange(changeValues);
    if (onDragChange) {
      onDragChange({
        rawValues: nextValues,
        deleteIndex: deleteMark ? draggingIndex : -1,
        draggingIndex,
        draggingValue: nextValue
      });
    }
  };
  const updateCacheValue = useEvent_default((valueIndex, offsetPercent, deleteMark) => {
    if (valueIndex === -1) {
      const startValue = originValues[0];
      const endValue = originValues[originValues.length - 1];
      const maxStartOffset = min - startValue;
      const maxEndOffset = max - endValue;
      let offset3 = offsetPercent * (max - min);
      offset3 = Math.max(offset3, maxStartOffset);
      offset3 = Math.min(offset3, maxEndOffset);
      const formatStartValue = formatValue2(startValue + offset3);
      offset3 = formatStartValue - startValue;
      const cloneCacheValues = originValues.map((val) => val + offset3);
      flushValues(cloneCacheValues);
    } else {
      const offsetDist = (max - min) * offsetPercent;
      const cloneValues = [...cacheValues];
      cloneValues[valueIndex] = originValues[valueIndex];
      const next2 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
      flushValues(next2.values, next2.value, deleteMark);
    }
  });
  const onStartMove = (e3, valueIndex, startValues) => {
    e3.stopPropagation();
    const initialValues = startValues || rawValues;
    const originValue = initialValues[valueIndex];
    setDraggingIndex(valueIndex);
    setDraggingValue(originValue);
    setOriginValues(initialValues);
    setCacheValues(initialValues);
    setDraggingDelete(false);
    const {
      pageX: startX,
      pageY: startY
    } = getPosition3(e3);
    let deleteMark = false;
    if (onDragStart) {
      onDragStart({
        rawValues: initialValues,
        draggingIndex: valueIndex,
        draggingValue: originValue
      });
    }
    const onMouseMove = (event) => {
      event.preventDefault();
      const {
        pageX: moveX,
        pageY: moveY
      } = getPosition3(event);
      const offsetX = moveX - startX;
      const offsetY = moveY - startY;
      const {
        width,
        height
      } = containerRef.current.getBoundingClientRect();
      let offSetPercent;
      let removeDist;
      switch (direction) {
        case "btt":
          offSetPercent = -offsetY / height;
          removeDist = offsetX;
          break;
        case "ttb":
          offSetPercent = offsetY / height;
          removeDist = offsetX;
          break;
        case "rtl":
          offSetPercent = -offsetX / width;
          removeDist = offsetY;
          break;
        default:
          offSetPercent = offsetX / width;
          removeDist = offsetY;
      }
      deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;
      setDraggingDelete(deleteMark);
      updateCacheValue(valueIndex, offSetPercent, deleteMark);
    };
    const onMouseUp = (event) => {
      event.preventDefault();
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", onMouseMove);
      if (touchEventTargetRef.current) {
        touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
        touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
      }
      mouseMoveEventRef.current = null;
      mouseUpEventRef.current = null;
      touchEventTargetRef.current = null;
      finishChange(deleteMark);
      setDraggingIndex(-1);
      setDraggingDelete(false);
    };
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("mousemove", onMouseMove);
    e3.currentTarget.addEventListener("touchend", onMouseUp);
    e3.currentTarget.addEventListener("touchmove", onMouseMove);
    mouseMoveEventRef.current = onMouseMove;
    mouseUpEventRef.current = onMouseUp;
    touchEventTargetRef.current = e3.currentTarget;
  };
  const returnValues = React384.useMemo(() => {
    const sourceValues = [...rawValues].sort((a, b) => a - b);
    const targetValues = [...cacheValues].sort((a, b) => a - b);
    const counts = {};
    targetValues.forEach((val) => {
      counts[val] = (counts[val] || 0) + 1;
    });
    sourceValues.forEach((val) => {
      counts[val] = (counts[val] || 0) - 1;
    });
    const maxDiffCount = editable ? 1 : 0;
    const diffCount = Object.values(counts).reduce((prev2, next2) => prev2 + Math.abs(next2), 0);
    return diffCount <= maxDiffCount ? cacheValues : rawValues;
  }, [rawValues, cacheValues, editable]);
  return [draggingIndex, draggingValue, draggingDelete, returnValues, onStartMove];
}
var useDrag_default = useDrag;

// node_modules/@rc-component/slider/es/hooks/useOffset.js
var React385 = __toESM(require_react());
function useOffset(min, max, step, markList, allowCross, pushable) {
  const formatRangeValue = React385.useCallback((val) => Math.max(min, Math.min(max, val)), [min, max]);
  const formatStepValue = React385.useCallback((val) => {
    if (step !== null) {
      const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
      const getDecimal = (num) => (String(num).split(".")[1] || "").length;
      const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
      const fixedValue = Number(stepValue.toFixed(maxDecimal));
      return min <= fixedValue && fixedValue <= max ? fixedValue : null;
    }
    return null;
  }, [step, min, max, formatRangeValue]);
  const formatValue2 = React385.useCallback((val) => {
    const formatNextValue = formatRangeValue(val);
    const alignValues = markList.map((mark) => mark.value);
    if (step !== null) {
      alignValues.push(formatStepValue(val));
    }
    alignValues.push(min, max);
    let closeValue = alignValues[0];
    let closeDist = max - min;
    alignValues.forEach((alignValue) => {
      const dist = Math.abs(formatNextValue - alignValue);
      if (dist <= closeDist) {
        closeValue = alignValue;
        closeDist = dist;
      }
    });
    return closeValue;
  }, [min, max, markList, step, formatRangeValue, formatStepValue]);
  const offsetValue = (values, offset3, valueIndex, mode = "unit") => {
    if (typeof offset3 === "number") {
      let nextValue;
      const originValue = values[valueIndex];
      const targetDistValue = originValue + offset3;
      let potentialValues = [];
      markList.forEach((mark) => {
        potentialValues.push(mark.value);
      });
      potentialValues.push(min, max);
      potentialValues.push(formatStepValue(originValue));
      const sign = offset3 > 0 ? 1 : -1;
      if (mode === "unit") {
        potentialValues.push(formatStepValue(originValue + sign * step));
      } else {
        potentialValues.push(formatStepValue(targetDistValue));
      }
      potentialValues = potentialValues.filter((val) => val !== null).filter((val) => offset3 < 0 ? val <= originValue : val >= originValue);
      if (mode === "unit") {
        potentialValues = potentialValues.filter((val) => val !== originValue);
      }
      const compareValue = mode === "unit" ? originValue : targetDistValue;
      nextValue = potentialValues[0];
      let valueDist = Math.abs(nextValue - compareValue);
      potentialValues.forEach((potentialValue) => {
        const dist = Math.abs(potentialValue - compareValue);
        if (dist < valueDist) {
          nextValue = potentialValue;
          valueDist = dist;
        }
      });
      if (nextValue === void 0) {
        return offset3 < 0 ? min : max;
      }
      if (mode === "dist") {
        return nextValue;
      }
      if (Math.abs(offset3) > 1) {
        const cloneValues = [...values];
        cloneValues[valueIndex] = nextValue;
        return offsetValue(cloneValues, offset3 - sign, valueIndex, mode);
      }
      return nextValue;
    } else if (offset3 === "min") {
      return min;
    } else if (offset3 === "max") {
      return max;
    }
  };
  const offsetChangedValue = (values, offset3, valueIndex, mode = "unit") => {
    const originValue = values[valueIndex];
    const nextValue = offsetValue(values, offset3, valueIndex, mode);
    return {
      value: nextValue,
      changed: nextValue !== originValue
    };
  };
  const needPush = (dist) => {
    return pushable === null && dist === 0 || typeof pushable === "number" && dist < pushable;
  };
  const offsetValues = (values, offset3, valueIndex, mode = "unit") => {
    const nextValues = values.map(formatValue2);
    const originValue = nextValues[valueIndex];
    const nextValue = offsetValue(nextValues, offset3, valueIndex, mode);
    nextValues[valueIndex] = nextValue;
    if (allowCross === false) {
      const pushNum = pushable || 0;
      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {
        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
      }
      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {
        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
      }
    } else if (typeof pushable === "number" || pushable === null) {
      for (let i = valueIndex + 1; i < nextValues.length; i += 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i],
            changed
          } = offsetChangedValue(nextValues, 1, i));
        }
      }
      for (let i = valueIndex; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i - 1],
            changed
          } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = nextValues.length - 1; i > 0; i -= 1) {
        let changed = true;
        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {
          ({
            value: nextValues[i - 1],
            changed
          } = offsetChangedValue(nextValues, -1, i - 1));
        }
      }
      for (let i = 0; i < nextValues.length - 1; i += 1) {
        let changed = true;
        while (needPush(nextValues[i + 1] - nextValues[i]) && changed) {
          ({
            value: nextValues[i + 1],
            changed
          } = offsetChangedValue(nextValues, 1, i + 1));
        }
      }
    }
    return {
      value: nextValues[valueIndex],
      values: nextValues
    };
  };
  return [formatValue2, offsetValues];
}

// node_modules/@rc-component/slider/es/hooks/useRange.js
var import_react144 = __toESM(require_react());
function useRange(range3) {
  return (0, import_react144.useMemo)(() => {
    if (range3 === true || !range3) {
      return [!!range3, false, false, 0];
    }
    const {
      editable,
      draggableTrack,
      minCount,
      maxCount
    } = range3;
    if (true) {
      warning(!editable || !draggableTrack, "`editable` can not work with `draggableTrack`.");
    }
    return [true, editable, !editable && draggableTrack, minCount || 0, maxCount];
  }, [range3]);
}

// node_modules/@rc-component/slider/es/Slider.js
var Slider3 = React386.forwardRef((props, ref) => {
  const {
    prefixCls = "rc-slider",
    className,
    style: style2,
    classNames,
    styles,
    id,
    // Status
    disabled = false,
    keyboard = true,
    autoFocus,
    onFocus,
    onBlur,
    // Value
    min = 0,
    max = 100,
    step = 1,
    value,
    defaultValue,
    range: range3,
    count,
    onChange,
    onBeforeChange,
    onAfterChange,
    onChangeComplete,
    // Cross
    allowCross = true,
    pushable = false,
    // Direction
    reverse,
    vertical,
    // Style
    included = true,
    startPoint,
    trackStyle,
    handleStyle,
    railStyle,
    dotStyle,
    activeDotStyle,
    // Decorations
    marks,
    dots,
    // Components
    handleRender,
    activeHandleRender,
    track,
    // Accessibility
    tabIndex = 0,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle
  } = props;
  const handlesRef = React386.useRef(null);
  const containerRef = React386.useRef(null);
  const direction = React386.useMemo(() => {
    if (vertical) {
      return reverse ? "ttb" : "btt";
    }
    return reverse ? "rtl" : "ltr";
  }, [reverse, vertical]);
  const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range3);
  const mergedMin = React386.useMemo(() => isFinite(min) ? min : 0, [min]);
  const mergedMax = React386.useMemo(() => isFinite(max) ? max : 100, [max]);
  const mergedStep = React386.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);
  const mergedPush = React386.useMemo(() => {
    if (typeof pushable === "boolean") {
      return pushable ? mergedStep : false;
    }
    return pushable >= 0 ? pushable : false;
  }, [pushable, mergedStep]);
  const markList = React386.useMemo(() => {
    return Object.keys(marks || {}).map((key) => {
      const mark = marks[key];
      const markObj = {
        value: Number(key)
      };
      if (mark && typeof mark === "object" && !React386.isValidElement(mark) && ("label" in mark || "style" in mark)) {
        markObj.style = mark.style;
        markObj.label = mark.label;
      } else {
        markObj.label = mark;
      }
      return markObj;
    }).filter(({
      label
    }) => label || typeof label === "number").sort((a, b) => a.value - b.value);
  }, [marks]);
  const [formatValue2, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);
  const [mergedValue, setValue] = useControlledState(defaultValue, value);
  const rawValues = React386.useMemo(() => {
    const valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    const [val0 = mergedMin] = valueList;
    let returnValues = mergedValue === null ? [] : [val0];
    if (rangeEnabled) {
      returnValues = [...valueList];
      if (count || mergedValue === void 0) {
        const pointCount = count >= 0 ? count + 1 : 2;
        returnValues = returnValues.slice(0, pointCount);
        while (returnValues.length < pointCount) {
          returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);
        }
      }
      returnValues.sort((a, b) => a - b);
    }
    returnValues.forEach((val, index2) => {
      returnValues[index2] = formatValue2(val);
    });
    return returnValues;
  }, [mergedValue, rangeEnabled, mergedMin, count, formatValue2]);
  const getTriggerValue = (triggerValues) => rangeEnabled ? triggerValues : triggerValues[0];
  const triggerChange = useEvent_default((nextValues) => {
    const cloneNextValues = [...nextValues].sort((a, b) => a - b);
    if (onChange && !isEqual_default(cloneNextValues, rawValues, true)) {
      onChange(getTriggerValue(cloneNextValues));
    }
    setValue(cloneNextValues);
  });
  const finishChange = useEvent_default((draggingDelete2) => {
    if (draggingDelete2) {
      handlesRef.current.hideHelp();
    }
    const finishValue = getTriggerValue(rawValues);
    onAfterChange == null ? void 0 : onAfterChange(finishValue);
    warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
    onChangeComplete == null ? void 0 : onChangeComplete(finishValue);
  });
  const onDelete = (index2) => {
    if (disabled || !rangeEditable || rawValues.length <= minCount) {
      return;
    }
    const cloneNextValues = [...rawValues];
    cloneNextValues.splice(index2, 1);
    onBeforeChange == null ? void 0 : onBeforeChange(getTriggerValue(cloneNextValues));
    triggerChange(cloneNextValues);
    const nextFocusIndex = Math.max(0, index2 - 1);
    handlesRef.current.hideHelp();
    handlesRef.current.focus(nextFocusIndex);
  };
  const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag_default(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue2, triggerChange, finishChange, offsetValues, rangeEditable, minCount);
  const changeToCloseValue = (newValue, e3) => {
    var _a, _b;
    if (!disabled) {
      const cloneNextValues = [...rawValues];
      let valueIndex = 0;
      let valueBeforeIndex = 0;
      let valueDist = mergedMax - mergedMin;
      rawValues.forEach((val, index2) => {
        const dist = Math.abs(newValue - val);
        if (dist <= valueDist) {
          valueDist = dist;
          valueIndex = index2;
        }
        if (val < newValue) {
          valueBeforeIndex = index2;
        }
      });
      let focusIndex = valueIndex;
      if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {
        cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);
        focusIndex = valueBeforeIndex + 1;
      } else {
        cloneNextValues[valueIndex] = newValue;
      }
      if (rangeEnabled && !rawValues.length && count === void 0) {
        cloneNextValues.push(newValue);
      }
      const nextValue = getTriggerValue(cloneNextValues);
      onBeforeChange == null ? void 0 : onBeforeChange(nextValue);
      triggerChange(cloneNextValues);
      if (e3) {
        (_b = (_a = document.activeElement) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
        handlesRef.current.focus(focusIndex);
        onStartDrag(e3, focusIndex, cloneNextValues);
      } else {
        onAfterChange == null ? void 0 : onAfterChange(nextValue);
        warning_default(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
        onChangeComplete == null ? void 0 : onChangeComplete(nextValue);
      }
    }
  };
  const onSliderMouseDown = (e3) => {
    e3.preventDefault();
    const {
      width,
      height,
      left,
      top,
      bottom,
      right
    } = containerRef.current.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = e3;
    let percent;
    switch (direction) {
      case "btt":
        percent = (bottom - clientY) / height;
        break;
      case "ttb":
        percent = (clientY - top) / height;
        break;
      case "rtl":
        percent = (right - clientX) / width;
        break;
      default:
        percent = (clientX - left) / width;
    }
    const nextValue = mergedMin + percent * (mergedMax - mergedMin);
    changeToCloseValue(formatValue2(nextValue), e3);
  };
  const [keyboardValue, setKeyboardValue] = React386.useState(null);
  const onHandleOffsetChange = (offset3, valueIndex) => {
    if (!disabled) {
      const next2 = offsetValues(rawValues, offset3, valueIndex);
      onBeforeChange == null ? void 0 : onBeforeChange(getTriggerValue(rawValues));
      triggerChange(next2.values);
      setKeyboardValue(next2.value);
    }
  };
  React386.useEffect(() => {
    if (keyboardValue !== null) {
      const valueIndex = rawValues.indexOf(keyboardValue);
      if (valueIndex >= 0) {
        handlesRef.current.focus(valueIndex);
      }
    }
    setKeyboardValue(null);
  }, [keyboardValue]);
  const mergedDraggableTrack = React386.useMemo(() => {
    if (rangeDraggableTrack && mergedStep === null) {
      if (true) {
        warning_default(false, "`draggableTrack` is not supported when `step` is `null`.");
      }
      return false;
    }
    return rangeDraggableTrack;
  }, [rangeDraggableTrack, mergedStep]);
  const onStartMove = useEvent_default((e3, valueIndex) => {
    onStartDrag(e3, valueIndex);
    onBeforeChange == null ? void 0 : onBeforeChange(getTriggerValue(rawValues));
  });
  const dragging = draggingIndex !== -1;
  React386.useEffect(() => {
    if (!dragging) {
      const valueIndex = rawValues.lastIndexOf(draggingValue);
      handlesRef.current.focus(valueIndex);
    }
  }, [dragging]);
  const sortedCacheValues = React386.useMemo(() => [...cacheValues].sort((a, b) => a - b), [cacheValues]);
  const [includedStart, includedEnd] = React386.useMemo(() => {
    if (!rangeEnabled) {
      return [mergedMin, sortedCacheValues[0]];
    }
    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
  }, [sortedCacheValues, rangeEnabled, mergedMin]);
  React386.useImperativeHandle(ref, () => ({
    focus: () => {
      handlesRef.current.focus(0);
    },
    blur: () => {
      var _a;
      const {
        activeElement
      } = document;
      if ((_a = containerRef.current) == null ? void 0 : _a.contains(activeElement)) {
        activeElement == null ? void 0 : activeElement.blur();
      }
    }
  }));
  React386.useEffect(() => {
    if (autoFocus) {
      handlesRef.current.focus(0);
    }
  }, []);
  const context = React386.useMemo(() => ({
    min: mergedMin,
    max: mergedMax,
    direction,
    disabled,
    keyboard,
    step: mergedStep,
    included,
    includedStart,
    includedEnd,
    range: rangeEnabled,
    tabIndex,
    ariaLabelForHandle,
    ariaLabelledByForHandle,
    ariaRequired,
    ariaValueTextFormatterForHandle,
    styles: styles || {},
    classNames: classNames || {}
  }), [mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, rangeEnabled, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames]);
  return React386.createElement(context_default10.Provider, {
    value: context
  }, React386.createElement("div", {
    ref: containerRef,
    className: clsx(prefixCls, className, {
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-vertical`]: vertical,
      [`${prefixCls}-horizontal`]: !vertical,
      [`${prefixCls}-with-marks`]: markList.length
    }),
    style: style2,
    onMouseDown: onSliderMouseDown,
    id
  }, React386.createElement("div", {
    className: clsx(`${prefixCls}-rail`, classNames == null ? void 0 : classNames.rail),
    style: {
      ...railStyle,
      ...styles == null ? void 0 : styles.rail
    }
  }), track !== false && React386.createElement(Tracks_default, {
    prefixCls,
    style: trackStyle,
    values: rawValues,
    startPoint,
    onStartMove: mergedDraggableTrack ? onStartMove : void 0
  }), React386.createElement(Steps_default, {
    prefixCls,
    marks: markList,
    dots,
    style: dotStyle,
    activeStyle: activeDotStyle
  }), React386.createElement(Handles_default, {
    ref: handlesRef,
    prefixCls,
    style: handleStyle,
    values: cacheValues,
    draggingIndex,
    draggingDelete,
    onStartMove,
    onOffsetChange: onHandleOffsetChange,
    onFocus,
    onBlur,
    handleRender,
    activeHandleRender,
    onChangeComplete: finishChange,
    onDelete: rangeEditable ? onDelete : void 0
  }), React386.createElement(Marks_default, {
    prefixCls,
    marks: markList,
    onClick: changeToCloseValue
  })));
});
if (true) {
  Slider3.displayName = "Slider";
}
var Slider_default2 = Slider3;

// node_modules/@rc-component/slider/es/index.js
var es_default25 = Slider_default2;

// node_modules/antd/es/slider/index.js
var import_react147 = __toESM(require_react());

// node_modules/antd/es/slider/Context.js
var import_react145 = __toESM(require_react());
var SliderInternalContext = (0, import_react145.createContext)({});
var Context_default3 = SliderInternalContext;

// node_modules/antd/es/slider/SliderTooltip.js
var React387 = __toESM(require_react());
var import_react146 = __toESM(require_react());
var SliderTooltip = React387.forwardRef((props, ref) => {
  const {
    open: open3,
    draggingDelete,
    value
  } = props;
  const innerRef = (0, import_react146.useRef)(null);
  const mergedOpen = open3 && !draggingDelete;
  const rafRef = (0, import_react146.useRef)(null);
  function cancelKeepAlign() {
    raf_default.cancel(rafRef.current);
    rafRef.current = null;
  }
  function keepAlign() {
    rafRef.current = raf_default(() => {
      var _a;
      (_a = innerRef.current) == null ? void 0 : _a.forceAlign();
      rafRef.current = null;
    });
  }
  React387.useEffect(() => {
    if (mergedOpen) {
      keepAlign();
    } else {
      cancelKeepAlign();
    }
    return cancelKeepAlign;
  }, [mergedOpen, props.title, value]);
  return React387.createElement(tooltip_default, {
    ref: composeRef(innerRef, ref),
    ...props,
    open: mergedOpen
  });
});
if (true) {
  SliderTooltip.displayName = "SliderTooltip";
}
var SliderTooltip_default = SliderTooltip;

// node_modules/antd/es/slider/style/index.js
var genBaseStyle10 = (token2) => {
  const {
    componentCls,
    antCls,
    controlSize,
    dotSize,
    marginFull,
    marginPart,
    colorFillContentHover,
    handleColorDisabled,
    calc,
    handleSize,
    handleSizeHover,
    handleActiveColor,
    handleActiveOutlineColor,
    handleLineWidth,
    handleLineWidthHover,
    motionDurationMid
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      height: controlSize,
      margin: `${unit(marginPart)} ${unit(marginFull)}`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      "&-vertical": {
        margin: `${unit(marginFull)} ${unit(marginPart)}`
      },
      [`${componentCls}-rail`]: {
        position: "absolute",
        backgroundColor: token2.railBg,
        borderRadius: token2.borderRadiusXS,
        transition: `background-color ${motionDurationMid}`
      },
      [`${componentCls}-track,${componentCls}-tracks`]: {
        position: "absolute",
        transition: `background-color ${motionDurationMid}`
      },
      [`${componentCls}-track`]: {
        backgroundColor: token2.trackBg,
        borderRadius: token2.borderRadiusXS
      },
      [`${componentCls}-track-draggable`]: {
        boxSizing: "content-box",
        backgroundClip: "content-box",
        border: "solid rgba(0,0,0,0)"
      },
      "&:hover": {
        [`${componentCls}-rail`]: {
          backgroundColor: token2.railHoverBg
        },
        [`${componentCls}-track`]: {
          backgroundColor: token2.trackHoverBg
        },
        [`${componentCls}-dot`]: {
          borderColor: colorFillContentHover
        },
        [`${componentCls}-handle::after`]: {
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token2.colorPrimaryBorderHover}`
        },
        [`${componentCls}-dot-active`]: {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`${componentCls}-handle`]: {
        position: "absolute",
        width: handleSize,
        height: handleSize,
        outline: "none",
        userSelect: "none",
        // Dragging status
        "&-dragging-delete": {
          opacity: 0
        },
        // 
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: calc(handleLineWidth).mul(-1).equal(),
          insetBlockStart: calc(handleLineWidth).mul(-1).equal(),
          width: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
          height: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: handleSize,
          height: handleSize,
          backgroundColor: token2.colorBgElevated,
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${token2.handleColor}`,
          outline: `0px solid transparent`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${motionDurationMid},
            inset-block-start ${motionDurationMid},
            width ${motionDurationMid},
            height ${motionDurationMid},
            box-shadow ${motionDurationMid},
            outline ${motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
            insetBlockStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
            width: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal(),
            height: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal()
          },
          "&::after": {
            boxShadow: `0 0 0 ${unit(handleLineWidthHover)} ${handleActiveColor}`,
            outline: `6px solid ${handleActiveOutlineColor}`,
            width: handleSizeHover,
            height: handleSizeHover,
            insetInlineStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal(),
            insetBlockStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal()
          }
        }
      },
      [`&-lock ${componentCls}-handle`]: {
        "&::before, &::after": {
          transition: "none"
        }
      },
      [`${componentCls}-mark`]: {
        position: "absolute",
        fontSize: token2.fontSize
      },
      [`${componentCls}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: token2.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: token2.colorText
        }
      },
      [`${componentCls}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        width: dotSize,
        height: dotSize,
        backgroundColor: token2.colorBgElevated,
        border: `${unit(handleLineWidth)} solid ${token2.dotBorderColor}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        pointerEvents: "auto",
        "&-active": {
          borderColor: token2.dotActiveBorderColor
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-rail`]: {
          backgroundColor: `${token2.railBg} !important`
        },
        [`${componentCls}-track`]: {
          backgroundColor: `${token2.trackBgDisabled} !important`
        },
        [`
          ${componentCls}-dot
        `]: {
          backgroundColor: token2.colorBgElevated,
          borderColor: token2.trackBgDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${componentCls}-handle::after`]: {
          backgroundColor: token2.colorBgElevated,
          cursor: "not-allowed",
          width: handleSize,
          height: handleSize,
          boxShadow: `0 0 0 ${unit(handleLineWidth)} ${handleColorDisabled}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
          cursor: `not-allowed !important`
        }
      },
      [`&-tooltip ${antCls}-tooltip-container`]: {
        minWidth: "unset"
      }
    }
  };
};
var genDirectionStyle = (token2, horizontal) => {
  const {
    componentCls,
    railSize,
    handleSize,
    dotSize,
    marginFull,
    calc
  } = token2;
  const railPadding = horizontal ? "paddingBlock" : "paddingInline";
  const full = horizontal ? "width" : "height";
  const part = horizontal ? "height" : "width";
  const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
  const markInset = horizontal ? "top" : "insetInlineStart";
  const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
  const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
  const draggableBorder = horizontal ? {
    borderWidth: `${unit(draggableBorderSize)} 0`,
    transform: `translateY(${unit(calc(draggableBorderSize).mul(-1).equal())})`
  } : {
    borderWidth: `0 ${unit(draggableBorderSize)}`,
    transform: `translateX(${unit(token2.calc(draggableBorderSize).mul(-1).equal())})`
  };
  return {
    [railPadding]: railSize,
    [part]: calc(railSize).mul(3).equal(),
    [`${componentCls}-rail`]: {
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-track,${componentCls}-tracks`]: {
      [part]: railSize
    },
    [`${componentCls}-track-draggable`]: {
      ...draggableBorder
    },
    [`${componentCls}-handle`]: {
      [handlePos]: handlePosSize
    },
    [`${componentCls}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      // https://github.com/ant-design/ant-design/issues/43731
      [markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
      [full]: "100%"
    },
    [`${componentCls}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: railSize,
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-dot`]: {
      position: "absolute",
      [handlePos]: calc(railSize).sub(dotSize).div(2).equal()
    }
  };
};
var genHorizontalStyle = (token2) => {
  const {
    componentCls,
    marginPartWithMark
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      ...genDirectionStyle(token2, true),
      [`&${componentCls}-with-marks`]: {
        marginBottom: marginPartWithMark
      }
    }
  };
};
var genVerticalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: {
      ...genDirectionStyle(token2, false),
      height: "100%"
    }
  };
};
var prepareComponentToken31 = (token2) => {
  const increaseHandleWidth = 1;
  const controlSize = token2.controlHeightLG / 4;
  const controlSizeHover = token2.controlHeightSM / 2;
  const handleLineWidth = token2.lineWidth + increaseHandleWidth;
  const handleLineWidthHover = token2.lineWidth + increaseHandleWidth * 1.5;
  const handleActiveColor = token2.colorPrimary;
  const handleActiveOutlineColor = new FastColor(handleActiveColor).setA(0.2).toRgbString();
  return {
    controlSize,
    railSize: 4,
    handleSize: controlSize,
    handleSizeHover: controlSizeHover,
    dotSize: 8,
    handleLineWidth,
    handleLineWidthHover,
    railBg: token2.colorFillTertiary,
    railHoverBg: token2.colorFillSecondary,
    trackBg: token2.colorPrimaryBorder,
    trackHoverBg: token2.colorPrimaryBorderHover,
    handleColor: token2.colorPrimaryBorder,
    handleActiveColor,
    handleActiveOutlineColor,
    handleColorDisabled: new FastColor(token2.colorTextDisabled).onBackground(token2.colorBgContainer).toHexString(),
    dotBorderColor: token2.colorBorderSecondary,
    dotActiveBorderColor: token2.colorPrimaryBorder,
    trackBgDisabled: token2.colorBgContainerDisabled
  };
};
var style_default35 = genStyleHooks("Slider", (token2) => {
  const sliderToken = merge2(token2, {
    marginPart: token2.calc(token2.controlHeight).sub(token2.controlSize).div(2).equal(),
    marginFull: token2.calc(token2.controlSize).div(2).equal(),
    marginPartWithMark: token2.calc(token2.controlHeightLG).sub(token2.controlSize).equal()
  });
  return [genBaseStyle10(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken)];
}, prepareComponentToken31);

// node_modules/antd/es/slider/useRafLock.js
var React388 = __toESM(require_react());
function useRafLock() {
  const [state, setState] = React388.useState(false);
  const rafRef = React388.useRef(null);
  const cleanup2 = () => {
    raf_default.cancel(rafRef.current);
  };
  const setDelayState = (nextState) => {
    cleanup2();
    if (nextState) {
      setState(nextState);
    } else {
      rafRef.current = raf_default(() => {
        setState(nextState);
      });
    }
  };
  React388.useEffect(() => cleanup2, []);
  return [state, setDelayState];
}

// node_modules/antd/es/slider/index.js
function getTipFormatter(tipFormatter) {
  if (tipFormatter || tipFormatter === null) {
    return tipFormatter;
  }
  return (val) => typeof val === "number" ? val.toString() : "";
}
var Slider4 = import_react147.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    range: range3,
    className,
    rootClassName,
    style: style2,
    disabled,
    // Deprecated Props
    tooltip = {},
    onChangeComplete,
    classNames,
    styles,
    vertical,
    orientation,
    ...restProps
  } = props;
  const [, mergedVertical] = useOrientation(orientation, vertical);
  const {
    getPrefixCls,
    direction: contextDirection,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    getPopupContainer
  } = useComponentConfig("slider");
  const contextDisabled = import_react147.default.useContext(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const mergedProps = {
    ...props,
    disabled: mergedDisabled,
    vertical: mergedVertical
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const {
    handleRender: contextHandleRender,
    direction: internalContextDirection
  } = import_react147.default.useContext(Context_default3);
  const mergedDirection = internalContextDirection || contextDirection;
  const isRTL = mergedDirection === "rtl";
  const [hoverOpen, setHoverOpen] = useRafLock();
  const [focusOpen, setFocusOpen] = useRafLock();
  const tooltipProps = {
    ...tooltip
  };
  const {
    open: tooltipOpen,
    placement: tooltipPlacement,
    getPopupContainer: getTooltipPopupContainer,
    prefixCls: customizeTooltipPrefixCls,
    formatter: tipFormatter
  } = tooltipProps;
  const lockOpen = tooltipOpen;
  const activeOpen = (hoverOpen || focusOpen) && lockOpen !== false;
  const mergedTipFormatter = getTipFormatter(tipFormatter);
  const [dragging, setDragging] = useRafLock();
  const onInternalChangeComplete = (nextValues) => {
    onChangeComplete == null ? void 0 : onChangeComplete(nextValues);
    setDragging(false);
  };
  const getTooltipPlacement = (placement, vert) => {
    if (placement) {
      return placement;
    }
    if (!vert) {
      return "top";
    }
    return isRTL ? "left" : "right";
  };
  const prefixCls = getPrefixCls("slider", customizePrefixCls);
  const [hashId, cssVarCls] = style_default35(prefixCls);
  const rootClassNames = clsx(className, contextClassName, mergedClassNames.root, rootClassName, {
    [`${prefixCls}-rtl`]: isRTL,
    [`${prefixCls}-lock`]: dragging
  }, hashId, cssVarCls);
  if (isRTL && !mergedVertical) {
    restProps.reverse = !restProps.reverse;
  }
  if (true) {
    const warning5 = devUseWarning("Slider");
    [["tooltipPrefixCls", "prefixCls"], ["getTooltipPopupContainer", "getPopupContainer"], ["tipFormatter", "formatter"], ["tooltipPlacement", "placement"], ["tooltipVisible", "open"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, `tooltip.${newName}`);
    });
  }
  import_react147.default.useEffect(() => {
    const onMouseUp = () => {
      raf_default(() => {
        setFocusOpen(false);
      }, 1);
    };
    document.addEventListener("mouseup", onMouseUp);
    return () => {
      document.removeEventListener("mouseup", onMouseUp);
    };
  }, []);
  const useActiveTooltipHandle = range3 && !lockOpen;
  const handleRender = contextHandleRender || ((node2, info) => {
    const {
      index: index2
    } = info;
    const nodeProps = node2.props;
    function proxyEvent(eventName, event, triggerRestPropsEvent) {
      var _a, _b;
      if (triggerRestPropsEvent) {
        (_a = restProps[eventName]) == null ? void 0 : _a.call(restProps, event);
      }
      (_b = nodeProps[eventName]) == null ? void 0 : _b.call(nodeProps, event);
    }
    const passedProps = {
      ...nodeProps,
      onMouseEnter: (e3) => {
        setHoverOpen(true);
        proxyEvent("onMouseEnter", e3);
      },
      onMouseLeave: (e3) => {
        setHoverOpen(false);
        proxyEvent("onMouseLeave", e3);
      },
      onMouseDown: (e3) => {
        setFocusOpen(true);
        setDragging(true);
        proxyEvent("onMouseDown", e3);
      },
      onFocus: (e3) => {
        var _a;
        setFocusOpen(true);
        (_a = restProps.onFocus) == null ? void 0 : _a.call(restProps, e3);
        proxyEvent("onFocus", e3, true);
      },
      onBlur: (e3) => {
        var _a;
        setFocusOpen(false);
        (_a = restProps.onBlur) == null ? void 0 : _a.call(restProps, e3);
        proxyEvent("onBlur", e3, true);
      }
    };
    const cloneNode = import_react147.default.cloneElement(node2, passedProps);
    const open3 = (!!lockOpen || activeOpen) && mergedTipFormatter !== null;
    if (!useActiveTooltipHandle) {
      return import_react147.default.createElement(SliderTooltip_default, {
        ...tooltipProps,
        prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
        title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
        value: info.value,
        open: open3,
        placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
        key: index2,
        classNames: {
          root: `${prefixCls}-tooltip`
        },
        getPopupContainer: getTooltipPopupContainer || getPopupContainer
      }, cloneNode);
    }
    return cloneNode;
  });
  const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
    const cloneNode = import_react147.default.cloneElement(handle, {
      style: {
        ...handle.props.style,
        visibility: "hidden"
      }
    });
    return import_react147.default.createElement(SliderTooltip_default, {
      ...tooltipProps,
      prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
      title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
      open: mergedTipFormatter !== null && activeOpen,
      placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
      key: "tooltip",
      classNames: {
        root: `${prefixCls}-tooltip`
      },
      getPopupContainer: getTooltipPopupContainer || getPopupContainer,
      draggingDelete: info.draggingDelete
    }, cloneNode);
  } : void 0;
  const rootStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return (
    // @ts-ignore
    import_react147.default.createElement(es_default25, {
      ...restProps,
      classNames: mergedClassNames,
      styles: mergedStyles,
      step: restProps.step,
      range: range3,
      className: rootClassNames,
      style: rootStyle,
      disabled: mergedDisabled,
      vertical: mergedVertical,
      ref,
      prefixCls,
      handleRender,
      activeHandleRender,
      onChangeComplete: onInternalChangeComplete
    })
  );
});
if (true) {
  Slider4.displayName = "Slider";
}
var slider_default = Slider4;

// node_modules/antd/es/color-picker/components/ColorSlider.js
var GradientColorSlider = (props) => {
  const {
    prefixCls,
    colors,
    type: type5,
    color,
    range: range3 = false,
    className,
    activeIndex,
    onActive,
    onDragStart,
    onDragChange,
    onKeyDelete,
    ...restProps
  } = props;
  const sliderProps = {
    ...restProps,
    track: false
  };
  const linearCss = React390.useMemo(() => {
    const colorsStr = colors.map((c) => `${c.color} ${c.percent}%`).join(", ");
    return `linear-gradient(90deg, ${colorsStr})`;
  }, [colors]);
  const pointColor = React390.useMemo(() => {
    if (!color || !type5) {
      return null;
    }
    if (type5 === "alpha") {
      return color.toRgbString();
    }
    return `hsl(${color.toHsb().h}, 100%, 50%)`;
  }, [color, type5]);
  const onInternalDragStart = useEvent_default(onDragStart);
  const onInternalDragChange = useEvent_default(onDragChange);
  const unstableContext = React390.useMemo(() => ({
    onDragStart: onInternalDragStart,
    onDragChange: onInternalDragChange
  }), []);
  const handleRender = useEvent_default((ori, info) => {
    const {
      onFocus,
      style: style2,
      className: handleCls,
      onKeyDown: onKeyDown2
    } = ori.props;
    const mergedStyle = {
      ...style2
    };
    if (type5 === "gradient") {
      mergedStyle.background = getGradientPercentColor(colors, info.value);
    }
    return React390.cloneElement(ori, {
      onFocus: (e3) => {
        onActive == null ? void 0 : onActive(info.index);
        onFocus == null ? void 0 : onFocus(e3);
      },
      style: mergedStyle,
      className: clsx(handleCls, {
        [`${prefixCls}-slider-handle-active`]: activeIndex === info.index
      }),
      onKeyDown: (e3) => {
        if ((e3.key === "Delete" || e3.key === "Backspace") && onKeyDelete) {
          onKeyDelete(info.index);
        }
        onKeyDown2 == null ? void 0 : onKeyDown2(e3);
      }
    });
  });
  const sliderContext = React390.useMemo(() => ({
    direction: "ltr",
    handleRender
  }), []);
  return React390.createElement(Context_default3.Provider, {
    value: sliderContext
  }, React390.createElement(UnstableContext.Provider, {
    value: unstableContext
  }, React390.createElement(slider_default, {
    ...sliderProps,
    className: clsx(className, `${prefixCls}-slider`),
    tooltip: {
      open: false
    },
    range: {
      editable: range3,
      minCount: 2
    },
    styles: {
      rail: {
        background: linearCss
      },
      handle: pointColor ? {
        background: pointColor
      } : {}
    },
    classNames: {
      rail: `${prefixCls}-slider-rail`,
      handle: `${prefixCls}-slider-handle`
    }
  })));
};
var SingleColorSlider = (props) => {
  const {
    value,
    onChange,
    onChangeComplete
  } = props;
  const singleOnChange = (v) => onChange(v[0]);
  const singleOnChangeComplete = (v) => onChangeComplete(v[0]);
  return React390.createElement(GradientColorSlider, {
    ...props,
    value: [value],
    onChange: singleOnChange,
    onChangeComplete: singleOnChangeComplete
  });
};
var ColorSlider_default = SingleColorSlider;

// node_modules/antd/es/color-picker/components/PanelPicker/GradientColorBar.js
var React391 = __toESM(require_react());
function sortColors(colors) {
  return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);
}
var GradientColorBar = (props) => {
  const {
    prefixCls,
    mode,
    onChange,
    onChangeComplete,
    onActive,
    activeIndex,
    onGradientDragging,
    colors
  } = props;
  const isGradient = mode === "gradient";
  const colorList = React391.useMemo(() => colors.map((info) => ({
    percent: info.percent,
    color: info.color.toRgbString()
  })), [colors]);
  const values = React391.useMemo(() => colorList.map((info) => info.percent), [colorList]);
  const colorsRef = React391.useRef(colorList);
  const onDragStart = ({
    rawValues,
    draggingIndex,
    draggingValue
  }) => {
    if (rawValues.length > colorList.length) {
      const newPointColor = getGradientPercentColor(colorList, draggingValue);
      const nextColors = _toConsumableArray(colorList);
      nextColors.splice(draggingIndex, 0, {
        percent: draggingValue,
        color: newPointColor
      });
      colorsRef.current = nextColors;
    } else {
      colorsRef.current = colorList;
    }
    onGradientDragging(true);
    onChange(new AggregationColor(sortColors(colorsRef.current)), true);
  };
  const onDragChange = ({
    deleteIndex,
    draggingIndex,
    draggingValue
  }) => {
    let nextColors = _toConsumableArray(colorsRef.current);
    if (deleteIndex !== -1) {
      nextColors.splice(deleteIndex, 1);
    } else {
      nextColors[draggingIndex] = {
        ...nextColors[draggingIndex],
        percent: draggingValue
      };
      nextColors = sortColors(nextColors);
    }
    onChange(new AggregationColor(nextColors), true);
  };
  const onKeyDelete = (index2) => {
    const nextColors = _toConsumableArray(colorList);
    nextColors.splice(index2, 1);
    const nextColor = new AggregationColor(nextColors);
    onChange(nextColor);
    onChangeComplete(nextColor);
  };
  const onInternalChangeComplete = (nextValues) => {
    onChangeComplete(new AggregationColor(colorList));
    if (activeIndex >= nextValues.length) {
      onActive(nextValues.length - 1);
    }
    onGradientDragging(false);
  };
  if (!isGradient) {
    return null;
  }
  return React391.createElement(GradientColorSlider, {
    min: 0,
    max: 100,
    prefixCls,
    className: `${prefixCls}-gradient-slider`,
    colors: colorList,
    color: null,
    value: values,
    range: true,
    onChangeComplete: onInternalChangeComplete,
    disabled: false,
    type: "gradient",
    // Active
    activeIndex,
    onActive,
    // Drag
    onDragStart,
    onDragChange,
    onKeyDelete
  });
};
var GradientColorBar_default = React391.memo(GradientColorBar);

// node_modules/antd/es/color-picker/components/PanelPicker/index.js
var components = {
  slider: ColorSlider_default
};
var PanelPicker = () => {
  const panelPickerContext = (0, import_react148.useContext)(PanelPickerContext);
  const {
    mode,
    onModeChange,
    modeOptions,
    prefixCls,
    allowClear,
    value,
    disabledAlpha,
    onChange,
    onClear,
    onChangeComplete,
    activeIndex,
    gradientDragging,
    ...injectProps
  } = panelPickerContext;
  const colors = import_react148.default.useMemo(() => {
    if (!value.cleared) {
      return value.getColors();
    }
    return [{
      percent: 0,
      color: new AggregationColor("")
    }, {
      percent: 100,
      color: new AggregationColor("")
    }];
  }, [value]);
  const isSingle = !value.isGradient();
  const [lockedColor, setLockedColor] = import_react148.default.useState(value);
  useLayoutEffect_default(() => {
    var _a;
    if (!isSingle) {
      setLockedColor((_a = colors[activeIndex]) == null ? void 0 : _a.color);
    }
  }, [isSingle, colors, gradientDragging, activeIndex]);
  const activeColor = import_react148.default.useMemo(() => {
    var _a;
    if (isSingle) {
      return value;
    }
    if (gradientDragging) {
      return lockedColor;
    }
    return (_a = colors[activeIndex]) == null ? void 0 : _a.color;
  }, [colors, value, activeIndex, isSingle, lockedColor, gradientDragging]);
  const [pickerColor, setPickerColor] = import_react148.default.useState(activeColor);
  const [forceSync, setForceSync] = useForceUpdate();
  const mergedPickerColor = (pickerColor == null ? void 0 : pickerColor.equals(activeColor)) ? activeColor : pickerColor;
  useLayoutEffect_default(() => {
    setPickerColor(activeColor);
  }, [forceSync, activeColor == null ? void 0 : activeColor.toHexString()]);
  const fillColor = (nextColor, info) => {
    let submitColor = generateColor2(nextColor);
    if (value.cleared) {
      const rgb = submitColor.toRgb();
      if (!rgb.r && !rgb.g && !rgb.b && info) {
        const {
          type: infoType,
          value: infoValue = 0
        } = info;
        submitColor = new AggregationColor({
          h: infoType === "hue" ? infoValue : 0,
          s: 1,
          b: 1,
          a: infoType === "alpha" ? infoValue / 100 : 1
        });
      } else {
        submitColor = genAlphaColor(submitColor);
      }
    }
    if (mode === "single") {
      return submitColor;
    }
    const nextColors = _toConsumableArray(colors);
    nextColors[activeIndex] = {
      ...nextColors[activeIndex],
      color: submitColor
    };
    return new AggregationColor(nextColors);
  };
  const onPickerChange = (colorValue, fromPicker, info) => {
    const nextColor = fillColor(colorValue, info);
    setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);
    onChange(nextColor, fromPicker);
  };
  const onInternalChangeComplete = (nextColor, info) => {
    onChangeComplete(fillColor(nextColor, info));
    setForceSync();
  };
  const onInputChange = (colorValue) => {
    onChange(fillColor(colorValue));
  };
  let operationNode = null;
  const showMode = modeOptions.length > 1;
  if (allowClear || showMode) {
    operationNode = import_react148.default.createElement("div", {
      className: `${prefixCls}-operation`
    }, showMode && import_react148.default.createElement(segmented_default, {
      size: "small",
      options: modeOptions,
      value: mode,
      onChange: onModeChange
    }), import_react148.default.createElement(ColorClear_default, {
      prefixCls,
      value,
      onChange: (clearColor) => {
        onChange(clearColor);
        onClear == null ? void 0 : onClear();
      },
      ...injectProps
    }));
  }
  return import_react148.default.createElement(import_react148.default.Fragment, null, operationNode, import_react148.default.createElement(GradientColorBar_default, {
    ...panelPickerContext,
    colors
  }), import_react148.default.createElement(es_default5, {
    prefixCls,
    value: mergedPickerColor == null ? void 0 : mergedPickerColor.toHsb(),
    disabledAlpha,
    onChange: (colorValue, info) => {
      onPickerChange(colorValue, true, info);
    },
    onChangeComplete: (colorValue, info) => {
      onInternalChangeComplete(colorValue, info);
    },
    components
  }), import_react148.default.createElement(ColorInput_default, {
    value: activeColor,
    onChange: onInputChange,
    prefixCls,
    disabledAlpha,
    ...injectProps
  }));
};
var PanelPicker_default = PanelPicker;

// node_modules/antd/es/color-picker/components/PanelPresets.js
var import_react149 = __toESM(require_react());
var PanelPresets = () => {
  const {
    prefixCls,
    value,
    presets,
    onChange
  } = (0, import_react149.useContext)(PanelPresetsContext);
  return Array.isArray(presets) ? import_react149.default.createElement(ColorPresets_default, {
    value,
    presets,
    prefixCls,
    onChange
  }) : null;
};
var PanelPresets_default = PanelPresets;

// node_modules/antd/es/color-picker/ColorPickerPanel.js
var ColorPickerPanel = (props) => {
  const {
    prefixCls,
    presets,
    panelRender,
    value,
    onChange,
    onClear,
    allowClear,
    disabledAlpha,
    mode,
    onModeChange,
    modeOptions,
    onChangeComplete,
    activeIndex,
    onActive,
    format: format3,
    onFormatChange,
    gradientDragging,
    onGradientDragging,
    disabledFormat
  } = props;
  const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
  const panelContext = import_react150.default.useMemo(() => ({
    prefixCls,
    value,
    onChange,
    onClear,
    allowClear,
    disabledAlpha,
    mode,
    onModeChange,
    modeOptions,
    onChangeComplete,
    activeIndex,
    onActive,
    format: format3,
    onFormatChange,
    gradientDragging,
    onGradientDragging,
    disabledFormat
  }), [prefixCls, value, onChange, onClear, allowClear, disabledAlpha, mode, onModeChange, modeOptions, onChangeComplete, activeIndex, onActive, format3, onFormatChange, gradientDragging, onGradientDragging, disabledFormat]);
  const presetContext = import_react150.default.useMemo(() => ({
    prefixCls,
    value,
    presets,
    onChange
  }), [prefixCls, value, presets, onChange]);
  const innerPanel = import_react150.default.createElement("div", {
    className: `${colorPickerPanelPrefixCls}-content`
  }, import_react150.default.createElement(PanelPicker_default, null), Array.isArray(presets) && import_react150.default.createElement(divider_default, null), import_react150.default.createElement(PanelPresets_default, null));
  return import_react150.default.createElement(PanelPickerContext.Provider, {
    value: panelContext
  }, import_react150.default.createElement(PanelPresetsContext.Provider, {
    value: presetContext
  }, import_react150.default.createElement("div", {
    className: colorPickerPanelPrefixCls
  }, typeof panelRender === "function" ? panelRender(innerPanel, {
    components: {
      Picker: PanelPicker_default,
      Presets: PanelPresets_default
    }
  }) : innerPanel)));
};
if (true) {
  ColorPickerPanel.displayName = "ColorPickerPanel";
}
var ColorPickerPanel_default = ColorPickerPanel;

// node_modules/antd/es/color-picker/components/ColorTrigger.js
var import_react151 = __toESM(require_react());
var ColorTrigger = (0, import_react151.forwardRef)((props, ref) => {
  const {
    color,
    prefixCls,
    open: open3,
    disabled,
    format: format3,
    className,
    showText,
    activeIndex,
    ...rest
  } = props;
  const colorTriggerPrefixCls = `${prefixCls}-trigger`;
  const colorTextPrefixCls = `${colorTriggerPrefixCls}-text`;
  const colorTextCellPrefixCls = `${colorTextPrefixCls}-cell`;
  const [locale6] = useLocale_default("ColorPicker");
  const desc = import_react151.default.useMemo(() => {
    if (!showText) {
      return "";
    }
    if (typeof showText === "function") {
      return showText(color);
    }
    if (color.cleared) {
      return locale6.transparent;
    }
    if (color.isGradient()) {
      return color.getColors().map((c, index2) => {
        const inactive = activeIndex !== -1 && activeIndex !== index2;
        return import_react151.default.createElement("span", {
          key: index2,
          className: clsx(colorTextCellPrefixCls, inactive && `${colorTextCellPrefixCls}-inactive`)
        }, c.color.toRgbString(), " ", c.percent, "%");
      });
    }
    const hexString = color.toHexString().toUpperCase();
    const alpha = getColorAlpha(color);
    switch (format3) {
      case "rgb":
        return color.toRgbString();
      case "hsb":
        return color.toHsbString();
      default:
        return alpha < 100 ? `${hexString.slice(0, 7)},${alpha}%` : hexString;
    }
  }, [color, format3, showText, activeIndex, locale6.transparent, colorTextCellPrefixCls]);
  const containerNode = (0, import_react151.useMemo)(() => color.cleared ? import_react151.default.createElement(ColorClear_default, {
    prefixCls
  }) : import_react151.default.createElement(ColorBlock_default, {
    prefixCls,
    color: color.toCssString()
  }), [color, prefixCls]);
  return import_react151.default.createElement("div", {
    ref,
    className: clsx(colorTriggerPrefixCls, className, {
      [`${colorTriggerPrefixCls}-active`]: open3,
      [`${colorTriggerPrefixCls}-disabled`]: disabled
    }),
    ...pickAttrs(rest)
  }, containerNode, showText && import_react151.default.createElement("div", {
    className: colorTextPrefixCls
  }, desc));
});
var ColorTrigger_default = ColorTrigger;

// node_modules/antd/es/color-picker/hooks/useModeColor.js
var React396 = __toESM(require_react());
function useModeColor(defaultValue, value, mode) {
  const [locale6] = useLocale_default("ColorPicker");
  const [mergedColor, setMergedColor] = useControlledState(defaultValue, value);
  const [modeState, setModeState] = React396.useState("single");
  const [modeOptionList, modeSet] = React396.useMemo(() => {
    const list = (Array.isArray(mode) ? mode : [mode]).filter((m) => m);
    if (!list.length) {
      list.push("single");
    }
    const modes = new Set(list);
    const optionList = [];
    const pushOption = (modeType, localeTxt) => {
      if (modes.has(modeType)) {
        optionList.push({
          label: localeTxt,
          value: modeType
        });
      }
    };
    pushOption("single", locale6.singleColor);
    pushOption("gradient", locale6.gradientColor);
    return [optionList, modes];
  }, [mode, locale6.singleColor, locale6.gradientColor]);
  const [cacheColor, setCacheColor] = React396.useState(null);
  const setColor = useEvent_default((nextColor) => {
    setCacheColor(nextColor);
    setMergedColor(nextColor);
  });
  const postColor = React396.useMemo(() => {
    const colorObj = generateColor2(mergedColor || "");
    return colorObj.equals(cacheColor) ? cacheColor : colorObj;
  }, [mergedColor, cacheColor]);
  const postMode = React396.useMemo(() => {
    var _a;
    if (modeSet.has(modeState)) {
      return modeState;
    }
    return (_a = modeOptionList[0]) == null ? void 0 : _a.value;
  }, [modeSet, modeState, modeOptionList]);
  React396.useEffect(() => {
    setModeState(postColor.isGradient() ? "gradient" : "single");
  }, [postColor]);
  return [postColor, setColor, postMode, setModeState, modeOptionList];
}

// node_modules/antd/es/color-picker/style/color-block.js
var getTransBg = (size, colorFill) => ({
  backgroundImage: `conic-gradient(${colorFill} 25%, transparent 25% 50%, ${colorFill} 50% 75%, transparent 75% 100%)`,
  backgroundSize: `${size} ${size}`
});
var genColorBlockStyle = (token2, size) => {
  const {
    componentCls,
    borderRadiusSM,
    colorPickerInsetShadow,
    lineWidth,
    colorFillSecondary
  } = token2;
  return {
    [`${componentCls}-color-block`]: {
      position: "relative",
      borderRadius: borderRadiusSM,
      width: size,
      height: size,
      boxShadow: colorPickerInsetShadow,
      flex: "none",
      ...getTransBg("50%", token2.colorFillSecondary),
      [`${componentCls}-color-block-inner`]: {
        width: "100%",
        height: "100%",
        boxShadow: `inset 0 0 0 ${unit(lineWidth)} ${colorFillSecondary}`,
        borderRadius: "inherit"
      }
    }
  };
};
var color_block_default = genColorBlockStyle;

// node_modules/antd/es/color-picker/style/input.js
var genInputStyle2 = (token2) => {
  const {
    componentCls,
    antCls,
    fontSizeSM,
    lineHeightSM,
    colorPickerAlphaInputWidth,
    marginXXS,
    paddingXXS,
    controlHeightSM,
    marginXS,
    fontSizeIcon,
    paddingXS,
    colorTextPlaceholder,
    colorPickerInputNumberHandleWidth,
    lineWidth
  } = token2;
  return {
    [`${componentCls}-input-container`]: {
      display: "flex",
      [`${componentCls}-steppers${antCls}-input-number`]: {
        fontSize: fontSizeSM,
        lineHeight: lineHeightSM,
        padding: 0,
        [`${antCls}-input-number-input`]: {
          paddingInlineStart: paddingXXS,
          paddingInlineEnd: 0
        },
        [`${antCls}-input-number-handler-wrap`]: {
          width: colorPickerInputNumberHandleWidth
        }
      },
      [`${componentCls}-steppers${componentCls}-alpha-input`]: {
        flex: `0 0 ${unit(colorPickerAlphaInputWidth)}`,
        marginInlineStart: marginXXS
      },
      [`${componentCls}-format-select${antCls}-select`]: {
        marginInlineEnd: marginXS,
        width: "auto",
        "&-single": {
          [`${antCls}-select-selector`]: {
            padding: 0,
            border: 0
          },
          [`${antCls}-select-arrow`]: {
            insetInlineEnd: 0
          },
          [`${antCls}-select-selection-item`]: {
            paddingInlineEnd: token2.calc(fontSizeIcon).add(marginXXS).equal(),
            fontSize: fontSizeSM,
            lineHeight: unit(controlHeightSM)
          },
          [`${antCls}-select-item-option-content`]: {
            fontSize: fontSizeSM,
            lineHeight: lineHeightSM
          },
          [`${antCls}-select-dropdown`]: {
            [`${antCls}-select-item`]: {
              minHeight: "auto"
            }
          }
        }
      },
      [`${componentCls}-input`]: {
        gap: marginXXS,
        alignItems: "center",
        flex: 1,
        width: 0,
        [`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
          display: "flex",
          gap: marginXXS,
          alignItems: "center"
        },
        [`${componentCls}-steppers`]: {
          flex: 1
        },
        [`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
          flex: 1,
          padding: `0 ${unit(paddingXS)}`,
          [`${antCls}-input`]: {
            fontSize: fontSizeSM,
            textTransform: "uppercase",
            lineHeight: unit(token2.calc(controlHeightSM).sub(token2.calc(lineWidth).mul(2)).equal())
          },
          [`${antCls}-input-prefix`]: {
            color: colorTextPlaceholder
          }
        }
      }
    }
  };
};
var input_default = genInputStyle2;

// node_modules/antd/es/color-picker/style/picker.js
var genPickerStyle2 = (token2) => {
  const {
    componentCls,
    controlHeightLG,
    borderRadiusSM,
    colorPickerInsetShadow,
    marginSM,
    colorBgElevated,
    colorFillSecondary,
    lineWidthBold,
    colorPickerHandlerSize
  } = token2;
  return {
    userSelect: "none",
    [`${componentCls}-select`]: {
      [`${componentCls}-palette`]: {
        minHeight: token2.calc(controlHeightLG).mul(4).equal(),
        overflow: "hidden",
        borderRadius: borderRadiusSM
      },
      [`${componentCls}-saturation`]: {
        position: "absolute",
        borderRadius: "inherit",
        boxShadow: colorPickerInsetShadow,
        inset: 0
      },
      marginBottom: marginSM
    },
    // ======================== Panel =========================
    [`${componentCls}-handler`]: {
      width: colorPickerHandlerSize,
      height: colorPickerHandlerSize,
      border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
      position: "relative",
      borderRadius: "50%",
      cursor: "pointer",
      boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`
    }
  };
};
var picker_default = genPickerStyle2;

// node_modules/antd/es/color-picker/style/presets.js
var genPresetsStyle = (token2) => {
  const {
    componentCls,
    antCls,
    colorTextQuaternary,
    paddingXXS,
    colorPickerPresetColorSize,
    fontSizeSM,
    colorText,
    lineHeightSM,
    lineWidth,
    borderRadius,
    colorFill,
    colorWhite,
    marginXXS,
    paddingXS,
    fontHeightSM
  } = token2;
  return {
    [`${componentCls}-presets`]: {
      [`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
        padding: 0,
        [`${antCls}-collapse-expand-icon`]: {
          height: fontHeightSM,
          color: colorTextQuaternary,
          paddingInlineEnd: paddingXXS
        }
      },
      [`${antCls}-collapse`]: {
        display: "flex",
        flexDirection: "column",
        gap: marginXXS
      },
      [`${antCls}-collapse-item > ${antCls}-collapse-panel > ${antCls}-collapse-body`]: {
        padding: `${unit(paddingXS)} 0`
      },
      "&-label": {
        fontSize: fontSizeSM,
        color: colorText,
        lineHeight: lineHeightSM
      },
      "&-items": {
        display: "flex",
        flexWrap: "wrap",
        gap: token2.calc(marginXXS).mul(1.5).equal(),
        [`${componentCls}-presets-color`]: {
          position: "relative",
          cursor: "pointer",
          width: colorPickerPresetColorSize,
          height: colorPickerPresetColorSize,
          "&::before": {
            content: '""',
            pointerEvents: "none",
            width: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            height: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
            position: "absolute",
            top: token2.calc(lineWidth).mul(-2).equal(),
            insetInlineStart: token2.calc(lineWidth).mul(-2).equal(),
            borderRadius,
            border: `${unit(lineWidth)} solid transparent`,
            transition: `border-color ${token2.motionDurationMid} ${token2.motionEaseInBack}`
          },
          "&:hover::before": {
            borderColor: colorFill
          },
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: token2.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
            height: token2.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
            border: `${unit(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          },
          [`&${componentCls}-presets-color-checked`]: {
            "&::after": {
              opacity: 1,
              borderColor: colorWhite,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `transform ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            },
            [`&${componentCls}-presets-color-bright`]: {
              "&::after": {
                borderColor: "rgba(0, 0, 0, 0.45)"
              }
            }
          }
        }
      },
      "&-empty": {
        fontSize: fontSizeSM,
        color: colorTextQuaternary
      }
    }
  };
};
var presets_default = genPresetsStyle;

// node_modules/antd/es/color-picker/style/slider.js
var genSliderStyle = (token2) => {
  const {
    componentCls,
    colorPickerInsetShadow,
    colorBgElevated,
    colorFillSecondary,
    lineWidthBold,
    colorPickerHandlerSizeSM,
    colorPickerSliderHeight,
    marginSM,
    marginXS
  } = token2;
  const handleInnerSize = token2.calc(colorPickerHandlerSizeSM).sub(token2.calc(lineWidthBold).mul(2).equal()).equal();
  const handleHoverSize = token2.calc(colorPickerHandlerSizeSM).add(token2.calc(lineWidthBold).mul(2).equal()).equal();
  const activeHandleStyle = {
    "&:after": {
      transform: "scale(1)",
      boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${token2.colorPrimaryActive}`
    }
  };
  return {
    // ======================== Slider ========================
    [`${componentCls}-slider`]: [getTransBg(unit(colorPickerSliderHeight), token2.colorFillSecondary), {
      margin: 0,
      padding: 0,
      height: colorPickerSliderHeight,
      borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
      "&-rail": {
        height: colorPickerSliderHeight,
        borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
        boxShadow: colorPickerInsetShadow
      },
      [`& ${componentCls}-slider-handle`]: {
        width: handleInnerSize,
        height: handleInnerSize,
        top: 0,
        borderRadius: "100%",
        "&:before": {
          display: "block",
          position: "absolute",
          background: "transparent",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          top: "50%",
          transform: "translate(-50%, -50%)",
          width: handleHoverSize,
          height: handleHoverSize,
          borderRadius: "100%"
        },
        "&:after": {
          width: colorPickerHandlerSizeSM,
          height: colorPickerHandlerSizeSM,
          border: `${unit(lineWidthBold)} solid ${colorBgElevated}`,
          boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
          outline: "none",
          insetInlineStart: token2.calc(lineWidthBold).mul(-1).equal(),
          top: token2.calc(lineWidthBold).mul(-1).equal(),
          background: "transparent",
          transition: "none"
        },
        "&:focus": activeHandleStyle
      }
    }],
    // ======================== Layout ========================
    [`${componentCls}-slider-container`]: {
      display: "flex",
      gap: marginSM,
      marginBottom: marginSM,
      // Group
      [`${componentCls}-slider-group`]: {
        flex: 1,
        flexDirection: "column",
        justifyContent: "space-between",
        display: "flex",
        "&-disabled-alpha": {
          justifyContent: "center"
        }
      }
    },
    [`${componentCls}-gradient-slider`]: {
      marginBottom: marginXS,
      [`& ${componentCls}-slider-handle`]: {
        "&:after": {
          transform: "scale(0.8)"
        },
        "&-active, &:focus": activeHandleStyle
      }
    }
  };
};
var slider_default2 = genSliderStyle;

// node_modules/antd/es/color-picker/style/index.js
var genActiveStyle = (token2, borderColor, outlineColor) => ({
  borderInlineEndWidth: token2.lineWidth,
  borderColor,
  boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${outlineColor}`,
  outline: 0
});
var genRtlStyle2 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    "&-rtl": {
      [`${componentCls}-presets-color`]: {
        "&::after": {
          direction: "ltr"
        }
      },
      [`${componentCls}-clear`]: {
        "&::after": {
          direction: "ltr"
        }
      }
    }
  };
};
var genClearStyle = (token2, size, extraStyle) => {
  const {
    componentCls,
    borderRadiusSM,
    lineWidth,
    colorSplit,
    colorBorder,
    red6
  } = token2;
  return {
    [`${componentCls}-clear`]: {
      width: size,
      height: size,
      borderRadius: borderRadiusSM,
      border: `${unit(lineWidth)} solid ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      cursor: "inherit",
      transition: `all ${token2.motionDurationFast}`,
      ...extraStyle,
      "&::after": {
        content: '""',
        position: "absolute",
        insetInlineEnd: token2.calc(lineWidth).mul(-1).equal(),
        top: token2.calc(lineWidth).mul(-1).equal(),
        display: "block",
        width: 40,
        // maximum
        height: 2,
        // fixed
        transformOrigin: `calc(100% - 1px) 1px`,
        transform: "rotate(-45deg)",
        backgroundColor: red6
      },
      "&:hover": {
        borderColor: colorBorder
      }
    }
  };
};
var genStatusStyle2 = (token2) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorHover,
    colorWarningHover,
    colorErrorOutline,
    colorWarningOutline
  } = token2;
  return {
    [`&${componentCls}-status-error`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorError, colorErrorOutline)
      }
    },
    [`&${componentCls}-status-warning`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningHover
      },
      [`&${componentCls}-trigger-active`]: {
        ...genActiveStyle(token2, colorWarning, colorWarningOutline)
      }
    }
  };
};
var genSizeStyle2 = (token2) => {
  const {
    componentCls,
    controlHeightLG,
    controlHeightSM,
    controlHeight,
    controlHeightXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusXS,
    borderRadiusLG,
    fontSizeLG
  } = token2;
  return {
    [`&${componentCls}-lg`]: {
      minWidth: controlHeightLG,
      minHeight: controlHeightLG,
      borderRadius: borderRadiusLG,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeight,
        height: controlHeight,
        borderRadius
      },
      [`${componentCls}-trigger-text`]: {
        fontSize: fontSizeLG
      }
    },
    [`&${componentCls}-sm`]: {
      minWidth: controlHeightSM,
      minHeight: controlHeightSM,
      borderRadius: borderRadiusSM,
      [`${componentCls}-color-block, ${componentCls}-clear`]: {
        width: controlHeightXS,
        height: controlHeightXS,
        borderRadius: borderRadiusXS
      },
      [`${componentCls}-trigger-text`]: {
        lineHeight: unit(controlHeightXS)
      }
    }
  };
};
var genColorPickerStyle = (token2) => {
  const {
    antCls,
    componentCls,
    colorPickerWidth,
    colorPrimary,
    motionDurationMid,
    colorBgElevated,
    colorTextDisabled,
    colorText,
    colorBgContainerDisabled,
    borderRadius,
    marginXS,
    marginSM,
    controlHeight,
    controlHeightSM,
    colorBgTextActive,
    colorPickerPresetColorSize,
    colorPickerPreviewSize,
    lineWidth,
    colorBorder,
    paddingXXS,
    fontSize,
    colorPrimaryHover,
    controlOutline
  } = token2;
  return [{
    [componentCls]: {
      [`${componentCls}-inner`]: {
        "&-content": {
          display: "flex",
          flexDirection: "column",
          width: colorPickerWidth,
          [`& > ${antCls}-divider`]: {
            margin: `${unit(marginSM)} 0 ${unit(marginXS)}`
          }
        },
        [`${componentCls}-panel`]: {
          ...picker_default(token2)
        },
        ...slider_default2(token2),
        ...color_block_default(token2, colorPickerPreviewSize),
        ...input_default(token2),
        ...presets_default(token2),
        ...genClearStyle(token2, colorPickerPresetColorSize, {
          marginInlineStart: "auto"
        }),
        // Operation bar
        [`${componentCls}-operation`]: {
          display: "flex",
          justifyContent: "space-between",
          marginBottom: marginXS
        }
      },
      "&-trigger": {
        minWidth: controlHeight,
        minHeight: controlHeight,
        borderRadius,
        border: `${unit(lineWidth)} solid ${colorBorder}`,
        cursor: "pointer",
        display: "inline-flex",
        alignItems: "flex-start",
        justifyContent: "center",
        transition: `all ${motionDurationMid}`,
        background: colorBgElevated,
        padding: token2.calc(paddingXXS).sub(lineWidth).equal(),
        [`${componentCls}-trigger-text`]: {
          marginInlineStart: marginXS,
          marginInlineEnd: token2.calc(marginXS).sub(token2.calc(paddingXXS).sub(lineWidth)).equal(),
          fontSize,
          color: colorText,
          alignSelf: "center",
          "&-cell": {
            "&:not(:last-child):after": {
              content: '", "'
            },
            "&-inactive": {
              color: colorTextDisabled
            }
          }
        },
        "&:hover": {
          borderColor: colorPrimaryHover
        },
        [`&${componentCls}-trigger-active`]: {
          ...genActiveStyle(token2, colorPrimary, controlOutline)
        },
        "&-disabled": {
          color: colorTextDisabled,
          background: colorBgContainerDisabled,
          cursor: "not-allowed",
          "&:hover": {
            borderColor: colorBgTextActive
          },
          [`${componentCls}-trigger-text`]: {
            color: colorTextDisabled
          }
        },
        ...genClearStyle(token2, controlHeightSM),
        ...color_block_default(token2, controlHeightSM),
        ...genStatusStyle2(token2),
        ...genSizeStyle2(token2)
      },
      ...genRtlStyle2(token2)
    }
  }, genCompactItemStyle(token2, {
    focusElCls: `${componentCls}-trigger-active`
  })];
};
var style_default36 = genStyleHooks("ColorPicker", (token2) => {
  const {
    colorTextQuaternary,
    marginSM
  } = token2;
  const colorPickerSliderHeight = 8;
  const colorPickerToken = merge2(token2, {
    colorPickerWidth: 234,
    colorPickerHandlerSize: 16,
    colorPickerHandlerSizeSM: 12,
    colorPickerAlphaInputWidth: 44,
    colorPickerInputNumberHandleWidth: 16,
    colorPickerPresetColorSize: 24,
    colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
    colorPickerSliderHeight,
    colorPickerPreviewSize: token2.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
  });
  return genColorPickerStyle(colorPickerToken);
});

// node_modules/antd/es/color-picker/ColorPicker.js
var ColorPicker2 = (props) => {
  var _a, _b;
  const {
    mode,
    value,
    defaultValue,
    format: format3,
    defaultFormat,
    allowClear = false,
    presets,
    children,
    trigger = "click",
    open: open3,
    disabled,
    placement = "bottomLeft",
    arrow = true,
    panelRender,
    showText,
    style: style2,
    className,
    size: customizeSize,
    rootClassName,
    prefixCls: customizePrefixCls,
    styles,
    classNames,
    disabledAlpha = false,
    onFormatChange,
    onChange,
    onClear,
    onOpenChange,
    onChangeComplete,
    getPopupContainer,
    autoAdjustOverflow: autoAdjustOverflow3 = true,
    destroyTooltipOnHide,
    destroyOnHidden,
    disabledFormat,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("colorPicker");
  const contextDisabled = (0, import_react152.useContext)(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const mergedProps = {
    ...props,
    trigger,
    allowClear,
    autoAdjustOverflow: autoAdjustOverflow3,
    disabledAlpha,
    arrow,
    placement,
    disabled: mergedDisabled,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const [internalPopupOpen, setPopupOpen] = useControlledState(false, open3);
  const popupOpen = !mergedDisabled && internalPopupOpen;
  const [formatValue2, setFormatValue] = useControlledState(defaultFormat, format3);
  const triggerFormatChange = (newFormat) => {
    setFormatValue(newFormat);
    if (formatValue2 !== newFormat) {
      onFormatChange == null ? void 0 : onFormatChange(newFormat);
    }
  };
  const triggerOpenChange = (visible) => {
    if (!visible || !mergedDisabled) {
      setPopupOpen(visible);
      onOpenChange == null ? void 0 : onOpenChange(visible);
    }
  };
  const [mergedColor, setColor, modeState, setModeState, modeOptions] = useModeColor(defaultValue, value, mode);
  const isAlphaColor = (0, import_react152.useMemo)(() => getColorAlpha(mergedColor) < 100, [mergedColor]);
  const [cachedGradientColor, setCachedGradientColor] = import_react152.default.useState(null);
  const onInternalChangeComplete = (color) => {
    if (onChangeComplete) {
      let changeColor = generateColor2(color);
      if (disabledAlpha && isAlphaColor) {
        changeColor = genAlphaColor(color);
      }
      onChangeComplete(changeColor);
    }
  };
  const onInternalChange = (data, changeFromPickerDrag) => {
    let color = generateColor2(data);
    if (disabledAlpha && isAlphaColor) {
      color = genAlphaColor(color);
    }
    setColor(color);
    setCachedGradientColor(null);
    if (onChange) {
      onChange(color, color.toCssString());
    }
    if (!changeFromPickerDrag) {
      onInternalChangeComplete(color);
    }
  };
  const [activeIndex, setActiveIndex] = import_react152.default.useState(0);
  const [gradientDragging, setGradientDragging] = import_react152.default.useState(false);
  const onInternalModeChange = (newMode) => {
    setModeState(newMode);
    if (newMode === "single" && mergedColor.isGradient()) {
      setActiveIndex(0);
      onInternalChange(new AggregationColor(mergedColor.getColors()[0].color));
      setCachedGradientColor(mergedColor);
    } else if (newMode === "gradient" && !mergedColor.isGradient()) {
      const baseColor = isAlphaColor ? genAlphaColor(mergedColor) : mergedColor;
      onInternalChange(new AggregationColor(cachedGradientColor || [{
        percent: 0,
        color: baseColor
      }, {
        percent: 100,
        color: baseColor
      }]));
    }
  };
  const {
    status: contextStatus
  } = import_react152.default.useContext(FormItemInputContext);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default36(prefixCls, rootCls);
  const rtlCls = {
    [`${prefixCls}-rtl`]: direction
  };
  const mergedRootCls = clsx(mergedClassNames.root, rootClassName, cssVarCls, rootCls, rtlCls);
  const mergedCls = clsx(getStatusClassNames(prefixCls, contextStatus), {
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large"
  }, compactItemClassnames, contextClassName, mergedRootCls, className, hashId);
  const mergedPopupCls = clsx(prefixCls, mergedRootCls, (_a = mergedClassNames.popup) == null ? void 0 : _a.root);
  if (true) {
    const warning5 = devUseWarning("ColorPicker");
    true ? warning5(!(disabledAlpha && isAlphaColor), "usage", "`disabledAlpha` will make the alpha to be 100% when use alpha color.") : void 0;
  }
  const popoverProps = {
    open: popupOpen,
    trigger,
    placement,
    arrow,
    rootClassName,
    getPopupContainer,
    autoAdjustOverflow: autoAdjustOverflow3,
    destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
  };
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return import_react152.default.createElement(popover_default, {
    classNames: {
      root: mergedPopupCls
    },
    styles: {
      root: (_b = mergedStyles.popup) == null ? void 0 : _b.root,
      container: styles == null ? void 0 : styles.popupOverlayInner
    },
    onOpenChange: triggerOpenChange,
    content: import_react152.default.createElement(ContextIsolator_default, {
      form: true
    }, import_react152.default.createElement(ColorPickerPanel_default, {
      mode: modeState,
      onModeChange: onInternalModeChange,
      modeOptions,
      prefixCls,
      value: mergedColor,
      allowClear,
      disabled: mergedDisabled,
      disabledAlpha,
      presets,
      panelRender,
      format: formatValue2,
      onFormatChange: triggerFormatChange,
      onChange: onInternalChange,
      onChangeComplete: onInternalChangeComplete,
      onClear,
      activeIndex,
      onActive: setActiveIndex,
      gradientDragging,
      onGradientDragging: setGradientDragging,
      disabledFormat
    })),
    ...popoverProps
  }, children || import_react152.default.createElement(ColorTrigger_default, {
    activeIndex: popupOpen ? activeIndex : -1,
    open: popupOpen,
    className: mergedCls,
    style: mergedStyle,
    prefixCls,
    disabled: mergedDisabled,
    showText,
    format: formatValue2,
    ...rest,
    color: mergedColor
  }));
};
if (true) {
  ColorPicker2.displayName = "ColorPicker";
}
var PurePanel9 = PurePanel_default3(
  ColorPicker2,
  void 0,
  (props) => ({
    ...props,
    placement: "bottom",
    autoAdjustOverflow: false
  }),
  "color-picker",
  /* istanbul ignore next */
  (prefixCls) => prefixCls
);
ColorPicker2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel9;
var ColorPicker_default2 = ColorPicker2;

// node_modules/antd/es/color-picker/index.js
var color_picker_default = ColorPicker_default2;

// node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var React402 = __toESM(require_react());
var import_react155 = __toESM(require_react());

// node_modules/antd/es/date-picker/hooks/useMergedPickerSemantic.js
var React398 = __toESM(require_react());
var useMergedPickerSemantic = (pickerType, classNames, styles, popupClassName, popupStyle, mergedProps) => {
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig(pickerType);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React398.useMemo(() => {
    var _a, _b;
    const filledClassNames = {
      ...mergedClassNames,
      popup: {
        ...mergedClassNames.popup,
        root: clsx((_a = mergedClassNames.popup) == null ? void 0 : _a.root, popupClassName)
      }
    };
    const filledStyles = {
      ...mergedStyles,
      popup: {
        ...mergedStyles.popup,
        root: {
          ...(_b = mergedStyles.popup) == null ? void 0 : _b.root,
          ...popupStyle
        }
      }
    };
    return [filledClassNames, filledStyles];
  }, [mergedClassNames, mergedStyles, popupClassName, popupStyle]);
};
var useMergedPickerSemantic_default = useMergedPickerSemantic;

// node_modules/antd/es/date-picker/util.js
var React399 = __toESM(require_react());
function getPlaceholder(locale6, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale6.lang.yearPlaceholder) {
    return locale6.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale6.lang.quarterPlaceholder) {
    return locale6.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale6.lang.monthPlaceholder) {
    return locale6.lang.monthPlaceholder;
  }
  if (picker === "week" && locale6.lang.weekPlaceholder) {
    return locale6.lang.weekPlaceholder;
  }
  if (picker === "time" && locale6.timePickerLocale.placeholder) {
    return locale6.timePickerLocale.placeholder;
  }
  return locale6.lang.placeholder;
}
function getRangePlaceholder(locale6, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale6.lang.yearPlaceholder) {
    return locale6.lang.rangeYearPlaceholder;
  }
  if (picker === "quarter" && locale6.lang.quarterPlaceholder) {
    return locale6.lang.rangeQuarterPlaceholder;
  }
  if (picker === "month" && locale6.lang.monthPlaceholder) {
    return locale6.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale6.lang.weekPlaceholder) {
    return locale6.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale6.timePickerLocale.placeholder) {
    return locale6.timePickerLocale.rangePlaceholder;
  }
  return locale6.lang.rangePlaceholder;
}
function useIcons2(props, prefixCls) {
  const {
    allowClear = true
  } = props;
  const {
    clearIcon,
    removeIcon
  } = useIcons({
    ...props,
    prefixCls,
    componentName: "DatePicker"
  });
  const mergedAllowClear = React399.useMemo(() => {
    if (allowClear === false) {
      return false;
    }
    const allowClearConfig = allowClear === true ? {} : allowClear;
    return {
      clearIcon,
      ...allowClearConfig
    };
  }, [allowClear, clearIcon]);
  return [mergedAllowClear, removeIcon];
}

// node_modules/antd/es/date-picker/generatePicker/constant.js
var [WEEK, WEEKPICKER] = ["week", "WeekPicker"];
var [MONTH, MONTHPICKER] = ["month", "MonthPicker"];
var [YEAR, YEARPICKER] = ["year", "YearPicker"];
var [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"];
var [TIME, TIMEPICKER] = ["time", "TimePicker"];

// node_modules/antd/es/date-picker/generatePicker/SuffixIcon.js
var import_react153 = __toESM(require_react());
var SuffixIcon = ({
  picker,
  hasFeedback,
  feedbackIcon,
  suffixIcon
}) => {
  if (suffixIcon === null || suffixIcon === false) {
    return null;
  }
  if (suffixIcon === true || suffixIcon === void 0) {
    return import_react153.default.createElement(import_react153.default.Fragment, null, picker === TIME ? import_react153.default.createElement(ClockCircleOutlined_default, null) : import_react153.default.createElement(CalendarOutlined_default, null), hasFeedback && feedbackIcon);
  }
  return suffixIcon;
};
var SuffixIcon_default = SuffixIcon;

// node_modules/antd/es/date-picker/generatePicker/useComponents.js
var import_react154 = __toESM(require_react());

// node_modules/antd/es/date-picker/PickerButton.js
var React401 = __toESM(require_react());
var PickerButton = (props) => React401.createElement(Button_default, {
  size: "small",
  type: "primary",
  ...props
});
var PickerButton_default = PickerButton;

// node_modules/antd/es/date-picker/generatePicker/useComponents.js
function useComponents2(components2) {
  return (0, import_react154.useMemo)(() => ({
    button: PickerButton_default,
    ...components2
  }), [components2]);
}

// node_modules/antd/es/date-picker/generatePicker/generateRangePicker.js
var generateRangePicker = (generateConfig2) => {
  const RangePicker3 = (0, import_react155.forwardRef)((props, ref) => {
    var _a, _b;
    const {
      prefixCls: customizePrefixCls,
      getPopupContainer: customGetPopupContainer,
      components: components2,
      className,
      style: style2,
      classNames,
      styles,
      placement,
      size: customizeSize,
      disabled: customDisabled,
      bordered = true,
      placeholder,
      status: customStatus,
      variant: customVariant,
      picker,
      dropdownClassName,
      popupClassName,
      popupStyle,
      rootClassName,
      suffixIcon,
      ...restProps
    } = props;
    const pickerType = picker === TIME ? "timePicker" : "datePicker";
    if (true) {
      const warning5 = devUseWarning("DatePicker.RangePicker");
      const deprecatedProps = {
        dropdownClassName: "classNames.popup.root",
        popupClassName: "classNames.popup.root",
        popupStyle: "styles.popup.root",
        bordered: "variant",
        onSelect: "onCalendarChange"
      };
      Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
        warning5.deprecated(!(oldProp in props), oldProp, newProp);
      });
    }
    const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle);
    const innerRef = React402.useRef(null);
    const {
      getPrefixCls,
      direction,
      getPopupContainer,
      rangePicker
    } = (0, import_react155.useContext)(ConfigContext);
    const prefixCls = getPrefixCls("picker", customizePrefixCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const rootPrefixCls = getPrefixCls();
    const [variant, enableVariantCls] = useVariants_default("rangePicker", customVariant, bordered);
    const rootCls = useCSSVarCls_default(prefixCls);
    const [hashId, cssVarCls] = style_default25(prefixCls, rootCls);
    const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
    const [mergedAllowClear] = useIcons2(props, prefixCls);
    const mergedComponents = useComponents2(components2);
    const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
    const disabled = React402.useContext(DisabledContext_default);
    const mergedDisabled = customDisabled ?? disabled;
    const formItemContext = (0, import_react155.useContext)(FormItemInputContext);
    const {
      hasFeedback,
      status: contextStatus,
      feedbackIcon
    } = formItemContext;
    const mergedSuffixIcon = React402.createElement(SuffixIcon_default, {
      picker,
      hasFeedback,
      feedbackIcon,
      suffixIcon
    });
    (0, import_react155.useImperativeHandle)(ref, () => innerRef.current);
    const [contextLocale] = useLocale_default("Calendar", en_US_default4);
    const locale6 = {
      ...contextLocale,
      ...props.locale
    };
    const [zIndex] = useZIndex("DatePicker", (_b = (_a = mergedStyles == null ? void 0 : mergedStyles.popup) == null ? void 0 : _a.root) == null ? void 0 : _b.zIndex);
    return React402.createElement(ContextIsolator_default, {
      space: true
    }, React402.createElement(RangePicker_default, {
      separator: React402.createElement("span", {
        "aria-label": "to",
        className: `${prefixCls}-separator`
      }, React402.createElement(SwapRightOutlined_default, null)),
      disabled: mergedDisabled,
      ref: innerRef,
      placement,
      placeholder: getRangePlaceholder(locale6, picker, placeholder),
      suffixIcon: mergedSuffixIcon,
      prevIcon: React402.createElement("span", {
        className: `${prefixCls}-prev-icon`
      }),
      nextIcon: React402.createElement("span", {
        className: `${prefixCls}-next-icon`
      }),
      superPrevIcon: React402.createElement("span", {
        className: `${prefixCls}-super-prev-icon`
      }),
      superNextIcon: React402.createElement("span", {
        className: `${prefixCls}-super-next-icon`
      }),
      transitionName: `${rootPrefixCls}-slide-up`,
      picker,
      ...restProps,
      locale: locale6.lang,
      getPopupContainer: customGetPopupContainer || getPopupContainer,
      generateConfig: generateConfig2,
      components: mergedComponents,
      direction,
      // Style
      prefixCls,
      rootClassName: mergedRootClassName,
      className: clsx({
        [`${prefixCls}-${mergedSize}`]: mergedSize,
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, className, rangePicker == null ? void 0 : rangePicker.className),
      style: {
        ...rangePicker == null ? void 0 : rangePicker.style,
        ...style2
      },
      // Semantic Style
      classNames: mergedClassNames,
      styles: {
        ...mergedStyles,
        popup: {
          ...mergedStyles.popup,
          root: {
            ...mergedStyles.popup.root,
            zIndex
          }
        }
      },
      allowClear: mergedAllowClear
    }));
  });
  if (true) {
    RangePicker3.displayName = "RangePicker";
  }
  return RangePicker3;
};
var generateRangePicker_default = generateRangePicker;

// node_modules/antd/es/date-picker/generatePicker/generateSinglePicker.js
var React403 = __toESM(require_react());
var import_react156 = __toESM(require_react());
var generatePicker = (generateConfig2) => {
  const getPicker = (picker, displayName) => {
    const pickerType = displayName === TIMEPICKER ? "timePicker" : "datePicker";
    const Picker3 = (0, import_react156.forwardRef)((props, ref) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        getPopupContainer: customizeGetPopupContainer,
        components: components2,
        style: style2,
        className,
        size: customizeSize,
        bordered,
        placement,
        placeholder,
        disabled: customDisabled,
        status: customStatus,
        variant: customVariant,
        onCalendarChange,
        classNames,
        styles,
        dropdownClassName,
        popupClassName,
        popupStyle,
        rootClassName,
        suffixIcon,
        ...restProps
      } = props;
      if (true) {
        const warning5 = devUseWarning(displayName || "DatePicker");
        true ? warning5(picker !== "quarter", "deprecated", `DatePicker.${displayName} is legacy usage. Please use DatePicker[picker='${picker}'] directly.`) : void 0;
        const deprecatedProps = {
          dropdownClassName: "classNames.popup.root",
          popupClassName: "classNames.popup.root",
          popupStyle: "styles.popup.root",
          bordered: "variant",
          onSelect: "onCalendarChange"
        };
        Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
          warning5.deprecated(!(oldProp in props), oldProp, newProp);
        });
      }
      const {
        getPrefixCls,
        direction,
        getPopupContainer,
        // Consume different styles according to different names
        [pickerType]: contextPickerConfig
      } = (0, import_react156.useContext)(ConfigContext);
      const prefixCls = getPrefixCls("picker", customizePrefixCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
      const disabled = React403.useContext(DisabledContext_default);
      const mergedDisabled = customDisabled ?? disabled;
      const mergedProps = {
        ...props,
        size: mergedSize,
        disabled: mergedDisabled,
        status: customStatus,
        variant: customVariant
      };
      const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default(pickerType, classNames, styles, popupClassName || dropdownClassName, popupStyle, mergedProps);
      const innerRef = React403.useRef(null);
      const [variant, enableVariantCls] = useVariants_default("datePicker", customVariant, bordered);
      const rootCls = useCSSVarCls_default(prefixCls);
      const [hashId, cssVarCls] = style_default25(prefixCls, rootCls);
      const mergedRootClassName = clsx(hashId, cssVarCls, rootCls, rootClassName);
      (0, import_react156.useImperativeHandle)(ref, () => innerRef.current);
      const additionalProps = {
        showToday: true
      };
      const mergedPicker = picker || props.picker;
      const rootPrefixCls = getPrefixCls();
      const {
        onSelect,
        multiple
      } = restProps;
      const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
      const onInternalCalendarChange = (date4, dateStr, info) => {
        onCalendarChange == null ? void 0 : onCalendarChange(date4, dateStr, info);
        if (hasLegacyOnSelect) {
          onSelect(date4);
        }
      };
      const [mergedAllowClear, removeIcon] = useIcons2(props, prefixCls);
      const mergedComponents = useComponents2(components2);
      const formItemContext = (0, import_react156.useContext)(FormItemInputContext);
      const {
        hasFeedback,
        status: contextStatus,
        feedbackIcon
      } = formItemContext;
      const mergedSuffixIcon = React403.createElement(SuffixIcon_default, {
        picker: mergedPicker,
        hasFeedback,
        feedbackIcon,
        suffixIcon
      });
      const [contextLocale] = useLocale_default("DatePicker", en_US_default4);
      const locale6 = {
        ...contextLocale,
        ...props.locale
      };
      const [zIndex] = useZIndex("DatePicker", (_b = (_a = mergedStyles == null ? void 0 : mergedStyles.popup) == null ? void 0 : _a.root) == null ? void 0 : _b.zIndex);
      return React403.createElement(ContextIsolator_default, {
        space: true
      }, React403.createElement(es_default16, {
        ref: innerRef,
        placeholder: getPlaceholder(locale6, mergedPicker, placeholder),
        suffixIcon: mergedSuffixIcon,
        placement,
        prevIcon: React403.createElement("span", {
          className: `${prefixCls}-prev-icon`
        }),
        nextIcon: React403.createElement("span", {
          className: `${prefixCls}-next-icon`
        }),
        superPrevIcon: React403.createElement("span", {
          className: `${prefixCls}-super-prev-icon`
        }),
        superNextIcon: React403.createElement("span", {
          className: `${prefixCls}-super-next-icon`
        }),
        transitionName: `${rootPrefixCls}-slide-up`,
        picker,
        onCalendarChange: onInternalCalendarChange,
        ...additionalProps,
        ...restProps,
        locale: locale6.lang,
        getPopupContainer: customizeGetPopupContainer || getPopupContainer,
        generateConfig: generateConfig2,
        components: mergedComponents,
        direction,
        disabled: mergedDisabled,
        // Style
        prefixCls,
        rootClassName: mergedRootClassName,
        className: clsx({
          [`${prefixCls}-${mergedSize}`]: mergedSize,
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), compactItemClassnames, contextPickerConfig == null ? void 0 : contextPickerConfig.className, className),
        style: {
          ...contextPickerConfig == null ? void 0 : contextPickerConfig.style,
          ...style2
        },
        // Semantic Style
        classNames: mergedClassNames,
        styles: {
          ...mergedStyles,
          popup: {
            ...mergedStyles.popup,
            root: {
              ...mergedStyles.popup.root,
              zIndex
            }
          }
        },
        allowClear: mergedAllowClear,
        removeIcon
      }));
    });
    if (displayName) {
      Picker3.displayName = displayName;
    }
    return Picker3;
  };
  const DatePicker2 = getPicker();
  const WeekPicker = getPicker(WEEK, WEEKPICKER);
  const MonthPicker = getPicker(MONTH, MONTHPICKER);
  const YearPicker = getPicker(YEAR, YEARPICKER);
  const QuarterPicker = getPicker(QUARTER, QUARTERPICKER);
  const TimePicker2 = getPicker(TIME, TIMEPICKER);
  return {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  };
};
var generateSinglePicker_default = generatePicker;

// node_modules/antd/es/date-picker/generatePicker/index.js
var generatePicker2 = (generateConfig2) => {
  const {
    DatePicker: DatePicker2,
    WeekPicker,
    MonthPicker,
    YearPicker,
    TimePicker: TimePicker2,
    QuarterPicker
  } = generateSinglePicker_default(generateConfig2);
  const RangePicker3 = generateRangePicker_default(generateConfig2);
  const MergedDatePicker = DatePicker2;
  MergedDatePicker.WeekPicker = WeekPicker;
  MergedDatePicker.MonthPicker = MonthPicker;
  MergedDatePicker.YearPicker = YearPicker;
  MergedDatePicker.RangePicker = RangePicker3;
  MergedDatePicker.TimePicker = TimePicker2;
  MergedDatePicker.QuarterPicker = QuarterPicker;
  if (true) {
    MergedDatePicker.displayName = "DatePicker";
  }
  return MergedDatePicker;
};
var generatePicker_default = generatePicker2;

// node_modules/antd/es/date-picker/index.js
var DatePicker = generatePicker_default(dayjs_default);
var PurePanel10 = PurePanel_default3(DatePicker, "popupAlign", void 0, "picker");
DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel10;
var PureRangePanel = PurePanel_default3(DatePicker.RangePicker, "popupAlign", void 0, "picker");
DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
DatePicker.generatePicker = generatePicker_default;
var date_picker_default = DatePicker;

// node_modules/antd/es/descriptions/index.js
var React408 = __toESM(require_react());

// node_modules/antd/es/descriptions/constant.js
var DEFAULT_COLUMN_MAP = {
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
var constant_default = DEFAULT_COLUMN_MAP;

// node_modules/antd/es/descriptions/DescriptionsContext.js
var import_react157 = __toESM(require_react());
var DescriptionsContext = import_react157.default.createContext(null);
var DescriptionsContext_default = DescriptionsContext;

// node_modules/antd/es/descriptions/hooks/useItems.js
var React405 = __toESM(require_react());
var transChildren2Items = (childNodes) => toArray(childNodes).map((node2) => ({
  ...node2 == null ? void 0 : node2.props,
  key: node2.key
}));
function useItems3(screens, items, children) {
  const mergedItems = React405.useMemo(() => (
    // Take `items` first or convert `children` into items
    items || transChildren2Items(children)
  ), [items, children]);
  const responsiveItems = React405.useMemo(() => mergedItems.map(({
    span,
    ...restItem
  }) => {
    if (span === "filled") {
      return {
        ...restItem,
        filled: true
      };
    }
    return {
      ...restItem,
      span: typeof span === "number" ? span : matchScreen(screens, span)
    };
  }), [mergedItems, screens]);
  return responsiveItems;
}

// node_modules/antd/es/descriptions/hooks/useRow.js
var import_react158 = __toESM(require_react());
function getCalcRows(rowItems, mergedColumn) {
  let rows = [];
  let tmpRow = [];
  let exceed = false;
  let count = 0;
  rowItems.filter((n2) => n2).forEach((rowItem) => {
    const {
      filled,
      ...restItem
    } = rowItem;
    if (filled) {
      tmpRow.push(restItem);
      rows.push(tmpRow);
      tmpRow = [];
      count = 0;
      return;
    }
    const restSpan = mergedColumn - count;
    count += rowItem.span || 1;
    if (count >= mergedColumn) {
      if (count > mergedColumn) {
        exceed = true;
        tmpRow.push({
          ...restItem,
          span: restSpan
        });
      } else {
        tmpRow.push(restItem);
      }
      rows.push(tmpRow);
      tmpRow = [];
      count = 0;
    } else {
      tmpRow.push(restItem);
    }
  });
  if (tmpRow.length > 0) {
    rows.push(tmpRow);
  }
  rows = rows.map((rows2) => {
    const count2 = rows2.reduce((acc, item) => acc + (item.span || 1), 0);
    if (count2 < mergedColumn) {
      const last = rows2[rows2.length - 1];
      last.span = mergedColumn - (count2 - (last.span || 1));
      return rows2;
    }
    return rows2;
  });
  return [rows, exceed];
}
var useRow = (mergedColumn, items) => {
  const [rows, exceed] = (0, import_react158.useMemo)(() => getCalcRows(items, mergedColumn), [items, mergedColumn]);
  if (true) {
    const warning5 = devUseWarning("Descriptions");
    true ? warning5(!exceed, "usage", "Sum of column `span` in a line not match `column` of Descriptions.") : void 0;
  }
  return rows;
};
var useRow_default = useRow;

// node_modules/antd/es/descriptions/Item.js
var DescriptionsItem = (props) => {
  return props.children;
};
var Item_default2 = DescriptionsItem;

// node_modules/antd/es/descriptions/Row.js
var React407 = __toESM(require_react());

// node_modules/antd/es/descriptions/Cell.js
var React406 = __toESM(require_react());
var Cell = (props) => {
  const {
    itemPrefixCls,
    component,
    span,
    className,
    style: style2,
    labelStyle,
    contentStyle,
    bordered,
    label,
    content,
    colon,
    type: type5,
    styles,
    classNames
  } = props;
  const Component8 = component;
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = React406.useContext(DescriptionsContext_default);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const mergedLabelStyle = {
    ...labelStyle,
    ...mergedStyles.label
  };
  const mergedContentStyle = {
    ...contentStyle,
    ...mergedStyles.content
  };
  if (bordered) {
    return React406.createElement(Component8, {
      colSpan: span,
      style: style2,
      className: clsx(className, {
        [`${itemPrefixCls}-item-${type5}`]: type5 === "label" || type5 === "content",
        [mergedClassNames.label]: mergedClassNames.label && type5 === "label",
        [mergedClassNames.content]: mergedClassNames.content && type5 === "content"
      })
    }, isNonNullable_default(label) && React406.createElement("span", {
      style: mergedLabelStyle
    }, label), isNonNullable_default(content) && React406.createElement("span", {
      style: mergedContentStyle
    }, content));
  }
  return React406.createElement(Component8, {
    className: clsx(`${itemPrefixCls}-item`, className),
    style: style2,
    colSpan: span
  }, React406.createElement("div", {
    className: `${itemPrefixCls}-item-container`
  }, isNonNullable_default(label) && React406.createElement("span", {
    style: mergedLabelStyle,
    className: clsx(`${itemPrefixCls}-item-label`, mergedClassNames.label, {
      [`${itemPrefixCls}-item-no-colon`]: !colon
    })
  }, label), isNonNullable_default(content) && React406.createElement("span", {
    style: mergedContentStyle,
    className: clsx(`${itemPrefixCls}-item-content`, mergedClassNames.content)
  }, content)));
};
var Cell_default = Cell;

// node_modules/antd/es/descriptions/Row.js
function renderCells(items, {
  colon,
  prefixCls,
  bordered
}, {
  component,
  type: type5,
  showLabel,
  showContent,
  labelStyle: rootLabelStyle,
  contentStyle: rootContentStyle,
  styles: rootStyles
}) {
  return items.map(({
    label,
    children,
    prefixCls: itemPrefixCls = prefixCls,
    className,
    style: style2,
    labelStyle,
    contentStyle,
    span = 1,
    key,
    styles,
    classNames
  }, index2) => {
    if (typeof component === "string") {
      return React407.createElement(Cell_default, {
        key: `${type5}-${key || index2}`,
        className,
        style: style2,
        classNames,
        styles: {
          label: {
            ...rootLabelStyle,
            ...rootStyles == null ? void 0 : rootStyles.label,
            ...labelStyle,
            ...styles == null ? void 0 : styles.label
          },
          content: {
            ...rootContentStyle,
            ...rootStyles == null ? void 0 : rootStyles.content,
            ...contentStyle,
            ...styles == null ? void 0 : styles.content
          }
        },
        span,
        colon,
        component,
        itemPrefixCls,
        bordered,
        label: showLabel ? label : null,
        content: showContent ? children : null,
        type: type5
      });
    }
    return [React407.createElement(Cell_default, {
      key: `label-${key || index2}`,
      className,
      style: {
        ...rootLabelStyle,
        ...rootStyles == null ? void 0 : rootStyles.label,
        ...style2,
        ...labelStyle,
        ...styles == null ? void 0 : styles.label
      },
      span: 1,
      colon,
      component: component[0],
      itemPrefixCls,
      bordered,
      label,
      type: "label"
    }), React407.createElement(Cell_default, {
      key: `content-${key || index2}`,
      className,
      style: {
        ...rootContentStyle,
        ...rootStyles == null ? void 0 : rootStyles.content,
        ...style2,
        ...contentStyle,
        ...styles == null ? void 0 : styles.content
      },
      span: span * 2 - 1,
      component: component[1],
      itemPrefixCls,
      bordered,
      content: children,
      type: "content"
    })];
  });
}
var Row2 = (props) => {
  const descContext = React407.useContext(DescriptionsContext_default);
  const {
    prefixCls,
    vertical,
    row,
    index: index2,
    bordered
  } = props;
  if (vertical) {
    return React407.createElement(React407.Fragment, null, React407.createElement("tr", {
      key: `label-${index2}`,
      className: `${prefixCls}-row`
    }, renderCells(row, props, {
      component: "th",
      type: "label",
      showLabel: true,
      ...descContext
    })), React407.createElement("tr", {
      key: `content-${index2}`,
      className: `${prefixCls}-row`
    }, renderCells(row, props, {
      component: "td",
      type: "content",
      showContent: true,
      ...descContext
    })));
  }
  return React407.createElement("tr", {
    key: index2,
    className: `${prefixCls}-row`
  }, renderCells(row, props, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    ...descContext
  }));
};
var Row_default = Row2;

// node_modules/antd/es/descriptions/style/index.js
var genBorderedStyle = (token2) => {
  const {
    componentCls,
    labelBg
  } = token2;
  return {
    [`&${componentCls}-bordered`]: {
      [`> ${componentCls}-view`]: {
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
        "> table": {
          tableLayout: "auto"
        },
        [`${componentCls}-row`]: {
          borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
          "&:first-child": {
            "> th:first-child, > td:first-child": {
              borderStartStartRadius: token2.borderRadiusLG
            }
          },
          "&:last-child": {
            borderBottom: "none",
            "> th:first-child, > td:first-child": {
              borderEndStartRadius: token2.borderRadiusLG
            }
          },
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.padding)} ${unit(token2.paddingLG)}`,
            borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
            "&:last-child": {
              borderInlineEnd: "none"
            }
          },
          [`> ${componentCls}-item-label`]: {
            color: token2.colorTextSecondary,
            backgroundColor: labelBg,
            "&::after": {
              display: "none"
            }
          }
        }
      },
      [`&${componentCls}-middle`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.paddingSM)} ${unit(token2.paddingLG)}`
          }
        }
      },
      [`&${componentCls}-small`]: {
        [`${componentCls}-row`]: {
          [`> ${componentCls}-item-label, > ${componentCls}-item-content`]: {
            padding: `${unit(token2.paddingXS)} ${unit(token2.padding)}`
          }
        }
      }
    }
  };
};
var genDescriptionStyles = (token2) => {
  const {
    componentCls,
    extraColor,
    itemPaddingBottom,
    itemPaddingEnd,
    colonMarginRight,
    colonMarginLeft,
    titleMarginBottom
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      ...genBorderedStyle(token2),
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: titleMarginBottom
      },
      [`${componentCls}-title`]: {
        ...textEllipsis,
        flex: "auto",
        color: token2.titleColor,
        fontWeight: token2.fontWeightStrong,
        fontSize: token2.fontSizeLG,
        lineHeight: token2.lineHeightLG
      },
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: extraColor,
        fontSize: token2.fontSize
      },
      [`${componentCls}-view`]: {
        width: "100%",
        borderRadius: token2.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed",
          borderCollapse: "collapse"
        }
      },
      [`${componentCls}-row`]: {
        "> th, > td": {
          paddingBottom: itemPaddingBottom,
          paddingInlineEnd: itemPaddingEnd
        },
        "> th:last-child, > td:last-child": {
          paddingInlineEnd: 0
        },
        "&:last-child": {
          borderBottom: "none",
          "> th, > td": {
            paddingBottom: 0
          }
        }
      },
      [`${componentCls}-item-label`]: {
        color: token2.labelColor,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          // magic for position
          marginInline: `${unit(colonMarginLeft)} ${unit(colonMarginRight)}`
        },
        [`&${componentCls}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${componentCls}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${componentCls}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: token2.contentColor,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${componentCls}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${componentCls}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${componentCls}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline",
            minWidth: "1em"
          }
        }
      },
      "&-middle": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token2.paddingSM
          }
        }
      },
      "&-small": {
        [`${componentCls}-row`]: {
          "> th, > td": {
            paddingBottom: token2.paddingXS
          }
        }
      }
    }
  };
};
var prepareComponentToken32 = (token2) => ({
  labelBg: token2.colorFillAlter,
  labelColor: token2.colorTextTertiary,
  titleColor: token2.colorText,
  titleMarginBottom: token2.fontSizeSM * token2.lineHeightSM,
  itemPaddingBottom: token2.padding,
  itemPaddingEnd: token2.padding,
  colonMarginRight: token2.marginXS,
  colonMarginLeft: token2.marginXXS / 2,
  contentColor: token2.colorText,
  extraColor: token2.colorText
});
var style_default37 = genStyleHooks("Descriptions", (token2) => {
  const descriptionToken = merge2(token2, {});
  return genDescriptionStyles(descriptionToken);
}, prepareComponentToken32);

// node_modules/antd/es/descriptions/index.js
var Descriptions = (props) => {
  const {
    prefixCls: customizePrefixCls,
    title,
    extra,
    column: column2,
    colon = true,
    bordered,
    layout,
    children,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    labelStyle,
    contentStyle,
    styles,
    items,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("descriptions");
  const prefixCls = getPrefixCls("descriptions", customizePrefixCls);
  const screens = useBreakpoint_default();
  if (true) {
    const warning5 = devUseWarning("Descriptions");
    [["labelStyle", "styles.label"], ["contentStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const mergedColumn = React408.useMemo(() => {
    if (typeof column2 === "number") {
      return column2;
    }
    return matchScreen(screens, {
      ...constant_default,
      ...column2
    }) ?? 3;
  }, [screens, column2]);
  const mergedItems = useItems3(screens, items, children);
  const mergedSize = useSize_default(customizeSize);
  const rows = useRow_default(mergedColumn, mergedItems);
  const [hashId, cssVarCls] = style_default37(prefixCls);
  const mergedProps = {
    ...props,
    column: mergedColumn,
    items: mergedItems,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const memoizedValue = React408.useMemo(() => ({
    labelStyle,
    contentStyle,
    styles: {
      label: mergedStyles.label,
      content: mergedStyles.content
    },
    classNames: {
      label: clsx(mergedClassNames.label),
      content: clsx(mergedClassNames.content)
    }
  }), [labelStyle, contentStyle, mergedStyles.label, mergedStyles.content, mergedClassNames.label, mergedClassNames.content]);
  return React408.createElement(DescriptionsContext_default.Provider, {
    value: memoizedValue
  }, React408.createElement("div", {
    className: clsx(prefixCls, contextClassName, mergedClassNames.root, {
      [`${prefixCls}-${mergedSize}`]: mergedSize && mergedSize !== "default",
      [`${prefixCls}-bordered`]: !!bordered,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId, cssVarCls),
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style2
    },
    ...restProps
  }, (title || extra) && React408.createElement("div", {
    className: clsx(`${prefixCls}-header`, mergedClassNames.header),
    style: mergedStyles.header
  }, title && React408.createElement("div", {
    className: clsx(`${prefixCls}-title`, mergedClassNames.title),
    style: mergedStyles.title
  }, title), extra && React408.createElement("div", {
    className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
    style: mergedStyles.extra
  }, extra)), React408.createElement("div", {
    className: `${prefixCls}-view`
  }, React408.createElement("table", null, React408.createElement("tbody", null, rows.map((row, index2) => React408.createElement(Row_default, {
    key: index2,
    index: index2,
    colon,
    prefixCls,
    vertical: layout === "vertical",
    bordered,
    row
  })))))));
};
if (true) {
  Descriptions.displayName = "Descriptions";
}
Descriptions.Item = Item_default2;
var descriptions_default = Descriptions;

// node_modules/antd/es/drawer/index.js
var React415 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/Drawer.js
var React413 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/context.js
var React409 = __toESM(require_react());
var DrawerContext = React409.createContext(null);
var RefContext2 = React409.createContext({});
var context_default11 = DrawerContext;

// node_modules/@rc-component/drawer/es/DrawerPopup.js
var React412 = __toESM(require_react());

// node_modules/@rc-component/drawer/es/DrawerPanel.js
var React410 = __toESM(require_react());
function _extends64() {
  _extends64 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends64.apply(this, arguments);
}
var DrawerPanel = (props) => {
  const {
    prefixCls,
    className,
    containerRef,
    ...restProps
  } = props;
  const {
    panel: panelRef
  } = React410.useContext(RefContext2);
  const mergedRef = useComposeRef(panelRef, containerRef);
  return React410.createElement("div", _extends64({
    className: clsx(`${prefixCls}-section`, className),
    role: "dialog",
    ref: mergedRef
  }, pickAttrs(props, {
    aria: true
  }), {
    "aria-modal": "true"
  }, restProps));
};
if (true) {
  DrawerPanel.displayName = "DrawerPanel";
}
var DrawerPanel_default = DrawerPanel;

// node_modules/@rc-component/drawer/es/hooks/useDrag.js
var React411 = __toESM(require_react());
function useDrag2(options) {
  const {
    prefixCls,
    direction,
    className,
    style: style2,
    maxSize,
    containerRef,
    currentSize,
    onResize: onResize2,
    onResizeEnd,
    onResizeStart
  } = options;
  const [isDragging, setIsDragging] = React411.useState(false);
  const [startPos, setStartPos] = React411.useState(0);
  const [startSize, setStartSize] = React411.useState(0);
  const isHorizontal = direction === "left" || direction === "right";
  const handleMouseDown = useEvent_default((e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    setIsDragging(true);
    if (isHorizontal) {
      setStartPos(e3.clientX);
    } else {
      setStartPos(e3.clientY);
    }
    let startSize2;
    if (typeof currentSize === "number") {
      startSize2 = currentSize;
    } else if (containerRef == null ? void 0 : containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      startSize2 = isHorizontal ? rect.width : rect.height;
    }
    setStartSize(startSize2);
    onResizeStart == null ? void 0 : onResizeStart(startSize2);
  });
  const handleMouseMove = useEvent_default((e3) => {
    if (!isDragging)
      return;
    const currentPos = isHorizontal ? e3.clientX : e3.clientY;
    let delta = currentPos - startPos;
    if (direction === "right" || direction === "bottom") {
      delta = -delta;
    }
    let newSize = startSize + delta;
    if (newSize < 0) {
      newSize = 0;
    }
    if (maxSize && newSize > maxSize) {
      newSize = maxSize;
    }
    onResize2 == null ? void 0 : onResize2(newSize);
  });
  const handleMouseUp = React411.useCallback(() => {
    if (isDragging) {
      setIsDragging(false);
      if (containerRef == null ? void 0 : containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const finalSize = isHorizontal ? rect.width : rect.height;
        onResizeEnd == null ? void 0 : onResizeEnd(finalSize);
      }
    }
  }, [isDragging, containerRef, onResizeEnd, isHorizontal]);
  React411.useEffect(() => {
    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);
  const dragElementClassName = clsx(`${prefixCls}-dragger`, `${prefixCls}-dragger-${direction}`, {
    [`${prefixCls}-dragger-dragging`]: isDragging,
    [`${prefixCls}-dragger-horizontal`]: isHorizontal,
    [`${prefixCls}-dragger-vertical`]: !isHorizontal
  }, className);
  return {
    dragElementProps: {
      className: dragElementClassName,
      style: style2,
      onMouseDown: handleMouseDown
    },
    isDragging
  };
}

// node_modules/@rc-component/drawer/es/util.js
function parseWidthHeight(value) {
  if (typeof value === "string") {
    const num = Number(value.replace(/px$/i, ""));
    const floatNum = parseFloat(value);
    if (floatNum === num) {
      warning_default(false, "Invalid value type of `width` or `height` which should be number type instead.");
    }
    if (!Number.isNaN(num)) {
      return num;
    }
  }
  return value;
}
function warnCheck(props) {
  warning_default(!("wrapperClassName" in props), `'wrapperClassName' is removed. Please use 'rootClassName' instead.`);
  warning_default(canUseDom() || !props.open, `Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.`);
}

// node_modules/@rc-component/drawer/es/DrawerPopup.js
function _extends65() {
  _extends65 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends65.apply(this, arguments);
}
var sentinelStyle2 = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none",
  position: "absolute"
};
var DrawerPopup = (props, ref) => {
  const {
    prefixCls,
    open: open3,
    placement,
    inline: inline2,
    push,
    forceRender,
    autoFocus,
    keyboard,
    // classNames
    classNames: drawerClassNames,
    // Root
    rootClassName,
    rootStyle,
    zIndex,
    // Drawer
    className,
    id,
    style: style2,
    motion: motion2,
    width,
    height,
    size,
    maxSize,
    children,
    // Mask
    mask,
    maskClosable,
    maskMotion,
    maskClassName,
    maskStyle,
    // Events
    afterOpenChange,
    onClose,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    styles,
    drawerRender,
    resizable,
    defaultSize
  } = props;
  const panelRef = React412.useRef(null);
  const sentinelStartRef = React412.useRef(null);
  const sentinelEndRef = React412.useRef(null);
  React412.useImperativeHandle(ref, () => panelRef.current);
  const onPanelKeyDown = (event) => {
    var _a, _b;
    const {
      keyCode,
      shiftKey
    } = event;
    switch (keyCode) {
      case KeyCode_default.TAB: {
        if (keyCode === KeyCode_default.TAB) {
          if (!shiftKey && document.activeElement === sentinelEndRef.current) {
            (_a = sentinelStartRef.current) == null ? void 0 : _a.focus({
              preventScroll: true
            });
          } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
            (_b = sentinelEndRef.current) == null ? void 0 : _b.focus({
              preventScroll: true
            });
          }
        }
        break;
      }
      case KeyCode_default.ESC: {
        if (onClose && keyboard) {
          event.stopPropagation();
          onClose(event);
        }
        break;
      }
    }
  };
  React412.useEffect(() => {
    var _a;
    if (open3 && autoFocus) {
      (_a = panelRef.current) == null ? void 0 : _a.focus({
        preventScroll: true
      });
    }
  }, [open3]);
  const [pushed, setPushed] = React412.useState(false);
  const parentContext = React412.useContext(context_default11);
  let pushConfig;
  if (typeof push === "boolean") {
    pushConfig = push ? {} : {
      distance: 0
    };
  } else {
    pushConfig = push || {};
  }
  const pushDistance = (pushConfig == null ? void 0 : pushConfig.distance) ?? (parentContext == null ? void 0 : parentContext.pushDistance) ?? 180;
  const mergedContext = React412.useMemo(() => ({
    pushDistance,
    push: () => {
      setPushed(true);
    },
    pull: () => {
      setPushed(false);
    }
  }), [pushDistance]);
  React412.useEffect(() => {
    var _a, _b;
    if (open3) {
      (_a = parentContext == null ? void 0 : parentContext.push) == null ? void 0 : _a.call(parentContext);
    } else {
      (_b = parentContext == null ? void 0 : parentContext.pull) == null ? void 0 : _b.call(parentContext);
    }
  }, [open3]);
  React412.useEffect(() => () => {
    var _a;
    (_a = parentContext == null ? void 0 : parentContext.pull) == null ? void 0 : _a.call(parentContext);
  }, []);
  const maskNode = React412.createElement(es_default2, _extends65({
    key: "mask"
  }, maskMotion, {
    visible: mask && open3
  }), ({
    className: motionMaskClassName,
    style: motionMaskStyle
  }, maskRef) => React412.createElement("div", {
    className: clsx(`${prefixCls}-mask`, motionMaskClassName, drawerClassNames == null ? void 0 : drawerClassNames.mask, maskClassName),
    style: {
      ...motionMaskStyle,
      ...maskStyle,
      ...styles == null ? void 0 : styles.mask
    },
    onClick: maskClosable && open3 ? onClose : void 0,
    ref: maskRef
  }));
  const motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
  const [currentSize, setCurrentSize] = React412.useState();
  const isHorizontal = placement === "left" || placement === "right";
  const mergedSize = React412.useMemo(() => {
    const legacySize = isHorizontal ? width : height;
    const nextMergedSize = size ?? legacySize ?? currentSize ?? defaultSize ?? (isHorizontal ? 378 : void 0);
    return parseWidthHeight(nextMergedSize);
  }, [size, width, height, defaultSize, isHorizontal, currentSize]);
  const wrapperStyle = React412.useMemo(() => {
    const nextWrapperStyle = {};
    if (pushed && pushDistance) {
      switch (placement) {
        case "top":
          nextWrapperStyle.transform = `translateY(${pushDistance}px)`;
          break;
        case "bottom":
          nextWrapperStyle.transform = `translateY(${-pushDistance}px)`;
          break;
        case "left":
          nextWrapperStyle.transform = `translateX(${pushDistance}px)`;
          break;
        default:
          nextWrapperStyle.transform = `translateX(${-pushDistance}px)`;
          break;
      }
    }
    if (isHorizontal) {
      nextWrapperStyle.width = parseWidthHeight(mergedSize);
    } else {
      nextWrapperStyle.height = parseWidthHeight(mergedSize);
    }
    return nextWrapperStyle;
  }, [pushed, pushDistance, placement, isHorizontal, mergedSize]);
  const wrapperRef = React412.useRef(null);
  const isResizable = !!resizable;
  const resizeConfig = typeof resizable === "object" && resizable || {};
  const onInternalResize = useEvent_default((size2) => {
    var _a;
    setCurrentSize(size2);
    (_a = resizeConfig.onResize) == null ? void 0 : _a.call(resizeConfig, size2);
  });
  const {
    dragElementProps,
    isDragging
  } = useDrag2({
    prefixCls: `${prefixCls}-resizable`,
    direction: placement,
    className: drawerClassNames == null ? void 0 : drawerClassNames.dragger,
    style: styles == null ? void 0 : styles.dragger,
    maxSize,
    containerRef: wrapperRef,
    currentSize: mergedSize,
    onResize: onInternalResize,
    onResizeStart: resizeConfig.onResizeStart,
    onResizeEnd: resizeConfig.onResizeEnd
  });
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const panelNode = React412.createElement(es_default2, _extends65({
    key: "panel"
  }, motionProps, {
    visible: open3,
    forceRender,
    onVisibleChanged: (nextVisible) => {
      afterOpenChange == null ? void 0 : afterOpenChange(nextVisible);
    },
    removeOnLeave: false,
    leavedClassName: `${prefixCls}-content-wrapper-hidden`
  }), ({
    className: motionClassName,
    style: motionStyle
  }, motionRef) => {
    const content = React412.createElement(DrawerPanel_default, _extends65({
      id,
      containerRef: motionRef,
      prefixCls,
      className: clsx(className, drawerClassNames == null ? void 0 : drawerClassNames.section),
      style: {
        ...style2,
        ...styles == null ? void 0 : styles.section
      }
    }, pickAttrs(props, {
      aria: true
    }), eventHandlers), children);
    return React412.createElement("div", _extends65({
      ref: wrapperRef,
      className: clsx(`${prefixCls}-content-wrapper`, isDragging && `${prefixCls}-content-wrapper-dragging`, drawerClassNames == null ? void 0 : drawerClassNames.wrapper, !isDragging && motionClassName),
      style: {
        ...motionStyle,
        ...wrapperStyle,
        ...styles == null ? void 0 : styles.wrapper
      }
    }, pickAttrs(props, {
      data: true
    })), isResizable && React412.createElement("div", dragElementProps), drawerRender ? drawerRender(content) : content);
  });
  const containerStyle = {
    ...rootStyle
  };
  if (zIndex) {
    containerStyle.zIndex = zIndex;
  }
  return React412.createElement(context_default11.Provider, {
    value: mergedContext
  }, React412.createElement("div", {
    className: clsx(prefixCls, `${prefixCls}-${placement}`, rootClassName, {
      [`${prefixCls}-open`]: open3,
      [`${prefixCls}-inline`]: inline2
    }),
    style: containerStyle,
    tabIndex: -1,
    ref: panelRef,
    onKeyDown: onPanelKeyDown
  }, maskNode, React412.createElement("div", {
    tabIndex: 0,
    ref: sentinelStartRef,
    style: sentinelStyle2,
    "aria-hidden": "true",
    "data-sentinel": "start"
  }), panelNode, React412.createElement("div", {
    tabIndex: 0,
    ref: sentinelEndRef,
    style: sentinelStyle2,
    "aria-hidden": "true",
    "data-sentinel": "end"
  })));
};
var RefDrawerPopup = React412.forwardRef(DrawerPopup);
if (true) {
  RefDrawerPopup.displayName = "DrawerPopup";
}
var DrawerPopup_default = RefDrawerPopup;

// node_modules/@rc-component/drawer/es/Drawer.js
var Drawer = (props) => {
  const {
    open: open3 = false,
    prefixCls = "rc-drawer",
    placement = "right",
    autoFocus = true,
    keyboard = true,
    width,
    height,
    size,
    maxSize,
    mask = true,
    maskClosable = true,
    getContainer,
    forceRender,
    afterOpenChange,
    destroyOnHidden,
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp,
    resizable,
    defaultSize,
    // Refs
    panelRef
  } = props;
  const [animatedVisible, setAnimatedVisible] = React413.useState(false);
  if (true) {
    warnCheck(props);
  }
  const [mounted, setMounted] = React413.useState(false);
  useLayoutEffect_default(() => {
    setMounted(true);
  }, []);
  const mergedOpen = mounted ? open3 : false;
  const popupRef = React413.useRef(null);
  const lastActiveRef = React413.useRef(null);
  useLayoutEffect_default(() => {
    if (mergedOpen) {
      lastActiveRef.current = document.activeElement;
    }
  }, [mergedOpen]);
  const internalAfterOpenChange = (nextVisible) => {
    var _a, _b;
    setAnimatedVisible(nextVisible);
    afterOpenChange == null ? void 0 : afterOpenChange(nextVisible);
    if (!nextVisible && lastActiveRef.current && !((_a = popupRef.current) == null ? void 0 : _a.contains(lastActiveRef.current))) {
      (_b = lastActiveRef.current) == null ? void 0 : _b.focus({
        preventScroll: true
      });
    }
  };
  const refContext = React413.useMemo(() => ({
    panel: panelRef
  }), [panelRef]);
  if (!forceRender && !animatedVisible && !mergedOpen && destroyOnHidden) {
    return null;
  }
  const eventHandlers = {
    onMouseEnter,
    onMouseOver,
    onMouseLeave,
    onClick,
    onKeyDown: onKeyDown2,
    onKeyUp
  };
  const drawerPopupProps = {
    ...props,
    open: mergedOpen,
    prefixCls,
    placement,
    autoFocus,
    keyboard,
    width,
    height,
    size,
    maxSize,
    defaultSize,
    mask,
    maskClosable,
    inline: getContainer === false,
    afterOpenChange: internalAfterOpenChange,
    ref: popupRef,
    resizable,
    ...eventHandlers
  };
  return React413.createElement(RefContext2.Provider, {
    value: refContext
  }, React413.createElement(es_default3, {
    open: mergedOpen || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer,
    autoLock: mask && (mergedOpen || animatedVisible)
  }, React413.createElement(DrawerPopup_default, drawerPopupProps)));
};
if (true) {
  Drawer.displayName = "Drawer";
}
var Drawer_default = Drawer;

// node_modules/@rc-component/drawer/es/index.js
var es_default26 = Drawer_default;

// node_modules/antd/es/drawer/DrawerPanel.js
var React414 = __toESM(require_react());
var DrawerPanel2 = (props) => {
  const {
    prefixCls,
    ariaId,
    title,
    footer,
    extra,
    closable,
    loading,
    onClose,
    headerStyle,
    bodyStyle,
    footerStyle,
    children,
    classNames: drawerClassNames,
    styles: drawerStyles
  } = props;
  const drawerContext = useComponentConfig("drawer");
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = drawerContext;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, drawerClassNames], [contextStyles, drawerStyles], {
    props
  });
  let closablePlacement;
  if (closable === false) {
    closablePlacement = void 0;
  } else if (closable === void 0 || closable === true) {
    closablePlacement = "start";
  } else {
    closablePlacement = (closable == null ? void 0 : closable.placement) === "end" ? "end" : "start";
  }
  const customCloseIconRender = React414.useCallback((icon) => React414.createElement("button", {
    type: "button",
    onClick: onClose,
    className: clsx(`${prefixCls}-close`, {
      [`${prefixCls}-close-${closablePlacement}`]: closablePlacement === "end"
    }, mergedClassNames.close),
    style: mergedStyles.close
  }, icon), [onClose, prefixCls, closablePlacement, mergedClassNames.close, mergedStyles.close]);
  const [mergedClosable, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(drawerContext), {
    closable: true,
    closeIconRender: customCloseIconRender
  });
  const renderHeader = () => {
    if (!title && !mergedClosable) {
      return null;
    }
    return React414.createElement("div", {
      style: {
        ...mergedStyles.header,
        ...headerStyle
      },
      className: clsx(`${prefixCls}-header`, mergedClassNames.header, {
        [`${prefixCls}-header-close-only`]: mergedClosable && !title && !extra
      })
    }, React414.createElement("div", {
      className: `${prefixCls}-header-title`
    }, closablePlacement === "start" && mergedCloseIcon, title && React414.createElement("div", {
      className: clsx(`${prefixCls}-title`, mergedClassNames.title),
      style: mergedStyles.title,
      id: ariaId
    }, title)), extra && React414.createElement("div", {
      className: clsx(`${prefixCls}-extra`, mergedClassNames.extra),
      style: mergedStyles.extra
    }, extra), closablePlacement === "end" && mergedCloseIcon);
  };
  const renderFooter = () => {
    if (!footer) {
      return null;
    }
    return React414.createElement("div", {
      className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
      style: {
        ...mergedStyles.footer,
        ...footerStyle
      }
    }, footer);
  };
  return React414.createElement(React414.Fragment, null, renderHeader(), React414.createElement("div", {
    className: clsx(`${prefixCls}-body`, mergedClassNames.body),
    style: {
      ...mergedStyles.body,
      ...bodyStyle
    }
  }, loading ? React414.createElement(skeleton_default, {
    active: true,
    title: false,
    paragraph: {
      rows: 5
    },
    className: `${prefixCls}-body-skeleton`
  }) : children), renderFooter());
};
var DrawerPanel_default2 = DrawerPanel2;

// node_modules/antd/es/drawer/style/motion.js
var getMoveTranslate = (direction) => {
  const value = "100%";
  return {
    left: `translateX(-${value})`,
    right: `translateX(${value})`,
    top: `translateY(-${value})`,
    bottom: `translateY(${value})`
  }[direction];
};
var getEnterLeaveStyle = (startStyle, endStyle) => ({
  "&-enter, &-appear": {
    ...startStyle,
    "&-active": endStyle
  },
  "&-leave": {
    ...endStyle,
    "&-active": startStyle
  }
});
var getFadeStyle = (from2, duration) => ({
  "&-enter, &-appear, &-leave": {
    "&-start": {
      transition: "none"
    },
    "&-active": {
      transition: `all ${duration}`
    }
  },
  ...getEnterLeaveStyle({
    opacity: from2
  }, {
    opacity: 1
  })
});
var getPanelMotionStyles = (direction, duration) => [getFadeStyle(0.7, duration), getEnterLeaveStyle({
  transform: getMoveTranslate(direction)
}, {
  transform: "none"
})];
var genMotionStyle2 = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return {
    [componentCls]: {
      // ======================== Mask ========================
      [`${componentCls}-mask-motion`]: getFadeStyle(0, motionDurationSlow),
      // ======================= Panel ========================
      [`${componentCls}-panel-motion`]: ["left", "right", "top", "bottom"].reduce((obj, direction) => ({
        ...obj,
        [`&-${direction}`]: getPanelMotionStyles(direction, motionDurationSlow)
      }), {})
    }
  };
};
var motion_default3 = genMotionStyle2;

// node_modules/antd/es/drawer/style/index.js
var genDrawerStyle = (token2) => {
  const {
    borderRadiusSM,
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    paddingXS,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginXS,
    colorIcon,
    colorIconHover,
    colorBgTextHover,
    colorBgTextActive,
    colorText,
    fontWeightStrong,
    footerPaddingBlock,
    footerPaddingInline,
    draggerSize,
    calc
  } = token2;
  const wrapperCls = `${componentCls}-content-wrapper`;
  const draggerCls = `${componentCls}-resizable-dragger`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      color: colorText,
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        display: "flex",
        flexDirection: "column",
        [`&${componentCls}-left`]: {
          boxShadow: token2.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token2.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token2.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token2.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto",
        [`&${componentCls}-mask-blur`]: {
          backdropFilter: "blur(4px)"
        }
      },
      // ==================== Content =====================
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        maxWidth: "100vw",
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token2.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token2.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerDown
      },
      [`${componentCls}-section`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      // Header
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${unit(padding)} ${unit(paddingLG)}`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-flex",
        width: calc(fontSizeLG).add(paddingXS).equal(),
        height: calc(fontSizeLG).add(paddingXS).equal(),
        borderRadius: borderRadiusSM,
        justifyContent: "center",
        alignItems: "center",
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        cursor: "pointer",
        transition: `all ${motionDurationMid}`,
        textRendering: "auto",
        [`&${componentCls}-close-end`]: {
          marginInlineStart: marginXS
        },
        [`&:not(${componentCls}-close-end)`]: {
          marginInlineEnd: marginXS
        },
        "&:hover": {
          color: colorIconHover,
          backgroundColor: colorBgTextHover,
          textDecoration: "none"
        },
        "&:active": {
          backgroundColor: colorBgTextActive
        },
        ...genFocusStyle(token2)
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        fontWeight: token2.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      // Body
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto",
        [`${componentCls}-body-skeleton`]: {
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center"
        }
      },
      // Footer
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${unit(footerPaddingBlock)} ${unit(footerPaddingInline)}`,
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
      },
      // ==================== Resizable ===================
      [draggerCls]: {
        position: "absolute",
        zIndex: 1,
        backgroundColor: "transparent",
        userSelect: "none",
        pointerEvents: "auto",
        "&:hover": {
          backgroundColor: token2.colorPrimary,
          opacity: 0.2
        },
        "&-dragging": {
          backgroundColor: token2.colorPrimary,
          opacity: 0.3
        }
      },
      [`${draggerCls}-left`]: {
        top: 0,
        bottom: 0,
        insetInlineEnd: 0,
        width: draggerSize,
        cursor: "col-resize"
      },
      [`${draggerCls}-right`]: {
        top: 0,
        bottom: 0,
        insetInlineStart: 0,
        width: draggerSize,
        cursor: "col-resize"
      },
      [`${draggerCls}-top`]: {
        insetInline: 0,
        bottom: 0,
        height: draggerSize,
        cursor: "row-resize"
      },
      [`${draggerCls}-bottom`]: {
        insetInline: 0,
        top: 0,
        height: draggerSize,
        cursor: "row-resize"
      },
      // Wrapper dragging state - disable transitions for smooth dragging
      [`${wrapperCls}-dragging`]: {
        userSelect: "none",
        transition: "none",
        willChange: "width, height",
        [`${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-section`]: {
          pointerEvents: "none"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken33 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase,
  footerPaddingBlock: token2.paddingXS,
  footerPaddingInline: token2.padding,
  draggerSize: 4
});
var style_default38 = genStyleHooks("Drawer", (token2) => {
  const drawerToken = merge2(token2, {});
  return [genDrawerStyle(drawerToken), motion_default3(drawerToken)];
}, prepareComponentToken33);

// node_modules/antd/es/drawer/index.js
var defaultPushState = {
  distance: 180
};
var DEFAULT_SIZE3 = 378;
var Drawer2 = (props) => {
  var _a;
  const {
    rootClassName,
    size,
    defaultSize = DEFAULT_SIZE3,
    height,
    width,
    mask: drawerMask,
    push = defaultPushState,
    open: open3,
    afterOpenChange,
    onClose,
    prefixCls: customizePrefixCls,
    getContainer: customizeGetContainer,
    panelRef = null,
    style: style2,
    className,
    resizable,
    "aria-labelledby": ariaLabelledby,
    // Deprecated
    maskStyle,
    drawerStyle,
    contentWrapperStyle,
    destroyOnClose,
    destroyOnHidden,
    ...rest
  } = props;
  const {
    placement
  } = rest;
  const id = useId_default();
  const ariaId = rest.title ? id : void 0;
  const {
    getPopupContainer,
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    mask: contextMask
  } = useComponentConfig("drawer");
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default38(prefixCls);
  const getContainer = (
    //  false
    customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer
  );
  if (true) {
    const warning5 = devUseWarning("Drawer");
    [["headerStyle", "styles.header"], ["bodyStyle", "styles.body"], ["footerStyle", "styles.footer"], ["contentWrapperStyle", "styles.wrapper"], ["maskStyle", "styles.mask"], ["drawerStyle", "styles.section"], ["destroyInactivePanel", "destroyOnHidden"], ["width", "size"], ["height", "size"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (getContainer !== void 0 && ((_a = props.style) == null ? void 0 : _a.position) === "absolute") {
      true ? warning5(false, "breaking", "`style` is replaced by `rootStyle` in v5. Please check that `position: absolute` is necessary.") : void 0;
    }
  }
  const drawerSize = React415.useMemo(() => {
    if (typeof size === "number") {
      return size;
    }
    if (size === "large") {
      return 736;
    }
    if (size === "default") {
      return DEFAULT_SIZE3;
    }
    if (!placement || placement === "left" || placement === "right") {
      return width;
    }
    return height;
  }, [size, placement, width, height]);
  const maskMotion = {
    motionName: getTransitionName2(prefixCls, "mask-motion"),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  };
  const panelMotion = (motionPlacement) => ({
    motionName: getTransitionName2(prefixCls, `panel-motion-${motionPlacement}`),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  });
  const innerPanelRef = usePanelRef();
  const mergedPanelRef = composeRef(panelRef, innerPanelRef);
  const [zIndex, contextZIndex] = useZIndex("Drawer", rest.zIndex);
  const {
    classNames,
    styles,
    rootStyle
  } = rest;
  const [mergedMask, maskBlurClassName] = useMergedMask(drawerMask, contextMask, prefixCls);
  const mergedProps = {
    ...props,
    zIndex,
    panelRef,
    mask: mergedMask,
    defaultSize,
    push
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const drawerClassName = clsx({
    "no-mask": !mergedMask,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  return React415.createElement(ContextIsolator_default, {
    form: true,
    space: true
  }, React415.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, React415.createElement(es_default26, {
    prefixCls,
    onClose,
    maskMotion,
    motion: panelMotion,
    ...rest,
    classNames: {
      mask: clsx(mergedClassNames.mask, maskBlurClassName.mask),
      section: mergedClassNames.section,
      wrapper: mergedClassNames.wrapper,
      dragger: mergedClassNames.dragger
    },
    styles: {
      mask: {
        ...mergedStyles.mask,
        ...maskStyle
      },
      section: {
        ...mergedStyles.section,
        ...drawerStyle
      },
      wrapper: {
        ...mergedStyles.wrapper,
        ...contentWrapperStyle
      },
      dragger: mergedStyles.dragger
    },
    open: open3,
    mask: mergedMask,
    push,
    size: drawerSize,
    defaultSize,
    style: {
      ...contextStyle,
      ...style2
    },
    rootStyle: {
      ...rootStyle,
      ...mergedStyles.root
    },
    className: clsx(contextClassName, className),
    rootClassName: drawerClassName,
    getContainer,
    afterOpenChange,
    panelRef: mergedPanelRef,
    zIndex,
    ...resizable ? {
      resizable
    } : {},
    "aria-labelledby": ariaLabelledby ?? ariaId,
    destroyOnHidden: destroyOnHidden ?? destroyOnClose
  }, React415.createElement(DrawerPanel_default2, {
    prefixCls,
    size,
    ...rest,
    ariaId,
    onClose
  }))));
};
var PurePanel11 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    style: style2,
    className,
    placement = "right",
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React415.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default38(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, cssVarCls, className);
  return React415.createElement("div", {
    className: cls,
    style: style2
  }, React415.createElement(DrawerPanel_default2, {
    prefixCls,
    ...restProps
  }));
};
Drawer2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel11;
if (true) {
  Drawer2.displayName = "Drawer";
}
var drawer_default = Drawer2;

// node_modules/antd/es/dropdown/dropdown-button.js
var React419 = __toESM(require_react());

// node_modules/antd/es/space/index.js
var React418 = __toESM(require_react());

// node_modules/antd/es/_util/gapSize.js
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}
function isValidGapNumber(size) {
  if (!size) {
    return false;
  }
  return typeof size === "number" && !Number.isNaN(size);
}

// node_modules/antd/es/space/context.js
var import_react159 = __toESM(require_react());
var SpaceContext = import_react159.default.createContext({
  latestIndex: 0
});
var SpaceContextProvider = SpaceContext.Provider;

// node_modules/antd/es/space/Item.js
var React417 = __toESM(require_react());
var Item3 = (props) => {
  const {
    className,
    prefix: prefix2,
    index: index2,
    children,
    separator,
    style: style2,
    classNames,
    styles
  } = props;
  const {
    latestIndex
  } = React417.useContext(SpaceContext);
  if (!isNonNullable_default(children)) {
    return null;
  }
  return React417.createElement(React417.Fragment, null, React417.createElement("div", {
    className,
    style: style2
  }, children), index2 < latestIndex && separator && React417.createElement("span", {
    className: clsx(`${prefix2}-item-separator`, classNames.separator),
    style: styles.separator
  }, separator));
};
var Item_default3 = Item3;

// node_modules/antd/es/space/style/index.js
var genSpaceStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item:empty`]: {
        display: "none"
      },
      // https://github.com/ant-design/ant-design/issues/47875
      [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
        display: "block"
      }
    }
  };
};
var genSpaceGapStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-gap-row-small": {
        rowGap: token2.spaceGapSmallSize
      },
      "&-gap-row-middle": {
        rowGap: token2.spaceGapMiddleSize
      },
      "&-gap-row-large": {
        rowGap: token2.spaceGapLargeSize
      },
      "&-gap-col-small": {
        columnGap: token2.spaceGapSmallSize
      },
      "&-gap-col-middle": {
        columnGap: token2.spaceGapMiddleSize
      },
      "&-gap-col-large": {
        columnGap: token2.spaceGapLargeSize
      }
    }
  };
};
var style_default39 = genStyleHooks("Space", (token2) => {
  const spaceToken = merge2(token2, {
    spaceGapSmallSize: token2.paddingXS,
    spaceGapMiddleSize: token2.padding,
    spaceGapLargeSize: token2.paddingLG
  });
  return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken)];
}, () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: false
});

// node_modules/antd/es/space/index.js
var InternalSpace = React418.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction: directionConfig,
    size: contextSize,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("space");
  const {
    size = contextSize ?? "small",
    align,
    className,
    rootClassName,
    children,
    direction,
    orientation,
    prefixCls: customizePrefixCls,
    split,
    separator,
    style: style2,
    vertical,
    wrap = false,
    classNames,
    styles,
    ...restProps
  } = props;
  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
  const isPresetVerticalSize = isPresetSize(verticalSize);
  const isPresetHorizontalSize = isPresetSize(horizontalSize);
  const isValidVerticalSize = isValidGapNumber(verticalSize);
  const isValidHorizontalSize = isValidGapNumber(horizontalSize);
  const childNodes = toArray(children, {
    keepEmpty: true
  });
  const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
  const mergedAlign = align === void 0 && !mergedVertical ? "center" : align;
  const mergedSeparator = separator ?? split;
  const prefixCls = getPrefixCls("space", customizePrefixCls);
  const [hashId, cssVarCls] = style_default39(prefixCls);
  const mergedProps = {
    ...props,
    size,
    orientation: mergedOrientation,
    align: mergedAlign
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(prefixCls, contextClassName, hashId, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
    [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
  }, className, rootClassName, cssVarCls, mergedClassNames.root);
  const itemClassName = clsx(`${prefixCls}-item`, mergedClassNames.item);
  const renderedItems = childNodes.map((child, i) => {
    const key = (child == null ? void 0 : child.key) || `${itemClassName}-${i}`;
    return React418.createElement(Item_default3, {
      prefix: prefixCls,
      classNames: mergedClassNames,
      styles: mergedStyles,
      className: itemClassName,
      key,
      index: i,
      separator: mergedSeparator,
      style: mergedStyles.item
    }, child);
  });
  if (true) {
    const warning5 = devUseWarning("Space");
    [["direction", "orientation"], ["split", "separator"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const memoizedSpaceContext = React418.useMemo(() => {
    const calcLatestIndex = childNodes.reduce((latest, child, i) => isNonNullable_default(child) ? i : latest, 0);
    return {
      latestIndex: calcLatestIndex
    };
  }, [childNodes]);
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = "wrap";
  }
  if (!isPresetHorizontalSize && isValidHorizontalSize) {
    gapStyle.columnGap = horizontalSize;
  }
  if (!isPresetVerticalSize && isValidVerticalSize) {
    gapStyle.rowGap = verticalSize;
  }
  return React418.createElement("div", {
    ref,
    className: rootClassNames,
    style: {
      ...gapStyle,
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    ...restProps
  }, React418.createElement(SpaceContextProvider, {
    value: memoizedSpaceContext
  }, renderedItems));
});
var Space = InternalSpace;
Space.Compact = Compact_default;
Space.Addon = Addon_default;
if (true) {
  Space.displayName = "Space";
}
var space_default = Space;

// node_modules/antd/es/dropdown/dropdown-button.js
var DropdownButton = (props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = React419.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type: type5 = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    trigger,
    align,
    open: open3,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = React419.createElement(EllipsisOutlined_default, null),
    title,
    buttonsRender = (buttons) => buttons,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyOnHidden,
    destroyPopupOnHide,
    dropdownRender,
    popupRender,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const buttonPrefixCls = `${prefixCls}-button`;
  const mergedPopupRender = popupRender || dropdownRender;
  const dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    classNames: {
      root: overlayClassName
    },
    styles: {
      root: overlayStyle
    },
    destroyOnHidden,
    popupRender: mergedPopupRender
  };
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const classes = clsx(buttonPrefixCls, compactItemClassnames, className);
  if ("destroyPopupOnHide" in props) {
    dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
  }
  if ("open" in props) {
    dropdownProps.open = open3;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  if (true) {
    const warning5 = devUseWarning("Dropdown.Button");
    warning5.deprecated(false, "Dropdown.Button", "Space.Compact + Dropdown + Button");
  }
  const leftButton = React419.createElement(button_default, {
    type: type5,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title
  }, children);
  const rightButton = React419.createElement(button_default, {
    type: type5,
    danger,
    icon
  });
  const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return React419.createElement(space_default.Compact, {
    className: classes,
    size: compactSize,
    block: true,
    ...restProps
  }, leftButtonToRender, React419.createElement(dropdown_default2, {
    ...dropdownProps
  }, rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
var dropdown_button_default = DropdownButton;

// node_modules/antd/es/dropdown/index.js
var Dropdown3 = dropdown_default2;
Dropdown3.Button = dropdown_button_default;
var dropdown_default3 = Dropdown3;

// node_modules/antd/es/flex/index.js
var import_react160 = __toESM(require_react());

// node_modules/antd/es/flex/utils.js
var flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
var justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
var alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
var genClsWrap = (prefixCls, props) => {
  const wrap = props.wrap === true ? "wrap" : props.wrap;
  return {
    [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap)
  };
};
var genClsAlign = (prefixCls, props) => {
  const alignCls = {};
  alignItemsValues.forEach((cssKey) => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
  return alignCls;
};
var genClsJustify = (prefixCls, props) => {
  const justifyCls = {};
  justifyContentValues.forEach((cssKey) => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
  });
  return justifyCls;
};
var createFlexClassNames = (prefixCls, props) => {
  return clsx({
    ...genClsWrap(prefixCls, props),
    ...genClsAlign(prefixCls, props),
    ...genClsJustify(prefixCls, props)
  });
};
var utils_default = createFlexClassNames;

// node_modules/antd/es/flex/style/index.js
var genFlexStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      margin: 0,
      padding: 0,
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
};
var genFlexGapStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-gap-small": {
        gap: token2.flexGapSM
      },
      "&-gap-middle": {
        gap: token2.flexGap
      },
      "&-gap-large": {
        gap: token2.flexGapLG
      }
    }
  };
};
var genFlexWrapStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const wrapStyle = {};
  flexWrapValues.forEach((value) => {
    wrapStyle[`${componentCls}-wrap-${value}`] = {
      flexWrap: value
    };
  });
  return wrapStyle;
};
var genAlignItemsStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const alignStyle = {};
  alignItemsValues.forEach((value) => {
    alignStyle[`${componentCls}-align-${value}`] = {
      alignItems: value
    };
  });
  return alignStyle;
};
var genJustifyContentStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const justifyStyle = {};
  justifyContentValues.forEach((value) => {
    justifyStyle[`${componentCls}-justify-${value}`] = {
      justifyContent: value
    };
  });
  return justifyStyle;
};
var prepareComponentToken34 = () => ({});
var style_default40 = genStyleHooks("Flex", (token2) => {
  const {
    paddingXS,
    padding,
    paddingLG
  } = token2;
  const flexToken = merge2(token2, {
    flexGapSM: paddingXS,
    flexGap: padding,
    flexGapLG: paddingLG
  });
  return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
}, prepareComponentToken34, {
  // Flex component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/46403
  resetStyle: false
});

// node_modules/antd/es/flex/index.js
var Flex = import_react160.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    rootClassName,
    className,
    style: style2,
    flex,
    gap,
    vertical,
    orientation,
    component: Component8 = "div",
    children,
    ...othersProps
  } = props;
  const {
    flex: ctxFlex,
    direction: ctxDirection,
    getPrefixCls
  } = import_react160.default.useContext(ConfigContext);
  const prefixCls = getPrefixCls("flex", customizePrefixCls);
  const [hashId, cssVarCls] = style_default40(prefixCls);
  const [, mergedVertical] = useOrientation(orientation, vertical ?? (ctxFlex == null ? void 0 : ctxFlex.vertical));
  const mergedCls = clsx(className, rootClassName, ctxFlex == null ? void 0 : ctxFlex.className, prefixCls, hashId, cssVarCls, utils_default(prefixCls, props), {
    [`${prefixCls}-rtl`]: ctxDirection === "rtl",
    [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
    [`${prefixCls}-vertical`]: mergedVertical
  });
  const mergedStyle = {
    ...ctxFlex == null ? void 0 : ctxFlex.style,
    ...style2
  };
  if (isNonNullable_default(flex)) {
    mergedStyle.flex = flex;
  }
  if (isNonNullable_default(gap) && !isPresetSize(gap)) {
    mergedStyle.gap = gap;
  }
  return import_react160.default.createElement(Component8, {
    ref,
    className: mergedCls,
    style: mergedStyle,
    ...omit(othersProps, ["justify", "wrap", "align"])
  }, children);
});
if (true) {
  Flex.displayName = "Flex";
}
var flex_default = Flex;

// node_modules/antd/es/float-button/BackTop.js
var import_react164 = __toESM(require_react());

// node_modules/antd/es/float-button/context.js
var import_react161 = __toESM(require_react());
var GroupContext2 = import_react161.default.createContext(null);

// node_modules/antd/es/float-button/FloatButton.js
var import_react163 = __toESM(require_react());

// node_modules/antd/es/_util/convertToTooltipProps.js
var import_react162 = __toESM(require_react());
var convertToTooltipProps = (tooltip) => {
  if (!isNonNullable_default(tooltip)) {
    return null;
  }
  if (typeof tooltip === "object" && !(0, import_react162.isValidElement)(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
};
var convertToTooltipProps_default = convertToTooltipProps;

// node_modules/antd/es/float-button/style/button.js
var genFloatButtonStyle = (token2) => {
  const {
    componentCls,
    floatButtonSize,
    iconCls,
    antCls,
    floatButtonIconSize
  } = token2;
  const getCssVar = genCssVar(antCls, "float-btn");
  const badgeCls = `${componentCls}-badge`;
  const R = Math.SQRT2;
  const offsetR = (R - 1) / R;
  const offsetSquare = token2.calc(token2.borderRadius).mul(offsetR).equal();
  const offsetCircle = token2.calc(token2.controlHeight).div(2).mul(offsetR).equal();
  return {
    [componentCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        [getCssVar("size")]: unit(floatButtonSize)
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        flexDirection: "column",
        margin: 0,
        padding: `${unit(token2.paddingXXS)} 0`,
        width: `var(${getCssVar("size")})`,
        minHeight: `var(${getCssVar("size")})`,
        height: "auto",
        wordBreak: "break-word",
        whiteSpace: "normal",
        gap: token2.calc(token2.paddingXXS).div(2).equal(),
        "&-rtl": {
          direction: "rtl"
        },
        // ======================== Individual ========================
        // Not in group
        [`&${componentCls}-individual`]: {
          position: "fixed",
          zIndex: token2.zIndexPopupBase,
          insetInlineEnd: token2.floatButtonInsetInlineEnd,
          bottom: token2.floatButtonInsetBlockEnd,
          boxShadow: token2.boxShadowSecondary
        },
        // =========================== Pure ===========================
        [`&${componentCls}-pure`]: {
          position: "relative",
          inset: "auto"
        },
        // ========================== Empty ===========================
        "&:empty": {
          display: "none"
        },
        // =========================== Icon ===========================
        [`${componentCls}-icon`]: {
          lineHeight: 1
        },
        // Icon Only will has large icon Size
        [`&${componentCls}-icon-only`]: {
          [iconCls]: {
            fontSize: floatButtonIconSize
          }
        },
        // =========================== Desc ===========================
        [`${componentCls}-content`]: {
          fontSize: token2.fontSizeSM
        },
        // ========================== Badge ===========================
        [badgeCls]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          [`&:not(${badgeCls}-dot)`]: {
            transform: "translate(50%, -50%)"
          }
        },
        // RTL
        [`&-rtl ${badgeCls}:not(${badgeCls}-dot)`]: {
          transform: "translate(-50%, -50%)"
        },
        // Shape: square
        "&-square": {
          [`${badgeCls}-dot`]: {
            marginTop: offsetSquare,
            marginInlineEnd: offsetSquare
          }
        },
        // Shape: circle
        "&-circle": {
          [badgeCls]: {
            marginTop: offsetCircle,
            marginInlineEnd: offsetCircle
          }
        }
      }
    ]
  };
};
var button_default2 = genFloatButtonStyle;

// node_modules/antd/es/float-button/style/group.js
var genGroupStyle4 = (token2) => {
  const {
    componentCls,
    antCls,
    floatButtonSize,
    padding
  } = token2;
  const groupCls = `${componentCls}-group`;
  const listCls = `${groupCls}-list`;
  const getCssVar = genCssVar(antCls, "float-btn");
  return {
    [groupCls]: [
      // ==============================================================
      // ==                         Variable                         ==
      // ==============================================================
      {
        [getCssVar("list-transform-start")]: `translate(0,${unit(floatButtonSize)})`,
        [getCssVar("list-trigger-offset")]: `calc(${unit(floatButtonSize)} + ${unit(padding)})`
      },
      // ==============================================================
      // ==                         Template                         ==
      // ==============================================================
      {
        ...resetComponent(token2),
        position: "fixed",
        zIndex: token2.zIndexPopupBase,
        insetInlineEnd: token2.floatButtonInsetInlineEnd,
        bottom: token2.floatButtonInsetBlockEnd,
        gap: padding,
        "&-rtl": {
          direction: "rtl"
        },
        // =========================== Pure ===========================
        [`&${componentCls}-pure`]: {
          position: "relative",
          inset: "auto"
        },
        // ========================== Button ==========================
        [componentCls]: {
          position: "relative",
          inset: "auto"
        }
      },
      // ==============================================================
      // ==                           List                           ==
      // ==============================================================
      {
        // ======================== Individual ========================
        // Not in group
        [`&:not(${groupCls}-individual) ${listCls}`]: {
          boxShadow: token2.boxShadowSecondary
        },
        [`&${groupCls}-individual ${listCls}`]: {
          gap: padding
        },
        // =========================== Menu ===========================
        [`&-menu-mode ${listCls}`]: {
          position: "absolute"
        },
        // ========================== Motion ==========================
        [listCls]: {
          borderRadius: token2.borderRadiusLG,
          "&-motion": {
            transition: `all ${token2.motionDurationSlow}`,
            "&-enter, &-appear": {
              opacity: 0,
              transform: getCssVar("list-transform-start", true),
              "&-active": {
                opacity: 1,
                transform: `translate(0, 0)`
              }
            },
            "&-leave": {
              "&-active": {
                opacity: 0,
                transform: getCssVar("list-transform-start", true)
              }
            }
          }
        },
        // ======================== Placements ========================
        "&-top": {
          [listCls]: {
            bottom: getCssVar("list-trigger-offset", true)
          }
        },
        "&-bottom": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(0, calc(${unit(floatButtonSize)} * -1))`,
            top: getCssVar("list-trigger-offset", true)
          }
        },
        "&-left": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(${unit(floatButtonSize)}, 0)`,
            right: getCssVar("list-trigger-offset", true)
          }
        },
        "&-right": {
          [listCls]: {
            [getCssVar("list-transform-start")]: `translate(calc(${unit(floatButtonSize)} * -1), 0)`,
            left: getCssVar("list-trigger-offset", true)
          }
        }
      }
    ]
  };
};
var group_default3 = genGroupStyle4;

// node_modules/antd/es/float-button/style/index.js
var prepareComponentToken35 = () => ({});
var style_default41 = genStyleHooks("FloatButton", (token2) => {
  const {
    controlHeightLG,
    marginXXL,
    marginLG,
    fontSizeIcon,
    calc
  } = token2;
  const floatButtonToken = merge2(token2, {
    floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
    floatButtonSize: controlHeightLG,
    floatButtonInsetBlockEnd: marginXXL,
    floatButtonInsetInlineEnd: marginLG
  });
  return [button_default2(floatButtonToken), group_default3(floatButtonToken), initFadeMotion(token2)];
}, prepareComponentToken35, {
  // Should be higher than Button (-999)
  order: -998
});

// node_modules/antd/es/float-button/FloatButton.js
var floatButtonPrefixCls = "float-btn";
var InternalFloatButton = import_react163.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    type: type5 = "default",
    shape = "circle",
    icon,
    description,
    content,
    tooltip,
    badge = {},
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = import_react163.default.useContext(ConfigContext);
  const groupContext = import_react163.default.useContext(GroupContext2);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const {
    shape: contextShape,
    individual: contextIndividual,
    classNames: contextClassNames,
    styles: contextStyles
  } = groupContext || {};
  const mergedShape = contextShape || shape;
  const mergedIndividual = contextIndividual ?? true;
  const mergedContent = content ?? description;
  const mergedProps = {
    ...props,
    type: type5,
    shape: mergedShape
  };
  const [hashId, cssVarCls] = style_default41(prefixCls, rootCls);
  const floatButtonClassNames = import_react163.default.useMemo(() => ({
    icon: `${prefixCls}-icon`,
    content: `${prefixCls}-content`
  }), [prefixCls]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([floatButtonClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const mergedIcon = !mergedContent && !icon ? import_react163.default.createElement(FileTextOutlined_default, null) : icon;
  const [zIndex] = useZIndex("FloatButton", style2 == null ? void 0 : style2.zIndex);
  const mergedStyle = {
    ...style2,
    zIndex
  };
  const badgeProps = omit(badge, ["title", "children", "status", "text"]);
  const badgeNode = "badge" in props && import_react163.default.createElement(badge_default, {
    ...badgeProps,
    className: clsx(badgeProps.className, `${prefixCls}-badge`, {
      [`${prefixCls}-badge-dot`]: badgeProps.dot
    })
  });
  const tooltipProps = convertToTooltipProps_default(tooltip);
  if (true) {
    const warning5 = devUseWarning("FloatButton");
    true ? warning5(!(mergedShape === "circle" && mergedContent), "usage", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended.") : void 0;
    warning5.deprecated(!description, "description", "content");
  }
  let node2 = import_react163.default.createElement(Button_default, {
    ...restProps,
    ref,
    // Styles
    className: clsx(hashId, cssVarCls, rootCls, prefixCls, className, rootClassName, `${prefixCls}-${type5}`, `${prefixCls}-${mergedShape}`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-individual`]: mergedIndividual,
      [`${prefixCls}-icon-only`]: !mergedContent
    }),
    classNames: mergedClassNames,
    styles: mergedStyles,
    style: mergedStyle,
    shape: mergedShape,
    // Others
    type: type5,
    size: "large",
    icon: mergedIcon,
    _skipSemantic: true
  }, mergedContent, badgeNode);
  if (tooltipProps) {
    node2 = import_react163.default.createElement(tooltip_default, {
      ...tooltipProps
    }, node2);
  }
  return node2;
});
var FloatButton = InternalFloatButton;
if (true) {
  FloatButton.displayName = "FloatButton";
}
var FloatButton_default = FloatButton;

// node_modules/antd/es/float-button/BackTop.js
var defaultIcon = import_react164.default.createElement(VerticalAlignTopOutlined_default, null);
var BackTop2 = import_react164.default.forwardRef((props, ref) => {
  var _a;
  const {
    backTopIcon: contextIcon
  } = useComponentConfig("floatButton");
  const {
    prefixCls: customizePrefixCls,
    className,
    type: type5 = "default",
    shape = "circle",
    visibilityHeight = 400,
    icon,
    target,
    onClick,
    duration = 450,
    ...restProps
  } = props;
  const mergedIcon = icon ?? contextIcon ?? defaultIcon;
  const [visible, setVisible] = (0, import_react164.useState)(visibilityHeight === 0);
  const internalRef = import_react164.default.useRef(null);
  import_react164.default.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const getDefaultTarget2 = () => {
    var _a2;
    return ((_a2 = internalRef.current) == null ? void 0 : _a2.ownerDocument) || window;
  };
  const handleScroll = throttleByAnimationFrame_default((e3) => {
    const scrollTop = getScroll_default(e3.target);
    setVisible(scrollTop >= visibilityHeight);
  });
  (0, import_react164.useEffect)(() => {
    const getTarget = target || getDefaultTarget2;
    const container = getTarget();
    handleScroll({
      target: container
    });
    container == null ? void 0 : container.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container == null ? void 0 : container.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = (e3) => {
    scrollTo(0, {
      getContainer: target || getDefaultTarget2,
      duration
    });
    onClick == null ? void 0 : onClick(e3);
  };
  const {
    getPrefixCls
  } = (0, import_react164.useContext)(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const groupShape = (_a = (0, import_react164.useContext)(GroupContext2)) == null ? void 0 : _a.shape;
  const mergedShape = groupShape || shape;
  const contentProps = {
    prefixCls,
    icon: mergedIcon,
    type: type5,
    shape: mergedShape,
    ...restProps
  };
  return import_react164.default.createElement(es_default2, {
    visible,
    motionName: `${rootPrefixCls}-fade`
  }, ({
    className: motionClassName
  }, setRef) => import_react164.default.createElement(FloatButton_default, {
    ref: composeRef(internalRef, setRef),
    ...contentProps,
    onClick: scrollToTop,
    className: clsx(className, motionClassName)
  }));
});
if (true) {
  BackTop2.displayName = "FloatButton.BackTop";
}
var BackTop_default = BackTop2;

// node_modules/antd/es/float-button/FloatButtonGroup.js
var import_react165 = __toESM(require_react());
var FloatButtonGroup = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    classNames,
    styles,
    rootClassName,
    shape = "circle",
    type: type5 = "default",
    placement,
    icon = import_react165.default.createElement(FileTextOutlined_default, null),
    closeIcon,
    trigger,
    children,
    onOpenChange,
    open: customOpen,
    onClick: onTriggerButtonClick,
    ...floatButtonProps
  } = props;
  const {
    direction,
    getPrefixCls,
    closeIcon: contextCloseIcon,
    classNames: contextClassNames,
    styles: contextStyles,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("floatButtonGroup");
  const mergedCloseIcon = closeIcon ?? contextCloseIcon ?? import_react165.default.createElement(CloseOutlined_default, null);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default41(prefixCls, rootCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const isMenuMode = trigger && ["click", "hover"].includes(trigger);
  const [zIndex] = useZIndex("FloatButton", style2 == null ? void 0 : style2.zIndex);
  const floatButtonGroupRef = import_react165.default.useRef(null);
  const mergedPlacement = ["top", "left", "right", "bottom"].includes(placement) ? placement : "top";
  const [open3, setOpen] = useControlledState(false, customOpen);
  const hoverTrigger = trigger === "hover";
  const clickTrigger = trigger === "click";
  const triggerOpen = useEvent_default((nextOpen) => {
    if (open3 !== nextOpen) {
      setOpen(nextOpen);
      onOpenChange == null ? void 0 : onOpenChange(nextOpen);
    }
  });
  const onMouseEnter = () => {
    if (hoverTrigger) {
      triggerOpen(true);
    }
  };
  const onMouseLeave = () => {
    if (hoverTrigger) {
      triggerOpen(false);
    }
  };
  const onInternalTriggerButtonClick = (e3) => {
    if (clickTrigger) {
      triggerOpen(!open3);
    }
    onTriggerButtonClick == null ? void 0 : onTriggerButtonClick(e3);
  };
  import_react165.default.useEffect(() => {
    if (clickTrigger) {
      const onDocClick = (e3) => {
        var _a;
        if ((_a = floatButtonGroupRef.current) == null ? void 0 : _a.contains(e3.target)) {
          return;
        }
        triggerOpen(false);
      };
      document.addEventListener("click", onDocClick, {
        capture: true
      });
      return () => document.removeEventListener("click", onDocClick, {
        capture: true
      });
    }
  }, [clickTrigger]);
  if (true) {
    const warning5 = devUseWarning("FloatButton.Group");
    true ? warning5(!("open" in props) || !!trigger, "usage", "`open` need to be used together with `trigger`") : void 0;
  }
  const individual = shape === "circle";
  const mergedProps = {
    ...props,
    shape,
    type: type5,
    placement: mergedPlacement
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const listContext = import_react165.default.useMemo(() => ({
    shape,
    individual,
    classNames: {
      root: mergedClassNames.item,
      icon: mergedClassNames.itemIcon,
      content: mergedClassNames.itemContent
    },
    styles: {
      root: mergedStyles.item,
      icon: mergedStyles.itemIcon,
      content: mergedStyles.itemContent
    }
  }), [shape, individual, mergedClassNames, mergedStyles]);
  const triggerContext = import_react165.default.useMemo(() => ({
    ...listContext,
    individual: true,
    classNames: {
      root: mergedClassNames.trigger,
      icon: mergedClassNames.triggerIcon,
      content: mergedClassNames.triggerContent
    },
    styles: {
      root: mergedStyles.trigger,
      icon: mergedStyles.triggerIcon,
      content: mergedStyles.triggerContent
    }
  }), [listContext, mergedClassNames, mergedStyles]);
  let listNode;
  const listCls = `${groupPrefixCls}-list`;
  const renderList = (motionClassName) => {
    const vertical = mergedPlacement === "top" || mergedPlacement === "bottom";
    const sharedProps = {
      className: clsx(listCls, mergedClassNames.list, motionClassName),
      style: mergedStyles.list
    };
    if (individual) {
      listNode = import_react165.default.createElement(flex_default, {
        vertical,
        ...sharedProps
      }, children);
    } else {
      listNode = import_react165.default.createElement(space_default.Compact, {
        vertical,
        ...sharedProps
      }, children);
    }
    return listNode;
  };
  return import_react165.default.createElement(GroupContext2.Provider, {
    value: listContext
  }, import_react165.default.createElement("div", {
    className: clsx(groupPrefixCls, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, className, rootClassName, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-individual`]: individual,
      [`${groupPrefixCls}-${mergedPlacement}`]: isMenuMode,
      [`${groupPrefixCls}-menu-mode`]: isMenuMode
    }),
    style: {
      ...contextStyle,
      zIndex,
      ...mergedStyles.root,
      ...style2
    },
    // ref
    ref: floatButtonGroupRef,
    // Hover trigger
    onMouseEnter,
    onMouseLeave
  }, isMenuMode ? import_react165.default.createElement(es_default2, {
    visible: open3,
    motionName: `${listCls}-motion`
  }, ({
    className: motionClassName
  }) => renderList(motionClassName)) : renderList(), isMenuMode && import_react165.default.createElement(GroupContext2.Provider, {
    value: triggerContext
  }, import_react165.default.createElement(FloatButton_default, {
    type: type5,
    icon: open3 ? mergedCloseIcon : icon,
    "aria-label": props["aria-label"],
    className: `${groupPrefixCls}-trigger`,
    onClick: onInternalTriggerButtonClick,
    ...floatButtonProps
  }))));
};
var FloatButtonGroup_default = FloatButtonGroup;

// node_modules/antd/es/float-button/PurePanel.js
var React425 = __toESM(require_react());
var PureFloatButton = ({
  backTop,
  ...props
}) => backTop ? React425.createElement(BackTop_default, {
  ...props,
  visibilityHeight: 0
}) : React425.createElement(FloatButton_default, {
  ...props
});
var PurePanel12 = ({
  className,
  items,
  classNames: cls,
  styles,
  prefixCls: customizePrefixCls,
  ...restProps
}) => {
  const {
    getPrefixCls
  } = React425.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const pureCls = `${prefixCls}-pure`;
  if (items) {
    return React425.createElement(FloatButtonGroup_default, {
      className: clsx(className, pureCls),
      classNames: cls,
      styles,
      ...restProps
    }, items.map((item, index2) => React425.createElement(PureFloatButton, {
      key: index2,
      ...item
    })));
  }
  return React425.createElement(PureFloatButton, {
    className: clsx(className, pureCls),
    classNames: cls,
    styles,
    ...restProps
  });
};
var PurePanel_default6 = PurePanel12;

// node_modules/antd/es/float-button/index.js
FloatButton_default.BackTop = BackTop_default;
FloatButton_default.Group = FloatButtonGroup_default;
FloatButton_default._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default6;
var float_button_default = FloatButton_default;

// node_modules/antd/es/form/ErrorList.js
var React427 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useDebounce.js
var React426 = __toESM(require_react());
function useDebounce(value) {
  const [cacheValue, setCacheValue] = React426.useState(value);
  React426.useEffect(() => {
    const timeout = setTimeout(() => {
      setCacheValue(value);
    }, value.length ? 0 : 10);
    return () => {
      clearTimeout(timeout);
    };
  }, [value]);
  return cacheValue;
}

// node_modules/antd/es/form/style/explain.js
var genFormValidateMotionStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const helpCls = `${componentCls}-show-help`;
  const helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      // Explain holder
      transition: `opacity ${token2.motionDurationFast} ${token2.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationFast} ${token2.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: `translateY(-5px)`,
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: `translateY(-5px)`
        }
      }
    }
  };
};
var explain_default = genFormValidateMotionStyle;

// node_modules/antd/es/form/style/index.js
var resetForm = (token2) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token2.marginLG,
    padding: 0,
    color: token2.colorTextDescription,
    fontSize: token2.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
    outline: 0,
    boxShadow: `0 0 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight
  }
});
var genFormSize = (token2, height) => {
  const {
    formItemCls
  } = token2;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
};
var genFormStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [token2.componentCls]: {
      ...resetComponent(token2),
      ...resetForm(token2),
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token2.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": {
        ...genFormSize(token2, token2.controlHeightSM)
      },
      "&-large": {
        ...genFormSize(token2, token2.controlHeightLG)
      }
    }
  };
};
var genFormItemStyle = (token2) => {
  const {
    formItemCls,
    iconCls,
    rootPrefixCls,
    antCls,
    labelRequiredMarkColor,
    labelColor,
    labelFontSize,
    labelHeight,
    labelColonMarginInlineStart,
    labelColonMarginInlineEnd,
    itemMarginBottom
  } = token2;
  return {
    [formItemCls]: {
      ...resetComponent(token2),
      marginBottom: itemMarginBottom,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden${antCls}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token2.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token2.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${formItemCls}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: token2.lineHeight,
          whiteSpace: "unset",
          "> label": {
            verticalAlign: "middle",
            textWrap: "balance"
          }
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: labelHeight,
          color: labelColor,
          fontSize: labelFontSize,
          [`> ${iconCls}`]: {
            fontSize: token2.fontSize,
            verticalAlign: "top"
          },
          [`&${formItemCls}-required`]: {
            "&::before": {
              display: "inline-block",
              marginInlineEnd: token2.marginXXS,
              color: labelRequiredMarkColor,
              fontSize: token2.fontSize,
              fontFamily: "SimSun, sans-serif",
              lineHeight: 1,
              content: '"*"'
            },
            [`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: {
              "&::before": {
                display: "none"
              }
            }
          },
          // Optional mark
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token2.marginXXS,
            color: token2.colorTextDescription,
            [`&${formItemCls}-required-mark-hidden`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-tooltip`]: {
            color: token2.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token2.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: labelColonMarginInlineStart,
            marginInlineEnd: labelColonMarginInlineEnd
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${formItemCls}-control`]: {
        ["--ant-display"]: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token2.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%",
            // Fix https://github.com/ant-design/ant-design/issues/54042
            // Remove impact of whitespaces
            [`&:has(> ${antCls}-switch:only-child, > ${antCls}-rate:only-child)`]: {
              display: "flex",
              alignItems: "center"
            }
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [formItemCls]: {
        "&-additional": {
          display: "flex",
          flexDirection: "column"
        },
        "&-explain, &-extra": {
          clear: "both",
          color: token2.colorTextDescription,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token2.controlHeightSM,
          transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token2.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token2.motionDurationMid,
        animationTimingFunction: token2.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token2.colorSuccess
        },
        "&-error": {
          color: token2.colorError
        },
        "&-warning": {
          color: token2.colorWarning
        },
        "&-validating": {
          color: token2.colorPrimary
        }
      }
    }
  };
};
var makeVerticalLayoutLabel = (token2) => ({
  padding: token2.verticalLabelPadding,
  margin: token2.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
});
var genHorizontalStyle2 = (token2) => {
  const {
    antCls,
    formItemCls
  } = token2;
  return {
    [`${formItemCls}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
        [`& + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      },
      [`${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
    }
  };
};
var genInlineStyle = (token2) => {
  const {
    componentCls,
    formItemCls,
    inlineItemMarginBottom
  } = token2;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [`${formItemCls}-inline`]: {
        flex: "none",
        marginInlineEnd: token2.margin,
        marginBottom: inlineItemMarginBottom,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
};
var makeVerticalLayout = (token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${componentCls}:not(${componentCls}-inline)`]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label, ${formItemCls}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
};
var genVerticalStyle2 = (token2) => {
  const {
    componentCls,
    formItemCls,
    antCls
  } = token2;
  return {
    [`${formItemCls}-vertical`]: {
      [`${formItemCls}-row`]: {
        flexDirection: "column"
      },
      [`${formItemCls}-label > label`]: {
        height: "auto"
      },
      [`${formItemCls}-control`]: {
        width: "100%"
      },
      [`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
    },
    [`@media (max-width: ${unit(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    }],
    [`@media (max-width: ${unit(token2.screenSMMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    },
    [`@media (max-width: ${unit(token2.screenMDMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    },
    [`@media (max-width: ${unit(token2.screenLGMax)})`]: {
      [componentCls]: {
        [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
          [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    }
  };
};
var prepareComponentToken36 = (token2) => ({
  labelRequiredMarkColor: token2.colorError,
  labelColor: token2.colorTextHeading,
  labelFontSize: token2.fontSize,
  labelHeight: token2.controlHeight,
  labelColonMarginInlineStart: token2.marginXXS / 2,
  labelColonMarginInlineEnd: token2.marginXS,
  itemMarginBottom: token2.marginLG,
  verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
  verticalLabelMargin: 0,
  inlineItemMarginBottom: 0
});
var prepareToken4 = (token2, rootPrefixCls) => {
  const formToken = merge2(token2, {
    formItemCls: `${token2.componentCls}-item`,
    rootPrefixCls
  });
  return formToken;
};
var style_default42 = genStyleHooks("Form", (token2, {
  rootPrefixCls
}) => {
  const formToken = prepareToken4(token2, rootPrefixCls);
  return [genFormStyle(formToken), genFormItemStyle(formToken), explain_default(formToken), genHorizontalStyle2(formToken), genInlineStyle(formToken), genVerticalStyle2(formToken), collapse_default(formToken), zoomIn];
}, prepareComponentToken36, {
  // Let From style before the Grid
  // ref https://github.com/ant-design/ant-design/issues/44386
  order: -1e3
});

// node_modules/antd/es/form/ErrorList.js
var EMPTY_LIST4 = [];
function toErrorEntity(error, prefix2, errorStatus, index2 = 0) {
  return {
    key: typeof error === "string" ? error : `${prefix2}-${index2}`,
    error,
    errorStatus
  };
}
var ErrorList = ({
  help,
  helpStatus,
  errors = EMPTY_LIST4,
  warnings = EMPTY_LIST4,
  className: rootClassName,
  fieldId,
  onVisibleChanged
}) => {
  const {
    prefixCls
  } = React427.useContext(FormItemPrefixContext);
  const baseClassName = `${prefixCls}-item-explain`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default42(prefixCls, rootCls);
  const collapseMotion = React427.useMemo(() => motion_default(prefixCls), [prefixCls]);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const fullKeyList = React427.useMemo(() => {
    if (isNonNullable_default(help)) {
      return [toErrorEntity(help, "help", helpStatus)];
    }
    return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning5, index2) => toErrorEntity(warning5, "warning", "warning", index2))));
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  const filledKeyFullKeyList = React427.useMemo(() => {
    const keysCount = {};
    fullKeyList.forEach(({
      key
    }) => {
      keysCount[key] = (keysCount[key] || 0) + 1;
    });
    return fullKeyList.map((entity, index2) => ({
      ...entity,
      key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index2}` : entity.key
    }));
  }, [fullKeyList]);
  const helpProps = {};
  if (fieldId) {
    helpProps.id = `${fieldId}_help`;
  }
  return React427.createElement(es_default2, {
    motionDeadline: collapseMotion.motionDeadline,
    motionName: `${prefixCls}-show-help`,
    visible: !!filledKeyFullKeyList.length,
    onVisibleChanged
  }, (holderProps) => {
    const {
      className: holderClassName,
      style: holderStyle
    } = holderProps;
    return React427.createElement("div", {
      ...helpProps,
      className: clsx(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
      style: holderStyle
    }, React427.createElement(CSSMotionList_default, {
      keys: filledKeyFullKeyList,
      ...motion_default(prefixCls),
      motionName: `${prefixCls}-show-help-item`,
      component: false
    }, (itemProps) => {
      const {
        key,
        error,
        errorStatus,
        className: itemClassName,
        style: itemStyle
      } = itemProps;
      return React427.createElement("div", {
        key,
        className: clsx(itemClassName, {
          [`${baseClassName}-${errorStatus}`]: errorStatus
        }),
        style: itemStyle
      }, error);
    }));
  });
};
var ErrorList_default = ErrorList;

// node_modules/antd/es/form/Form.js
var React429 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useFormWarning.js
var React428 = __toESM(require_react());
var names = {};
function useFormWarning({
  name
}) {
  const warning5 = devUseWarning("Form");
  React428.useEffect(() => {
    if (name) {
      names[name] = (names[name] || 0) + 1;
      true ? warning5(names[name] <= 1, "usage", "There exist multiple Form with same `name`.") : void 0;
      return () => {
        names[name] -= 1;
      };
    }
  }, [name]);
}

// node_modules/antd/es/form/Form.js
var InternalForm2 = (props, ref) => {
  const contextDisabled = React429.useContext(DisabledContext_default);
  const {
    getPrefixCls,
    direction,
    requiredMark: contextRequiredMark,
    colon: contextColon,
    scrollToFirstError: contextScrollToFirstError,
    className: contextClassName,
    style: contextStyle,
    styles: contextStyles,
    classNames: contextClassNames
  } = useComponentConfig("form");
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    size,
    disabled = contextDisabled,
    form,
    colon,
    labelAlign,
    labelWrap,
    labelCol,
    wrapperCol,
    layout = "horizontal",
    scrollToFirstError,
    requiredMark,
    onFinishFailed,
    name,
    style: style2,
    feedbackIcons,
    variant,
    classNames,
    styles,
    ...restFormProps
  } = props;
  const mergedSize = useSize_default(size);
  const contextValidateMessages = React429.useContext(validateMessagesContext_default);
  if (true) {
    useFormWarning(props);
  }
  const mergedRequiredMark = React429.useMemo(() => {
    if (requiredMark !== void 0) {
      return requiredMark;
    }
    if (contextRequiredMark !== void 0) {
      return contextRequiredMark;
    }
    return true;
  }, [requiredMark, contextRequiredMark]);
  const mergedColon = colon ?? contextColon;
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default42(prefixCls, rootCls);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled,
    layout,
    colon: mergedColon,
    requiredMark: mergedRequiredMark
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const formClassName = clsx(prefixCls, `${prefixCls}-${layout}`, {
    [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
    // todo: remove in next major version
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${mergedSize}`]: mergedSize
  }, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName, mergedClassNames.root);
  const [wrapForm] = useForm2(form);
  const {
    __INTERNAL__
  } = wrapForm;
  __INTERNAL__.name = name;
  const formContextValue = React429.useMemo(() => ({
    name,
    labelAlign,
    labelCol,
    labelWrap,
    wrapperCol,
    layout,
    colon: mergedColon,
    requiredMark: mergedRequiredMark,
    itemRef: __INTERNAL__.itemRef,
    form: wrapForm,
    feedbackIcons,
    classNames: mergedClassNames,
    styles: mergedStyles
  }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons, mergedClassNames, mergedStyles]);
  const nativeElementRef = React429.useRef(null);
  React429.useImperativeHandle(ref, () => {
    var _a;
    return {
      ...wrapForm,
      nativeElement: (_a = nativeElementRef.current) == null ? void 0 : _a.nativeElement
    };
  });
  const scrollToField = (options, fieldName) => {
    if (options) {
      let defaultScrollToFirstError = {
        block: "nearest"
      };
      if (typeof options === "object") {
        defaultScrollToFirstError = {
          ...defaultScrollToFirstError,
          ...options
        };
      }
      wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
    }
  };
  const onInternalFinishFailed = (errorInfo) => {
    onFinishFailed == null ? void 0 : onFinishFailed(errorInfo);
    if (errorInfo.errorFields.length) {
      const fieldName = errorInfo.errorFields[0].name;
      if (scrollToFirstError !== void 0) {
        scrollToField(scrollToFirstError, fieldName);
        return;
      }
      if (contextScrollToFirstError !== void 0) {
        scrollToField(contextScrollToFirstError, fieldName);
      }
    }
  };
  return React429.createElement(VariantContext.Provider, {
    value: variant
  }, React429.createElement(DisabledContextProvider, {
    disabled
  }, React429.createElement(SizeContext_default.Provider, {
    value: mergedSize
  }, React429.createElement(FormProvider2, {
    // This is not list in API, we pass with spread
    validateMessages: contextValidateMessages
  }, React429.createElement(FormContext2.Provider, {
    value: formContextValue
  }, React429.createElement(NoFormStyle, {
    status: true
  }, React429.createElement(es_default9, {
    id: name,
    ...restFormProps,
    name,
    onFinishFailed: onInternalFinishFailed,
    form: wrapForm,
    ref: nativeElementRef,
    style: {
      ...mergedStyles == null ? void 0 : mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    className: formClassName
  })))))));
};
var Form2 = React429.forwardRef(InternalForm2);
if (true) {
  Form2.displayName = "Form";
}
var Form_default2 = Form2;

// node_modules/antd/es/form/FormItem/index.js
var React437 = __toESM(require_react());

// node_modules/antd/es/form/hooks/useChildren.js
function useChildren2(children) {
  if (typeof children === "function") {
    return children;
  }
  const childList = toArray(children);
  return childList.length <= 1 ? childList[0] : childList;
}

// node_modules/antd/es/form/hooks/useFormItemStatus.js
var React430 = __toESM(require_react());
var useFormItemStatus = () => {
  const {
    status,
    errors = [],
    warnings = []
  } = React430.useContext(FormItemInputContext);
  if (true) {
    const warning5 = devUseWarning("Form.Item");
    true ? warning5(status !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus") : void 0;
  }
  return {
    status,
    errors,
    warnings
  };
};
useFormItemStatus.Context = FormItemInputContext;
var useFormItemStatus_default = useFormItemStatus;

// node_modules/antd/es/form/hooks/useFrameState.js
var React431 = __toESM(require_react());
function useFrameState(defaultValue) {
  const [value, setValue] = React431.useState(defaultValue);
  const frameRef = React431.useRef(null);
  const batchRef = React431.useRef([]);
  const destroyRef = React431.useRef(false);
  React431.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
      raf_default.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = raf_default(() => {
        frameRef.current = null;
        setValue((prevValue) => {
          let current = prevValue;
          batchRef.current.forEach((func) => {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  return [value, setFrameValue];
}

// node_modules/antd/es/form/hooks/useItemRef.js
var React432 = __toESM(require_react());
function useItemRef() {
  const {
    itemRef
  } = React432.useContext(FormContext2);
  const cacheRef = React432.useRef({});
  function getRef(name, children) {
    const childrenRef = children && typeof children === "object" && getNodeRef(children);
    const nameStr = name.join("_");
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
    }
    return cacheRef.current.ref;
  }
  return getRef;
}

// node_modules/antd/es/form/FormItem/ItemHolder.js
var React436 = __toESM(require_react());

// node_modules/antd/es/form/FormItemInput.js
var React433 = __toESM(require_react());

// node_modules/antd/es/form/style/fallbackCmp.js
var genFallbackStyle = (token2) => {
  const {
    formItemCls
  } = token2;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${formItemCls}-control`]: {
        display: "flex"
      }
    }
  };
};
var fallbackCmp_default = genSubStyleComponent(["Form", "item-item"], (token2, {
  rootPrefixCls
}) => {
  const formToken = prepareToken4(token2, rootPrefixCls);
  return genFallbackStyle(formToken);
});

// node_modules/antd/es/form/FormItemInput.js
var GRID_MAX = 24;
var FormItemInput = (props) => {
  const {
    prefixCls,
    status,
    labelCol,
    wrapperCol,
    children,
    errors,
    warnings,
    _internalItemRender: formItemRender,
    extra,
    help,
    fieldId,
    marginBottom,
    onErrorVisibleChanged,
    label
  } = props;
  const baseClassName = `${prefixCls}-item`;
  const formContext = React433.useContext(FormContext2);
  const {
    classNames: contextClassNames,
    styles: contextStyles
  } = formContext;
  const mergedWrapperCol = React433.useMemo(() => {
    let mergedWrapper = {
      ...wrapperCol || formContext.wrapperCol || {}
    };
    if (label === null && !labelCol && !wrapperCol && formContext.labelCol) {
      const list = [void 0, "xs", "sm", "md", "lg", "xl", "xxl"];
      list.forEach((size) => {
        const _size = size ? [size] : [];
        const formLabel = get(formContext.labelCol, _size);
        const formLabelObj = typeof formLabel === "object" ? formLabel : {};
        const wrapper = get(mergedWrapper, _size);
        const wrapperObj = typeof wrapper === "object" ? wrapper : {};
        if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) {
          mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
        }
      });
    }
    return mergedWrapper;
  }, [wrapperCol, formContext.wrapperCol, formContext.labelCol, label, labelCol]);
  const className = clsx(`${baseClassName}-control`, mergedWrapperCol.className);
  const subFormContext = React433.useMemo(() => {
    const {
      labelCol: _labelCol,
      wrapperCol: _wrapperCol,
      ...rest
    } = formContext;
    return rest;
  }, [formContext]);
  const extraRef = React433.useRef(null);
  const [extraHeight, setExtraHeight] = React433.useState(0);
  useLayoutEffect_default(() => {
    if (extra && extraRef.current) {
      setExtraHeight(extraRef.current.clientHeight);
    } else {
      setExtraHeight(0);
    }
  }, [extra]);
  const inputDom = React433.createElement("div", {
    className: `${baseClassName}-control-input`
  }, React433.createElement("div", {
    className: clsx(`${baseClassName}-control-input-content`, contextClassNames == null ? void 0 : contextClassNames.content),
    style: contextStyles == null ? void 0 : contextStyles.content
  }, children));
  const formItemContext = React433.useMemo(() => ({
    prefixCls,
    status
  }), [prefixCls, status]);
  const errorListDom = marginBottom !== null || errors.length || warnings.length ? React433.createElement(FormItemPrefixContext.Provider, {
    value: formItemContext
  }, React433.createElement(ErrorList_default, {
    fieldId,
    errors,
    warnings,
    help,
    helpStatus: status,
    className: `${baseClassName}-explain-connected`,
    onVisibleChanged: onErrorVisibleChanged
  })) : null;
  const extraProps = {};
  if (fieldId) {
    extraProps.id = `${fieldId}_extra`;
  }
  const extraDom = extra ? React433.createElement("div", {
    ...extraProps,
    className: `${baseClassName}-extra`,
    ref: extraRef
  }, extra) : null;
  const additionalDom = errorListDom || extraDom ? React433.createElement("div", {
    className: `${baseClassName}-additional`,
    style: marginBottom ? {
      minHeight: marginBottom + extraHeight
    } : {}
  }, errorListDom, extraDom) : null;
  const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) : React433.createElement(React433.Fragment, null, inputDom, additionalDom);
  return React433.createElement(FormContext2.Provider, {
    value: subFormContext
  }, React433.createElement(col_default, {
    ...mergedWrapperCol,
    className
  }, dom), React433.createElement(fallbackCmp_default, {
    prefixCls
  }));
};
var FormItemInput_default = FormItemInput;

// node_modules/antd/es/form/FormItemLabel.js
var React434 = __toESM(require_react());
var FormItemLabel = ({
  prefixCls,
  label,
  htmlFor,
  labelCol,
  labelAlign,
  colon,
  required: required5,
  requiredMark,
  tooltip,
  vertical
}) => {
  var _a;
  const [formLocale] = useLocale_default("Form");
  const {
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon,
    classNames: contextClassNames,
    styles: contextStyles
  } = React434.useContext(FormContext2);
  if (!label) {
    return null;
  }
  const mergedLabelCol = labelCol || contextLabelCol || {};
  const mergedLabelAlign = labelAlign || contextLabelAlign;
  const labelClsBasic = `${prefixCls}-item-label`;
  const labelColClassName = clsx(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
    [`${labelClsBasic}-wrap`]: !!labelWrap
  });
  let labelChildren = label;
  const computedColon = colon === true || contextColon !== false && colon !== false;
  const haveColon = computedColon && !vertical;
  if (haveColon && typeof label === "string" && label.trim()) {
    labelChildren = label.replace(/[:|]\s*$/, "");
  }
  const tooltipProps = convertToTooltipProps_default(tooltip);
  if (tooltipProps) {
    const {
      icon = React434.createElement(QuestionCircleOutlined_default, null),
      ...restTooltipProps
    } = tooltipProps;
    const tooltipNode = React434.createElement(tooltip_default, {
      ...restTooltipProps
    }, React434.cloneElement(icon, {
      className: `${prefixCls}-item-tooltip`,
      title: "",
      onClick: (e3) => {
        e3.preventDefault();
      },
      tabIndex: null
    }));
    labelChildren = React434.createElement(React434.Fragment, null, labelChildren, tooltipNode);
  }
  const isOptionalMark = requiredMark === "optional";
  const isRenderMark = typeof requiredMark === "function";
  const hideRequiredMark = requiredMark === false;
  if (isRenderMark) {
    labelChildren = requiredMark(labelChildren, {
      required: !!required5
    });
  } else if (isOptionalMark && !required5) {
    labelChildren = React434.createElement(React434.Fragment, null, labelChildren, React434.createElement("span", {
      className: `${prefixCls}-item-optional`,
      title: ""
    }, (formLocale == null ? void 0 : formLocale.optional) || ((_a = en_US_default6.Form) == null ? void 0 : _a.optional)));
  }
  let markType;
  if (hideRequiredMark) {
    markType = "hidden";
  } else if (isOptionalMark || isRenderMark) {
    markType = "optional";
  }
  const labelClassName = clsx(contextClassNames == null ? void 0 : contextClassNames.label, {
    [`${prefixCls}-item-required`]: required5,
    [`${prefixCls}-item-required-mark-${markType}`]: markType,
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return React434.createElement(col_default, {
    ...mergedLabelCol,
    className: labelColClassName
  }, React434.createElement("label", {
    htmlFor,
    className: labelClassName,
    style: contextStyles == null ? void 0 : contextStyles.label,
    title: typeof label === "string" ? label : ""
  }, labelChildren));
};
var FormItemLabel_default = FormItemLabel;

// node_modules/antd/es/form/FormItem/StatusProvider.js
var React435 = __toESM(require_react());
var iconMap = {
  success: CheckCircleFilled_default,
  warning: ExclamationCircleFilled_default,
  error: CloseCircleFilled_default,
  validating: LoadingOutlined_default
};
function StatusProvider({
  children,
  errors,
  warnings,
  hasFeedback,
  validateStatus,
  prefixCls,
  meta,
  noStyle,
  name
}) {
  const itemPrefixCls = `${prefixCls}-item`;
  const {
    feedbackIcons
  } = React435.useContext(FormContext2);
  const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
  const {
    isFormItemInput: parentIsFormItemInput,
    status: parentStatus,
    hasFeedback: parentHasFeedback,
    feedbackIcon: parentFeedbackIcon,
    name: parentName
  } = React435.useContext(FormItemInputContext);
  const formItemStatusContext = React435.useMemo(() => {
    var _a;
    let feedbackIcon;
    if (hasFeedback) {
      const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
      const customIconNode = mergedValidateStatus && ((_a = customIcons == null ? void 0 : customIcons({
        status: mergedValidateStatus,
        errors,
        warnings
      })) == null ? void 0 : _a[mergedValidateStatus]);
      const IconNode2 = mergedValidateStatus ? iconMap[mergedValidateStatus] : null;
      feedbackIcon = customIconNode !== false && IconNode2 ? React435.createElement("span", {
        className: clsx(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
      }, customIconNode || React435.createElement(IconNode2, null)) : null;
    }
    const context = {
      status: mergedValidateStatus || "",
      errors,
      warnings,
      hasFeedback: !!hasFeedback,
      feedbackIcon,
      isFormItemInput: true,
      name
    };
    if (noStyle) {
      context.status = (mergedValidateStatus ?? parentStatus) || "";
      context.isFormItemInput = parentIsFormItemInput;
      context.hasFeedback = !!(hasFeedback ?? parentHasFeedback);
      context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
      context.name = name ?? parentName;
    }
    return context;
  }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
  return React435.createElement(FormItemInputContext.Provider, {
    value: formItemStatusContext
  }, children);
}
var StatusProvider_default = StatusProvider;

// node_modules/antd/es/form/FormItem/ItemHolder.js
function ItemHolder(props) {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    help,
    errors,
    warnings,
    validateStatus,
    meta,
    hasFeedback,
    hidden,
    children,
    fieldId,
    required: required5,
    isRequired,
    onSubItemMetaChange,
    layout: propsLayout,
    name,
    ...restProps
  } = props;
  const itemPrefixCls = `${prefixCls}-item`;
  const {
    requiredMark,
    layout: formLayout
  } = React436.useContext(FormContext2);
  const layout = propsLayout || formLayout;
  const vertical = layout === "vertical";
  const itemRef = React436.useRef(null);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const hasHelp = isNonNullable_default(help);
  const hasError = !!(hasHelp || errors.length || warnings.length);
  const isOnScreen = !!itemRef.current && isVisible_default(itemRef.current);
  const [marginBottom, setMarginBottom] = React436.useState(null);
  useLayoutEffect_default(() => {
    if (hasError && itemRef.current) {
      const itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(Number.parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError, isOnScreen]);
  const onErrorVisibleChanged = (nextVisible) => {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  };
  const getValidateState = (isDebounce = false) => {
    const _errors = isDebounce ? debounceErrors : meta.errors;
    const _warnings = isDebounce ? debounceWarnings : meta.warnings;
    return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
  };
  const mergedValidateStatus = getValidateState();
  const itemClassName = clsx(itemPrefixCls, className, rootClassName, {
    [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
    // Status
    [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
    [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
    [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
    [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
    [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
    [`${itemPrefixCls}-hidden`]: hidden,
    // Layout
    [`${itemPrefixCls}-${layout}`]: layout
  });
  return React436.createElement("div", {
    className: itemClassName,
    style: style2,
    ref: itemRef
  }, React436.createElement(row_default, {
    className: `${itemPrefixCls}-row`,
    ...omit(restProps, [
      "_internalItemRender",
      "colon",
      "dependencies",
      "extra",
      "fieldKey",
      "getValueFromEvent",
      "getValueProps",
      "htmlFor",
      "id",
      // It is deprecated because `htmlFor` is its replacement.
      "initialValue",
      "isListField",
      "label",
      "labelAlign",
      "labelCol",
      "labelWrap",
      "messageVariables",
      "name",
      "normalize",
      "noStyle",
      "preserve",
      "requiredMark",
      "rules",
      "shouldUpdate",
      "trigger",
      "tooltip",
      "validateFirst",
      "validateTrigger",
      "valuePropName",
      "wrapperCol",
      "validateDebounce"
    ])
  }, React436.createElement(FormItemLabel_default, {
    htmlFor: fieldId,
    ...props,
    requiredMark,
    required: required5 ?? isRequired,
    prefixCls,
    vertical
  }), React436.createElement(FormItemInput_default, {
    ...props,
    ...meta,
    errors: debounceErrors,
    warnings: debounceWarnings,
    prefixCls,
    status: mergedValidateStatus,
    help,
    marginBottom,
    onErrorVisibleChanged
  }, React436.createElement(NoStyleItemContext.Provider, {
    value: onSubItemMetaChange
  }, React436.createElement(StatusProvider_default, {
    prefixCls,
    meta,
    errors: meta.errors,
    warnings: meta.warnings,
    hasFeedback,
    // Already calculated
    validateStatus: mergedValidateStatus,
    name
  }, children)))), !!marginBottom && React436.createElement("div", {
    className: `${itemPrefixCls}-margin-offset`,
    style: {
      marginBottom: -marginBottom
    }
  }));
}

// node_modules/antd/es/form/FormItem/index.js
var NAME_SPLIT = "__SPLIT__";
function isSimilarControl(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  return keysA.length === keysB.length && keysA.every((key) => {
    const propValueA = a[key];
    const propValueB = b[key];
    return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
  });
}
var MemoInput = React437.memo((props) => props.children, (prev2, next2) => isSimilarControl(prev2.control, next2.control) && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: [],
    validated: false
  };
}
function InternalFormItem(props) {
  const {
    name,
    noStyle,
    className,
    dependencies,
    prefixCls: customizePrefixCls,
    shouldUpdate,
    rules,
    children,
    required: required5,
    label,
    messageVariables,
    trigger = "onChange",
    validateTrigger,
    hidden,
    help,
    layout
  } = props;
  const {
    getPrefixCls
  } = React437.useContext(ConfigContext);
  const {
    name: formName
  } = React437.useContext(FormContext2);
  const mergedChildren = useChildren2(children);
  const isRenderProps = typeof mergedChildren === "function";
  const notifyParentMetaChange = React437.useContext(NoStyleItemContext);
  const {
    validateTrigger: contextValidateTrigger
  } = React437.useContext(FieldContext_default);
  const mergedValidateTrigger = isNonNullable_default(validateTrigger) ? validateTrigger : contextValidateTrigger;
  const hasName = isNonNullable_default(name);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default42(prefixCls, rootCls);
  const warning5 = devUseWarning("Form.Item");
  if (true) {
    true ? warning5(name !== null, "usage", "`null` is passed as `name` property") : void 0;
  }
  const listContext = React437.useContext(ListContext_default);
  const fieldKeyPathRef = React437.useRef(null);
  const [subFieldErrors, setSubFieldErrors] = useFrameState({});
  const [meta, setMeta] = useSafeState(() => genEmptyMeta());
  const onMetaChange = (nextMeta) => {
    const keyInfo = listContext == null ? void 0 : listContext.getKey(nextMeta.name);
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    if (noStyle && help !== false && notifyParentMetaChange) {
      let namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== void 0) {
          const [fieldKey, restPath] = keyInfo;
          namePath = [fieldKey].concat(_toConsumableArray(restPath));
          fieldKeyPathRef.current = namePath;
        }
      } else {
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  };
  const onSubItemMetaChange = (subMeta, uniqueKeys) => {
    setSubFieldErrors((prevSubFieldErrors) => {
      const clone = {
        ...prevSubFieldErrors
      };
      const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
      const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        delete clone[mergedNameKey];
      } else {
        clone[mergedNameKey] = subMeta;
      }
      return clone;
    });
  };
  const [mergedErrors, mergedWarnings] = React437.useMemo(() => {
    const errorList = _toConsumableArray(meta.errors);
    const warningList = _toConsumableArray(meta.warnings);
    Object.values(subFieldErrors).forEach((subFieldError) => {
      errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
      warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
    });
    return [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]);
  const getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return React437.createElement(StatusProvider_default, {
        prefixCls,
        hasFeedback: props.hasFeedback,
        validateStatus: props.validateStatus,
        meta,
        errors: mergedErrors,
        warnings: mergedWarnings,
        noStyle: true,
        name
      }, baseChildren);
    }
    return React437.createElement(ItemHolder, {
      key: "row",
      ...props,
      className: clsx(className, cssVarCls, rootCls, hashId),
      prefixCls,
      fieldId,
      isRequired,
      errors: mergedErrors,
      warnings: mergedWarnings,
      meta,
      onSubItemMetaChange,
      layout,
      name
    }, baseChildren);
  }
  if (!hasName && !isRenderProps && !dependencies) {
    return renderLayout(mergedChildren);
  }
  let variables = {};
  if (typeof label === "string") {
    variables.label = label;
  } else if (name) {
    variables.label = String(name);
  }
  if (messageVariables) {
    variables = {
      ...variables,
      ...messageVariables
    };
  }
  return React437.createElement(Field_default, {
    ...props,
    messageVariables: variables,
    trigger,
    validateTrigger: mergedValidateTrigger,
    onMetaChange
  }, (control, renderMeta, context) => {
    const mergedName = toArray6(name).length && renderMeta ? renderMeta.name : [];
    const fieldId = getFieldId(mergedName, formName);
    const isRequired = required5 !== void 0 ? required5 : !!(rules == null ? void 0 : rules.some((rule) => {
      if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
        return true;
      }
      if (typeof rule === "function") {
        const ruleEntity = rule(context);
        return (ruleEntity == null ? void 0 : ruleEntity.required) && !(ruleEntity == null ? void 0 : ruleEntity.warningOnly);
      }
      return false;
    }));
    const mergedControl = {
      ...control
    };
    let childNode = null;
    true ? warning5(!(shouldUpdate && dependencies), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps.") : void 0;
    if (Array.isArray(mergedChildren) && hasName) {
      true ? warning5(false, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item.") : void 0;
      childNode = mergedChildren;
    } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) {
      true ? warning5(!!(shouldUpdate || dependencies), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`.") : void 0;
      true ? warning5(!hasName, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.") : void 0;
    } else if (dependencies && !isRenderProps && !hasName) {
      true ? warning5(false, "usage", "Must set `name` or use a render function when `dependencies` is set.") : void 0;
    } else if (React437.isValidElement(mergedChildren)) {
      true ? warning5(mergedChildren.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.") : void 0;
      const childProps = {
        ...mergedChildren.props,
        ...mergedControl
      };
      if (!childProps.id) {
        childProps.id = fieldId;
      }
      if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
        const describedbyArr = [];
        if (help || mergedErrors.length > 0) {
          describedbyArr.push(`${fieldId}_help`);
        }
        if (props.extra) {
          describedbyArr.push(`${fieldId}_extra`);
        }
        childProps["aria-describedby"] = describedbyArr.join(" ");
      }
      if (mergedErrors.length > 0) {
        childProps["aria-invalid"] = "true";
      }
      if (isRequired) {
        childProps["aria-required"] = "true";
      }
      if (supportRef(mergedChildren)) {
        childProps.ref = getItemRef(mergedName, mergedChildren);
      }
      const triggers = new Set([].concat(_toConsumableArray(toArray6(trigger)), _toConsumableArray(toArray6(mergedValidateTrigger))));
      triggers.forEach((eventName) => {
        childProps[eventName] = (...args) => {
          var _a, _b, _c;
          (_a = mergedControl[eventName]) == null ? void 0 : _a.call(mergedControl, ...args);
          (_c = (_b = mergedChildren.props)[eventName]) == null ? void 0 : _c.call(_b, ...args);
        };
      });
      const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
      childNode = React437.createElement(MemoInput, {
        control: mergedControl,
        update: mergedChildren,
        childProps: watchingChildProps
      }, cloneElement3(mergedChildren, childProps));
    } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
      childNode = mergedChildren(context);
    } else {
      true ? warning5(!mergedName.length || !!noStyle, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead.") : void 0;
      childNode = mergedChildren;
    }
    return renderLayout(childNode, fieldId, isRequired);
  });
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus_default;
var FormItem_default = FormItem;

// node_modules/antd/es/form/FormList.js
var React438 = __toESM(require_react());
var FormList = ({
  prefixCls: customizePrefixCls,
  children,
  ...props
}) => {
  if (true) {
    const warning5 = devUseWarning("Form.List");
    true ? warning5(typeof props.name === "number" || (Array.isArray(props.name) ? !!props.name.length : !!props.name), "usage", "Miss `name` prop.") : void 0;
  }
  const {
    getPrefixCls
  } = React438.useContext(ConfigContext);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const contextValue = React438.useMemo(() => ({
    prefixCls,
    status: "error"
  }), [prefixCls]);
  return React438.createElement(List_default, {
    ...props
  }, (fields, operation, meta) => React438.createElement(FormItemPrefixContext.Provider, {
    value: contextValue
  }, children(fields.map((field) => ({
    ...field,
    fieldKey: field.key
  })), operation, {
    errors: meta.errors,
    warnings: meta.warnings
  })));
};
var FormList_default = FormList;

// node_modules/antd/es/form/hooks/useFormInstance.js
var React439 = __toESM(require_react());
function useFormInstance() {
  const {
    form
  } = React439.useContext(FormContext2);
  return form;
}

// node_modules/antd/es/form/index.js
var Form3 = Form_default2;
Form3.Item = FormItem_default;
Form3.List = FormList_default;
Form3.ErrorList = ErrorList_default;
Form3.useForm = useForm2;
Form3.useFormInstance = useFormInstance;
Form3.useWatch = useWatch_default;
Form3.Provider = FormProvider2;
var form_default = Form3;

// node_modules/antd/es/image/index.js
var React451 = __toESM(require_react());

// node_modules/@rc-component/image/es/Image.js
var React448 = __toESM(require_react());
var import_react172 = __toESM(require_react());

// node_modules/@rc-component/image/es/Preview/index.js
var import_react170 = __toESM(require_react());

// node_modules/@rc-component/image/es/context.js
var React440 = __toESM(require_react());
var PreviewGroupContext = React440.createContext(null);

// node_modules/@rc-component/image/es/util.js
function isImageValid(src) {
  return new Promise((resolve) => {
    if (!src) {
      resolve(false);
      return;
    }
    const img = document.createElement("img");
    img.onerror = () => resolve(false);
    img.onload = () => resolve(true);
    img.src = src;
  });
}
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}

// node_modules/@rc-component/image/es/hooks/useImageTransform.js
var import_react166 = __toESM(require_react());
var initialTransform = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: false,
  flipY: false
};
function useImageTransform(imgRef, minScale, maxScale, onTransform) {
  const frame = (0, import_react166.useRef)(null);
  const queue = (0, import_react166.useRef)([]);
  const [transform, setTransform] = (0, import_react166.useState)(initialTransform);
  const resetTransform = (action) => {
    setTransform(initialTransform);
    if (!isEqual_default(initialTransform, transform)) {
      onTransform == null ? void 0 : onTransform({
        transform: initialTransform,
        action
      });
    }
  };
  const updateTransform = (newTransform, action) => {
    if (frame.current === null) {
      queue.current = [];
      frame.current = raf_default(() => {
        setTransform((preState) => {
          let memoState = preState;
          queue.current.forEach((queueState) => {
            memoState = {
              ...memoState,
              ...queueState
            };
          });
          frame.current = null;
          onTransform == null ? void 0 : onTransform({
            transform: memoState,
            action
          });
          return memoState;
        });
      });
    }
    queue.current.push({
      ...transform,
      ...newTransform
    });
  };
  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {
    const {
      width,
      height,
      offsetWidth,
      offsetHeight,
      offsetLeft,
      offsetTop
    } = imgRef.current;
    let newRatio = ratio;
    let newScale = transform.scale * ratio;
    if (newScale > maxScale) {
      newScale = maxScale;
      newRatio = maxScale / transform.scale;
    } else if (newScale < minScale) {
      newScale = isTouch ? newScale : minScale;
      newRatio = newScale / transform.scale;
    }
    const mergedCenterX = centerX ?? innerWidth / 2;
    const mergedCenterY = centerY ?? innerHeight / 2;
    const diffRatio = newRatio - 1;
    const diffImgX = diffRatio * width * 0.5;
    const diffImgY = diffRatio * height * 0.5;
    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);
    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);
    let newX = transform.x - (diffOffsetLeft - diffImgX);
    let newY = transform.y - (diffOffsetTop - diffImgY);
    if (ratio < 1 && newScale === 1) {
      const mergedWidth = offsetWidth * newScale;
      const mergedHeight = offsetHeight * newScale;
      const {
        width: clientWidth,
        height: clientHeight
      } = getClientSize();
      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {
        newX = 0;
        newY = 0;
      }
    }
    updateTransform({
      x: newX,
      y: newY,
      scale: newScale
    }, action);
  };
  return {
    transform,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  };
}

// node_modules/@rc-component/image/es/hooks/useMouseEvent.js
var import_react167 = __toESM(require_react());

// node_modules/@rc-component/image/es/getFixScaleEleTransPosition.js
function fixPoint(key, start, width, clientWidth) {
  const startAddWidth = start + width;
  const offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return {
        [key]: offsetStart
      };
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return {
        [key]: -offsetStart
      };
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return {
      [key]: start < 0 ? offsetStart : -offsetStart
    };
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  const {
    width: clientWidth,
    height: clientHeight
  } = getClientSize();
  let fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = {
      ...fixPoint("x", left, width, clientWidth),
      ...fixPoint("y", top, height, clientHeight)
    };
  }
  return fixPos;
}

// node_modules/@rc-component/image/es/previewConfig.js
var BASE_SCALE_RATIO = 1;
var WHEEL_MAX_SCALE_RATIO = 1;

// node_modules/@rc-component/image/es/hooks/useMouseEvent.js
function useMouseEvent(imgRef, movable, open3, scaleStep, transform, updateTransform, dispatchZoomChange) {
  const {
    rotate,
    scale,
    x,
    y
  } = transform;
  const [isMoving, setMoving] = (0, import_react167.useState)(false);
  const startPositionInfo = (0, import_react167.useRef)({
    diffX: 0,
    diffY: 0,
    transformX: 0,
    transformY: 0
  });
  const onMouseDown = (event) => {
    if (!movable || event.button !== 0)
      return;
    event.preventDefault();
    event.stopPropagation();
    startPositionInfo.current = {
      diffX: event.pageX - x,
      diffY: event.pageY - y,
      transformX: x,
      transformY: y
    };
    setMoving(true);
  };
  const onMouseMove = (event) => {
    if (open3 && isMoving) {
      updateTransform({
        x: event.pageX - startPositionInfo.current.diffX,
        y: event.pageY - startPositionInfo.current.diffY
      }, "move");
    }
  };
  const onMouseUp = () => {
    if (open3 && isMoving) {
      setMoving(false);
      const {
        transformX,
        transformY
      } = startPositionInfo.current;
      const hasChangedPosition = x !== transformX && y !== transformY;
      if (!hasChangedPosition)
        return;
      const width = imgRef.current.offsetWidth * scale;
      const height = imgRef.current.offsetHeight * scale;
      const {
        left,
        top
      } = imgRef.current.getBoundingClientRect();
      const isRotate = rotate % 180 !== 0;
      const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
      if (fixState) {
        updateTransform({
          ...fixState
        }, "dragRebound");
      }
    }
  };
  const onWheel = (event) => {
    if (!open3 || event.deltaY == 0)
      return;
    const scaleRatio = Math.abs(event.deltaY / 100);
    const mergedScaleRatio = Math.min(scaleRatio, WHEEL_MAX_SCALE_RATIO);
    let ratio = BASE_SCALE_RATIO + mergedScaleRatio * scaleStep;
    if (event.deltaY > 0) {
      ratio = BASE_SCALE_RATIO / ratio;
    }
    dispatchZoomChange(ratio, "wheel", event.clientX, event.clientY);
  };
  (0, import_react167.useEffect)(() => {
    if (movable) {
      window.addEventListener("mouseup", onMouseUp, false);
      window.addEventListener("mousemove", onMouseMove, false);
      try {
        if (window.top !== window.self) {
          window.top.addEventListener("mouseup", onMouseUp, false);
          window.top.addEventListener("mousemove", onMouseMove, false);
        }
      } catch (error) {
        warning(false, `[rc-image] ${error}`);
      }
    }
    return () => {
      var _a, _b;
      window.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("mousemove", onMouseMove);
      try {
        (_a = window.top) == null ? void 0 : _a.removeEventListener("mouseup", onMouseUp);
        (_b = window.top) == null ? void 0 : _b.removeEventListener("mousemove", onMouseMove);
      } catch (error) {
      }
    };
  }, [open3, isMoving, x, y, rotate, movable]);
  return {
    isMoving,
    onMouseDown,
    onMouseMove,
    onMouseUp,
    onWheel
  };
}

// node_modules/@rc-component/image/es/hooks/useStatus.js
var import_react168 = __toESM(require_react());
function useStatus2({
  src,
  isCustomPlaceholder,
  fallback
}) {
  const [status, setStatus] = (0, import_react168.useState)(isCustomPlaceholder ? "loading" : "normal");
  const isLoaded = (0, import_react168.useRef)(false);
  const isError = status === "error";
  (0, import_react168.useEffect)(() => {
    let isCurrentSrc = true;
    isImageValid(src).then((isValid) => {
      if (!isValid && isCurrentSrc) {
        setStatus("error");
      }
    });
    return () => {
      isCurrentSrc = false;
    };
  }, [src]);
  (0, import_react168.useEffect)(() => {
    if (isCustomPlaceholder && !isLoaded.current) {
      setStatus("loading");
    } else if (isError) {
      setStatus("normal");
    }
  }, [src]);
  const onLoad = () => {
    setStatus("normal");
  };
  const getImgRef = (img) => {
    isLoaded.current = false;
    if (status === "loading" && (img == null ? void 0 : img.complete) && (img.naturalWidth || img.naturalHeight)) {
      isLoaded.current = true;
      onLoad();
    }
  };
  const srcAndOnload = isError && fallback ? {
    src: fallback
  } : {
    onLoad,
    src
  };
  return [getImgRef, srcAndOnload, status];
}

// node_modules/@rc-component/image/es/hooks/useTouchEvent.js
var import_react169 = __toESM(require_react());
function getDistance(a, b) {
  const x = a.x - b.x;
  const y = a.y - b.y;
  return Math.hypot(x, y);
}
function getCenter(oldPoint1, oldPoint2, newPoint1, newPoint2) {
  const distance1 = getDistance(oldPoint1, newPoint1);
  const distance2 = getDistance(oldPoint2, newPoint2);
  if (distance1 === 0 && distance2 === 0) {
    return [oldPoint1.x, oldPoint1.y];
  }
  const ratio = distance1 / (distance1 + distance2);
  const x = oldPoint1.x + ratio * (oldPoint2.x - oldPoint1.x);
  const y = oldPoint1.y + ratio * (oldPoint2.y - oldPoint1.y);
  return [x, y];
}
function useTouchEvent(imgRef, movable, open3, minScale, transform, updateTransform, dispatchZoomChange) {
  const {
    rotate,
    scale,
    x,
    y
  } = transform;
  const [isTouching, setIsTouching] = (0, import_react169.useState)(false);
  const touchPointInfo = (0, import_react169.useRef)({
    point1: {
      x: 0,
      y: 0
    },
    point2: {
      x: 0,
      y: 0
    },
    eventType: "none"
  });
  const updateTouchPointInfo = (values) => {
    touchPointInfo.current = {
      ...touchPointInfo.current,
      ...values
    };
  };
  const onTouchStart = (event) => {
    if (!movable)
      return;
    event.stopPropagation();
    setIsTouching(true);
    const {
      touches = []
    } = event;
    if (touches.length > 1) {
      updateTouchPointInfo({
        point1: {
          x: touches[0].clientX,
          y: touches[0].clientY
        },
        point2: {
          x: touches[1].clientX,
          y: touches[1].clientY
        },
        eventType: "touchZoom"
      });
    } else {
      updateTouchPointInfo({
        point1: {
          x: touches[0].clientX - x,
          y: touches[0].clientY - y
        },
        eventType: "move"
      });
    }
  };
  const onTouchMove = (event) => {
    const {
      touches = []
    } = event;
    const {
      point1,
      point2,
      eventType
    } = touchPointInfo.current;
    if (touches.length > 1 && eventType === "touchZoom") {
      const newPoint1 = {
        x: touches[0].clientX,
        y: touches[0].clientY
      };
      const newPoint2 = {
        x: touches[1].clientX,
        y: touches[1].clientY
      };
      const [centerX, centerY] = getCenter(point1, point2, newPoint1, newPoint2);
      const ratio = getDistance(newPoint1, newPoint2) / getDistance(point1, point2);
      dispatchZoomChange(ratio, "touchZoom", centerX, centerY, true);
      updateTouchPointInfo({
        point1: newPoint1,
        point2: newPoint2,
        eventType: "touchZoom"
      });
    } else if (eventType === "move") {
      updateTransform({
        x: touches[0].clientX - point1.x,
        y: touches[0].clientY - point1.y
      }, "move");
      updateTouchPointInfo({
        eventType: "move"
      });
    }
  };
  const onTouchEnd = () => {
    if (!open3)
      return;
    if (isTouching) {
      setIsTouching(false);
    }
    updateTouchPointInfo({
      eventType: "none"
    });
    if (minScale > scale) {
      return updateTransform({
        x: 0,
        y: 0,
        scale: minScale
      }, "touchZoom");
    }
    const width = imgRef.current.offsetWidth * scale;
    const height = imgRef.current.offsetHeight * scale;
    const {
      left,
      top
    } = imgRef.current.getBoundingClientRect();
    const isRotate = rotate % 180 !== 0;
    const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left, top);
    if (fixState) {
      updateTransform({
        ...fixState
      }, "dragRebound");
    }
  };
  (0, import_react169.useEffect)(() => {
    const preventDefault = (e3) => {
      e3.preventDefault();
    };
    if (open3 && movable) {
      window.addEventListener("touchmove", preventDefault, {
        passive: false
      });
    }
    return () => {
      window.removeEventListener("touchmove", preventDefault);
    };
  }, [open3, movable]);
  return {
    isTouching,
    onTouchStart,
    onTouchMove,
    onTouchEnd
  };
}

// node_modules/@rc-component/image/es/Preview/CloseBtn.js
var React441 = __toESM(require_react());
function CloseBtn(props) {
  const {
    prefixCls,
    icon,
    onClick
  } = props;
  return React441.createElement("button", {
    className: `${prefixCls}-close`,
    onClick
  }, icon);
}

// node_modules/@rc-component/image/es/Preview/Footer.js
var React442 = __toESM(require_react());
function Footer3(props) {
  const {
    prefixCls,
    showProgress,
    current,
    count,
    showSwitch,
    // Style
    classNames,
    styles,
    // render
    icons: icons2,
    image,
    transform,
    countRender,
    actionsRender,
    // Scale
    scale,
    minScale,
    maxScale,
    // Actions
    onActive,
    onFlipY,
    onFlipX,
    onRotateLeft,
    onRotateRight,
    onZoomOut,
    onZoomIn,
    onClose,
    onReset
  } = props;
  const {
    left,
    right,
    prev: prev2,
    next: next2,
    flipY,
    flipX,
    rotateLeft,
    rotateRight,
    zoomOut: zoomOut2,
    zoomIn: zoomIn2
  } = icons2;
  const progressNode = showProgress && React442.createElement("div", {
    className: `${prefixCls}-progress`
  }, countRender ? countRender(current + 1, count) : React442.createElement("bdi", null, `${current + 1} / ${count}`));
  const actionCls = `${prefixCls}-actions-action`;
  const renderOperation = ({
    type: type5,
    disabled,
    onClick,
    icon
  }) => {
    return React442.createElement("div", {
      key: type5,
      className: clsx(actionCls, `${actionCls}-${type5}`, {
        [`${actionCls}-disabled`]: !!disabled
      }),
      onClick
    }, icon);
  };
  const switchPrevNode = showSwitch ? renderOperation({
    icon: prev2 ?? left,
    onClick: () => onActive(-1),
    type: "prev",
    disabled: current === 0
  }) : void 0;
  const switchNextNode = showSwitch ? renderOperation({
    icon: next2 ?? right,
    onClick: () => onActive(1),
    type: "next",
    disabled: current === count - 1
  }) : void 0;
  const flipYNode = renderOperation({
    icon: flipY,
    onClick: onFlipY,
    type: "flipY"
  });
  const flipXNode = renderOperation({
    icon: flipX,
    onClick: onFlipX,
    type: "flipX"
  });
  const rotateLeftNode = renderOperation({
    icon: rotateLeft,
    onClick: onRotateLeft,
    type: "rotateLeft"
  });
  const rotateRightNode = renderOperation({
    icon: rotateRight,
    onClick: onRotateRight,
    type: "rotateRight"
  });
  const zoomOutNode = renderOperation({
    icon: zoomOut2,
    onClick: onZoomOut,
    type: "zoomOut",
    disabled: scale <= minScale
  });
  const zoomInNode = renderOperation({
    icon: zoomIn2,
    onClick: onZoomIn,
    type: "zoomIn",
    disabled: scale === maxScale
  });
  const actionsNode = React442.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames.actions),
    style: styles.actions
  }, flipYNode, flipXNode, rotateLeftNode, rotateRightNode, zoomOutNode, zoomInNode);
  return React442.createElement("div", {
    className: clsx(`${prefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, progressNode, actionsRender ? actionsRender(actionsNode, {
    icons: {
      prevIcon: switchPrevNode,
      nextIcon: switchNextNode,
      flipYIcon: flipYNode,
      flipXIcon: flipXNode,
      rotateLeftIcon: rotateLeftNode,
      rotateRightIcon: rotateRightNode,
      zoomOutIcon: zoomOutNode,
      zoomInIcon: zoomInNode
    },
    actions: {
      onActive,
      onFlipY,
      onFlipX,
      onRotateLeft,
      onRotateRight,
      onZoomOut,
      onZoomIn,
      onReset,
      onClose
    },
    transform,
    current,
    total: count,
    image
  }) : actionsNode);
}

// node_modules/@rc-component/image/es/Preview/PrevNext.js
var React443 = __toESM(require_react());
function PrevNext(props) {
  const {
    prefixCls,
    onActive,
    current,
    count,
    icons: {
      left,
      right,
      prev: prev2,
      next: next2
    }
  } = props;
  const switchCls = `${prefixCls}-switch`;
  return React443.createElement(React443.Fragment, null, React443.createElement("div", {
    className: clsx(switchCls, `${switchCls}-prev`, {
      [`${switchCls}-disabled`]: current === 0
    }),
    onClick: () => onActive(-1)
  }, prev2 ?? left), React443.createElement("div", {
    className: clsx(switchCls, `${switchCls}-next`, {
      [`${switchCls}-disabled`]: current === count - 1
    }),
    onClick: () => onActive(1)
  }, next2 ?? right));
}

// node_modules/@rc-component/image/es/Preview/index.js
function _extends66() {
  _extends66 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends66.apply(this, arguments);
}
var PreviewImage = ({
  fallback,
  src,
  imgRef,
  ...props
}) => {
  const [getImgRef, srcAndOnload] = useStatus2({
    src,
    fallback
  });
  return import_react170.default.createElement("img", _extends66({
    ref: (ref) => {
      imgRef.current = ref;
      getImgRef(ref);
    }
  }, props, srcAndOnload));
};
var Preview = (props) => {
  const {
    prefixCls,
    rootClassName,
    src,
    alt,
    imageInfo,
    fallback,
    movable = true,
    onClose,
    open: open3,
    afterOpenChange,
    icons: icons2 = {},
    closeIcon,
    getContainer,
    current = 0,
    count = 1,
    countRender,
    scaleStep = 0.5,
    minScale = 1,
    maxScale = 50,
    motionName = "fade",
    imageRender,
    imgCommonProps,
    actionsRender,
    onTransform,
    onChange,
    classNames = {},
    styles = {},
    mousePosition: mousePosition2,
    zIndex
  } = props;
  const imgRef = (0, import_react170.useRef)();
  const groupContext = (0, import_react170.useContext)(PreviewGroupContext);
  const showLeftOrRightSwitches = groupContext && count > 1;
  const showOperationsProgress = groupContext && count >= 1;
  const [enableTransition, setEnableTransition] = (0, import_react170.useState)(true);
  const {
    transform,
    resetTransform,
    updateTransform,
    dispatchZoomChange
  } = useImageTransform(imgRef, minScale, maxScale, onTransform);
  const {
    isMoving,
    onMouseDown,
    onWheel
  } = useMouseEvent(imgRef, movable, open3, scaleStep, transform, updateTransform, dispatchZoomChange);
  const {
    isTouching,
    onTouchStart,
    onTouchMove,
    onTouchEnd
  } = useTouchEvent(imgRef, movable, open3, minScale, transform, updateTransform, dispatchZoomChange);
  const {
    rotate,
    scale
  } = transform;
  (0, import_react170.useEffect)(() => {
    if (!enableTransition) {
      setEnableTransition(true);
    }
  }, [enableTransition]);
  (0, import_react170.useEffect)(() => {
    if (!open3) {
      resetTransform("close");
    }
  }, [open3]);
  const onDoubleClick = (event) => {
    if (open3) {
      if (scale !== 1) {
        updateTransform({
          x: 0,
          y: 0,
          scale: 1
        }, "doubleClick");
      } else {
        dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "doubleClick", event.clientX, event.clientY);
      }
    }
  };
  const imgNode = import_react170.default.createElement(PreviewImage, _extends66({}, imgCommonProps, {
    width: props.width,
    height: props.height,
    imgRef,
    className: `${prefixCls}-img`,
    alt,
    style: {
      transform: `translate3d(${transform.x}px, ${transform.y}px, 0) scale3d(${transform.flipX ? "-" : ""}${scale}, ${transform.flipY ? "-" : ""}${scale}, 1) rotate(${rotate}deg)`,
      transitionDuration: (!enableTransition || isTouching) && "0s"
    },
    fallback,
    src,
    onWheel,
    onMouseDown,
    onDoubleClick,
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onTouchCancel: onTouchEnd
  }));
  const image = {
    url: src,
    alt,
    ...imageInfo
  };
  const onZoomIn = () => {
    dispatchZoomChange(BASE_SCALE_RATIO + scaleStep, "zoomIn");
  };
  const onZoomOut = () => {
    dispatchZoomChange(BASE_SCALE_RATIO / (BASE_SCALE_RATIO + scaleStep), "zoomOut");
  };
  const onRotateRight = () => {
    updateTransform({
      rotate: rotate + 90
    }, "rotateRight");
  };
  const onRotateLeft = () => {
    updateTransform({
      rotate: rotate - 90
    }, "rotateLeft");
  };
  const onFlipX = () => {
    updateTransform({
      flipX: !transform.flipX
    }, "flipX");
  };
  const onFlipY = () => {
    updateTransform({
      flipY: !transform.flipY
    }, "flipY");
  };
  const onReset = () => {
    resetTransform("reset");
  };
  const onActive = (offset3) => {
    const nextCurrent = current + offset3;
    if (nextCurrent >= 0 && nextCurrent <= count - 1) {
      setEnableTransition(false);
      resetTransform(offset3 < 0 ? "prev" : "next");
      onChange == null ? void 0 : onChange(nextCurrent, current);
    }
  };
  const onKeyDown2 = useEvent_default((event) => {
    if (open3) {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode_default.ESC) {
        onClose == null ? void 0 : onClose();
      }
      if (showLeftOrRightSwitches) {
        if (keyCode === KeyCode_default.LEFT) {
          onActive(-1);
        } else if (keyCode === KeyCode_default.RIGHT) {
          onActive(1);
        }
      }
    }
  });
  (0, import_react170.useEffect)(() => {
    if (open3) {
      window.addEventListener("keydown", onKeyDown2);
      return () => {
        window.removeEventListener("keydown", onKeyDown2);
      };
    }
  }, [open3]);
  const [lockScroll, setLockScroll] = (0, import_react170.useState)(false);
  import_react170.default.useEffect(() => {
    if (open3) {
      setLockScroll(true);
    }
  }, [open3]);
  const onVisibleChanged = (nextVisible) => {
    if (!nextVisible) {
      setLockScroll(false);
    }
    afterOpenChange == null ? void 0 : afterOpenChange(nextVisible);
  };
  const [portalRender, setPortalRender] = (0, import_react170.useState)(false);
  useLayoutEffect_default(() => {
    if (open3) {
      setPortalRender(true);
    }
  }, [open3]);
  const bodyStyle = {
    ...styles.body
  };
  if (mousePosition2) {
    bodyStyle.transformOrigin = `${mousePosition2.x}px ${mousePosition2.y}px`;
  }
  return import_react170.default.createElement(es_default3, {
    open: portalRender,
    getContainer,
    autoLock: lockScroll
  }, import_react170.default.createElement(es_default2, {
    motionName,
    visible: portalRender && open3,
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    onVisibleChanged
  }, ({
    className: motionClassName,
    style: motionStyle
  }) => {
    const mergedStyle = {
      ...styles.root,
      ...motionStyle
    };
    if (zIndex) {
      mergedStyle.zIndex = zIndex;
    }
    return import_react170.default.createElement("div", {
      className: clsx(prefixCls, rootClassName, classNames.root, motionClassName, {
        [`${prefixCls}-moving`]: isMoving
      }),
      style: mergedStyle
    }, import_react170.default.createElement("div", {
      className: clsx(`${prefixCls}-mask`, classNames.mask),
      style: styles.mask,
      onClick: onClose
    }), import_react170.default.createElement("div", {
      className: clsx(`${prefixCls}-body`, classNames.body),
      style: bodyStyle
    }, imageRender ? imageRender(imgNode, {
      transform,
      image,
      ...groupContext ? {
        current
      } : {}
    }) : imgNode), closeIcon !== false && closeIcon !== null && import_react170.default.createElement(CloseBtn, {
      prefixCls,
      icon: closeIcon === true ? icons2.close : closeIcon || icons2.close,
      onClick: onClose
    }), showLeftOrRightSwitches && import_react170.default.createElement(PrevNext, {
      prefixCls,
      current,
      count,
      icons: icons2,
      onActive
    }), import_react170.default.createElement(Footer3, {
      prefixCls,
      showProgress: showOperationsProgress,
      current,
      count,
      showSwitch: showLeftOrRightSwitches,
      classNames,
      styles,
      image,
      transform,
      icons: icons2,
      countRender,
      actionsRender,
      scale,
      minScale,
      maxScale,
      onActive,
      onFlipY,
      onFlipX,
      onRotateLeft,
      onRotateRight,
      onZoomOut,
      onZoomIn,
      onClose,
      onReset
    }));
  }));
};
var Preview_default = Preview;

// node_modules/@rc-component/image/es/PreviewGroup.js
var React446 = __toESM(require_react());
var import_react171 = __toESM(require_react());

// node_modules/@rc-component/image/es/hooks/usePreviewItems.js
var React445 = __toESM(require_react());

// node_modules/@rc-component/image/es/common.js
var COMMON_PROPS = ["crossOrigin", "decoding", "draggable", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "alt"];

// node_modules/@rc-component/image/es/hooks/usePreviewItems.js
function usePreviewItems(items) {
  const [images, setImages] = React445.useState({});
  const registerImage = React445.useCallback((id, data) => {
    setImages((imgs) => ({
      ...imgs,
      [id]: data
    }));
    return () => {
      setImages((imgs) => {
        const cloneImgs = {
          ...imgs
        };
        delete cloneImgs[id];
        return cloneImgs;
      });
    };
  }, []);
  const mergedItems = React445.useMemo(() => {
    if (items) {
      return items.map((item) => {
        if (typeof item === "string") {
          return {
            data: {
              src: item
            }
          };
        }
        const data = {};
        Object.keys(item).forEach((key) => {
          if (["src", ...COMMON_PROPS].includes(key)) {
            data[key] = item[key];
          }
        });
        return {
          data
        };
      });
    }
    return Object.keys(images).reduce((total, id) => {
      const {
        canPreview,
        data
      } = images[id];
      if (canPreview) {
        total.push({
          data,
          id
        });
      }
      return total;
    }, []);
  }, [items, images]);
  return [mergedItems, registerImage, !!items];
}

// node_modules/@rc-component/image/es/PreviewGroup.js
function _extends67() {
  _extends67 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends67.apply(this, arguments);
}
var Group = ({
  previewPrefixCls = "rc-image-preview",
  classNames,
  styles,
  children,
  icons: icons2 = {},
  items,
  preview,
  fallback
}) => {
  var _a;
  const {
    open: previewOpen,
    onOpenChange,
    current: currentIndex,
    onChange,
    ...restProps
  } = preview && typeof preview === "object" ? preview : {};
  const [mergedItems, register2, fromItems] = usePreviewItems(items);
  const [current, setCurrent] = useControlledState(0, currentIndex);
  const [keepOpenIndex, setKeepOpenIndex] = (0, import_react171.useState)(false);
  const {
    src,
    ...imgCommonProps
  } = ((_a = mergedItems[current]) == null ? void 0 : _a.data) || {};
  const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
  const triggerShowPreview = useEvent_default((next2) => {
    setShowPreview(next2);
    if (next2 !== isShowPreview) {
      onOpenChange == null ? void 0 : onOpenChange(next2, {
        current
      });
    }
  });
  const [mousePosition2, setMousePosition] = (0, import_react171.useState)(null);
  const onPreviewFromImage = React446.useCallback((id, imageSrc, mouseX, mouseY) => {
    const index2 = fromItems ? mergedItems.findIndex((item) => item.data.src === imageSrc) : mergedItems.findIndex((item) => item.id === id);
    setCurrent(index2 < 0 ? 0 : index2);
    triggerShowPreview(true);
    setMousePosition({
      x: mouseX,
      y: mouseY
    });
    setKeepOpenIndex(true);
  }, [mergedItems, fromItems]);
  React446.useEffect(() => {
    if (isShowPreview) {
      if (!keepOpenIndex) {
        setCurrent(0);
      }
    } else {
      setKeepOpenIndex(false);
    }
  }, [isShowPreview]);
  const onInternalChange = (next2, prev2) => {
    setCurrent(next2);
    onChange == null ? void 0 : onChange(next2, prev2);
  };
  const onPreviewClose = () => {
    triggerShowPreview(false);
    setMousePosition(null);
  };
  const previewGroupContext = React446.useMemo(() => ({
    register: register2,
    onPreview: onPreviewFromImage
  }), [register2, onPreviewFromImage]);
  return React446.createElement(PreviewGroupContext.Provider, {
    value: previewGroupContext
  }, children, React446.createElement(Preview_default, _extends67({
    "aria-hidden": !isShowPreview,
    open: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    imgCommonProps,
    src,
    fallback,
    icons: icons2,
    current,
    count: mergedItems.length,
    onChange: onInternalChange
  }, restProps, {
    classNames: classNames == null ? void 0 : classNames.popup,
    styles: styles == null ? void 0 : styles.popup
  })));
};
var PreviewGroup_default = Group;

// node_modules/@rc-component/image/es/hooks/useRegisterImage.js
var React447 = __toESM(require_react());
var uid = 0;
function useRegisterImage(canPreview, data) {
  const [id] = React447.useState(() => {
    uid += 1;
    return String(uid);
  });
  const groupContext = React447.useContext(PreviewGroupContext);
  const registerData = {
    data,
    canPreview
  };
  React447.useEffect(() => {
    if (groupContext) {
      return groupContext.register(id, registerData);
    }
  }, []);
  React447.useEffect(() => {
    if (groupContext) {
      groupContext.register(id, registerData);
    }
  }, [canPreview, data]);
  return id;
}

// node_modules/@rc-component/image/es/Image.js
function _extends68() {
  _extends68 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends68.apply(this, arguments);
}
var ImageInternal = (props) => {
  const {
    // Misc
    prefixCls = "rc-image",
    previewPrefixCls = `${prefixCls}-preview`,
    // Style
    rootClassName,
    className,
    style: style2,
    classNames = {},
    styles = {},
    width,
    height,
    // Image
    src: imgSrc,
    alt,
    placeholder,
    fallback,
    // Preview
    preview = true,
    // Events
    onClick,
    onError,
    ...otherProps
  } = props;
  const groupContext = (0, import_react172.useContext)(PreviewGroupContext);
  const canPreview = !!preview;
  const {
    src: previewSrc,
    open: previewOpen,
    onOpenChange: onPreviewOpenChange,
    cover,
    rootClassName: previewRootClassName,
    ...restProps
  } = preview && typeof preview === "object" ? preview : {};
  const coverPlacement = typeof cover === "object" && cover.placement ? cover.placement || "center" : "center";
  const coverNode = typeof cover === "object" && cover.coverNode ? cover.coverNode : cover;
  const [isShowPreview, setShowPreview] = useControlledState(!!previewOpen, previewOpen);
  const [mousePosition2, setMousePosition] = (0, import_react172.useState)(null);
  const triggerPreviewOpen = (nextOpen) => {
    setShowPreview(nextOpen);
    onPreviewOpenChange == null ? void 0 : onPreviewOpenChange(nextOpen);
  };
  const onPreviewClose = () => {
    triggerPreviewOpen(false);
  };
  const isCustomPlaceholder = placeholder && placeholder !== true;
  const src = previewSrc ?? imgSrc;
  const [getImgRef, srcAndOnload, status] = useStatus2({
    src: imgSrc,
    isCustomPlaceholder,
    fallback
  });
  const imgCommonProps = (0, import_react172.useMemo)(() => {
    const obj = {};
    COMMON_PROPS.forEach((prop) => {
      if (props[prop] !== void 0) {
        obj[prop] = props[prop];
      }
    });
    return obj;
  }, COMMON_PROPS.map((prop) => props[prop]));
  const registerData = (0, import_react172.useMemo)(() => ({
    ...imgCommonProps,
    src
  }), [src, imgCommonProps]);
  const imageId = useRegisterImage(canPreview, registerData);
  const onPreview = (e3) => {
    const rect = e3.target.getBoundingClientRect();
    const left = rect.x + rect.width / 2;
    const top = rect.y + rect.height / 2;
    if (groupContext) {
      groupContext.onPreview(imageId, src, left, top);
    } else {
      setMousePosition({
        x: left,
        y: top
      });
      triggerPreviewOpen(true);
    }
    onClick == null ? void 0 : onClick(e3);
  };
  return React448.createElement(React448.Fragment, null, React448.createElement("div", _extends68({}, otherProps, {
    className: clsx(prefixCls, rootClassName, classNames.root, {
      [`${prefixCls}-error`]: status === "error"
    }),
    onClick: canPreview ? onPreview : onClick,
    style: {
      width,
      height,
      ...styles.root
    }
  }), React448.createElement("img", _extends68({}, imgCommonProps, {
    className: clsx(`${prefixCls}-img`, {
      [`${prefixCls}-img-placeholder`]: placeholder === true
    }, classNames.image, className),
    style: {
      height,
      ...styles.image,
      ...style2
    },
    ref: getImgRef
  }, srcAndOnload, {
    width,
    height,
    onError
  })), status === "loading" && React448.createElement("div", {
    "aria-hidden": "true",
    className: `${prefixCls}-placeholder`
  }, placeholder), cover !== false && canPreview && React448.createElement("div", {
    className: clsx(`${prefixCls}-cover`, classNames.cover, `${prefixCls}-cover-${coverPlacement}`),
    style: {
      display: (style2 == null ? void 0 : style2.display) === "none" ? "none" : void 0,
      ...styles.cover
    }
  }, coverNode)), !groupContext && canPreview && React448.createElement(Preview_default, _extends68({
    "aria-hidden": !isShowPreview,
    open: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition: mousePosition2,
    src,
    alt,
    imageInfo: {
      width,
      height
    },
    fallback,
    imgCommonProps
  }, restProps, {
    classNames: classNames == null ? void 0 : classNames.popup,
    styles: styles == null ? void 0 : styles.popup,
    rootClassName: clsx(previewRootClassName, rootClassName)
  })));
};
ImageInternal.PreviewGroup = PreviewGroup_default;
if (true) {
  ImageInternal.displayName = "Image";
}
var Image_default2 = ImageInternal;

// node_modules/@rc-component/image/es/index.js
var es_default27 = Image_default2;

// node_modules/antd/es/image/hooks/useMergedPreviewConfig.js
var import_react173 = __toESM(require_react());
var useMergedPreviewConfig = (previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, icons2, defaultCover) => {
  const [zIndex] = useZIndex("ImagePreview", previewConfig == null ? void 0 : previewConfig.zIndex);
  const [mergedPreviewMask, blurClassName] = useMergedMask(previewConfig == null ? void 0 : previewConfig.mask, contextPreviewConfig == null ? void 0 : contextPreviewConfig.mask, `${prefixCls}-preview`);
  return import_react173.default.useMemo(() => {
    if (!previewConfig) {
      return previewConfig;
    }
    const {
      cover,
      getContainer,
      closeIcon,
      rootClassName: previewRootClassName
    } = previewConfig;
    const {
      closeIcon: contextCloseIcon
    } = contextPreviewConfig ?? {};
    return {
      motionName: getTransitionName2(`${prefixCls}-preview`, "fade"),
      ...previewConfig,
      ...defaultCover ? {
        cover: cover ?? defaultCover
      } : {},
      icons: icons2,
      getContainer: getContainer ?? getContextPopupContainer,
      zIndex,
      closeIcon: closeIcon ?? contextCloseIcon,
      rootClassName: clsx(mergedRootClassName, previewRootClassName),
      mask: mergedPreviewMask,
      blurClassName: blurClassName.mask
    };
  }, [previewConfig, contextPreviewConfig, prefixCls, mergedRootClassName, getContextPopupContainer, defaultCover, icons2, zIndex, mergedPreviewMask, blurClassName]);
};
var useMergedPreviewConfig_default = useMergedPreviewConfig;

// node_modules/antd/es/image/hooks/usePreviewConfig.js
var import_react174 = __toESM(require_react());
function normalizeMask(mask) {
  if ((0, import_react174.isValidElement)(mask)) {
    return [mask, void 0];
  }
  if (typeof mask === "boolean" || mask && typeof mask === "object") {
    return [void 0, mask];
  }
  return [void 0, void 0];
}
function usePreviewConfig(preview) {
  const rawPreviewConfig = (0, import_react174.useMemo)(() => {
    if (typeof preview === "boolean") {
      return preview ? {} : null;
    }
    return preview && typeof preview === "object" ? preview : {};
  }, [preview]);
  const splittedPreviewConfig = (0, import_react174.useMemo)(() => {
    if (!rawPreviewConfig) {
      return [rawPreviewConfig, "", ""];
    }
    const {
      open: open3,
      onOpenChange,
      cover,
      actionsRender,
      visible,
      onVisibleChange,
      rootClassName,
      maskClassName,
      mask,
      forceRender: _forceRender,
      destroyOnClose: _destroyOnClose,
      toolbarRender,
      ...restPreviewConfig
    } = rawPreviewConfig;
    let onInternalOpenChange;
    if (onOpenChange) {
      onInternalOpenChange = onOpenChange;
    } else if (onVisibleChange) {
      onInternalOpenChange = (nextOpen, info) => {
        const {
          current
        } = info || {};
        if (current !== void 0) {
          onVisibleChange(nextOpen, !nextOpen, current);
        } else {
          onVisibleChange(nextOpen, !nextOpen);
        }
      };
    }
    const [coverElement, maskConfig] = normalizeMask(mask);
    return [{
      ...restPreviewConfig,
      open: open3 ?? visible,
      onOpenChange: onInternalOpenChange,
      cover: cover ?? coverElement,
      mask: maskConfig,
      actionsRender: actionsRender ?? toolbarRender
    }, rootClassName, maskClassName];
  }, [rawPreviewConfig]);
  if (true) {
    const warning5 = devUseWarning("Image");
    if (rawPreviewConfig) {
      [["visible", "open"], ["onVisibleChange", "onOpenChange"], ["maskClassName", "classNames.cover"], ["rootClassName", "classNames.root"], ["toolbarRender", "actionsRender"]].forEach(([deprecatedName, newName]) => {
        warning5.deprecated(!(deprecatedName in rawPreviewConfig), deprecatedName, newName);
      });
      true ? warning5(!(0, import_react174.isValidElement)(rawPreviewConfig.mask), "deprecated", "`mask` used as ReactNode is deprecated. Please use `cover` instead.") : void 0;
      true ? warning5(!("forceRender" in rawPreviewConfig), "breaking", "`forceRender` is no longer supported.") : void 0;
      true ? warning5(!("destroyOnClose" in rawPreviewConfig), "breaking", "`destroyOnClose` is no longer supported.") : void 0;
    }
  }
  return splittedPreviewConfig;
}

// node_modules/antd/es/image/PreviewGroup.js
var React450 = __toESM(require_react());

// node_modules/antd/es/image/style/index.js
var genBoxStyle = (position3) => ({
  position: position3 || "absolute",
  inset: 0
});
var genImageCoverStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    colorTextLightSolid
  } = token2;
  return {
    [componentCls]: {
      [`${componentCls}-cover`]: {
        position: "absolute",
        inset: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: colorTextLightSolid,
        background: new FastColor("#000").setA(0.3).toRgbString(),
        cursor: "pointer",
        opacity: 0,
        transition: `opacity ${motionDurationSlow}`
      },
      "&:hover": {
        [`${componentCls}-cover`]: {
          opacity: 1
        }
      },
      [`${componentCls}-cover-top`]: {
        inset: "0 0 auto 0",
        justifyContent: "center"
      },
      [`${componentCls}-cover-bottom`]: {
        inset: "auto 0 0 0",
        justifyContent: "center"
      }
    }
  };
};
var genImagePreviewStyle = (token2) => {
  const {
    motionEaseOut,
    previewCls,
    motionDurationSlow,
    componentCls,
    colorBgMask,
    marginXL,
    marginSM,
    margin,
    colorTextLightSolid,
    paddingSM,
    paddingLG,
    previewOperationHoverColor,
    previewOperationColorDisabled,
    previewOperationSize,
    zIndexPopup
  } = token2;
  const operationBg = new FastColor(colorBgMask).setA(0.1);
  const operationBgHover = operationBg.clone().setA(0.2);
  const singleBtn = {
    position: "absolute",
    color: colorTextLightSolid,
    backgroundColor: operationBg.toRgbString(),
    borderRadius: "50%",
    padding: paddingSM,
    outline: 0,
    border: 0,
    cursor: "pointer",
    transition: `all ${motionDurationSlow}`,
    display: "flex",
    fontSize: previewOperationSize,
    "&:hover": {
      backgroundColor: operationBgHover.toRgbString()
    },
    "&:active": {
      backgroundColor: operationBg.toRgbString()
    }
  };
  return {
    [`${componentCls}-preview`]: {
      textAlign: "center",
      inset: 0,
      position: "fixed",
      userSelect: "none",
      zIndex: zIndexPopup,
      // ================= Mask =================
      [`${previewCls}-mask`]: {
        inset: 0,
        position: "absolute",
        background: colorBgMask,
        [`&${componentCls}-preview-mask-blur`]: {
          backdropFilter: "blur(4px)"
        },
        [`&${componentCls}-preview-mask-hidden`]: {
          display: "none"
        }
      },
      // ================= Body =================
      [`${previewCls}-body`]: {
        ...genBoxStyle(),
        "pointer-events": "none",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "> *": {
          pointerEvents: "auto"
        }
      },
      // Body > Image
      [`${previewCls}-img`]: {
        maxWidth: "100%",
        maxHeight: "70%",
        verticalAlign: "middle",
        transform: "scale3d(1, 1, 1)",
        cursor: "grab",
        transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`
      },
      [`&-moving ${previewCls}-img`]: {
        cursor: "grabbing"
      },
      // =============== CloseBtn ===============
      [`${previewCls}-close`]: {
        // Shared style
        ...singleBtn,
        top: marginSM,
        insetInlineEnd: marginSM
      },
      // ================ Switch ================
      [`${previewCls}-switch`]: {
        ...singleBtn,
        top: "50%",
        transform: `translateY(-50%)`,
        "&-disabled": {
          "&, &:hover, &:active": {
            color: previewOperationColorDisabled,
            background: "transparent",
            cursor: "not-allowed"
          }
        },
        "&-prev": {
          insetInlineStart: marginSM
        },
        "&-next": {
          insetInlineEnd: marginSM
        }
      },
      // ================ Footer ================
      [`${previewCls}-footer`]: {
        position: "absolute",
        bottom: marginXL,
        left: {
          _skip_check_: true,
          value: "50%"
        },
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        color: token2.previewOperationColor,
        transform: "translateX(-50%)",
        gap: margin
      },
      // =============== Actions ================
      [`${previewCls}-actions`]: {
        display: "flex",
        gap: paddingSM,
        padding: `0 ${unit(paddingLG)}`,
        backgroundColor: operationBg.toRgbString(),
        borderRadius: 100,
        fontSize: previewOperationSize,
        "&-action": {
          padding: paddingSM,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          display: "flex",
          [`&:not(${previewCls}-actions-action-disabled):hover`]: {
            color: previewOperationHoverColor
          },
          "&-disabled": {
            color: previewOperationColorDisabled,
            cursor: "not-allowed"
          }
        }
      }
    }
  };
};
var genImageStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ============================== image ==============================
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-placeholder`]: {
        ...genBoxStyle()
      }
    }
  };
};
var genPreviewMotion = (token2) => {
  const {
    previewCls,
    motionDurationSlow
  } = token2;
  return {
    [previewCls]: {
      "&-fade": {
        transition: `opacity ${motionDurationSlow}`,
        "&-enter, &-appear": {
          opacity: 0,
          [`${previewCls}-body`]: {
            transform: "scale(0)"
          },
          "&-active": {
            opacity: 1,
            [`${previewCls}-body`]: {
              transform: "scale(1)",
              transition: `transform ${motionDurationSlow}`
            }
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0,
            [`${previewCls}-body`]: {
              transform: "scale(0)",
              transition: `transform ${motionDurationSlow}`
            }
          }
        }
      }
    }
  };
};
var prepareComponentToken37 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 80,
  previewOperationColor: new FastColor(token2.colorTextLightSolid).setA(0.65).toRgbString(),
  previewOperationHoverColor: new FastColor(token2.colorTextLightSolid).setA(0.85).toRgbString(),
  previewOperationColorDisabled: new FastColor(token2.colorTextLightSolid).setA(0.25).toRgbString(),
  previewOperationSize: token2.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
});
var style_default43 = genStyleHooks("Image", (token2) => {
  const previewCls = `${token2.componentCls}-preview`;
  const imageToken = merge2(token2, {
    previewCls,
    imagePreviewSwitchSize: token2.controlHeightLG
  });
  return [genImageStyle(imageToken), genImageCoverStyle(imageToken), genImagePreviewStyle(imageToken), genPreviewMotion(imageToken)];
}, prepareComponentToken37);

// node_modules/antd/es/image/PreviewGroup.js
var icons = {
  rotateLeft: React450.createElement(RotateLeftOutlined_default, null),
  rotateRight: React450.createElement(RotateRightOutlined_default, null),
  zoomIn: React450.createElement(ZoomInOutlined_default, null),
  zoomOut: React450.createElement(ZoomOutOutlined_default, null),
  close: React450.createElement(CloseOutlined_default, null),
  left: React450.createElement(LeftOutlined_default, null),
  right: React450.createElement(RightOutlined_default, null),
  flipX: React450.createElement(SwapOutlined_default, null),
  flipY: React450.createElement(SwapOutlined_default, {
    rotate: 90
  })
};
var InternalPreviewGroup = ({
  previewPrefixCls: customizePrefixCls,
  preview,
  classNames,
  styles,
  ...otherProps
}) => {
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    direction,
    preview: contextPreview,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("image");
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  const previewPrefixCls = `${prefixCls}-preview`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default43(prefixCls, rootCls);
  const mergedRootClassName = clsx(hashId, cssVarCls, rootCls);
  const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
  const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
  const memoizedIcons = React450.useMemo(() => ({
    ...icons,
    left: direction === "rtl" ? React450.createElement(RightOutlined_default, null) : React450.createElement(LeftOutlined_default, null),
    right: direction === "rtl" ? React450.createElement(LeftOutlined_default, null) : React450.createElement(RightOutlined_default, null)
  }), [direction]);
  const mergedPreview = useMergedPreviewConfig_default(
    // Preview config
    previewConfig,
    contextPreviewConfig,
    // MISC
    prefixCls,
    mergedRootClassName,
    getContextPopupContainer,
    icons
  );
  const {
    mask: mergedMask,
    blurClassName
  } = mergedPreview ?? {};
  const mergedProps = {
    ...otherProps,
    classNames,
    styles
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames, {
    cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
    popup: {
      root: clsx(contextPreviewRootClassName, previewRootClassName),
      mask: clsx({
        [`${prefixCls}-preview-mask-hidden`]: !mergedMask
      }, blurClassName)
    }
  }], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  return React450.createElement(es_default27.PreviewGroup, {
    preview: mergedPreview,
    previewPrefixCls,
    icons: memoizedIcons,
    ...otherProps,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
};
var PreviewGroup_default2 = InternalPreviewGroup;

// node_modules/antd/es/image/index.js
var Image2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    preview,
    className,
    rootClassName,
    style: style2,
    styles,
    classNames,
    wrapperStyle,
    fallback,
    ...otherProps
  } = props;
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    preview: contextPreview,
    styles: contextStyles,
    classNames: contextClassNames,
    fallback: contextFallback
  } = useComponentConfig("image");
  const prefixCls = getPrefixCls("image", customizePrefixCls);
  if (true) {
    const warning5 = devUseWarning("Image");
    warning5.deprecated(!wrapperStyle, "wrapperStyle", "styles.root");
  }
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default43(prefixCls, rootCls);
  const mergedRootClassName = clsx(rootClassName, hashId, cssVarCls, rootCls);
  const mergedClassName = clsx(className, hashId, contextClassName);
  const [previewConfig, previewRootClassName, previewMaskClassName] = usePreviewConfig(preview);
  const [contextPreviewConfig, contextPreviewRootClassName, contextPreviewMaskClassName] = usePreviewConfig(contextPreview);
  const mergedPreviewConfig = useMergedPreviewConfig_default(
    // Preview config
    previewConfig,
    contextPreviewConfig,
    // MISC
    prefixCls,
    mergedRootClassName,
    getContextPopupContainer,
    icons,
    true
  );
  const mergedProps = {
    ...props,
    preview: mergedPreviewConfig
  };
  const mergedLegacyClassNames = React451.useMemo(() => ({
    cover: clsx(contextPreviewMaskClassName, previewMaskClassName),
    popup: {
      root: clsx(contextPreviewRootClassName, previewRootClassName)
    }
  }), [previewRootClassName, previewMaskClassName, contextPreviewRootClassName, contextPreviewMaskClassName]);
  const {
    mask: mergedMask,
    blurClassName
  } = mergedPreviewConfig ?? {};
  const mergedPopupClassNames = React451.useMemo(() => ({
    mask: clsx({
      [`${prefixCls}-preview-mask-hidden`]: !mergedMask
    }, blurClassName)
  }), [mergedMask, prefixCls, blurClassName]);
  const internalClassNames = React451.useMemo(() => [contextClassNames, classNames, mergedLegacyClassNames, {
    popup: mergedPopupClassNames
  }], [contextClassNames, classNames, mergedLegacyClassNames, mergedPopupClassNames]);
  const [mergedClassNames, mergedStyles] = useMergeSemantic(internalClassNames, [contextStyles, {
    root: wrapperStyle
  }, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedStyle = {
    ...contextStyle,
    ...style2
  };
  const mergedFallback = fallback ?? contextFallback;
  return React451.createElement(es_default27, {
    prefixCls,
    preview: mergedPreviewConfig || false,
    rootClassName: mergedRootClassName,
    className: mergedClassName,
    style: mergedStyle,
    fallback: mergedFallback,
    ...otherProps,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
};
Image2.PreviewGroup = PreviewGroup_default2;
if (true) {
  Image2.displayName = "Image";
}
var image_default = Image2;

// node_modules/antd/es/input/Group.js
var React452 = __toESM(require_react());
var import_react175 = __toESM(require_react());
var Group2 = (props) => {
  const {
    getPrefixCls,
    direction
  } = (0, import_react175.useContext)(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className
  } = props;
  const prefixCls = getPrefixCls("input-group", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input");
  const [hashId, cssVarCls] = style_default24(inputPrefixCls);
  const cls = clsx(prefixCls, cssVarCls, {
    [`${prefixCls}-lg`]: props.size === "large",
    [`${prefixCls}-sm`]: props.size === "small",
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, className);
  const formItemContext = (0, import_react175.useContext)(FormItemInputContext);
  const groupFormItemContext = (0, import_react175.useMemo)(() => ({
    ...formItemContext,
    isFormItemInput: false
  }), [formItemContext]);
  if (true) {
    const warning5 = devUseWarning("Input.Group");
    warning5.deprecated(false, "Input.Group", "Space.Compact");
  }
  return React452.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, React452.createElement(space_default.Compact, {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, props.children));
};
var Group_default2 = Group2;

// node_modules/antd/es/input/OTP/index.js
var React454 = __toESM(require_react());

// node_modules/antd/es/input/style/otp.js
var genOTPStyle = (token2) => {
  const {
    componentCls,
    paddingXS
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: paddingXS,
      [`${componentCls}-input-wrapper`]: {
        position: "relative",
        [`${componentCls}-mask-icon`]: {
          position: "absolute",
          zIndex: "1",
          top: "50%",
          right: "50%",
          transform: "translate(50%, -50%)",
          pointerEvents: "none"
        },
        [`${componentCls}-mask-input`]: {
          color: "transparent",
          caretColor: token2.colorText
        },
        [`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
          "-webkit-appearance": "none",
          margin: 0
        },
        [`${componentCls}-mask-input[type=number]`]: {
          "-moz-appearance": "textfield"
        }
      },
      "&-rtl": {
        direction: "rtl"
      },
      [`${componentCls}-input`]: {
        textAlign: "center",
        paddingInline: token2.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token2.paddingXS
      }
    }
  };
};
var otp_default = genStyleHooks(["Input", "OTP"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return genOTPStyle(inputToken);
}, initComponentToken);

// node_modules/antd/es/input/OTP/OTPInput.js
var React453 = __toESM(require_react());
var OTPInput = React453.forwardRef((props, ref) => {
  const {
    className,
    value,
    onChange,
    onActiveChange,
    index: index2,
    mask,
    onFocus,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React453.useContext(ConfigContext);
  const prefixCls = getPrefixCls("otp");
  const maskValue = typeof mask === "string" ? mask : value;
  const inputRef = React453.useRef(null);
  React453.useImperativeHandle(ref, () => inputRef.current);
  const onInternalChange = (e3) => {
    onChange(index2, e3.target.value);
  };
  const syncSelection = () => {
    raf_default(() => {
      var _a;
      const inputEle = (_a = inputRef.current) == null ? void 0 : _a.input;
      if (document.activeElement === inputEle && inputEle) {
        inputEle.select();
      }
    });
  };
  const onInternalFocus = (e3) => {
    onFocus == null ? void 0 : onFocus(e3);
    syncSelection();
  };
  const onInternalKeyDown = (event) => {
    const {
      key,
      ctrlKey,
      metaKey
    } = event;
    if (key === "ArrowLeft") {
      onActiveChange(index2 - 1);
    } else if (key === "ArrowRight") {
      onActiveChange(index2 + 1);
    } else if (key === "z" && (ctrlKey || metaKey)) {
      event.preventDefault();
    } else if (key === "Backspace" && !value) {
      onActiveChange(index2 - 1);
    }
    syncSelection();
  };
  return React453.createElement("span", {
    className: `${prefixCls}-input-wrapper`,
    role: "presentation"
  }, mask && value !== "" && value !== void 0 && React453.createElement("span", {
    className: `${prefixCls}-mask-icon`,
    "aria-hidden": "true"
  }, maskValue), React453.createElement(Input_default5, {
    "aria-label": `OTP Input ${index2 + 1}`,
    type: mask === true ? "password" : "text",
    ...restProps,
    ref: inputRef,
    value,
    onInput: onInternalChange,
    onFocus: onInternalFocus,
    onKeyDown: onInternalKeyDown,
    onMouseDown: syncSelection,
    onMouseUp: syncSelection,
    className: clsx(className, {
      [`${prefixCls}-mask-input`]: mask
    })
  }));
});
var OTPInput_default = OTPInput;

// node_modules/antd/es/input/OTP/index.js
function strToArr(str) {
  return (str || "").split("");
}
var Separator = (props) => {
  const {
    index: index2,
    prefixCls,
    separator,
    className: semanticClassName,
    style: semanticStyle
  } = props;
  const separatorNode = typeof separator === "function" ? separator(index2) : separator;
  if (!separatorNode) {
    return null;
  }
  return React454.createElement("span", {
    className: clsx(`${prefixCls}-separator`, semanticClassName),
    style: semanticStyle
  }, separatorNode);
};
var OTP = React454.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    length: length2 = 6,
    size: customSize,
    defaultValue,
    value,
    onChange,
    formatter,
    separator,
    variant,
    disabled,
    status: customStatus,
    autoFocus,
    mask,
    type: type5,
    onInput,
    onFocus,
    inputMode,
    classNames,
    styles,
    className,
    style: style2,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Input.OTP");
    true ? warning5(!(typeof mask === "string" && mask.length > 1), "usage", "`mask` prop should be a single character.") : void 0;
  }
  const {
    classNames: contextClassNames,
    styles: contextStyles,
    getPrefixCls,
    direction,
    style: contextStyle,
    className: contextClassName
  } = useComponentConfig("otp");
  const prefixCls = getPrefixCls("otp", customizePrefixCls);
  const mergedProps = {
    ...props,
    length: length2
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const domAttrs = pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  });
  const [hashId, cssVarCls] = otp_default(prefixCls);
  const mergedSize = useSize_default((ctx) => customSize ?? ctx);
  const formContext = React454.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(formContext.status, customStatus);
  const proxyFormContext = React454.useMemo(() => ({
    ...formContext,
    status: mergedStatus,
    hasFeedback: false,
    feedbackIcon: null
  }), [formContext, mergedStatus]);
  const containerRef = React454.useRef(null);
  const refs = React454.useRef({});
  React454.useImperativeHandle(ref, () => ({
    focus: () => {
      var _a;
      (_a = refs.current[0]) == null ? void 0 : _a.focus();
    },
    blur: () => {
      var _a;
      for (let i = 0; i < length2; i += 1) {
        (_a = refs.current[i]) == null ? void 0 : _a.blur();
      }
    },
    nativeElement: containerRef.current
  }));
  const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
  const [valueCells, setValueCells] = React454.useState(() => strToArr(internalFormatter(defaultValue || "")));
  React454.useEffect(() => {
    if (value !== void 0) {
      setValueCells(strToArr(value));
    }
  }, [value]);
  const triggerValueCellsChange = useEvent_default((nextValueCells) => {
    setValueCells(nextValueCells);
    if (onInput) {
      onInput(nextValueCells);
    }
    if (onChange && nextValueCells.length === length2 && nextValueCells.every((c) => c) && nextValueCells.some((c, index2) => valueCells[index2] !== c)) {
      onChange(nextValueCells.join(""));
    }
  });
  const patchValue = useEvent_default((index2, txt) => {
    let nextCells = _toConsumableArray(valueCells);
    for (let i = 0; i < index2; i += 1) {
      if (!nextCells[i]) {
        nextCells[i] = "";
      }
    }
    if (txt.length <= 1) {
      nextCells[index2] = txt;
    } else {
      nextCells = nextCells.slice(0, index2).concat(strToArr(txt));
    }
    nextCells = nextCells.slice(0, length2);
    for (let i = nextCells.length - 1; i >= 0; i -= 1) {
      if (nextCells[i]) {
        break;
      }
      nextCells.pop();
    }
    const formattedValue = internalFormatter(nextCells.map((c) => c || " ").join(""));
    nextCells = strToArr(formattedValue).map((c, i) => {
      if (c === " " && !nextCells[i]) {
        return nextCells[i];
      }
      return c;
    });
    return nextCells;
  });
  const onInputChange = (index2, txt) => {
    var _a;
    const nextCells = patchValue(index2, txt);
    const nextIndex = Math.min(index2 + txt.length, length2 - 1);
    if (nextIndex !== index2 && nextCells[index2] !== void 0) {
      (_a = refs.current[nextIndex]) == null ? void 0 : _a.focus();
    }
    triggerValueCellsChange(nextCells);
  };
  const onInputActiveChange = (nextIndex) => {
    var _a;
    (_a = refs.current[nextIndex]) == null ? void 0 : _a.focus();
  };
  const onInputFocus = (event, index2) => {
    var _a, _b, _c;
    for (let i = 0; i < index2; i += 1) {
      if (!((_b = (_a = refs.current[i]) == null ? void 0 : _a.input) == null ? void 0 : _b.value)) {
        (_c = refs.current[i]) == null ? void 0 : _c.focus();
        break;
      }
    }
    onFocus == null ? void 0 : onFocus(event);
  };
  const inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus,
    mask,
    type: type5,
    inputMode
  };
  return React454.createElement("div", {
    ...domAttrs,
    ref: containerRef,
    className: clsx(className, prefixCls, {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, cssVarCls, hashId, contextClassName, mergedClassNames.root),
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    role: "group"
  }, React454.createElement(FormItemInputContext.Provider, {
    value: proxyFormContext
  }, Array.from({
    length: length2
  }).map((_, index2) => {
    const key = `otp-${index2}`;
    const singleValue = valueCells[index2] || "";
    return React454.createElement(React454.Fragment, {
      key
    }, React454.createElement(OTPInput_default, {
      ref: (inputEle) => {
        refs.current[index2] = inputEle;
      },
      index: index2,
      size: mergedSize,
      htmlSize: 1,
      className: clsx(mergedClassNames.input, `${prefixCls}-input`),
      style: mergedStyles.input,
      onChange: onInputChange,
      value: singleValue,
      onActiveChange: onInputActiveChange,
      autoFocus: index2 === 0 && autoFocus,
      onFocus: (event) => onInputFocus(event, index2),
      ...inputSharedProps
    }), index2 < length2 - 1 && React454.createElement(Separator, {
      separator,
      index: index2,
      prefixCls,
      className: clsx(mergedClassNames.separator),
      style: mergedStyles.separator
    }));
  })));
});
var OTP_default = OTP;

// node_modules/antd/es/input/Password.js
var React455 = __toESM(require_react());
var import_react176 = __toESM(require_react());
var defaultIconRender = (visible) => visible ? React455.createElement(EyeOutlined_default, null) : React455.createElement(EyeInvisibleOutlined_default, null);
var actionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = React455.forwardRef((props, ref) => {
  const {
    disabled: customDisabled,
    action = "click",
    visibilityToggle = true,
    iconRender = defaultIconRender,
    suffix
  } = props;
  const disabled = React455.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
  const [visible, setVisible] = (0, import_react176.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
  const inputRef = (0, import_react176.useRef)(null);
  React455.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = () => {
    var _a;
    if (mergedDisabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    const nextVisible = !visible;
    setVisible(nextVisible);
    if (typeof visibilityToggle === "object") {
      (_a = visibilityToggle.onVisibleChange) == null ? void 0 : _a.call(visibilityToggle, nextVisible);
    }
  };
  const getIcon2 = (prefixCls2) => {
    const iconTrigger = actionMap[action] || "";
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: (e3) => {
        e3.preventDefault();
      },
      onMouseUp: (e3) => {
        e3.preventDefault();
      }
    };
    return React455.cloneElement(React455.isValidElement(icon) ? icon : React455.createElement("span", null, icon), iconProps);
  };
  const {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React455.useContext(ConfigContext);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const prefixCls = getPrefixCls("input-password", customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon2(prefixCls);
  const inputClassName = clsx(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = {
    ...omit(restProps, ["suffix", "iconRender", "visibilityToggle"]),
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: React455.createElement(React455.Fragment, null, suffixIcon, suffix)
  };
  if (size) {
    omittedProps.size = size;
  }
  return React455.createElement(Input_default5, {
    ref: composeRef(ref, inputRef),
    ...omittedProps
  });
});
if (true) {
  Password.displayName = "Input.Password";
}
var Password_default = Password;

// node_modules/antd/es/input/Search.js
var React456 = __toESM(require_react());

// node_modules/antd/es/input/style/search.js
var genSearchStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const btnCls = `${componentCls}-btn`;
  return {
    [componentCls]: {
      width: "100%",
      // =========================== Button ===========================
      [btnCls]: {
        "&-filled": {
          background: token2.colorFillTertiary,
          "&:not(:disabled)": {
            "&:hover": {
              background: token2.colorFillSecondary
            },
            "&:active": {
              background: token2.colorFill
            }
          }
        }
      }
    }
  };
};
var search_default = genStyleHooks(["Input", "Search"], (token2) => {
  return [genSearchStyle(token2)];
});

// node_modules/antd/es/input/Search.js
var Search = React456.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    style: style2,
    enterButton = false,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd,
    variant,
    onPressEnter: customOnPressEnter,
    classNames,
    styles,
    hidden,
    ...restProps
  } = props;
  const {
    direction,
    getPrefixCls,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("inputSearch");
  const mergedProps = {
    ...props,
    enterButton
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    button: {
      _default: "root"
    }
  });
  const composedRef = React456.useRef(false);
  const prefixCls = getPrefixCls("input-search", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const [hashId, cssVarCls] = search_default(prefixCls);
  const {
    compactSize
  } = useCompactItemContext(prefixCls, direction);
  const size = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const inputRef = React456.useRef(null);
  const onChange = (e3) => {
    if ((e3 == null ? void 0 : e3.target) && e3.type === "click" && customOnSearch) {
      customOnSearch(e3.target.value, e3, {
        source: "clear"
      });
    }
    customOnChange == null ? void 0 : customOnChange(e3);
  };
  const onMouseDown = (e3) => {
    var _a;
    if (document.activeElement === ((_a = inputRef.current) == null ? void 0 : _a.input)) {
      e3.preventDefault();
    }
  };
  const onSearch = (e3) => {
    var _a, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a = inputRef.current) == null ? void 0 : _a.input) == null ? void 0 : _b.value, e3, {
        source: "input"
      });
    }
  };
  const onPressEnter = (e3) => {
    if (composedRef.current || loading) {
      return;
    }
    customOnPressEnter == null ? void 0 : customOnPressEnter(e3);
    onSearch(e3);
  };
  const searchIcon = typeof enterButton === "boolean" ? React456.createElement(SearchOutlined_default, null) : null;
  const btnPrefixCls = `${prefixCls}-btn`;
  const btnClassName = clsx(btnPrefixCls, {
    [`${btnPrefixCls}-${variant}`]: variant
  });
  let button;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement3(enterButtonAsElement, {
      onMouseDown,
      onClick: (e3) => {
        var _a, _b;
        (_b = (_a = enterButtonAsElement == null ? void 0 : enterButtonAsElement.props) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, e3);
        onSearch(e3);
      },
      key: "enterButton",
      ...isAntdButton ? {
        className: btnClassName,
        size
      } : {}
    });
  } else {
    button = React456.createElement(Button_default, {
      classNames: mergedClassNames.button,
      styles: mergedStyles.button,
      className: btnClassName,
      color: enterButton ? "primary" : "default",
      size,
      disabled,
      key: "enterButton",
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon,
      variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
    }, enterButton);
  }
  if (addonAfter) {
    button = [button, cloneElement3(addonAfter, {
      key: "addonAfter"
    })];
  }
  const mergedClassName = clsx(prefixCls, cssVarCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className, hashId, mergedClassNames.root);
  const handleOnCompositionStart = (e3) => {
    composedRef.current = true;
    onCompositionStart == null ? void 0 : onCompositionStart(e3);
  };
  const handleOnCompositionEnd = (e3) => {
    composedRef.current = false;
    onCompositionEnd == null ? void 0 : onCompositionEnd(e3);
  };
  const rootProps = pickAttrs(restProps, {
    data: true
  });
  const inputProps = omit({
    ...restProps,
    classNames: omit(mergedClassNames, ["button", "root"]),
    styles: omit(mergedStyles, ["button", "root"]),
    prefixCls: inputPrefixCls,
    type: "search",
    size,
    variant,
    onPressEnter,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    onChange,
    disabled
  }, Object.keys(rootProps));
  return React456.createElement(Compact_default, {
    className: mergedClassName,
    style: {
      ...style2,
      ...mergedStyles.root
    },
    ...rootProps,
    hidden
  }, React456.createElement(Input_default5, {
    ref: composeRef(inputRef, ref),
    ...inputProps
  }), button);
});
if (true) {
  Search.displayName = "Search";
}
var Search_default = Search;

// node_modules/antd/es/input/TextArea.js
var React459 = __toESM(require_react());
var import_react178 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/TextArea.js
var import_react177 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/ResizableTextArea.js
var React457 = __toESM(require_react());

// node_modules/@rc-component/textarea/es/calculateNodeHeight.js
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node2, useCache = false) {
  const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  const style2 = window.getComputedStyle(node2);
  const boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  const paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  const sizingStyle = SIZING_STYLE.map((name) => `${name}:${style2.getPropertyValue(name)}`).join(";");
  const nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode, useCache = false, minRows = null, maxRows = null) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    hiddenTextarea.setAttribute("name", "hiddenTextarea");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  const {
    paddingSize,
    borderSize,
    boxSizing,
    sizingStyle
  } = calculateNodeStyling(uiTextNode, useCache);
  hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  let minHeight = void 0;
  let maxHeight = void 0;
  let overflowY;
  let height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  const style2 = {
    height,
    overflowY,
    resize: "none"
  };
  if (minHeight) {
    style2.minHeight = minHeight;
  }
  if (maxHeight) {
    style2.maxHeight = maxHeight;
  }
  return style2;
}

// node_modules/@rc-component/textarea/es/ResizableTextArea.js
function _extends69() {
  _extends69 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends69.apply(this, arguments);
}
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = React457.forwardRef((props, ref) => {
  const {
    prefixCls,
    defaultValue,
    value,
    autoSize,
    onResize: onResize2,
    className,
    style: style2,
    disabled,
    onChange,
    // Test only
    onInternalAutoSize,
    ...restProps
  } = props;
  const [internalValue, setMergedValue] = useControlledState(defaultValue, value);
  const mergedValue = internalValue ?? "";
  const onInternalChange = (event) => {
    setMergedValue(event.target.value);
    onChange == null ? void 0 : onChange(event);
  };
  const textareaRef = React457.useRef();
  React457.useImperativeHandle(ref, () => ({
    textArea: textareaRef.current
  }));
  const [minRows, maxRows] = React457.useMemo(() => {
    if (autoSize && typeof autoSize === "object") {
      return [autoSize.minRows, autoSize.maxRows];
    }
    return [];
  }, [autoSize]);
  const needAutoSize = !!autoSize;
  const [resizeState, setResizeState] = React457.useState(RESIZE_STABLE);
  const [autoSizeStyle, setAutoSizeStyle] = React457.useState();
  const startResize = () => {
    setResizeState(RESIZE_START);
    if (false) {
      onInternalAutoSize == null ? void 0 : onInternalAutoSize();
    }
  };
  useLayoutEffect_default(() => {
    if (needAutoSize) {
      startResize();
    }
  }, [value, minRows, maxRows, needAutoSize]);
  useLayoutEffect_default(() => {
    if (resizeState === RESIZE_START) {
      setResizeState(RESIZE_MEASURING);
    } else if (resizeState === RESIZE_MEASURING) {
      const textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
      setResizeState(RESIZE_STABLE);
      setAutoSizeStyle(textareaStyles);
    } else {
    }
  }, [resizeState]);
  const resizeRafRef = React457.useRef();
  const cleanRaf = () => {
    raf_default.cancel(resizeRafRef.current);
  };
  const onInternalResize = (size) => {
    if (resizeState === RESIZE_STABLE) {
      onResize2 == null ? void 0 : onResize2(size);
      if (autoSize) {
        cleanRaf();
        resizeRafRef.current = raf_default(() => {
          startResize();
        });
      }
    }
  };
  React457.useEffect(() => cleanRaf, []);
  const mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
  const mergedStyle = {
    ...style2,
    ...mergedAutoSizeStyle
  };
  if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
    mergedStyle.overflowY = "hidden";
    mergedStyle.overflowX = "hidden";
  }
  return React457.createElement(es_default, {
    onResize: onInternalResize,
    disabled: !(autoSize || onResize2)
  }, React457.createElement("textarea", _extends69({}, restProps, {
    ref: textareaRef,
    style: mergedStyle,
    className: clsx(prefixCls, className, {
      [`${prefixCls}-disabled`]: disabled
    }),
    disabled,
    value: mergedValue,
    onChange: onInternalChange
  })));
});
var ResizableTextArea_default = ResizableTextArea;

// node_modules/@rc-component/textarea/es/TextArea.js
function _extends70() {
  _extends70 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends70.apply(this, arguments);
}
var TextArea = import_react177.default.forwardRef(({
  defaultValue,
  value: customValue,
  onFocus,
  onBlur,
  onChange,
  allowClear,
  maxLength,
  onCompositionStart,
  onCompositionEnd,
  suffix,
  prefixCls = "rc-textarea",
  showCount,
  count,
  className,
  style: style2,
  disabled,
  hidden,
  classNames,
  styles,
  onResize: onResize2,
  onClear,
  onPressEnter,
  readOnly,
  autoSize,
  onKeyDown: onKeyDown2,
  ...rest
}, ref) => {
  const [value, setValue] = useControlledState(defaultValue, customValue);
  const formatValue2 = value === void 0 || value === null ? "" : String(value);
  const [focused, setFocused] = import_react177.default.useState(false);
  const compositionRef = import_react177.default.useRef(false);
  const [textareaResized, setTextareaResized] = import_react177.default.useState(null);
  const holderRef = (0, import_react177.useRef)(null);
  const resizableTextAreaRef = (0, import_react177.useRef)(null);
  const getTextArea = () => {
    var _a;
    return (_a = resizableTextAreaRef.current) == null ? void 0 : _a.textArea;
  };
  const focus = () => {
    getTextArea().focus();
  };
  (0, import_react177.useImperativeHandle)(ref, () => {
    var _a;
    return {
      resizableTextArea: resizableTextAreaRef.current,
      focus,
      blur: () => {
        getTextArea().blur();
      },
      nativeElement: ((_a = holderRef.current) == null ? void 0 : _a.nativeElement) || getTextArea()
    };
  });
  (0, import_react177.useEffect)(() => {
    setFocused((prev2) => !disabled && prev2);
  }, [disabled]);
  const [selection, setSelection] = import_react177.default.useState(null);
  import_react177.default.useEffect(() => {
    if (selection) {
      getTextArea().setSelectionRange(...selection);
    }
  }, [selection]);
  const countConfig = useCount(count, showCount);
  const mergedMax = countConfig.max ?? maxLength;
  const hasMaxLength = Number(mergedMax) > 0;
  const valueLength = countConfig.strategy(formatValue2);
  const isOutOfRange = !!mergedMax && valueLength > mergedMax;
  const triggerChange = (e3, currentValue) => {
    let cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
      }
    }
    setValue(cutValue);
    resolveOnChange(e3.currentTarget, e3, onChange, cutValue);
  };
  const onInternalCompositionStart = (e3) => {
    compositionRef.current = true;
    onCompositionStart == null ? void 0 : onCompositionStart(e3);
  };
  const onInternalCompositionEnd = (e3) => {
    compositionRef.current = false;
    triggerChange(e3, e3.currentTarget.value);
    onCompositionEnd == null ? void 0 : onCompositionEnd(e3);
  };
  const onInternalChange = (e3) => {
    triggerChange(e3, e3.target.value);
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter" && onPressEnter && !e3.nativeEvent.isComposing) {
      onPressEnter(e3);
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(e3);
  };
  const handleFocus = (e3) => {
    setFocused(true);
    onFocus == null ? void 0 : onFocus(e3);
  };
  const handleBlur = (e3) => {
    setFocused(false);
    onBlur == null ? void 0 : onBlur(e3);
  };
  const handleReset = (e3) => {
    setValue("");
    focus();
    resolveOnChange(getTextArea(), e3, onChange);
  };
  let suffixNode = suffix;
  let dataCount;
  if (countConfig.show) {
    if (countConfig.showFormatter) {
      dataCount = countConfig.showFormatter({
        value: formatValue2,
        count: valueLength,
        maxLength: mergedMax
      });
    } else {
      dataCount = `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
    }
    suffixNode = import_react177.default.createElement(import_react177.default.Fragment, null, suffixNode, import_react177.default.createElement("span", {
      className: clsx(`${prefixCls}-data-count`, classNames == null ? void 0 : classNames.count),
      style: styles == null ? void 0 : styles.count
    }, dataCount));
  }
  const handleResize = (size) => {
    var _a;
    onResize2 == null ? void 0 : onResize2(size);
    if ((_a = getTextArea()) == null ? void 0 : _a.style.height) {
      setTextareaResized(true);
    }
  };
  const isPureTextArea = !autoSize && !showCount && !allowClear;
  return import_react177.default.createElement(BaseInput_default, {
    ref: holderRef,
    value: formatValue2,
    allowClear,
    handleReset,
    suffix: suffixNode,
    prefixCls,
    classNames: {
      ...classNames,
      affixWrapper: clsx(classNames == null ? void 0 : classNames.affixWrapper, {
        [`${prefixCls}-show-count`]: showCount,
        [`${prefixCls}-textarea-allow-clear`]: allowClear
      })
    },
    disabled,
    focused,
    className: clsx(className, isOutOfRange && `${prefixCls}-out-of-range`),
    style: {
      ...style2,
      ...textareaResized && !isPureTextArea ? {
        height: "auto"
      } : {}
    },
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof dataCount === "string" ? dataCount : void 0
      }
    },
    hidden,
    readOnly,
    onClear
  }, import_react177.default.createElement(ResizableTextArea_default, _extends70({}, rest, {
    autoSize,
    maxLength,
    onKeyDown: handleKeyDown,
    onChange: onInternalChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onCompositionStart: onInternalCompositionStart,
    onCompositionEnd: onInternalCompositionEnd,
    className: clsx(classNames == null ? void 0 : classNames.textarea),
    style: {
      resize: style2 == null ? void 0 : style2.resize,
      ...styles == null ? void 0 : styles.textarea
    },
    disabled,
    prefixCls,
    onResize: handleResize,
    ref: resizableTextAreaRef,
    readOnly
  })));
});
var TextArea_default = TextArea;

// node_modules/@rc-component/textarea/es/index.js
var es_default28 = TextArea_default;

// node_modules/antd/es/input/style/textarea.js
var genTextAreaStyle = (token2) => {
  const {
    componentCls,
    paddingLG
  } = token2;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    // Raw Textarea
    [`textarea${componentCls}`]: {
      maxWidth: "100%",
      // prevent textarea resize from coming out of its container
      height: "auto",
      minHeight: token2.controlHeight,
      lineHeight: token2.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${token2.motionDurationSlow}`,
      resize: "vertical",
      [`&${componentCls}-mouse-active`]: {
        transition: `all ${token2.motionDurationSlow}, height 0s, width 0s`
      }
    },
    // Wrapper for resize
    [`${componentCls}-textarea-affix-wrapper-resize-dirty`]: {
      width: "auto"
    },
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        [`${componentCls}-data-count`]: {
          position: "absolute",
          bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
        paddingInlineEnd: paddingLG
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          minHeight: token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal(),
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token2.paddingInline,
            insetBlockStart: token2.paddingXS
          },
          // Feedback Icon
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: {
        [`${componentCls}-suffix`]: {
          [`${componentCls}-data-count`]: {
            direction: "ltr",
            insetInlineStart: 0
          }
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
        [`${componentCls}-suffix`]: {
          [`${componentCls}-clear-icon`]: {
            insetInlineEnd: token2.paddingInlineSM
          }
        }
      }
    }
  };
};
var textarea_default = genStyleHooks(["Input", "TextArea"], (token2) => {
  const inputToken = merge2(token2, initInputToken(token2));
  return genTextAreaStyle(inputToken);
}, initComponentToken, {
  resetFont: false
});

// node_modules/antd/es/input/TextArea.js
var TextArea2 = (0, import_react178.forwardRef)((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear,
    classNames,
    rootClassName,
    className,
    style: style2,
    styles,
    variant: customVariant,
    showCount,
    onMouseDown,
    onResize: onResize2,
    ...rest
  } = props;
  if (true) {
    const {
      deprecated
    } = devUseWarning("TextArea");
    deprecated(!("bordered" in props), "bordered", "variant");
  }
  const {
    getPrefixCls,
    direction,
    allowClear: contextAllowClear,
    autoComplete: contextAutoComplete,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("textArea");
  const disabled = React459.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React459.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const innerRef = React459.useRef(null);
  React459.useImperativeHandle(ref, () => {
    var _a2;
    return {
      resizableTextArea: (_a2 = innerRef.current) == null ? void 0 : _a2.resizableTextArea,
      focus: (option) => {
        var _a3, _b;
        triggerFocus((_b = (_a3 = innerRef.current) == null ? void 0 : _a3.resizableTextArea) == null ? void 0 : _b.textArea, option);
      },
      blur: () => {
        var _a3;
        return (_a3 = innerRef.current) == null ? void 0 : _a3.blur();
      }
    };
  });
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
  textarea_default(prefixCls, rootCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const [variant, enableVariantCls] = useVariants_default("textArea", customVariant, bordered);
  const mergedAllowClear = getAllowClear_default(allowClear ?? contextAllowClear);
  const [isMouseDown, setIsMouseDown] = React459.useState(false);
  const [resizeDirty, setResizeDirty] = React459.useState(false);
  const onInternalMouseDown = (e3) => {
    setIsMouseDown(true);
    onMouseDown == null ? void 0 : onMouseDown(e3);
    const onMouseUp = () => {
      setIsMouseDown(false);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mouseup", onMouseUp);
  };
  const onInternalResize = (size) => {
    var _a2, _b;
    onResize2 == null ? void 0 : onResize2(size);
    if (isMouseDown && typeof getComputedStyle === "function") {
      const ele = (_b = (_a2 = innerRef.current) == null ? void 0 : _a2.nativeElement) == null ? void 0 : _b.querySelector("textarea");
      if (ele && getComputedStyle(ele).resize === "both") {
        setResizeDirty(true);
      }
    }
  };
  return React459.createElement(es_default28, {
    autoComplete: contextAutoComplete,
    ...rest,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    styles: mergedStyles,
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    className: clsx(
      cssVarCls,
      rootCls,
      className,
      rootClassName,
      compactItemClassnames,
      contextClassName,
      mergedClassNames.root,
      // Only for wrapper
      {
        [`${prefixCls}-textarea-affix-wrapper-resize-dirty`]: resizeDirty
      }
    ),
    classNames: {
      ...mergedClassNames,
      textarea: clsx({
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large"
      }, hashId, mergedClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: clsx(`${prefixCls}-textarea-affix-wrapper`, {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
        [`${prefixCls}-textarea-show-count`]: showCount || ((_a = props.count) == null ? void 0 : _a.show)
      }, hashId)
    },
    prefixCls,
    suffix: hasFeedback && React459.createElement("span", {
      className: `${prefixCls}-textarea-suffix`
    }, feedbackIcon),
    showCount,
    ref: innerRef,
    onResize: onInternalResize,
    onMouseDown: onInternalMouseDown
  });
});
var TextArea_default2 = TextArea2;

// node_modules/antd/es/input/index.js
var Input5 = Input_default5;
Input5.Group = Group_default2;
Input5.Search = Search_default;
Input5.TextArea = TextArea_default2;
Input5.Password = Password_default;
Input5.OTP = OTP_default;
var input_default2 = Input5;

// node_modules/antd/es/layout/layout.js
var React460 = __toESM(require_react());

// node_modules/antd/es/layout/hooks/useHasSider.js
function useHasSider(siders, children, hasSider) {
  if (typeof hasSider === "boolean") {
    return hasSider;
  }
  if (siders.length) {
    return true;
  }
  const childNodes = toArray(children);
  return childNodes.some((node2) => node2.type === Sider_default);
}

// node_modules/antd/es/layout/layout.js
function generator({
  suffixCls,
  tagName,
  displayName
}) {
  return (BasicComponent) => {
    const Adapter = React460.forwardRef((props, ref) => React460.createElement(BasicComponent, {
      ref,
      suffixCls,
      tagName,
      ...props
    }));
    if (true) {
      Adapter.displayName = displayName;
    }
    return Adapter;
  };
}
var Basic = React460.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    suffixCls,
    className,
    tagName: TagName,
    ...others
  } = props;
  const {
    getPrefixCls
  } = React460.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const [hashId] = style_default19(prefixCls);
  const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
  return React460.createElement(TagName, {
    className: clsx(customizePrefixCls || prefixWithSuffixCls, className, hashId),
    ref,
    ...others
  });
});
var BasicLayout = React460.forwardRef((props, ref) => {
  const {
    direction
  } = React460.useContext(ConfigContext);
  const [siders, setSiders] = React460.useState([]);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    hasSider,
    tagName: Tag2,
    style: style2,
    ...others
  } = props;
  const passedProps = omit(others, ["suffixCls"]);
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("layout");
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const mergedHasSider = useHasSider(siders, children, hasSider);
  const [hashId, cssVarCls] = style_default19(prefixCls);
  const classString = clsx(prefixCls, {
    [`${prefixCls}-has-sider`]: mergedHasSider,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, hashId, cssVarCls);
  const contextValue = React460.useMemo(() => ({
    siderHook: {
      addSider: (id) => {
        setSiders((prev2) => [].concat(_toConsumableArray(prev2), [id]));
      },
      removeSider: (id) => {
        setSiders((prev2) => prev2.filter((currentId) => currentId !== id));
      }
    }
  }), []);
  return React460.createElement(LayoutContext.Provider, {
    value: contextValue
  }, React460.createElement(Tag2, {
    ref,
    className: classString,
    style: {
      ...contextStyle,
      ...style2
    },
    ...passedProps
  }, children));
});
var Layout = generator({
  tagName: "div",
  displayName: "Layout"
})(BasicLayout);
var Header = generator({
  suffixCls: "header",
  tagName: "header",
  displayName: "Header"
})(Basic);
var Footer4 = generator({
  suffixCls: "footer",
  tagName: "footer",
  displayName: "Footer"
})(Basic);
var Content2 = generator({
  suffixCls: "content",
  tagName: "main",
  displayName: "Content"
})(Basic);
var layout_default = Layout;

// node_modules/antd/es/layout/index.js
var Layout2 = layout_default;
Layout2.Header = Header;
Layout2.Footer = Footer4;
Layout2.Content = Content2;
Layout2.Sider = Sider_default;
Layout2._InternalSiderContext = SiderContext;
var layout_default2 = Layout2;

// node_modules/antd/es/list/index.js
var React472 = __toESM(require_react());

// node_modules/antd/es/pagination/Pagination.js
var React464 = __toESM(require_react());

// node_modules/@rc-component/pagination/es/Pagination.js
var import_react181 = __toESM(require_react());

// node_modules/@rc-component/pagination/es/locale/zh_CN.js
var locale5 = {
  // Options
  items_per_page: "/",
  jump_to: "",
  jump_to_confirm: "",
  page: "",
  // Pagination
  prev_page: "",
  next_page: "",
  prev_5: " 5 ",
  next_5: " 5 ",
  prev_3: " 3 ",
  next_3: " 3 ",
  page_size: ""
};
var zh_CN_default = locale5;

// node_modules/@rc-component/pagination/es/Options.js
var import_react179 = __toESM(require_react());
var defaultPageSizeOptions = [10, 20, 50, 100];
var Options = (props) => {
  const {
    pageSizeOptions = defaultPageSizeOptions,
    locale: locale6,
    changeSize,
    pageSize,
    goButton,
    quickGo,
    rootPrefixCls,
    disabled,
    buildOptionText,
    showSizeChanger,
    sizeChangerRender
  } = props;
  const [goInputText, setGoInputText] = import_react179.default.useState("");
  const getValidValue = import_react179.default.useMemo(() => {
    return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
  }, [goInputText]);
  const mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : (value) => `${value} ${locale6.items_per_page}`;
  const handleChange = (e3) => {
    const value = e3.target.value;
    if (/^\d*$/.test(value)) {
      setGoInputText(value);
    }
  };
  const handleBlur = (e3) => {
    if (goButton || goInputText === "") {
      return;
    }
    setGoInputText("");
    if (e3.relatedTarget && (e3.relatedTarget.className.includes(`${rootPrefixCls}-item-link`) || e3.relatedTarget.className.includes(`${rootPrefixCls}-item`))) {
      return;
    }
    quickGo == null ? void 0 : quickGo(getValidValue);
  };
  const go = (e3) => {
    if (goInputText === "") {
      return;
    }
    if (e3.keyCode === KeyCode_default.ENTER || e3.type === "click") {
      setGoInputText("");
      quickGo == null ? void 0 : quickGo(getValidValue);
    }
  };
  const getPageSizeOptions = () => {
    if (pageSizeOptions.some((option) => option.toString() === pageSize.toString())) {
      return pageSizeOptions;
    }
    return pageSizeOptions.concat([pageSize]).sort((a, b) => {
      const numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
      const numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
      return numberA - numberB;
    });
  };
  const prefixCls = `${rootPrefixCls}-options`;
  if (!showSizeChanger && !quickGo) {
    return null;
  }
  let changeSelect = null;
  let goInput = null;
  let gotoButton = null;
  if (showSizeChanger && sizeChangerRender) {
    changeSelect = sizeChangerRender({
      disabled,
      size: pageSize,
      onSizeChange: (nextValue) => {
        changeSize == null ? void 0 : changeSize(Number(nextValue));
      },
      "aria-label": locale6.page_size,
      className: `${prefixCls}-size-changer`,
      options: getPageSizeOptions().map((opt) => ({
        label: mergeBuildOptionText(opt),
        value: opt
      }))
    });
  }
  if (quickGo) {
    if (goButton) {
      gotoButton = typeof goButton === "boolean" ? import_react179.default.createElement("button", {
        type: "button",
        onClick: go,
        onKeyUp: go,
        disabled,
        className: `${prefixCls}-quick-jumper-button`
      }, locale6.jump_to_confirm) : import_react179.default.createElement("span", {
        onClick: go,
        onKeyUp: go
      }, goButton);
    }
    goInput = import_react179.default.createElement("div", {
      className: `${prefixCls}-quick-jumper`
    }, locale6.jump_to, import_react179.default.createElement("input", {
      disabled,
      type: "text",
      value: goInputText,
      onChange: handleChange,
      onKeyUp: go,
      onBlur: handleBlur,
      "aria-label": locale6.page
    }), locale6.page, gotoButton);
  }
  return import_react179.default.createElement("li", {
    className: prefixCls
  }, changeSelect, goInput);
};
if (true) {
  Options.displayName = "Options";
}
var Options_default = Options;

// node_modules/@rc-component/pagination/es/Pager.js
var import_react180 = __toESM(require_react());
var Pager = (props) => {
  const {
    rootPrefixCls,
    page,
    active,
    className,
    style: style2,
    showTitle,
    onClick,
    onKeyPress,
    itemRender
  } = props;
  const prefixCls = `${rootPrefixCls}-item`;
  const cls = clsx(prefixCls, `${prefixCls}-${page}`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-disabled`]: !page
  }, className);
  const handleClick = () => {
    onClick(page);
  };
  const handleKeyPress = (e3) => {
    onKeyPress(e3, onClick, page);
  };
  const pager = itemRender(page, "page", import_react180.default.createElement("a", {
    rel: "nofollow"
  }, page));
  return pager ? import_react180.default.createElement("li", {
    title: showTitle ? String(page) : null,
    className: cls,
    style: style2,
    onClick: handleClick,
    onKeyDown: handleKeyPress,
    tabIndex: 0
  }, pager) : null;
};
if (true) {
  Pager.displayName = "Pager";
}
var Pager_default = Pager;

// node_modules/@rc-component/pagination/es/Pagination.js
function _extends71() {
  _extends71 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends71.apply(this, arguments);
}
var defaultItemRender = (_, __, element) => element;
function noop4() {
}
function isInteger(v) {
  const value = Number(v);
  return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
}
function calculatePage(p, pageSize, total) {
  const _pageSize = typeof p === "undefined" ? pageSize : p;
  return Math.floor((total - 1) / _pageSize) + 1;
}
var Pagination = (props) => {
  const {
    // cls
    prefixCls = "rc-pagination",
    selectPrefixCls = "rc-select",
    className,
    classNames: paginationClassNames,
    styles,
    // control
    current: currentProp,
    defaultCurrent = 1,
    total = 0,
    pageSize: pageSizeProp,
    defaultPageSize = 10,
    onChange = noop4,
    // config
    hideOnSinglePage,
    align,
    showPrevNextJumpers = true,
    showQuickJumper,
    showLessItems,
    showTitle = true,
    onShowSizeChange = noop4,
    locale: locale6 = zh_CN_default,
    style: style2,
    totalBoundaryShowSizeChanger = 50,
    disabled,
    simple,
    showTotal,
    showSizeChanger = total > totalBoundaryShowSizeChanger,
    sizeChangerRender,
    pageSizeOptions,
    // render
    itemRender = defaultItemRender,
    jumpPrevIcon,
    jumpNextIcon,
    prevIcon,
    nextIcon
  } = props;
  const paginationRef = import_react181.default.useRef(null);
  const [pageSize, setPageSize] = useControlledState(defaultPageSize, pageSizeProp);
  const [internalCurrent, setCurrent] = useControlledState(defaultCurrent, currentProp);
  const current = Math.max(1, Math.min(internalCurrent, calculatePage(void 0, pageSize, total)));
  const [internalInputVal, setInternalInputVal] = import_react181.default.useState(current);
  (0, import_react181.useEffect)(() => {
    setInternalInputVal(current);
  }, [current]);
  const hasOnChange = onChange !== noop4;
  const hasCurrent = "current" in props;
  if (true) {
    warning_default(hasCurrent ? hasOnChange : true, "You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
  }
  const jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
  const jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
  function getItemIcon(icon, label) {
    let iconNode = icon || import_react181.default.createElement("button", {
      type: "button",
      "aria-label": label,
      className: `${prefixCls}-item-link`
    });
    if (typeof icon === "function") {
      iconNode = import_react181.default.createElement(icon, props);
    }
    return iconNode;
  }
  function getValidValue(e3) {
    const inputValue = e3.target.value;
    const allPages2 = calculatePage(void 0, pageSize, total);
    let value;
    if (inputValue === "") {
      value = inputValue;
    } else if (Number.isNaN(Number(inputValue))) {
      value = internalInputVal;
    } else if (inputValue >= allPages2) {
      value = allPages2;
    } else {
      value = Number(inputValue);
    }
    return value;
  }
  function isValid(page) {
    return isInteger(page) && page !== current && isInteger(total) && total > 0;
  }
  const shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
  function handleKeyDown(event) {
    if (event.keyCode === KeyCode_default.UP || event.keyCode === KeyCode_default.DOWN) {
      event.preventDefault();
    }
  }
  function handleKeyUp(event) {
    const value = getValidValue(event);
    if (value !== internalInputVal) {
      setInternalInputVal(value);
    }
    switch (event.keyCode) {
      case KeyCode_default.ENTER:
        handleChange(value);
        break;
      case KeyCode_default.UP:
        handleChange(value - 1);
        break;
      case KeyCode_default.DOWN:
        handleChange(value + 1);
        break;
      default:
        break;
    }
  }
  function handleBlur(event) {
    handleChange(getValidValue(event));
  }
  function changePageSize(size) {
    const newCurrent = calculatePage(size, pageSize, total);
    const nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
    setPageSize(size);
    setInternalInputVal(nextCurrent);
    onShowSizeChange == null ? void 0 : onShowSizeChange(current, size);
    setCurrent(nextCurrent);
    onChange == null ? void 0 : onChange(nextCurrent, size);
  }
  function handleChange(page) {
    if (isValid(page) && !disabled) {
      const currentPage = calculatePage(void 0, pageSize, total);
      let newPage = page;
      if (page > currentPage) {
        newPage = currentPage;
      } else if (page < 1) {
        newPage = 1;
      }
      if (newPage !== internalInputVal) {
        setInternalInputVal(newPage);
      }
      setCurrent(newPage);
      onChange == null ? void 0 : onChange(newPage, pageSize);
      return newPage;
    }
    return current;
  }
  const hasPrev = current > 1;
  const hasNext = current < calculatePage(void 0, pageSize, total);
  function prevHandle() {
    if (hasPrev)
      handleChange(current - 1);
  }
  function nextHandle() {
    if (hasNext)
      handleChange(current + 1);
  }
  function jumpPrevHandle() {
    handleChange(jumpPrevPage);
  }
  function jumpNextHandle() {
    handleChange(jumpNextPage);
  }
  function runIfEnter(event, callback, ...restParams) {
    if (event.key === "Enter" || event.charCode === KeyCode_default.ENTER || event.keyCode === KeyCode_default.ENTER) {
      callback(...restParams);
    }
  }
  function runIfEnterPrev(event) {
    runIfEnter(event, prevHandle);
  }
  function runIfEnterNext(event) {
    runIfEnter(event, nextHandle);
  }
  function runIfEnterJumpPrev(event) {
    runIfEnter(event, jumpPrevHandle);
  }
  function runIfEnterJumpNext(event) {
    runIfEnter(event, jumpNextHandle);
  }
  function renderPrev(prevPage2) {
    const prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
    return import_react181.default.isValidElement(prevButton) ? import_react181.default.cloneElement(prevButton, {
      disabled: !hasPrev
    }) : prevButton;
  }
  function renderNext(nextPage2) {
    const nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
    return import_react181.default.isValidElement(nextButton) ? import_react181.default.cloneElement(nextButton, {
      disabled: !hasNext
    }) : nextButton;
  }
  function handleGoTO(event) {
    if (event.type === "click" || event.keyCode === KeyCode_default.ENTER) {
      handleChange(internalInputVal);
    }
  }
  let jumpPrev = null;
  const dataOrAriaAttributeProps = pickAttrs(props, {
    aria: true,
    data: true
  });
  const totalText = showTotal && import_react181.default.createElement("li", {
    className: `${prefixCls}-total-text`
  }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
  let jumpNext = null;
  const allPages = calculatePage(void 0, pageSize, total);
  if (hideOnSinglePage && total <= pageSize) {
    return null;
  }
  const pagerList = [];
  const pagerProps = {
    rootPrefixCls: prefixCls,
    onClick: handleChange,
    onKeyPress: runIfEnter,
    showTitle,
    itemRender,
    page: -1,
    className: paginationClassNames == null ? void 0 : paginationClassNames.item,
    style: styles == null ? void 0 : styles.item
  };
  const prevPage = current - 1 > 0 ? current - 1 : 0;
  const nextPage = current + 1 < allPages ? current + 1 : allPages;
  const goButton = showQuickJumper && showQuickJumper.goButton;
  const isReadOnly = typeof simple === "object" ? simple.readOnly : !simple;
  let gotoButton = goButton;
  let simplePager = null;
  if (simple) {
    if (goButton) {
      if (typeof goButton === "boolean") {
        gotoButton = import_react181.default.createElement("button", {
          type: "button",
          onClick: handleGoTO,
          onKeyUp: handleGoTO
        }, locale6.jump_to_confirm);
      } else {
        gotoButton = import_react181.default.createElement("span", {
          onClick: handleGoTO,
          onKeyUp: handleGoTO
        }, goButton);
      }
      gotoButton = import_react181.default.createElement("li", {
        title: showTitle ? `${locale6.jump_to}${current}/${allPages}` : null,
        className: `${prefixCls}-simple-pager`
      }, gotoButton);
    }
    simplePager = import_react181.default.createElement("li", {
      title: showTitle ? `${current}/${allPages}` : null,
      className: clsx(`${prefixCls}-simple-pager`, paginationClassNames == null ? void 0 : paginationClassNames.item),
      style: styles == null ? void 0 : styles.item
    }, isReadOnly ? internalInputVal : import_react181.default.createElement("input", {
      type: "text",
      "aria-label": locale6.jump_to,
      value: internalInputVal,
      disabled,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onChange: handleKeyUp,
      onBlur: handleBlur,
      size: 3
    }), import_react181.default.createElement("span", {
      className: `${prefixCls}-slash`
    }, "/"), allPages);
  }
  const pageBufferSize = showLessItems ? 1 : 2;
  if (allPages <= 3 + pageBufferSize * 2) {
    if (!allPages) {
      pagerList.push(import_react181.default.createElement(Pager_default, _extends71({}, pagerProps, {
        key: "noPager",
        page: 1,
        className: `${prefixCls}-item-disabled`
      })));
    }
    for (let i = 1; i <= allPages; i += 1) {
      pagerList.push(import_react181.default.createElement(Pager_default, _extends71({}, pagerProps, {
        key: i,
        page: i,
        active: current === i
      })));
    }
  } else {
    const prevItemTitle = showLessItems ? locale6.prev_3 : locale6.prev_5;
    const nextItemTitle = showLessItems ? locale6.next_3 : locale6.next_5;
    const jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
    const jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
    if (showPrevNextJumpers) {
      jumpPrev = jumpPrevContent ? import_react181.default.createElement("li", {
        title: showTitle ? prevItemTitle : null,
        key: "prev",
        onClick: jumpPrevHandle,
        tabIndex: 0,
        onKeyDown: runIfEnterJumpPrev,
        className: clsx(`${prefixCls}-jump-prev`, {
          [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
        })
      }, jumpPrevContent) : null;
      jumpNext = jumpNextContent ? import_react181.default.createElement("li", {
        title: showTitle ? nextItemTitle : null,
        key: "next",
        onClick: jumpNextHandle,
        tabIndex: 0,
        onKeyDown: runIfEnterJumpNext,
        className: clsx(`${prefixCls}-jump-next`, {
          [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
        })
      }, jumpNextContent) : null;
    }
    let left = Math.max(1, current - pageBufferSize);
    let right = Math.min(current + pageBufferSize, allPages);
    if (current - 1 <= pageBufferSize) {
      right = 1 + pageBufferSize * 2;
    }
    if (allPages - current <= pageBufferSize) {
      left = allPages - pageBufferSize * 2;
    }
    for (let i = left; i <= right; i += 1) {
      pagerList.push(import_react181.default.createElement(Pager_default, _extends71({}, pagerProps, {
        key: i,
        page: i,
        active: current === i
      })));
    }
    if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
      pagerList[0] = import_react181.default.cloneElement(pagerList[0], {
        className: clsx(`${prefixCls}-item-after-jump-prev`, pagerList[0].props.className)
      });
      pagerList.unshift(jumpPrev);
    }
    if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
      const lastOne = pagerList[pagerList.length - 1];
      pagerList[pagerList.length - 1] = import_react181.default.cloneElement(lastOne, {
        className: clsx(`${prefixCls}-item-before-jump-next`, lastOne.props.className)
      });
      pagerList.push(jumpNext);
    }
    if (left !== 1) {
      pagerList.unshift(import_react181.default.createElement(Pager_default, _extends71({}, pagerProps, {
        key: 1,
        page: 1
      })));
    }
    if (right !== allPages) {
      pagerList.push(import_react181.default.createElement(Pager_default, _extends71({}, pagerProps, {
        key: allPages,
        page: allPages
      })));
    }
  }
  let prev2 = renderPrev(prevPage);
  if (prev2) {
    const prevDisabled = !hasPrev || !allPages;
    prev2 = import_react181.default.createElement("li", {
      title: showTitle ? locale6.prev_page : null,
      onClick: prevHandle,
      tabIndex: prevDisabled ? null : 0,
      onKeyDown: runIfEnterPrev,
      className: clsx(`${prefixCls}-prev`, paginationClassNames == null ? void 0 : paginationClassNames.item, {
        [`${prefixCls}-disabled`]: prevDisabled
      }),
      style: styles == null ? void 0 : styles.item,
      "aria-disabled": prevDisabled
    }, prev2);
  }
  let next2 = renderNext(nextPage);
  if (next2) {
    let nextDisabled, nextTabIndex;
    if (simple) {
      nextDisabled = !hasNext;
      nextTabIndex = hasPrev ? 0 : null;
    } else {
      nextDisabled = !hasNext || !allPages;
      nextTabIndex = nextDisabled ? null : 0;
    }
    next2 = import_react181.default.createElement("li", {
      title: showTitle ? locale6.next_page : null,
      onClick: nextHandle,
      tabIndex: nextTabIndex,
      onKeyDown: runIfEnterNext,
      className: clsx(`${prefixCls}-next`, paginationClassNames == null ? void 0 : paginationClassNames.item, {
        [`${prefixCls}-disabled`]: nextDisabled
      }),
      style: styles == null ? void 0 : styles.item,
      "aria-disabled": nextDisabled
    }, next2);
  }
  const cls = clsx(prefixCls, className, {
    [`${prefixCls}-start`]: align === "start",
    [`${prefixCls}-center`]: align === "center",
    [`${prefixCls}-end`]: align === "end",
    [`${prefixCls}-simple`]: simple,
    [`${prefixCls}-disabled`]: disabled
  });
  return import_react181.default.createElement("ul", _extends71({
    className: cls,
    style: style2,
    ref: paginationRef
  }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, import_react181.default.createElement(Options_default, {
    locale: locale6,
    rootPrefixCls: prefixCls,
    disabled,
    selectPrefixCls,
    changeSize: changePageSize,
    pageSize,
    pageSizeOptions,
    quickGo: shouldDisplayQuickJumper ? handleChange : null,
    goButton: gotoButton,
    showSizeChanger,
    sizeChangerRender
  }));
};
if (true) {
  Pagination.displayName = "Pagination";
}
var Pagination_default = Pagination;

// node_modules/antd/es/pagination/style/index.js
var genPaginationDisabledStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        backgroundColor: "transparent",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token2.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token2.colorBorder,
          backgroundColor: token2.itemActiveBgDisabled,
          "&:hover, &:active": {
            backgroundColor: token2.itemActiveBgDisabled
          },
          a: {
            color: token2.itemActiveColorDisabled
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        color: token2.colorTextDisabled
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        [`${componentCls}-item-link-icon`]: {
          opacity: 0
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 1
        }
      }
    }
  };
};
var genPaginationMiniStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token2.itemSizeSM,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit(token2.calc(token2.itemSizeSM).sub(2).equal())
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token2.itemSizeSM,
      height: token2.itemSizeSM,
      margin: 0,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM)
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token2.itemSizeSM,
      marginInlineEnd: 0,
      lineHeight: unit(token2.itemSizeSM)
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: token2.miniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: token2.itemSizeSM,
        lineHeight: unit(token2.itemSizeSM),
        input: {
          ...genInputSmallStyle(token2),
          width: token2.paginationMiniQuickJumperInputWidth,
          height: token2.controlHeightSM
        }
      }
    }
  };
};
var genPaginationSimpleStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-simple`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        height: token2.itemSize,
        lineHeight: unit(token2.itemSize),
        verticalAlign: "top",
        [`${componentCls}-item-link`]: {
          height: token2.itemSize,
          backgroundColor: "transparent",
          border: 0,
          "&:hover": {
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          },
          "&::after": {
            height: token2.itemSize,
            lineHeight: unit(token2.itemSize)
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        display: "inline-flex",
        alignItems: "center",
        height: token2.itemSize,
        marginInlineEnd: token2.marginXS,
        input: {
          boxSizing: "border-box",
          height: "100%",
          width: token2.quickJumperInputWidth,
          padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
          textAlign: "center",
          backgroundColor: token2.itemInputBg,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `border-color ${token2.motionDurationMid}`,
          color: "inherit",
          "&:hover": {
            borderColor: token2.colorPrimary
          },
          "&:focus": {
            borderColor: token2.colorPrimaryHover,
            boxShadow: `${unit(token2.inputOutlineOffset)} 0 ${unit(token2.controlOutlineWidth)} ${token2.controlOutline}`
          },
          "&[disabled]": {
            color: token2.colorTextDisabled,
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            cursor: "not-allowed"
          }
        }
      },
      [`&${componentCls}-disabled`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`${componentCls}-item-link`]: {
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        }
      },
      [`&${componentCls}-mini`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          height: token2.itemSizeSM,
          lineHeight: unit(token2.itemSizeSM),
          [`${componentCls}-item-link`]: {
            height: token2.itemSizeSM,
            "&::after": {
              height: token2.itemSizeSM,
              lineHeight: unit(token2.itemSizeSM)
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          height: token2.itemSizeSM,
          input: {
            width: token2.paginationMiniQuickJumperInputWidth
          }
        }
      }
    }
  };
};
var genPaginationJumpStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token2.colorPrimary,
          fontSize: token2.fontSizeSM,
          opacity: 0,
          transition: `all ${token2.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token2.colorTextDisabled,
          letterSpacing: token2.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token2.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token2.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      color: token2.colorText,
      fontFamily: token2.fontFamily,
      lineHeight: unit(token2.itemSize),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token2.borderRadius,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      outline: 0,
      button: {
        color: token2.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token2.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `all ${token2.motionDurationMid}`
      },
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token2.paginationSlashMarginInlineEnd,
      marginInlineStart: token2.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token2.margin,
      verticalAlign: "middle",
      "&-size-changer": {
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token2.controlHeight,
        marginInlineStart: token2.marginXS,
        lineHeight: unit(token2.controlHeight),
        verticalAlign: "top",
        input: {
          ...genBasicInputStyle(token2),
          ...genBaseOutlinedStyle(token2, {
            borderColor: token2.colorBorder,
            hoverBorderColor: token2.colorPrimaryHover,
            activeBorderColor: token2.colorPrimary,
            activeShadow: token2.activeShadow
          }),
          "&[disabled]": {
            ...genDisabledStyle(token2)
          },
          width: token2.quickJumperInputWidth,
          height: token2.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token2.marginXS,
          marginInlineEnd: token2.marginXS
        }
      }
    }
  };
};
var genPaginationItemStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-item`]: {
      display: "inline-block",
      minWidth: token2.itemSize,
      height: token2.itemSize,
      marginInlineEnd: token2.marginXS,
      fontFamily: token2.fontFamily,
      lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: token2.itemBg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} transparent`,
      borderRadius: token2.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${unit(token2.paginationItemPaddingInline)}`,
        color: token2.colorText,
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token2.motionDurationMid}`,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      },
      "&-active": {
        fontWeight: token2.fontWeightStrong,
        backgroundColor: token2.itemActiveBg,
        borderColor: token2.colorPrimary,
        a: {
          color: token2.itemActiveColor
        },
        "&:hover": {
          borderColor: token2.colorPrimaryHover
        },
        "&:hover a": {
          color: token2.itemActiveColorHover
        }
      }
    }
  };
};
var genPaginationStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      "&-start": {
        justifyContent: "start"
      },
      "&-center": {
        justifyContent: "center"
      },
      "&-end": {
        justifyContent: "end"
      },
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token2.itemSize,
        marginInlineEnd: token2.marginXS,
        lineHeight: unit(token2.calc(token2.itemSize).sub(2).equal()),
        verticalAlign: "middle"
      },
      // item style
      ...genPaginationItemStyle(token2),
      // jump btn style
      ...genPaginationJumpStyle(token2),
      // simple style
      ...genPaginationSimpleStyle(token2),
      // mini style
      ...genPaginationMiniStyle(token2),
      // disabled style
      ...genPaginationDisabledStyle(token2),
      // media query style
      [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    },
    // rtl style
    [`&${token2.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var genPaginationFocusStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}:not(${componentCls}-disabled)`]: {
      [`${componentCls}-item`]: {
        ...genFocusStyle(token2)
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        "&:focus-visible": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          },
          ...genFocusOutline(token2)
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&:focus-visible ${componentCls}-item-link`]: genFocusOutline(token2)
      }
    }
  };
};
var prepareComponentToken38 = (token2) => ({
  itemBg: token2.colorBgContainer,
  itemSize: token2.controlHeight,
  itemSizeSM: token2.controlHeightSM,
  itemActiveBg: token2.colorBgContainer,
  itemActiveColor: token2.colorPrimary,
  itemActiveColorHover: token2.colorPrimaryHover,
  itemLinkBg: token2.colorBgContainer,
  itemActiveColorDisabled: token2.colorTextDisabled,
  itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
  itemInputBg: token2.colorBgContainer,
  miniOptionsSizeChangerTop: 0,
  ...initComponentToken(token2)
});
var prepareToken5 = (token2) => merge2(token2, {
  inputOutlineOffset: 0,
  quickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
  paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
  paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
  paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
  paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
  paginationSlashMarginInlineStart: token2.marginSM,
  paginationSlashMarginInlineEnd: token2.marginSM,
  paginationEllipsisTextIndent: "0.13em"
  // magic for ui experience
}, initInputToken(token2));
var style_default44 = genStyleHooks("Pagination", (token2) => {
  const paginationToken = prepareToken5(token2);
  return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
}, prepareComponentToken38);

// node_modules/antd/es/pagination/style/bordered.js
var genBorderedStyle2 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          a: {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token2.itemActiveBgDisabled
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          color: token2.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder
        }
      }
    },
    [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token2.colorPrimaryHover,
          backgroundColor: token2.itemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.itemLinkBg,
          borderColor: token2.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          color: token2.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token2.itemBg,
        border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.itemBg,
          a: {
            color: token2.colorPrimary
          }
        },
        "&-active": {
          borderColor: token2.colorPrimary
        }
      }
    }
  };
};
var bordered_default = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
  const paginationToken = prepareToken5(token2);
  return genBorderedStyle2(paginationToken);
}, prepareComponentToken38);

// node_modules/antd/es/pagination/useShowSizeChanger.js
var import_react182 = __toESM(require_react());
function useShowSizeChanger(showSizeChanger) {
  return (0, import_react182.useMemo)(() => {
    if (typeof showSizeChanger === "boolean") {
      return [showSizeChanger, {}];
    }
    if (showSizeChanger && typeof showSizeChanger === "object") {
      return [true, showSizeChanger];
    }
    return [void 0, void 0];
  }, [showSizeChanger]);
}

// node_modules/antd/es/pagination/Pagination.js
var Pagination2 = (props) => {
  const {
    align,
    prefixCls: customizePrefixCls,
    selectPrefixCls: customizeSelectPrefixCls,
    className,
    rootClassName,
    style: style2,
    size: customizeSize,
    locale: customLocale,
    responsive,
    showSizeChanger,
    selectComponentClass,
    pageSizeOptions,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    xs
  } = useBreakpoint_default(responsive);
  const [, token2] = useToken();
  const {
    getPrefixCls,
    direction,
    showSizeChanger: contextShowSizeChangerConfig,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("pagination");
  const prefixCls = getPrefixCls("pagination", customizePrefixCls);
  const [hashId, cssVarCls] = style_default44(prefixCls);
  const mergedSize = useSize_default(customizeSize);
  const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
  const mergedProps = {
    ...props,
    size: mergedSize
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const [contextLocale] = useLocale_default("Pagination", en_US_default);
  const locale6 = {
    ...contextLocale,
    ...customLocale
  };
  const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
  const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
  const mergedShowSizeChanger = propShowSizeChanger ?? contextShowSizeChanger;
  const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps ?? contextSizeChangerSelectProps;
  const SizeChanger = selectComponentClass || select_default;
  const mergedPageSizeOptions = React464.useMemo(() => {
    return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
  }, [pageSizeOptions]);
  const sizeChangerRender = (info) => {
    var _a;
    const {
      disabled,
      size: pageSize,
      onSizeChange,
      "aria-label": ariaLabel,
      className: sizeChangerClassName,
      options
    } = info;
    const {
      className: propSizeChangerClassName,
      onChange: propSizeChangerOnChange
    } = mergedShowSizeChangerSelectProps || {};
    const selectedValue = (_a = options.find((option) => String(option.value) === String(pageSize))) == null ? void 0 : _a.value;
    return React464.createElement(SizeChanger, {
      disabled,
      showSearch: true,
      popupMatchSelectWidth: false,
      getPopupContainer: (triggerNode) => triggerNode.parentNode,
      "aria-label": ariaLabel,
      options,
      ...mergedShowSizeChangerSelectProps,
      value: selectedValue,
      onChange: (nextSize, option) => {
        onSizeChange == null ? void 0 : onSizeChange(nextSize);
        propSizeChangerOnChange == null ? void 0 : propSizeChangerOnChange(nextSize, option);
      },
      size: isSmall ? "small" : "middle",
      className: clsx(sizeChangerClassName, propSizeChangerClassName)
    });
  };
  if (true) {
    const warning5 = devUseWarning("Pagination");
    true ? warning5(!selectComponentClass, "usage", "`selectComponentClass` is not official api which will be removed.") : void 0;
  }
  const iconsProps = React464.useMemo(() => {
    const ellipsis = React464.createElement("span", {
      className: `${prefixCls}-item-ellipsis`
    }, "");
    const prevIcon = React464.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? React464.createElement(RightOutlined_default, null) : React464.createElement(LeftOutlined_default, null));
    const nextIcon = React464.createElement("button", {
      className: `${prefixCls}-item-link`,
      type: "button",
      tabIndex: -1
    }, direction === "rtl" ? React464.createElement(LeftOutlined_default, null) : React464.createElement(RightOutlined_default, null));
    const jumpPrevIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      React464.createElement("a", {
        className: `${prefixCls}-item-link`
      }, React464.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? React464.createElement(DoubleRightOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }) : React464.createElement(DoubleLeftOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    );
    const jumpNextIcon = (
      // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
      React464.createElement("a", {
        className: `${prefixCls}-item-link`
      }, React464.createElement("div", {
        className: `${prefixCls}-item-container`
      }, direction === "rtl" ? React464.createElement(DoubleLeftOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }) : React464.createElement(DoubleRightOutlined_default, {
        className: `${prefixCls}-item-link-icon`
      }), ellipsis))
    );
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  }, [direction, prefixCls]);
  const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
  const extendedClassName = clsx({
    [`${prefixCls}-${align}`]: !!align,
    [`${prefixCls}-mini`]: isSmall,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-bordered`]: token2.wireframe
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return React464.createElement(React464.Fragment, null, token2.wireframe && React464.createElement(bordered_default, {
    prefixCls
  }), React464.createElement(Pagination_default, {
    ...iconsProps,
    ...restProps,
    styles: mergedStyles,
    classNames: mergedClassNames,
    style: mergedStyle,
    prefixCls,
    selectPrefixCls,
    className: extendedClassName,
    locale: locale6,
    pageSizeOptions: mergedPageSizeOptions,
    showSizeChanger: mergedShowSizeChanger,
    sizeChangerRender
  }));
};
if (true) {
  Pagination2.displayName = "Pagination";
}
var Pagination_default2 = Pagination2;

// node_modules/antd/es/pagination/index.js
var pagination_default = Pagination_default2;

// node_modules/antd/es/spin/index.js
var React469 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/index.js
var React467 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/Looper.js
var React466 = __toESM(require_react());

// node_modules/antd/es/spin/Indicator/Progress.js
var React465 = __toESM(require_react());
var viewSize = 100;
var borderWidth = viewSize / 5;
var radius = viewSize / 2 - borderWidth / 2;
var circumference = radius * 2 * Math.PI;
var position2 = 50;
var CustomCircle = (props) => {
  const {
    dotClassName,
    style: style2,
    hasCircleCls
  } = props;
  return React465.createElement("circle", {
    className: clsx(`${dotClassName}-circle`, {
      [`${dotClassName}-circle-bg`]: hasCircleCls
    }),
    r: radius,
    cx: position2,
    cy: position2,
    strokeWidth: borderWidth,
    style: style2
  });
};
var Progress = ({
  percent,
  prefixCls
}) => {
  const dotClassName = `${prefixCls}-dot`;
  const holderClassName = `${dotClassName}-holder`;
  const hideClassName = `${holderClassName}-hidden`;
  const [render2, setRender] = React465.useState(false);
  useLayoutEffect_default(() => {
    if (percent !== 0) {
      setRender(true);
    }
  }, [percent !== 0]);
  const safePtg = Math.max(Math.min(percent, 100), 0);
  if (!render2) {
    return null;
  }
  const circleStyle = {
    strokeDashoffset: `${circumference / 4}`,
    strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
  };
  return React465.createElement("span", {
    className: clsx(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
  }, React465.createElement("svg", {
    viewBox: `0 0 ${viewSize} ${viewSize}`,
    role: "progressbar",
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    "aria-valuenow": safePtg
  }, React465.createElement(CustomCircle, {
    dotClassName,
    hasCircleCls: true
  }), React465.createElement(CustomCircle, {
    dotClassName,
    style: circleStyle
  })));
};
var Progress_default = Progress;

// node_modules/antd/es/spin/Indicator/Looper.js
function Looper(props) {
  const {
    prefixCls,
    percent = 0,
    className,
    style: style2
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  const holderClassName = `${dotClassName}-holder`;
  const hideClassName = `${holderClassName}-hidden`;
  return React466.createElement(React466.Fragment, null, React466.createElement("span", {
    className: clsx(holderClassName, className, percent > 0 && hideClassName),
    style: style2
  }, React466.createElement("span", {
    className: clsx(dotClassName, `${prefixCls}-dot-spin`)
  }, [1, 2, 3, 4].map((i) => React466.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: i
  })))), React466.createElement(Progress_default, {
    prefixCls,
    percent
  }));
}

// node_modules/antd/es/spin/Indicator/index.js
function Indicator(props) {
  const {
    prefixCls,
    indicator,
    percent,
    className,
    style: style2
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator && React467.isValidElement(indicator)) {
    return cloneElement3(indicator, (currentProps) => ({
      className: clsx(currentProps.className, dotClassName, className),
      style: {
        ...currentProps.style,
        ...style2
      },
      percent
    }));
  }
  return React467.createElement(Looper, {
    prefixCls,
    percent,
    className,
    style: style2
  });
}

// node_modules/antd/es/spin/style/index.js
var antSpinMove = new Keyframes_default("antSpinMove", {
  to: {
    opacity: 1
  }
});
var antRotate = new Keyframes_default("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
var genSpinStyle = (token2) => {
  const {
    componentCls,
    calc
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "absolute",
      display: "none",
      color: token2.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "relative",
        display: "inline-block",
        opacity: 1
      },
      [`${componentCls}-text`]: {
        fontSize: token2.fontSize,
        paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
      },
      "&-fullscreen": {
        position: "fixed",
        width: "100vw",
        height: "100vh",
        backgroundColor: token2.colorBgMask,
        zIndex: token2.zIndexPopupBase,
        inset: 0,
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        opacity: 0,
        visibility: "hidden",
        transition: `all ${token2.motionDurationMid}`,
        "&-show": {
          opacity: 1,
          visibility: "visible"
        },
        [componentCls]: {
          [`${componentCls}-dot-holder`]: {
            color: token2.colorWhite
          },
          [`${componentCls}-text`]: {
            color: token2.colorTextLightSolid
          }
        }
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${componentCls}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: token2.contentHeight,
          [`${componentCls}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: calc(token2.dotSize).mul(-1).div(2).equal()
          },
          [`${componentCls}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            textShadow: `0 1px 2px ${token2.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${componentCls}-show-text ${componentCls}-dot`]: {
            marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
          },
          "&-sm": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          "&-lg": {
            [`${componentCls}-dot`]: {
              margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${componentCls}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          "&::after": {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      "&-tip": {
        color: token2.spinDotDefault
      },
      // holder
      // ------------------------------
      [`${componentCls}-dot-holder`]: {
        width: "1em",
        height: "1em",
        fontSize: token2.dotSize,
        display: "inline-block",
        transition: `transform ${token2.motionDurationSlow} ease, opacity ${token2.motionDurationSlow} ease`,
        transformOrigin: "50% 50%",
        lineHeight: 1,
        color: token2.colorPrimary,
        "&-hidden": {
          transform: "scale(0.3)",
          opacity: 0
        }
      },
      // progress
      // ------------------------------
      [`${componentCls}-dot-progress`]: {
        position: "absolute",
        inset: 0
      },
      // dots
      // ------------------------------
      [`${componentCls}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: token2.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
          background: "currentColor",
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0,
            animationDelay: "0s"
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: antRotate,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        },
        "&-circle": {
          strokeLinecap: "round",
          transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${token2.motionDurationSlow} ease`).join(","),
          fillOpacity: 0,
          stroke: "currentcolor"
        },
        "&-circle-bg": {
          stroke: token2.colorFillSecondary
        }
      },
      // small
      [`&-sm ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token2.dotSizeSM
        }
      },
      [`&-sm ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
          height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${componentCls}-dot`]: {
        "&, &-holder": {
          fontSize: token2.dotSizeLG
        }
      },
      [`&-lg ${componentCls}-dot-holder`]: {
        i: {
          width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
          height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
        }
      },
      [`&${componentCls}-show-text ${componentCls}-text`]: {
        display: "block"
      }
    }
  };
};
var prepareComponentToken39 = (token2) => {
  const {
    controlHeightLG,
    controlHeight
  } = token2;
  return {
    contentHeight: 400,
    dotSize: controlHeightLG / 2,
    dotSizeSM: controlHeightLG * 0.35,
    dotSizeLG: controlHeight
  };
};
var style_default45 = genStyleHooks("Spin", (token2) => {
  const spinToken = merge2(token2, {
    spinDotDefault: token2.colorTextDescription
  });
  return genSpinStyle(spinToken);
}, prepareComponentToken39);

// node_modules/antd/es/spin/usePercent.js
var React468 = __toESM(require_react());
var AUTO_INTERVAL = 200;
var STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
function usePercent(spinning, percent) {
  const [mockPercent, setMockPercent] = React468.useState(0);
  const mockIntervalRef = React468.useRef(null);
  const isAuto = percent === "auto";
  React468.useEffect(() => {
    if (isAuto && spinning) {
      setMockPercent(0);
      mockIntervalRef.current = setInterval(() => {
        setMockPercent((prev2) => {
          const restPTG = 100 - prev2;
          for (let i = 0; i < STEP_BUCKETS.length; i += 1) {
            const [limit, stepPtg] = STEP_BUCKETS[i];
            if (prev2 <= limit) {
              return prev2 + restPTG * stepPtg;
            }
          }
          return prev2;
        });
      }, AUTO_INTERVAL);
    }
    return () => {
      if (mockIntervalRef.current) {
        clearInterval(mockIntervalRef.current);
        mockIntervalRef.current = null;
      }
    };
  }, [isAuto, spinning]);
  return isAuto ? mockPercent : percent;
}

// node_modules/antd/es/spin/index.js
var defaultIndicator;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !Number.isNaN(Number(delay));
}
var Spin = (props) => {
  const {
    prefixCls: customizePrefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    fullscreen = false,
    indicator,
    percent,
    classNames,
    styles,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    indicator: contextIndicator,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("spin");
  const prefixCls = getPrefixCls("spin", customizePrefixCls);
  const [hashId, cssVarCls] = style_default45(prefixCls);
  const [spinning, setSpinning] = React469.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
  const mergedPercent = usePercent(spinning, percent);
  React469.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        var _a;
        (_a = showSpinning == null ? void 0 : showSpinning.cancel) == null ? void 0 : _a.call(showSpinning);
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = React469.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
  const mergedProps = {
    ...props,
    size,
    spinning,
    tip,
    fullscreen,
    children,
    percent: mergedPercent
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning5 = devUseWarning("Spin");
    true ? warning5(!tip || isNestedPattern || fullscreen, "usage", "`tip` only work in nest or fullscreen pattern.") : void 0;
  }
  const spinClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, !fullscreen && rootClassName, !fullscreen && mergedClassNames.root, hashId, cssVarCls);
  const containerClassName = clsx(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const mergedIndicator = indicator ?? contextIndicator ?? defaultIndicator;
  const mergedStyle = {
    ...contextStyle,
    ...style2
  };
  const spinElement = React469.createElement("div", {
    ...restProps,
    style: fullscreen ? mergedStyle : {
      ...mergedStyles.root,
      ...mergedStyle
    },
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }, React469.createElement(Indicator, {
    className: mergedClassNames.indicator,
    style: mergedStyles.indicator,
    prefixCls,
    indicator: mergedIndicator,
    percent: mergedPercent
  }), tip && (isNestedPattern || fullscreen) ? React469.createElement("div", {
    className: clsx(`${prefixCls}-text`, mergedClassNames.tip),
    style: mergedStyles.tip
  }, tip) : null);
  if (isNestedPattern) {
    return React469.createElement("div", {
      ...restProps,
      className: clsx(`${prefixCls}-nested-loading`, wrapperClassName, mergedClassNames.wrapper, hashId, cssVarCls),
      style: mergedStyles.wrapper
    }, spinning && React469.createElement("div", {
      key: "loading"
    }, spinElement), React469.createElement("div", {
      className: containerClassName,
      key: "container"
    }, children));
  }
  if (fullscreen) {
    return React469.createElement("div", {
      className: clsx(`${prefixCls}-fullscreen`, {
        [`${prefixCls}-fullscreen-show`]: spinning
      }, rootClassName, hashId, cssVarCls, mergedClassNames.mask),
      style: mergedStyles.mask
    }, spinElement);
  }
  return spinElement;
};
Spin.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
if (true) {
  Spin.displayName = "Spin";
}
var spin_default = Spin;

// node_modules/antd/es/list/context.js
var import_react183 = __toESM(require_react());
var ListContext2 = import_react183.default.createContext({});
var ListConsumer = ListContext2.Consumer;

// node_modules/antd/es/list/Item.js
var import_react184 = __toESM(require_react());
var Meta = ({
  prefixCls: customizePrefixCls,
  className,
  avatar,
  title,
  description,
  ...others
}) => {
  const {
    getPrefixCls
  } = (0, import_react184.useContext)(ConfigContext);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const classString = clsx(`${prefixCls}-item-meta`, className);
  const content = import_react184.default.createElement("div", {
    className: `${prefixCls}-item-meta-content`
  }, title && import_react184.default.createElement("h4", {
    className: `${prefixCls}-item-meta-title`
  }, title), description && import_react184.default.createElement("div", {
    className: `${prefixCls}-item-meta-description`
  }, description));
  return import_react184.default.createElement("div", {
    ...others,
    className: classString
  }, avatar && import_react184.default.createElement("div", {
    className: `${prefixCls}-item-meta-avatar`
  }, avatar), (title || description) && content);
};
var InternalItem2 = import_react184.default.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    children,
    actions,
    extra,
    styles,
    className,
    classNames: customizeClassNames,
    colStyle,
    ...others
  } = props;
  const {
    grid,
    itemLayout
  } = (0, import_react184.useContext)(ListContext2);
  const {
    getPrefixCls,
    list
  } = (0, import_react184.useContext)(ConfigContext);
  const moduleClass = (moduleName) => {
    var _a, _b;
    return clsx((_b = (_a = list == null ? void 0 : list.item) == null ? void 0 : _a.classNames) == null ? void 0 : _b[moduleName], customizeClassNames == null ? void 0 : customizeClassNames[moduleName]);
  };
  const moduleStyle = (moduleName) => {
    var _a, _b;
    return {
      ...(_b = (_a = list == null ? void 0 : list.item) == null ? void 0 : _a.styles) == null ? void 0 : _b[moduleName],
      ...styles == null ? void 0 : styles[moduleName]
    };
  };
  const isItemContainsTextNodeAndNotSingular = () => {
    const childNodes = toArray(children);
    const hasTextNode = childNodes.some((node2) => typeof node2 === "string");
    return hasTextNode && childNodes.length > 1;
  };
  const isFlexMode = () => {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  };
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const actionsContent = actions && actions.length > 0 && import_react184.default.createElement("ul", {
    className: clsx(`${prefixCls}-item-action`, moduleClass("actions")),
    key: "actions",
    style: moduleStyle("actions")
  }, actions.map((action, i) => (
    // eslint-disable-next-line react/no-array-index-key
    import_react184.default.createElement("li", {
      key: `${prefixCls}-item-action-${i}`
    }, action, i !== actions.length - 1 && import_react184.default.createElement("em", {
      className: `${prefixCls}-item-action-split`
    }))
  )));
  const Element3 = grid ? "div" : "li";
  const itemChildren = import_react184.default.createElement(Element3, {
    ...others,
    ...!grid ? {
      ref
    } : {},
    className: clsx(`${prefixCls}-item`, {
      [`${prefixCls}-item-no-flex`]: !isFlexMode()
    }, className)
  }, itemLayout === "vertical" && extra ? [import_react184.default.createElement("div", {
    className: `${prefixCls}-item-main`,
    key: "content"
  }, children, actionsContent), import_react184.default.createElement("div", {
    className: clsx(`${prefixCls}-item-extra`, moduleClass("extra")),
    key: "extra",
    style: moduleStyle("extra")
  }, extra)] : [children, actionsContent, cloneElement3(extra, {
    key: "extra"
  })]);
  return grid ? import_react184.default.createElement(col_default, {
    ref,
    flex: 1,
    style: colStyle
  }, itemChildren) : itemChildren;
});
var Item4 = InternalItem2;
Item4.Meta = Meta;
var Item_default4 = Item4;

// node_modules/antd/es/list/style/index.js
var genBorderedStyle3 = (token2) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    itemPaddingSM,
    itemPaddingLG,
    marginLG,
    borderRadiusLG
  } = token2;
  const innerCornerBorderRadius = unit(token2.calc(borderRadiusLG).sub(token2.lineWidth).equal());
  return {
    [listBorderedCls]: {
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header`]: {
        borderRadius: `${innerCornerBorderRadius} ${innerCornerBorderRadius} 0 0`
      },
      [`${componentCls}-footer`]: {
        borderRadius: `0 0 ${innerCornerBorderRadius} ${innerCornerBorderRadius}`
      },
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${unit(margin)} ${unit(marginLG)}`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: itemPaddingLG
      }
    }
  };
};
var genResponsiveStyle = (token2) => {
  const {
    componentCls,
    screenSM,
    screenMD,
    marginLG,
    marginSM,
    margin
  } = token2;
  return {
    [`@media screen and (max-width:${screenMD}px)`]: {
      [componentCls]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM}px)`]: {
      [componentCls]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token2.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${unit(margin)}`
          }
        }
      }
    }
  };
};
var genBaseStyle11 = (token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    itemPadding,
    colorPrimary,
    itemPaddingSM,
    itemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth,
    headerBg,
    footerBg,
    emptyTextPadding,
    metaMarginBottom,
    avatarMarginRight,
    titleMarginBottom,
    descriptionFontSize
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      // fix https://github.com/ant-design/ant-design/issues/46177
      ["--rc-virtual-list-scrollbar-bg"]: token2.colorSplit,
      "*": {
        outline: "none"
      },
      [`${componentCls}-header`]: {
        background: headerBg
      },
      [`${componentCls}-footer`]: {
        background: footerBg
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: {
        marginBlockStart: marginLG,
        // https://github.com/ant-design/ant-design/issues/20037
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: itemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: avatarMarginRight
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            margin: `0 0 ${unit(token2.marginXXS)} 0`,
            color: colorText,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              "&:hover": {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: descriptionFontSize,
            lineHeight: token2.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token2.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          "& > li": {
            position: "relative",
            display: "inline-block",
            padding: `0 ${unit(paddingXS)}`,
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            textAlign: "center",
            "&:first-child": {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: token2.calc(token2.fontHeight).sub(token2.calc(token2.marginXXS).mul(2)).equal(),
            transform: "translateY(-50%)",
            backgroundColor: token2.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${unit(padding)} 0`,
        color: colorTextDescription,
        fontSize: token2.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding: emptyTextPadding,
        color: token2.colorTextDisabled,
        fontSize: token2.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    },
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: metaMarginBottom,
        [`${componentCls}-item-meta-title`]: {
          marginBlockStart: 0,
          marginBlockEnd: titleMarginBottom,
          color: colorText,
          fontSize: token2.fontSizeLG,
          lineHeight: token2.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${unit(padding)}`,
          "&:first-child": {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
      "&:last-child": {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: itemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: itemPaddingSM
    },
    // Horizontal
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
};
var prepareComponentToken40 = (token2) => ({
  contentWidth: 220,
  itemPadding: `${unit(token2.paddingContentVertical)} 0`,
  itemPaddingSM: `${unit(token2.paddingContentVerticalSM)} ${unit(token2.paddingContentHorizontal)}`,
  itemPaddingLG: `${unit(token2.paddingContentVerticalLG)} ${unit(token2.paddingContentHorizontalLG)}`,
  headerBg: "transparent",
  footerBg: "transparent",
  emptyTextPadding: token2.padding,
  metaMarginBottom: token2.padding,
  avatarMarginRight: token2.padding,
  titleMarginBottom: token2.paddingSM,
  descriptionFontSize: token2.fontSize
});
var style_default46 = genStyleHooks("List", (token2) => {
  const listToken = merge2(token2, {
    listBorderedCls: `${token2.componentCls}-bordered`,
    minHeight: token2.controlHeightLG
  });
  return [genBaseStyle11(listToken), genBorderedStyle3(listToken), genResponsiveStyle(listToken)];
}, prepareComponentToken40);

// node_modules/antd/es/list/index.js
var InternalList = (props, ref) => {
  const {
    pagination = false,
    prefixCls: customizePrefixCls,
    bordered = false,
    split = true,
    className,
    rootClassName,
    style: style2,
    children,
    itemLayout,
    loadMore,
    grid,
    dataSource = [],
    size: customizeSize,
    header,
    footer,
    loading = false,
    rowKey,
    renderItem: renderItem2,
    locale: locale6,
    ...rest
  } = props;
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  const [paginationCurrent, setPaginationCurrent] = React472.useState(paginationObj.defaultCurrent || 1);
  const [paginationSize, setPaginationSize] = React472.useState(paginationObj.defaultPageSize || 10);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("list");
  const {
    renderEmpty
  } = React472.useContext(ConfigContext);
  const defaultPaginationProps = {
    current: 1,
    total: 0,
    position: "bottom"
  };
  const triggerPaginationEvent = (eventName) => (page, pageSize) => {
    var _a;
    setPaginationCurrent(page);
    setPaginationSize(pageSize);
    if (pagination) {
      (_a = pagination == null ? void 0 : pagination[eventName]) == null ? void 0 : _a.call(pagination, page, pageSize);
    }
  };
  const onPaginationChange = triggerPaginationEvent("onChange");
  const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  const renderInternalItem = (item, index2) => {
    if (!renderItem2) {
      return null;
    }
    let key;
    if (typeof rowKey === "function") {
      key = rowKey(item);
    } else if (rowKey) {
      key = item[rowKey];
    } else {
      key = item.key;
    }
    if (!key) {
      key = `list-item-${index2}`;
    }
    return React472.createElement(React472.Fragment, {
      key
    }, renderItem2(item, index2));
  };
  const isSomethingAfterLastItem = !!(loadMore || pagination || footer);
  const prefixCls = getPrefixCls("list", customizePrefixCls);
  const [hashId, cssVarCls] = style_default46(prefixCls);
  let loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  const isLoading = !!(loadingProp == null ? void 0 : loadingProp.spinning);
  const mergedSize = useSize_default(customizeSize);
  let sizeCls = "";
  switch (mergedSize) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
    default:
      break;
  }
  const classString = clsx(prefixCls, {
    [`${prefixCls}-vertical`]: itemLayout === "vertical",
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-split`]: split,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-loading`]: isLoading,
    [`${prefixCls}-grid`]: !!grid,
    [`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, hashId, cssVarCls);
  const paginationProps = extendsObject_default(defaultPaginationProps, {
    total: dataSource.length,
    current: paginationCurrent,
    pageSize: paginationSize
  }, pagination || {});
  const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  paginationProps.current = Math.min(paginationProps.current, largestPage);
  const paginationContent = pagination && React472.createElement("div", {
    className: clsx(`${prefixCls}-pagination`)
  }, React472.createElement(pagination_default, {
    align: "end",
    ...paginationProps,
    onChange: onPaginationChange,
    onShowSizeChange: onPaginationShowSizeChange
  }));
  let splitDataSource = _toConsumableArray(dataSource);
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
    }
  }
  const needResponsive = Object.keys(grid || {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint_default(needResponsive);
  const currentBreakpoint = React472.useMemo(() => {
    for (let i = 0; i < responsiveArray.length; i += 1) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens]);
  const colStyle = React472.useMemo(() => {
    if (!grid) {
      return void 0;
    }
    const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: `${100 / columnCount}%`,
        maxWidth: `${100 / columnCount}%`
      };
    }
  }, [JSON.stringify(grid), currentBreakpoint]);
  let childrenContent = isLoading && React472.createElement("div", {
    style: {
      minHeight: 53
    }
  });
  if (splitDataSource.length > 0) {
    const items = splitDataSource.map(renderInternalItem);
    childrenContent = grid ? React472.createElement(row_default, {
      gutter: grid.gutter
    }, React472.Children.map(items, (child) => React472.createElement("div", {
      key: child == null ? void 0 : child.key,
      style: colStyle
    }, child))) : React472.createElement("ul", {
      className: `${prefixCls}-items`
    }, items);
  } else if (!children && !isLoading) {
    childrenContent = React472.createElement("div", {
      className: `${prefixCls}-empty-text`
    }, (locale6 == null ? void 0 : locale6.emptyText) || (renderEmpty == null ? void 0 : renderEmpty("List")) || React472.createElement(defaultRenderEmpty_default, {
      componentName: "List"
    }));
  }
  const paginationPosition = paginationProps.position;
  const contextValue = React472.useMemo(() => ({
    grid,
    itemLayout
  }), [JSON.stringify(grid), itemLayout]);
  if (true) {
    const warning5 = devUseWarning("List");
    true ? warning5(false, "deprecated", "The `List` component is deprecated. And will be removed in next major version.") : void 0;
  }
  return React472.createElement(ListContext2.Provider, {
    value: contextValue
  }, React472.createElement("div", {
    ref,
    style: {
      ...contextStyle,
      ...style2
    },
    className: classString,
    ...rest
  }, (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && React472.createElement("div", {
    className: `${prefixCls}-header`
  }, header), React472.createElement(spin_default, {
    ...loadingProp
  }, childrenContent, children), footer && React472.createElement("div", {
    className: `${prefixCls}-footer`
  }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent));
};
var ListWithForwardRef = React472.forwardRef(InternalList);
if (true) {
  ListWithForwardRef.displayName = "Deprecated.List";
}
var List3 = ListWithForwardRef;
List3.Item = Item_default4;
var list_default = List3;

// node_modules/antd/es/masonry/Masonry.js
var React477 = __toESM(require_react());

// node_modules/antd/es/masonry/hooks/useDelay.js
var React473 = __toESM(require_react());
function useDelay2(callback) {
  const idRef = React473.useRef(0);
  const clearRaf = () => {
    raf_default.cancel(idRef.current);
  };
  React473.useEffect(() => clearRaf, []);
  const triggerFn = useEvent_default(() => {
    clearRaf();
    idRef.current = raf_default(callback);
  });
  return triggerFn;
}

// node_modules/antd/es/masonry/hooks/usePositions.js
var React474 = __toESM(require_react());
function usePositions(itemHeights, columnCount, verticalGutter) {
  const [orderItemPositions, orderTotalHeight] = React474.useMemo(() => {
    const columnHeights = new Array(columnCount).fill(0);
    const itemPositions = /* @__PURE__ */ new Map();
    for (let i = 0; i < itemHeights.length; i += 1) {
      const [itemKey3, itemHeight, itemColumn] = itemHeights[i];
      let targetColumnIndex = itemColumn ?? columnHeights.indexOf(Math.min.apply(Math, _toConsumableArray(columnHeights)));
      targetColumnIndex = Math.min(targetColumnIndex, columnCount - 1);
      const top = columnHeights[targetColumnIndex];
      itemPositions.set(itemKey3, {
        column: targetColumnIndex,
        top
      });
      columnHeights[targetColumnIndex] += itemHeight + verticalGutter;
    }
    return [itemPositions, Math.max(0, Math.max.apply(Math, _toConsumableArray(columnHeights)) - verticalGutter)];
  }, [columnCount, itemHeights, verticalGutter]);
  return [orderItemPositions, orderTotalHeight];
}

// node_modules/antd/es/masonry/hooks/useRefs.js
var React475 = __toESM(require_react());
function useRefs() {
  const refs = React475.useRef(null);
  if (refs.current === null) {
    refs.current = /* @__PURE__ */ new Map();
  }
  const setRef = (key, element) => {
    refs.current.set(key, element);
  };
  const getRef = (key) => refs.current.get(key);
  return [setRef, getRef];
}

// node_modules/antd/es/masonry/MasonryItem.js
var import_react185 = __toESM(require_react());
var MasonryItem = import_react185.default.forwardRef((props, ref) => {
  const {
    item,
    style: style2,
    prefixCls,
    itemRender,
    className,
    index: index2,
    column: column2,
    onResize: onResize2
  } = props;
  const itemPrefix = `${prefixCls}-item`;
  const renderNode = (0, import_react185.useMemo)(() => {
    return item.children ?? (itemRender == null ? void 0 : itemRender({
      ...item,
      index: index2,
      column: column2
    }));
  }, [item, itemRender, column2, index2]);
  let returnNode = import_react185.default.createElement("div", {
    ref,
    style: style2,
    className: clsx(itemPrefix, className)
  }, renderNode);
  if (onResize2) {
    returnNode = import_react185.default.createElement(es_default, {
      onResize: onResize2
    }, returnNode);
  }
  return returnNode;
});
if (true) {
  MasonryItem.displayName = "MasonryItem";
}
var MasonryItem_default = MasonryItem;

// node_modules/antd/es/masonry/style/index.js
var genMasonryStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      position: "relative",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      flexWrap: "wrap",
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${itemCls}`]: {
        boxSizing: "border-box",
        // Motion
        "&-fade": {
          "&-appear": {
            transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseOut}`,
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            transition: `opacity ${token2.motionDurationFast} ${token2.motionEaseOut}`,
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          }
        },
        [`&:not(${itemCls}-fade)`]: {
          transition: ["left", "right", "top"].map((prop) => `${prop} ${token2.motionDurationSlow} ${token2.motionEaseOut}`).join(",")
        }
      }
    }
  };
};
var style_default47 = genStyleHooks("Masonry", (token2) => [genMasonryStyle(token2)]);

// node_modules/antd/es/masonry/Masonry.js
var Masonry = React477.forwardRef((props, ref) => {
  const {
    rootClassName,
    className,
    style: style2,
    classNames,
    styles,
    columns,
    prefixCls: customizePrefixCls,
    gutter = 0,
    items,
    itemRender,
    onLayoutChange,
    fresh
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("masonry");
  const prefixCls = getPrefixCls("masonry", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default47(prefixCls, rootCls);
  const containerRef = React477.useRef(null);
  React477.useImperativeHandle(ref, () => ({
    nativeElement: containerRef.current
  }));
  const [setItemRef, getItemRef] = useRefs();
  const [mergedItems, setMergedItems] = React477.useState([]);
  React477.useEffect(() => {
    setMergedItems(items || []);
  }, [items]);
  const screens = useBreakpoint_default();
  const gutters = useGutter(gutter, screens);
  const [horizontalGutter = 0, verticalGutter = horizontalGutter] = gutters;
  const columnCount = React477.useMemo(() => {
    if (!columns) {
      return 3;
    }
    if (typeof columns === "number") {
      return columns;
    }
    const matchingBreakpoint = responsiveArray.find((breakpoint) => screens[breakpoint] && columns[breakpoint] !== void 0);
    if (matchingBreakpoint) {
      return columns[matchingBreakpoint];
    }
    return columns.xs ?? 1;
  }, [columns, screens]);
  const mergedProps = {
    ...props,
    columns: columnCount
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const [itemHeights, setItemHeights] = React477.useState([]);
  const collectItemSize = useDelay2(() => {
    const nextItemsHeight = mergedItems.map((item, index2) => {
      const itemKey3 = item.key ?? index2;
      const itemEle = getItemRef(itemKey3);
      const rect = itemEle == null ? void 0 : itemEle.getBoundingClientRect();
      return [itemKey3, rect ? rect.height : 0, item.column];
    });
    setItemHeights((prevItemsHeight) => isEqual_default(prevItemsHeight, nextItemsHeight) ? prevItemsHeight : nextItemsHeight);
  });
  const [itemPositions, totalHeight] = usePositions(itemHeights, columnCount, verticalGutter);
  const itemWithPositions = React477.useMemo(() => mergedItems.map((item, index2) => {
    const key = item.key ?? index2;
    return {
      item,
      itemIndex: index2,
      // CSSMotion will transform key to string.
      // Let's keep the original key here.
      itemKey: key,
      key,
      position: itemPositions.get(key)
    };
  }), [mergedItems, itemPositions]);
  React477.useEffect(() => {
    collectItemSize();
  }, [mergedItems, columnCount]);
  const [itemColumns, setItemColumns] = React477.useState([]);
  useLayoutEffect_default(() => {
    if (onLayoutChange && itemWithPositions.every(({
      position: position3
    }) => position3)) {
      setItemColumns((prevItemColumns) => {
        const nextItemColumns = itemWithPositions.map(({
          item,
          position: position3
        }) => [item, position3.column]);
        return isEqual_default(prevItemColumns, nextItemColumns) ? prevItemColumns : nextItemColumns;
      });
    }
  }, [itemWithPositions]);
  useLayoutEffect_default(() => {
    if (onLayoutChange && items && items.length === itemColumns.length) {
      onLayoutChange(itemColumns.map(([item, column2]) => ({
        ...item,
        column: column2
      })));
    }
  }, [itemColumns]);
  return React477.createElement(es_default, {
    onResize: collectItemSize
  }, React477.createElement("div", {
    ref: containerRef,
    className: clsx(prefixCls, contextClassName, mergedClassNames.root, rootClassName, className, hashId, cssVarCls, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }),
    style: {
      height: totalHeight,
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    // Listen for image events
    onLoad: collectItemSize,
    onError: collectItemSize
  }, React477.createElement(CSSMotionList_default, {
    keys: itemWithPositions,
    component: false,
    // Motion config
    motionAppear: true,
    motionLeave: true,
    motionName: `${prefixCls}-item-fade`
  }, (motionInfo, motionRef) => {
    const {
      item,
      itemKey: itemKey3,
      position: position3 = {},
      itemIndex,
      key,
      className: motionClassName,
      style: motionStyle
    } = motionInfo;
    const {
      column: columnIndex = 0
    } = position3;
    const itemStyle = {
      "--item-width": `calc((100% + ${horizontalGutter}px) / ${columnCount})`,
      insetInlineStart: `calc(var(--item-width) * ${columnIndex})`,
      width: `calc(var(--item-width) - ${horizontalGutter}px)`,
      top: position3.top,
      position: "absolute"
    };
    return React477.createElement(MasonryItem_default, {
      prefixCls,
      key,
      item,
      style: {
        ...motionStyle,
        ...mergedStyles.item,
        ...itemStyle
      },
      className: clsx(mergedClassNames.item, motionClassName),
      ref: composeRef(motionRef, (ele) => setItemRef(itemKey3, ele)),
      index: itemIndex,
      itemRender,
      column: columnIndex,
      onResize: fresh ? collectItemSize : null
    });
  })));
});
if (true) {
  Masonry.displayName = "Masonry";
}
var Masonry_default = Masonry;

// node_modules/antd/es/masonry/index.js
var masonry_default = Masonry_default;

// node_modules/antd/es/mentions/index.js
var React483 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/Mentions.js
var import_react189 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/hooks/useEffectState.js
var import_react186 = __toESM(require_react());
function useEffectState2() {
  const [effectId, setEffectId] = (0, import_react186.useState)({
    id: 0,
    callback: null
  });
  const update = (0, import_react186.useCallback)((callback) => {
    setEffectId(({
      id
    }) => ({
      id: id + 1,
      callback
    }));
  }, []);
  (0, import_react186.useEffect)(() => {
    var _a;
    (_a = effectId.callback) == null ? void 0 : _a.call(effectId);
  }, [effectId]);
  return update;
}

// node_modules/@rc-component/mentions/es/KeywordTrigger.js
var React480 = __toESM(require_react());
var import_react188 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/DropdownMenu.js
var import_react187 = __toESM(require_react());

// node_modules/@rc-component/mentions/es/MentionsContext.js
var React478 = __toESM(require_react());
var MentionsContext = React478.createContext(null);
var MentionsContext_default = MentionsContext;

// node_modules/@rc-component/mentions/es/DropdownMenu.js
function DropdownMenu(props) {
  const {
    notFoundContent,
    activeIndex,
    setActiveIndex,
    selectOption,
    onFocus,
    onBlur,
    onScroll
  } = import_react187.default.useContext(MentionsContext_default);
  const {
    prefixCls,
    options,
    opened
  } = props;
  const activeOption = options[activeIndex] || {};
  const menuRef = (0, import_react187.useRef)(null);
  (0, import_react187.useEffect)(() => {
    var _a, _b;
    if (activeIndex === -1 || !menuRef.current || !opened) {
      return;
    }
    const activeItem = (_b = (_a = menuRef.current) == null ? void 0 : _a.findItem) == null ? void 0 : _b.call(_a, {
      key: activeOption.key
    });
    if (activeItem) {
      activeItem.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }, [activeIndex, activeOption.key, opened]);
  return import_react187.default.createElement(es_default15, {
    ref: menuRef,
    prefixCls: `${prefixCls}-menu`,
    activeKey: activeOption.key,
    onSelect: ({
      key
    }) => {
      const option = options.find(({
        key: optionKey
      }) => optionKey === key);
      selectOption(option);
    },
    onFocus,
    onBlur,
    onScroll
  }, options.map((option, index2) => {
    const {
      key,
      disabled,
      className,
      style: style2,
      label
    } = option;
    return import_react187.default.createElement(MenuItem_default, {
      key,
      disabled,
      className,
      style: style2,
      onMouseEnter: () => {
        setActiveIndex(index2);
      }
    }, label);
  }), !options.length && import_react187.default.createElement(MenuItem_default, {
    disabled: true
  }, notFoundContent));
}
var DropdownMenu_default = DropdownMenu;

// node_modules/@rc-component/mentions/es/KeywordTrigger.js
var BUILT_IN_PLACEMENTS2 = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
var KeywordTrigger = (props) => {
  const {
    prefixCls,
    options,
    children,
    visible,
    transitionName,
    getPopupContainer,
    popupClassName,
    popupStyle,
    direction,
    placement
  } = props;
  const dropdownPrefix = `${prefixCls}-dropdown`;
  const [opened, setOpened] = React480.useState(false);
  const dropdownElement = React480.createElement(DropdownMenu_default, {
    prefixCls: dropdownPrefix,
    options,
    opened
  });
  const dropdownPlacement = (0, import_react188.useMemo)(() => {
    let popupPlacement;
    if (direction === "rtl") {
      popupPlacement = placement === "top" ? "topLeft" : "bottomLeft";
    } else {
      popupPlacement = placement === "top" ? "topRight" : "bottomRight";
    }
    return popupPlacement;
  }, [direction, placement]);
  return React480.createElement(es_default4, {
    prefixCls: dropdownPrefix,
    popupVisible: visible,
    popup: dropdownElement,
    popupPlacement: dropdownPlacement,
    popupMotion: {
      motionName: transitionName
    },
    builtinPlacements: BUILT_IN_PLACEMENTS2,
    getPopupContainer,
    popupClassName,
    popupStyle,
    afterOpenChange: setOpened
  }, children);
};
var KeywordTrigger_default = KeywordTrigger;

// node_modules/@rc-component/mentions/es/Option.js
var Option4 = () => null;
var Option_default2 = Option4;

// node_modules/@rc-component/mentions/es/util.js
function getBeforeSelectionText(input) {
  const {
    selectionStart
  } = input;
  return input.value.slice(0, selectionStart);
}
function getLastMeasureIndex(text, prefix2) {
  return prefix2.reduce((lastMatch, prefixStr) => {
    const lastIndex = text.lastIndexOf(prefixStr);
    if (lastIndex > lastMatch.location) {
      return {
        location: lastIndex,
        prefix: prefixStr
      };
    }
    return lastMatch;
  }, {
    location: -1,
    prefix: ""
  });
}
function lower(char2) {
  return (char2 || "").toLowerCase();
}
function reduceText(text, targetText, split) {
  const firstChar = text[0];
  if (!firstChar || firstChar === split) {
    return text;
  }
  let restText = text;
  const targetTextLen = targetText.length;
  for (let i = 0; i < targetTextLen; i += 1) {
    if (lower(restText[i]) !== lower(targetText[i])) {
      restText = restText.slice(i);
      break;
    } else if (i === targetTextLen - 1) {
      restText = restText.slice(targetTextLen);
    }
  }
  return restText;
}
function replaceWithMeasure(text, measureConfig) {
  const {
    measureLocation,
    prefix: prefix2,
    targetText,
    selectionStart,
    split
  } = measureConfig;
  let beforeMeasureText = text.slice(0, measureLocation);
  if (beforeMeasureText[beforeMeasureText.length - split.length] === split) {
    beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split.length);
  }
  if (beforeMeasureText) {
    beforeMeasureText = `${beforeMeasureText}${split}`;
  }
  let restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix2.length), split);
  if (restText.slice(0, split.length) === split) {
    restText = restText.slice(split.length);
  }
  const connectedStartText = `${beforeMeasureText}${prefix2}${targetText}${split}`;
  return {
    text: `${connectedStartText}${restText}`,
    selectionLocation: connectedStartText.length
  };
}
function setInputSelection(input, location) {
  input.setSelectionRange(location, location);
  input.blur();
  input.focus();
}
function validateSearch(text, split) {
  return !split || text.indexOf(split) === -1;
}
function filterOption(input, {
  value = ""
}) {
  const lowerCase = input.toLowerCase();
  return value.toLowerCase().indexOf(lowerCase) !== -1;
}

// node_modules/@rc-component/mentions/es/context.js
var React481 = __toESM(require_react());
var UnstableContext2 = React481.createContext({});

// node_modules/@rc-component/mentions/es/Mentions.js
function _extends72() {
  _extends72 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends72.apply(this, arguments);
}
var InternalMentions = (0, import_react189.forwardRef)((props, ref) => {
  const {
    // Style
    prefixCls,
    className,
    style: style2,
    classNames: mentionClassNames,
    styles,
    // Misc
    prefix: prefix2 = "@",
    split = " ",
    notFoundContent = "Not Found",
    value,
    defaultValue,
    children,
    options,
    allowClear,
    hasWrapper,
    silent,
    // Events
    validateSearch: validateSearch2 = validateSearch,
    filterOption: filterOption2 = filterOption,
    onChange,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onPressEnter,
    onSearch,
    onSelect,
    onFocus,
    onBlur,
    // Dropdown
    transitionName,
    placement,
    direction,
    getPopupContainer,
    popupClassName,
    rows = 1,
    // Fix Warning: Received `false` for a non-boolean attribute `visible`.
    // https://github.com/ant-design/ant-design/blob/df933e94efc8f376003bbdc658d64b64a0e53495/components/mentions/demo/render-panel.tsx
    // @ts-expect-error
    visible,
    onPopupScroll,
    // Rest
    ...restProps
  } = props;
  const mergedPrefix = (0, import_react189.useMemo)(() => Array.isArray(prefix2) ? prefix2 : [prefix2], [prefix2]);
  const containerRef = (0, import_react189.useRef)(null);
  const textareaRef = (0, import_react189.useRef)(null);
  const measureRef = (0, import_react189.useRef)(null);
  const getTextArea = () => {
    var _a, _b;
    return (_b = (_a = textareaRef.current) == null ? void 0 : _a.resizableTextArea) == null ? void 0 : _b.textArea;
  };
  import_react189.default.useImperativeHandle(ref, () => {
    var _a, _b;
    return {
      focus: () => {
        var _a2;
        return (_a2 = textareaRef.current) == null ? void 0 : _a2.focus();
      },
      blur: () => {
        var _a2;
        return (_a2 = textareaRef.current) == null ? void 0 : _a2.blur();
      },
      textarea: (_b = (_a = textareaRef.current) == null ? void 0 : _a.resizableTextArea) == null ? void 0 : _b.textArea,
      nativeElement: containerRef.current
    };
  });
  const [measuring, setMeasuring] = (0, import_react189.useState)(false);
  const [measureText, setMeasureText] = (0, import_react189.useState)("");
  const [measurePrefix, setMeasurePrefix] = (0, import_react189.useState)("");
  const [measureLocation, setMeasureLocation] = (0, import_react189.useState)(0);
  const [activeIndex, setActiveIndex] = (0, import_react189.useState)(0);
  const [isFocus, setIsFocus] = (0, import_react189.useState)(false);
  const uniqueKey2 = useId_default(props.id);
  const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", value);
  const {
    open: open3
  } = (0, import_react189.useContext)(UnstableContext2);
  (0, import_react189.useEffect)(() => {
    if (measuring && measureRef.current) {
      measureRef.current.scrollTop = getTextArea().scrollTop;
    }
  }, [measuring]);
  const [mergedMeasuring, mergedMeasureText, mergedMeasurePrefix, mergedMeasureLocation] = import_react189.default.useMemo(() => {
    if (open3) {
      for (let i = 0; i < mergedPrefix.length; i += 1) {
        const curPrefix = mergedPrefix[i];
        const index2 = mergedValue.lastIndexOf(curPrefix);
        if (index2 >= 0) {
          return [true, "", curPrefix, index2];
        }
      }
    }
    return [measuring, measureText, measurePrefix, measureLocation];
  }, [open3, measuring, mergedPrefix, mergedValue, measureText, measurePrefix, measureLocation]);
  const getOptions = import_react189.default.useCallback((targetMeasureText) => {
    let list;
    if (options && options.length > 0) {
      list = options.map((item) => ({
        ...item,
        key: `${(item == null ? void 0 : item.key) ?? item.value}-${uniqueKey2}`
      }));
    } else {
      list = toArray(children).map(({
        props: optionProps,
        key
      }) => ({
        ...optionProps,
        label: optionProps.children,
        key: `${key || optionProps.value}-${uniqueKey2}`
      }));
    }
    return list.filter((option) => {
      if (filterOption2 === false) {
        return true;
      }
      return filterOption2(targetMeasureText, option);
    });
  }, [options, uniqueKey2, children, filterOption2]);
  const mergedOptions = import_react189.default.useMemo(() => getOptions(mergedMeasureText), [getOptions, mergedMeasureText]);
  const onSelectionEffect = useEffectState2();
  const startMeasure = (nextMeasureText, nextMeasurePrefix, nextMeasureLocation) => {
    setMeasuring(true);
    setMeasureText(nextMeasureText);
    setMeasurePrefix(nextMeasurePrefix);
    setMeasureLocation(nextMeasureLocation);
    setActiveIndex(0);
  };
  const stopMeasure = (callback) => {
    setMeasuring(false);
    setMeasureLocation(0);
    setMeasureText("");
    onSelectionEffect(callback);
  };
  const triggerChange = (nextValue) => {
    setMergedValue(nextValue);
    onChange == null ? void 0 : onChange(nextValue);
  };
  const onInternalChange = ({
    target: {
      value: nextValue
    }
  }) => {
    triggerChange(nextValue);
  };
  const selectOption = (option) => {
    var _a;
    const {
      value: mentionValue = ""
    } = option;
    const {
      text,
      selectionLocation
    } = replaceWithMeasure(mergedValue, {
      measureLocation: mergedMeasureLocation,
      targetText: mentionValue,
      prefix: mergedMeasurePrefix,
      selectionStart: (_a = getTextArea()) == null ? void 0 : _a.selectionStart,
      split
    });
    triggerChange(text);
    stopMeasure(() => {
      setInputSelection(getTextArea(), selectionLocation);
    });
    onSelect == null ? void 0 : onSelect(option, mergedMeasurePrefix);
  };
  const onInternalKeyDown = (event) => {
    const {
      which
    } = event;
    onKeyDown2 == null ? void 0 : onKeyDown2(event);
    if (!mergedMeasuring) {
      return;
    }
    if (which === KeyCode_default.UP || which === KeyCode_default.DOWN) {
      const optionLen = mergedOptions.length;
      const offset3 = which === KeyCode_default.UP ? -1 : 1;
      const newActiveIndex = (activeIndex + offset3 + optionLen) % optionLen;
      setActiveIndex(newActiveIndex);
      event.preventDefault();
    } else if (which === KeyCode_default.ESC) {
      stopMeasure();
    } else if (which === KeyCode_default.ENTER) {
      event.preventDefault();
      if (silent) {
        return;
      }
      if (!mergedOptions.length) {
        stopMeasure();
        return;
      }
      const option = mergedOptions[activeIndex];
      selectOption(option);
    }
  };
  const onInternalKeyUp = (event) => {
    const {
      key,
      which
    } = event;
    const target = event.target;
    const selectionStartText = getBeforeSelectionText(target);
    const {
      location: measureIndex,
      prefix: nextMeasurePrefix
    } = getLastMeasureIndex(selectionStartText, mergedPrefix);
    onKeyUp == null ? void 0 : onKeyUp(event);
    if ([KeyCode_default.ESC, KeyCode_default.UP, KeyCode_default.DOWN, KeyCode_default.ENTER].indexOf(which) !== -1) {
      return;
    }
    if (measureIndex !== -1) {
      const nextMeasureText = selectionStartText.slice(measureIndex + nextMeasurePrefix.length);
      const validateMeasure = validateSearch2(nextMeasureText, split);
      const matchOption = !!getOptions(nextMeasureText).length;
      if (validateMeasure) {
        if (key === nextMeasurePrefix || key === "Shift" || which === KeyCode_default.ALT || key === "AltGraph" || mergedMeasuring || nextMeasureText !== mergedMeasureText && matchOption) {
          startMeasure(nextMeasureText, nextMeasurePrefix, measureIndex);
        }
      } else if (mergedMeasuring) {
        stopMeasure();
      }
      if (onSearch && validateMeasure) {
        onSearch(nextMeasureText, nextMeasurePrefix);
      }
    } else if (mergedMeasuring) {
      stopMeasure();
    }
  };
  const onInternalPressEnter = (event) => {
    if (!mergedMeasuring && onPressEnter) {
      onPressEnter(event);
    }
  };
  const focusRef = (0, import_react189.useRef)();
  const onInternalFocus = (event) => {
    window.clearTimeout(focusRef.current);
    if (!isFocus && event && onFocus) {
      onFocus(event);
    }
    setIsFocus(true);
  };
  const onInternalBlur = (event) => {
    focusRef.current = window.setTimeout(() => {
      setIsFocus(false);
      stopMeasure();
      onBlur == null ? void 0 : onBlur(event);
    }, 0);
  };
  const onDropdownFocus = () => {
    onInternalFocus();
  };
  const onDropdownBlur = () => {
    onInternalBlur();
  };
  const onInternalPopupScroll = (event) => {
    onPopupScroll == null ? void 0 : onPopupScroll(event);
  };
  const mergedStyles = import_react189.default.useMemo(() => {
    var _a;
    const resizeStyle = ((_a = styles == null ? void 0 : styles.textarea) == null ? void 0 : _a.resize) ?? (style2 == null ? void 0 : style2.resize);
    const mergedTextareaStyle = {
      ...styles == null ? void 0 : styles.textarea
    };
    if (resizeStyle !== void 0) {
      mergedTextareaStyle.resize = resizeStyle;
    }
    return {
      ...styles,
      textarea: mergedTextareaStyle
    };
  }, [style2, styles]);
  const mentionNode = import_react189.default.createElement(import_react189.default.Fragment, null, import_react189.default.createElement(es_default28, _extends72({
    classNames: {
      textarea: mentionClassNames == null ? void 0 : mentionClassNames.textarea
    },
    styles: mergedStyles,
    ref: textareaRef,
    value: mergedValue
  }, restProps, {
    rows,
    onChange: onInternalChange,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onPressEnter: onInternalPressEnter,
    onFocus: onInternalFocus,
    onBlur: onInternalBlur
  })), mergedMeasuring && import_react189.default.createElement("div", {
    ref: measureRef,
    className: `${prefixCls}-measure`
  }, mergedValue.slice(0, mergedMeasureLocation), import_react189.default.createElement(MentionsContext_default.Provider, {
    value: {
      notFoundContent,
      activeIndex,
      setActiveIndex,
      selectOption,
      onFocus: onDropdownFocus,
      onBlur: onDropdownBlur,
      onScroll: onInternalPopupScroll
    }
  }, import_react189.default.createElement(KeywordTrigger_default, {
    prefixCls,
    transitionName,
    placement,
    direction,
    options: mergedOptions,
    visible: true,
    getPopupContainer,
    popupClassName: clsx(popupClassName, mentionClassNames == null ? void 0 : mentionClassNames.popup),
    popupStyle: styles == null ? void 0 : styles.popup
  }, import_react189.default.createElement("span", null, mergedMeasurePrefix))), mergedValue.slice(mergedMeasureLocation + mergedMeasurePrefix.length)));
  if (!hasWrapper) {
    return import_react189.default.createElement("div", {
      className: clsx(prefixCls, className),
      style: style2,
      ref: containerRef
    }, mentionNode);
  }
  return mentionNode;
});
var Mentions = (0, import_react189.forwardRef)(({
  suffix,
  prefixCls = "rc-mentions",
  defaultValue,
  value: customValue,
  id,
  allowClear,
  onChange,
  classNames: mentionsClassNames,
  styles,
  className,
  disabled,
  onClear,
  ...rest
}, ref) => {
  const hasSuffix = !!(suffix || allowClear);
  const holderRef = (0, import_react189.useRef)(null);
  const mentionRef = (0, import_react189.useRef)(null);
  (0, import_react189.useImperativeHandle)(ref, () => {
    var _a, _b;
    return {
      ...mentionRef.current,
      nativeElement: ((_a = holderRef.current) == null ? void 0 : _a.nativeElement) || ((_b = mentionRef.current) == null ? void 0 : _b.nativeElement)
    };
  });
  const [mergedValue, setMergedValue] = useControlledState(defaultValue || "", customValue);
  const triggerChange = (currentValue) => {
    setMergedValue(currentValue);
    onChange == null ? void 0 : onChange(currentValue);
  };
  const handleReset = () => {
    triggerChange("");
  };
  return import_react189.default.createElement(BaseInput_default, {
    suffix,
    prefixCls,
    value: mergedValue,
    allowClear,
    handleReset,
    className: clsx(prefixCls, className, {
      // hasSuffix
      [`${prefixCls}-has-suffix`]: hasSuffix
    }),
    classNames: mentionsClassNames,
    disabled,
    ref: holderRef,
    onClear
  }, import_react189.default.createElement(InternalMentions, _extends72({
    className: mentionsClassNames == null ? void 0 : mentionsClassNames.mentions,
    styles,
    classNames: mentionsClassNames,
    prefixCls,
    id,
    ref: mentionRef,
    onChange: triggerChange,
    disabled,
    hasWrapper: hasSuffix
  }, rest)));
});
Mentions.Option = Option_default2;
var Mentions_default = Mentions;

// node_modules/@rc-component/mentions/es/index.js
var es_default29 = Mentions_default;

// node_modules/antd/es/_util/toList.js
var toList = (candidate, skipEmpty = false) => {
  if (skipEmpty && !isNonNullable_default(candidate)) {
    return [];
  }
  return Array.isArray(candidate) ? candidate : [candidate];
};
var toList_default = toList;

// node_modules/antd/es/mentions/style/index.js
var genDropdownStyle2 = (token2) => {
  const {
    componentCls,
    fontSize,
    paddingXXS,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    itemPaddingVertical,
    controlPaddingHorizontal,
    colorText,
    borderRadius,
    lineHeight,
    colorTextDisabled,
    controlItemBgHover,
    motionDurationSlow
  } = token2;
  return {
    [componentCls]: {
      // ================== Dropdown ==================
      "&-dropdown": {
        // Ref select dropdown style
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        fontSize,
        fontVariant: "initial",
        padding: paddingXXS,
        backgroundColor: colorBgElevated,
        borderRadius: borderRadiusLG,
        outline: "none",
        boxShadow: boxShadowSecondary,
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token2.dropdownHeight,
          margin: 0,
          paddingInlineStart: 0,
          // Override default ul/ol
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": {
            ...textEllipsis,
            position: "relative",
            display: "block",
            minWidth: token2.controlItemWidth,
            padding: `${unit(itemPaddingVertical)} ${unit(controlPaddingHorizontal)}`,
            color: colorText,
            borderRadius,
            fontWeight: "normal",
            lineHeight,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&:hover": {
              backgroundColor: controlItemBgHover
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: controlItemBgHover,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: colorText,
              fontWeight: token2.fontWeightStrong,
              backgroundColor: controlItemBgHover
            },
            "&-active": {
              backgroundColor: controlItemBgHover
            }
          }
        }
      }
    }
  };
};
var genMentionsStyle = (token2) => {
  const {
    componentCls,
    calc,
    colorText,
    antCls,
    colorTextDisabled
  } = token2;
  return {
    [componentCls]: [
      // =========================== Common ===========================
      resetComponent(token2),
      genBasicInputStyle(token2, {
        largeStyle: {
          padding: void 0
        },
        smallStyle: {
          padding: void 0
        }
      }),
      // ========================== Variants ==========================
      genOutlinedStyle(token2),
      genFilledStyle(token2),
      genBorderlessStyle2(token2),
      genUnderlinedStyle(token2),
      // ========================== Mentions ==========================
      {
        "--mentions-padding-inline": token2.paddingInline,
        "--mentions-padding-block": token2.paddingBlock,
        "--mentions-control-height": token2.controlHeight,
        display: "flex",
        padding: 0,
        whiteSpace: "pre-wrap",
        // ========================= Textarea =========================
        "> textarea": [resetComponent(token2), genPlaceholderStyle(token2.colorTextPlaceholder), {
          background: "transparent",
          border: "none",
          borderRadius: "inherit",
          outline: "none",
          flex: "auto",
          minWidth: 0,
          resize: "none",
          "&:disabled": {
            color: colorTextDisabled
          }
        }],
        [`> textarea, ${componentCls}-measure`]: {
          color: colorText,
          boxSizing: "border-box",
          margin: 0,
          minHeight: calc("var(--mentions-control-height)").sub(calc(token2.lineWidth).mul(2).equal()).equal(),
          paddingInline: "var(--mentions-padding-inline)",
          paddingBlock: "var(--mentions-padding-block)",
          overflow: "inherit",
          overflowX: "hidden",
          overflowY: "auto",
          fontWeight: "inherit",
          fontSize: "inherit",
          fontFamily: "inherit",
          fontStyle: "inherit",
          fontVariant: "inherit",
          fontSizeAdjust: "inherit",
          fontStretch: "inherit",
          lineHeight: "inherit",
          direction: "inherit",
          letterSpacing: "inherit",
          whiteSpace: "inherit",
          textAlign: "inherit",
          verticalAlign: "top",
          wordWrap: "break-word",
          wordBreak: "inherit",
          tabSize: "inherit"
        },
        // ========================= Measure ==========================
        [`${componentCls}-measure`]: {
          position: "absolute",
          inset: 0,
          zIndex: -1,
          color: "transparent",
          pointerEvents: "none",
          "> span": {
            display: "inline-block",
            minHeight: "1em"
          }
        },
        // ========================== Suffix ==========================
        [`${componentCls}-suffix`]: {
          display: "inline-flex",
          alignItems: "center",
          flex: "none",
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          lineHeight: 1,
          position: "absolute",
          top: "50%",
          transform: "translateY(-50%)",
          insetInlineEnd: "var(--mentions-padding-inline)",
          columnGap: token2.marginXS,
          [`${componentCls}-clear-icon`]: {
            // https://github.com/ant-design/ant-design/pull/18151
            // https://codesandbox.io/s/wizardly-sun-u10br
            cursor: "pointer",
            border: 0,
            background: "transparent",
            "&:hover": {
              color: token2.colorIcon
            },
            "&:active": {
              color: token2.colorText
            },
            "&-hidden": {
              visibility: "hidden"
            }
          },
          [`${antCls}-form-item-feedback-icon`]: {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      },
      // ========================= AllowClear =========================
      {
        "&-has-suffix": {
          "> textarea": {
            paddingInlineEnd: calc(token2.paddingXXS).mul(1.5).add(token2.fontSizeIcon).add("var(--mentions-padding-inline)").equal()
          }
        }
      },
      // ========================== Disabled ==========================
      {
        "&-disabled": {
          "> textarea": {
            ...genDisabledStyle(token2)
          }
        }
      },
      // ============================ Size ============================
      {
        "&-lg": {
          "--mentions-padding-inline": token2.paddingInlineLG,
          "--mentions-padding-block": token2.paddingBlockLG,
          "--mentions-control-height": token2.controlHeightLG
        },
        "&-sm": {
          "--mentions-padding-inline": token2.paddingInlineSM,
          "--mentions-padding-block": token2.paddingBlockSM,
          "--mentions-control-height": token2.controlHeightSM
        }
      }
    ]
  };
};
var prepareComponentToken41 = (token2) => ({
  ...initComponentToken(token2),
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: token2.zIndexPopupBase + 50,
  itemPaddingVertical: (token2.controlHeight - token2.fontHeight) / 2
});
var style_default48 = genStyleHooks("Mentions", (token2) => {
  const mentionsToken = merge2(token2, initInputToken(token2));
  return [genMentionsStyle(mentionsToken), genDropdownStyle2(mentionsToken)];
}, prepareComponentToken41);

// node_modules/antd/es/mentions/index.js
var {
  Option: Option5
} = es_default29;
function loadingFilterOption() {
  return true;
}
var InternalMentions2 = React483.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    disabled: customDisabled,
    loading,
    filterOption: filterOption2,
    children,
    notFoundContent,
    options,
    status: customStatus,
    allowClear = false,
    popupClassName,
    style: style2,
    variant: customVariant,
    classNames,
    styles,
    size: customSize,
    ...restProps
  } = props;
  const [focused, setFocused] = React483.useState(false);
  const innerRef = React483.useRef(null);
  const mergedRef = composeRef(ref, innerRef);
  const mergedSize = useSize_default((ctx) => customSize ?? ctx);
  if (true) {
    const warning5 = devUseWarning("Mentions");
    warning5.deprecated(!children, "Mentions.Option", "options");
  }
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("mentions");
  const {
    renderEmpty
  } = React483.useContext(ConfigContext);
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = React483.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const contextDisabled = React483.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? contextDisabled;
  const prefixCls = getPrefixCls("mentions", customizePrefixCls);
  const mergedProps = {
    ...props,
    disabled: mergedDisabled,
    status: mergedStatus,
    loading,
    options,
    variant: customVariant
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const onFocus = (...args) => {
    if (restProps.onFocus) {
      restProps.onFocus.apply(restProps, args);
    }
    setFocused(true);
  };
  const onBlur = (...args) => {
    if (restProps.onBlur) {
      restProps.onBlur.apply(restProps, args);
    }
    setFocused(false);
  };
  const notFoundContentEle = React483.useMemo(() => {
    if (notFoundContent !== void 0) {
      return notFoundContent;
    }
    return (renderEmpty == null ? void 0 : renderEmpty("Select")) || React483.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }, [notFoundContent, renderEmpty]);
  const mentionOptions = React483.useMemo(() => {
    if (loading) {
      return React483.createElement(Option5, {
        value: "ANTD_SEARCHING",
        disabled: true
      }, React483.createElement(spin_default, {
        size: "small"
      }));
    }
    return children;
  }, [loading, children]);
  const mergedOptions = loading ? [{
    value: "ANTD_SEARCHING",
    disabled: true,
    label: React483.createElement(spin_default, {
      size: "small"
    })
  }] : options;
  const mentionsfilterOption = loading ? loadingFilterOption : filterOption2;
  const mergedAllowClear = getAllowClear_default(allowClear);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default48(prefixCls, rootCls);
  const [variant, enableVariantCls] = useVariants_default("mentions", customVariant);
  const suffixNode = hasFeedback && React483.createElement(React483.Fragment, null, feedbackIcon);
  const mergedClassName = clsx(contextClassName, className, rootClassName, cssVarCls, rootCls, mergedClassNames.root, {
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-lg`]: mergedSize === "large"
  });
  return React483.createElement(es_default29, {
    silent: loading,
    prefixCls,
    notFoundContent: notFoundContentEle,
    className: mergedClassName,
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    direction,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    ...restProps,
    filterOption: mentionsfilterOption,
    onFocus,
    onBlur,
    ref: mergedRef,
    options: mergedOptions,
    suffix: suffixNode,
    styles: {
      textarea: mergedStyles.textarea,
      popup: mergedStyles.popup,
      suffix: mergedStyles.suffix
    },
    classNames: {
      textarea: clsx(mergedClassNames.textarea),
      popup: clsx(mergedClassNames.popup, popupClassName, rootClassName, hashId, cssVarCls, rootCls),
      suffix: mergedClassNames.suffix,
      mentions: clsx({
        [`${prefixCls}-disabled`]: mergedDisabled,
        [`${prefixCls}-focused`]: focused,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId),
      variant: clsx({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, getStatusClassNames(prefixCls, mergedStatus)),
      affixWrapper: hashId
    }
  }, mentionOptions);
});
var Mentions2 = InternalMentions2;
if (true) {
  Mentions2.displayName = "Mentions";
}
Mentions2.Option = Option5;
var PurePanel13 = PurePanel_default3(Mentions2, void 0, void 0, "mentions");
Mentions2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel13;
Mentions2.getMentions = (value = "", config = {}) => {
  const {
    prefix: prefix2 = "@",
    split = " "
  } = config;
  const prefixList = toList_default(prefix2);
  return value.split(split).map((str = "") => {
    let hitPrefix = null;
    prefixList.some((prefixStr) => {
      const startStr = str.slice(0, prefixStr.length);
      if (startStr === prefixStr) {
        hitPrefix = prefixStr;
        return true;
      }
      return false;
    });
    if (hitPrefix !== null) {
      return {
        prefix: hitPrefix,
        value: str.slice(hitPrefix.length)
      };
    }
    return null;
  }).filter((entity) => !!entity && !!entity.value);
};
var mentions_default = Mentions2;

// node_modules/antd/es/message/index.js
var import_react190 = __toESM(require_react());
var message = null;
var act = (callback) => callback();
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
  const {
    getContainer,
    duration,
    rtl,
    maxCount,
    top
  } = defaultGlobalConfig;
  const mergedContainer = (getContainer == null ? void 0 : getContainer()) || document.body;
  return {
    getContainer: () => mergedContainer,
    duration,
    rtl,
    maxCount,
    top
  };
}
var GlobalHolder = import_react190.default.forwardRef((props, ref) => {
  const {
    messageConfig,
    sync
  } = props;
  const {
    getPrefixCls
  } = (0, import_react190.useContext)(ConfigContext);
  const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
  const appConfig = (0, import_react190.useContext)(AppConfigContext);
  const [api, holder] = useInternalMessage({
    ...messageConfig,
    prefixCls,
    ...appConfig.message
  });
  import_react190.default.useImperativeHandle(ref, () => {
    const instance = {
      ...api
    };
    Object.keys(instance).forEach((method4) => {
      instance[method4] = (...args) => {
        sync();
        return api[method4].apply(api, args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper = import_react190.default.forwardRef((_, ref) => {
  const [messageConfig, setMessageConfig] = import_react190.default.useState(getGlobalContext);
  const sync = () => {
    setMessageConfig(getGlobalContext);
  };
  import_react190.default.useEffect(sync, []);
  const global = globalConfig();
  const rootPrefixCls = global.getRootPrefixCls();
  const rootIconPrefixCls = global.getIconPrefixCls();
  const theme = global.getTheme();
  const dom = import_react190.default.createElement(GlobalHolder, {
    ref,
    sync,
    messageConfig
  });
  return import_react190.default.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    theme
  }, global.holderRender ? global.holderRender(dom) : dom);
});
var flushMessageQueue = () => {
  if (!message) {
    const holderFragment = document.createDocumentFragment();
    const newMessage = {
      fragment: holderFragment
    };
    message = newMessage;
    act(() => {
      render(import_react190.default.createElement(GlobalHolderWrapper, {
        ref: (node2) => {
          const {
            instance,
            sync
          } = node2 || {};
          Promise.resolve().then(() => {
            if (!newMessage.instance && instance) {
              newMessage.instance = instance;
              newMessage.sync = sync;
              flushMessageQueue();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  if (!message.instance) {
    return;
  }
  taskQueue.forEach((task) => {
    const {
      type: type5,
      skipped
    } = task;
    if (!skipped) {
      switch (type5) {
        case "open": {
          act(() => {
            const closeFn = message.instance.open({
              ...defaultGlobalConfig,
              ...task.config
            });
            closeFn == null ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
          break;
        }
        case "destroy":
          act(() => {
            message == null ? void 0 : message.instance.destroy(task.key);
          });
          break;
        default: {
          act(() => {
            var _message$instance;
            const closeFn = (_message$instance = message.instance)[type5].apply(_message$instance, _toConsumableArray(task.args));
            closeFn == null ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
        }
      }
    }
  });
  taskQueue = [];
};
function setMessageGlobalConfig(config) {
  defaultGlobalConfig = {
    ...defaultGlobalConfig,
    ...config
  };
  act(() => {
    var _a;
    (_a = message == null ? void 0 : message.sync) == null ? void 0 : _a.call(message);
  });
}
function open(config) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: "open",
      config,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
function typeOpen(type5, args) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("message");
  }
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: type5,
      args,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
var destroy = (key) => {
  taskQueue.push({
    type: "destroy",
    key
  });
  flushMessageQueue();
};
var methods = ["success", "info", "warning", "error", "loading"];
var baseStaticMethods = {
  open,
  destroy,
  config: setMessageGlobalConfig,
  useMessage,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default
};
var staticMethods = baseStaticMethods;
methods.forEach((type5) => {
  staticMethods[type5] = (...args) => typeOpen(type5, args);
});
if (false) {
  _actWrapper = (wrapper) => {
    act = wrapper;
  };
}
if (false) {
  _actDestroy = () => {
    message = null;
  };
}
var message_default = staticMethods;

// node_modules/antd/es/modal/PurePanel.js
var React485 = __toESM(require_react());
var PurePanel14 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    closeIcon,
    closable,
    type: type5,
    title,
    children,
    footer,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React485.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const prefixCls = customizePrefixCls || getPrefixCls("modal");
  const rootCls = useCSSVarCls_default(rootPrefixCls);
  const [hashId, cssVarCls] = style_default9(prefixCls, rootCls);
  const confirmPrefixCls = `${prefixCls}-confirm`;
  let additionalProps = {};
  if (type5) {
    additionalProps = {
      closable: closable ?? false,
      title: "",
      footer: "",
      children: React485.createElement(ConfirmContent, {
        ...props,
        prefixCls,
        confirmPrefixCls,
        rootPrefixCls,
        content: children
      })
    };
  } else {
    additionalProps = {
      closable: closable ?? true,
      title,
      footer: footer !== null && React485.createElement(Footer, {
        ...props
      }),
      children
    };
  }
  return React485.createElement(Panel_default2, {
    prefixCls,
    className: clsx(hashId, `${prefixCls}-pure-panel`, type5 && confirmPrefixCls, type5 && `${confirmPrefixCls}-${type5}`, className, cssVarCls, rootCls),
    ...restProps,
    closeIcon: renderCloseIcon(prefixCls, closeIcon),
    closable,
    ...additionalProps
  });
};
var PurePanel_default7 = withPureRenderTheme(PurePanel14);

// node_modules/antd/es/modal/index.js
function modalWarn(props) {
  return confirm(withWarn(props));
}
var Modal2 = Modal_default;
Modal2.useModal = useModal_default;
Modal2.info = function infoFn(props) {
  return confirm(withInfo(props));
};
Modal2.success = function successFn(props) {
  return confirm(withSuccess(props));
};
Modal2.error = function errorFn(props) {
  return confirm(withError(props));
};
Modal2.warning = modalWarn;
Modal2.warn = modalWarn;
Modal2.confirm = function confirmFn(props) {
  return confirm(withConfirm(props));
};
Modal2.destroyAll = function destroyAllFn() {
  while (destroyFns_default.length) {
    const close = destroyFns_default.pop();
    if (close) {
      close();
    }
  }
};
Modal2.config = modalGlobalConfig;
Modal2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default7;
if (true) {
  Modal2.displayName = "Modal";
}
var modal_default = Modal2;

// node_modules/antd/es/notification/index.js
var import_react191 = __toESM(require_react());
var notification = null;
var act2 = (callback) => callback();
var taskQueue2 = [];
var defaultGlobalConfig2 = {};
function getGlobalContext2() {
  const {
    getContainer,
    rtl,
    maxCount,
    top,
    bottom,
    showProgress,
    pauseOnHover
  } = defaultGlobalConfig2;
  const mergedContainer = (getContainer == null ? void 0 : getContainer()) || document.body;
  return {
    getContainer: () => mergedContainer,
    rtl,
    maxCount,
    top,
    bottom,
    showProgress,
    pauseOnHover
  };
}
var GlobalHolder2 = import_react191.default.forwardRef((props, ref) => {
  const {
    notificationConfig,
    sync
  } = props;
  const {
    getPrefixCls
  } = (0, import_react191.useContext)(ConfigContext);
  const prefixCls = defaultGlobalConfig2.prefixCls || getPrefixCls("notification");
  const appConfig = (0, import_react191.useContext)(AppConfigContext);
  const [api, holder] = useInternalNotification({
    ...notificationConfig,
    prefixCls,
    ...appConfig.notification
  });
  import_react191.default.useEffect(sync, []);
  import_react191.default.useImperativeHandle(ref, () => {
    const instance = {
      ...api
    };
    Object.keys(instance).forEach((method4) => {
      instance[method4] = (...args) => {
        sync();
        return api[method4].apply(api, args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper2 = import_react191.default.forwardRef((_, ref) => {
  const [notificationConfig, setNotificationConfig] = import_react191.default.useState(getGlobalContext2);
  const sync = () => {
    setNotificationConfig(getGlobalContext2);
  };
  import_react191.default.useEffect(sync, []);
  const global = globalConfig();
  const rootPrefixCls = global.getRootPrefixCls();
  const rootIconPrefixCls = global.getIconPrefixCls();
  const theme = global.getTheme();
  const dom = import_react191.default.createElement(GlobalHolder2, {
    ref,
    sync,
    notificationConfig
  });
  return import_react191.default.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    theme
  }, global.holderRender ? global.holderRender(dom) : dom);
});
var flushNotificationQueue = () => {
  if (!notification) {
    const holderFragment = document.createDocumentFragment();
    const newNotification = {
      fragment: holderFragment
    };
    notification = newNotification;
    act2(() => {
      render(import_react191.default.createElement(GlobalHolderWrapper2, {
        ref: (node2) => {
          const {
            instance,
            sync
          } = node2 || {};
          Promise.resolve().then(() => {
            if (!newNotification.instance && instance) {
              newNotification.instance = instance;
              newNotification.sync = sync;
              flushNotificationQueue();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  if (!notification.instance) {
    return;
  }
  taskQueue2.forEach((task) => {
    switch (task.type) {
      case "open": {
        act2(() => {
          notification.instance.open({
            ...defaultGlobalConfig2,
            ...task.config
          });
        });
        break;
      }
      case "destroy":
        act2(() => {
          var _a;
          (_a = notification == null ? void 0 : notification.instance) == null ? void 0 : _a.destroy(task.key);
        });
        break;
    }
  });
  taskQueue2 = [];
};
function setNotificationGlobalConfig(config) {
  defaultGlobalConfig2 = {
    ...defaultGlobalConfig2,
    ...config
  };
  act2(() => {
    var _a;
    (_a = notification == null ? void 0 : notification.sync) == null ? void 0 : _a.call(notification);
  });
}
function open2(config) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("notification");
  }
  taskQueue2.push({
    type: "open",
    config
  });
  flushNotificationQueue();
}
var destroy2 = (key) => {
  taskQueue2.push({
    type: "destroy",
    key
  });
  flushNotificationQueue();
};
var methods2 = ["success", "info", "warning", "error"];
var baseStaticMethods2 = {
  open: open2,
  destroy: destroy2,
  config: setNotificationGlobalConfig,
  useNotification: useNotification2,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default2
};
var staticMethods2 = baseStaticMethods2;
methods2.forEach((type5) => {
  staticMethods2[type5] = (config) => open2({
    ...config,
    type: type5
  });
});
if (false) {
  _actWrapper = (wrapper) => {
    act2 = wrapper;
  };
}
if (false) {
  _actDestroy = () => {
    notification = null;
  };
}
var notification_default = staticMethods2;

// node_modules/antd/es/popconfirm/index.js
var React488 = __toESM(require_react());

// node_modules/antd/es/popconfirm/PurePanel.js
var React487 = __toESM(require_react());

// node_modules/antd/es/popconfirm/style/index.js
var genBaseStyle12 = (token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    zIndexPopup,
    colorText,
    colorWarning,
    marginXXS,
    marginXS,
    fontSize,
    fontWeightStrong,
    colorTextHeading
  } = token2;
  return {
    [componentCls]: {
      zIndex: zIndexPopup,
      [`&${antCls}-popover`]: {
        fontSize
      },
      [`${componentCls}-message`]: {
        marginBottom: marginXS,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${componentCls}-message-icon ${iconCls}`]: {
          color: colorWarning,
          fontSize,
          lineHeight: 1,
          marginInlineEnd: marginXS
        },
        [`${componentCls}-title`]: {
          fontWeight: fontWeightStrong,
          color: colorTextHeading,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${componentCls}-description`]: {
          marginTop: marginXXS,
          color: colorText
        }
      },
      [`${componentCls}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: marginXS
        }
      }
    }
  };
};
var prepareComponentToken42 = (token2) => {
  const {
    zIndexPopupBase
  } = token2;
  return {
    zIndexPopup: zIndexPopupBase + 60
  };
};
var style_default49 = genStyleHooks("Popconfirm", (token2) => genBaseStyle12(token2), prepareComponentToken42, {
  resetStyle: false
});

// node_modules/antd/es/popconfirm/PurePanel.js
var Overlay3 = (props) => {
  const {
    prefixCls,
    okButtonProps,
    cancelButtonProps,
    title,
    description,
    cancelText,
    okText,
    okType = "primary",
    icon = React487.createElement(ExclamationCircleFilled_default, null),
    showCancel = true,
    close,
    onConfirm,
    onCancel,
    onPopupClick,
    classNames,
    styles
  } = props;
  const {
    getPrefixCls
  } = React487.useContext(ConfigContext);
  const [contextLocale] = useLocale_default("Popconfirm", en_US_default6.Popconfirm);
  const titleNode = getRenderPropValue(title);
  const descriptionNode = getRenderPropValue(description);
  return React487.createElement("div", {
    className: `${prefixCls}-inner-content`,
    onClick: onPopupClick
  }, React487.createElement("div", {
    className: `${prefixCls}-message`
  }, icon && React487.createElement("span", {
    className: `${prefixCls}-message-icon`
  }, icon), React487.createElement("div", {
    className: `${prefixCls}-message-text`
  }, titleNode && React487.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames == null ? void 0 : classNames.title),
    style: styles == null ? void 0 : styles.title
  }, titleNode), descriptionNode && React487.createElement("div", {
    className: clsx(`${prefixCls}-description`, classNames == null ? void 0 : classNames.content),
    style: styles == null ? void 0 : styles.content
  }, descriptionNode))), React487.createElement("div", {
    className: `${prefixCls}-buttons`
  }, showCancel && React487.createElement(Button_default, {
    onClick: onCancel,
    size: "small",
    ...cancelButtonProps
  }, cancelText || (contextLocale == null ? void 0 : contextLocale.cancelText)), React487.createElement(ActionButton_default, {
    buttonProps: {
      size: "small",
      ...convertLegacyProps(okType),
      ...okButtonProps
    },
    actionFn: onConfirm,
    close,
    prefixCls: getPrefixCls("btn"),
    quitOnNullishReturnValue: true,
    emitEvent: true
  }, okText || (contextLocale == null ? void 0 : contextLocale.okText))));
};
var PurePanel15 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    placement,
    className,
    style: style2,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React487.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  style_default49(prefixCls);
  return React487.createElement(PurePanel_default5, {
    placement,
    className: clsx(prefixCls, className),
    style: style2,
    content: React487.createElement(Overlay3, {
      prefixCls,
      ...restProps
    })
  });
};
var PurePanel_default8 = PurePanel15;

// node_modules/antd/es/popconfirm/index.js
var InternalPopconfirm = React488.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    placement = "top",
    trigger,
    okType = "primary",
    icon = React488.createElement(ExclamationCircleFilled_default, null),
    children,
    overlayClassName,
    onOpenChange,
    overlayStyle,
    styles,
    arrow: popconfirmArrow,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    arrow: contextArrow,
    trigger: contextTrigger
  } = useComponentConfig("popconfirm");
  const [open3, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
  const mergedArrow = useMergedArrow_default(popconfirmArrow, contextArrow);
  const mergedTrigger = trigger || contextTrigger || "click";
  const settingOpen = (value, e3) => {
    setOpen(value);
    onOpenChange == null ? void 0 : onOpenChange(value, e3);
  };
  const close = (e3) => {
    settingOpen(false, e3);
  };
  const onConfirm = (e3) => {
    var _a;
    return (_a = props.onConfirm) == null ? void 0 : _a.call(void 0, e3);
  };
  const onCancel = (e3) => {
    var _a;
    settingOpen(false, e3);
    (_a = props.onCancel) == null ? void 0 : _a.call(void 0, e3);
  };
  const onInternalOpenChange = (value, e3) => {
    const {
      disabled = false
    } = props;
    if (disabled) {
      return;
    }
    settingOpen(value, e3);
  };
  const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
  const mergedProps = {
    ...props,
    placement,
    trigger: mergedTrigger,
    okType,
    overlayStyle,
    styles,
    classNames
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rootClassNames = clsx(prefixCls, contextClassName, overlayClassName, mergedClassNames.root);
  style_default49(prefixCls);
  return React488.createElement(popover_default, {
    arrow: mergedArrow,
    ...omit(restProps, ["title"]),
    trigger: mergedTrigger,
    placement,
    onOpenChange: onInternalOpenChange,
    open: open3,
    ref,
    classNames: {
      root: rootClassNames,
      container: mergedClassNames.container,
      arrow: mergedClassNames.arrow
    },
    styles: {
      root: {
        ...contextStyle,
        ...mergedStyles.root,
        ...overlayStyle
      },
      container: mergedStyles.container,
      arrow: mergedStyles.arrow
    },
    content: React488.createElement(Overlay3, {
      okType,
      icon,
      ...props,
      prefixCls,
      close,
      onConfirm,
      onCancel,
      classNames: mergedClassNames,
      styles: mergedStyles
    }),
    "data-popover-inject": true
  }, children);
});
var Popconfirm = InternalPopconfirm;
Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default8;
if (true) {
  Popconfirm.displayName = "Popconfirm";
}
var popconfirm_default = Popconfirm;

// node_modules/antd/es/progress/progress.js
var React497 = __toESM(require_react());

// node_modules/antd/es/progress/Circle.js
var React494 = __toESM(require_react());

// node_modules/@rc-component/progress/es/Line.js
var React490 = __toESM(require_react());

// node_modules/@rc-component/progress/es/common.js
var import_react192 = __toESM(require_react());
var defaultProps2 = {
  percent: 0,
  prefixCls: "rc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  railColor: "#D9D9D9",
  railWidth: 1,
  gapPosition: "bottom",
  loading: false
};
var useTransitionDuration = () => {
  const pathsRef = (0, import_react192.useRef)([]);
  const prevTimeStamp = (0, import_react192.useRef)(null);
  (0, import_react192.useEffect)(() => {
    const now2 = Date.now();
    let updated = false;
    pathsRef.current.forEach((path2) => {
      if (!path2) {
        return;
      }
      updated = true;
      const pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated) {
      prevTimeStamp.current = Date.now();
    }
  });
  return pathsRef.current;
};

// node_modules/@rc-component/progress/es/utils/getIndeterminateLine.js
var import_react193 = __toESM(require_react());
var getIndeterminateLine_default = (options) => {
  const {
    id,
    percent,
    strokeLinecap,
    strokeWidth,
    loading
  } = options;
  if (!loading) {
    return {
      indeterminateStyleProps: {},
      indeterminateStyleAnimation: null
    };
  }
  const animationName = `${id}-indeterminate-animate`;
  const strokeDashOffset = 100 - (percent + (strokeLinecap === "round" ? strokeWidth : 0));
  return {
    indeterminateStyleProps: {
      strokeDasharray: `${percent} 100`,
      animation: `${animationName} .6s linear alternate infinite`,
      strokeDashoffset: 0
    },
    indeterminateStyleAnimation: import_react193.default.createElement("style", null, `@keyframes ${animationName} {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -${strokeDashOffset};
          }`)
  };
};

// node_modules/@rc-component/progress/es/Line.js
function _extends73() {
  _extends73 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends73.apply(this, arguments);
}
var Line = (props) => {
  const {
    id,
    className,
    percent,
    prefixCls,
    strokeColor,
    strokeLinecap,
    strokeWidth,
    style: style2,
    railColor,
    railWidth,
    transition,
    loading,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  const mergedId = useId_default(id);
  delete restProps.gapPosition;
  const percentList = Array.isArray(percent) ? percent : [percent];
  const strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
  const paths = useTransitionDuration();
  const center = strokeWidth / 2;
  const right = 100 - strokeWidth / 2;
  const pathString = `M ${strokeLinecap === "round" ? center : 0},${center}
         L ${strokeLinecap === "round" ? right : 100},${center}`;
  const viewBoxString = `0 0 100 ${strokeWidth}`;
  let stackPtg = 0;
  const {
    indeterminateStyleProps,
    indeterminateStyleAnimation
  } = getIndeterminateLine_default({
    id: mergedId,
    loading,
    percent: percentList[0],
    strokeLinecap,
    strokeWidth
  });
  return React490.createElement("svg", _extends73({
    className: clsx(`${prefixCls}-line`, className),
    viewBox: viewBoxString,
    preserveAspectRatio: "none",
    style: style2
  }, restProps), React490.createElement("path", {
    className: `${prefixCls}-line-rail`,
    d: pathString,
    strokeLinecap,
    stroke: railColor,
    strokeWidth: railWidth || strokeWidth,
    fillOpacity: "0"
  }), percentList.map((ptg, index2) => {
    let dashPercent = 1;
    switch (strokeLinecap) {
      case "round":
        dashPercent = 1 - strokeWidth / 100;
        break;
      case "square":
        dashPercent = 1 - strokeWidth / 2 / 100;
        break;
      default:
        dashPercent = 1;
        break;
    }
    const pathStyle = {
      strokeDasharray: `${ptg * dashPercent}px, 100px`,
      strokeDashoffset: `-${stackPtg}px`,
      transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear",
      ...indeterminateStyleProps
    };
    const color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
    stackPtg += ptg;
    return React490.createElement("path", {
      key: index2,
      className: `${prefixCls}-line-path`,
      d: pathString,
      strokeLinecap,
      stroke: color,
      strokeWidth,
      fillOpacity: "0",
      ref: (elem) => {
        paths[index2] = elem;
      },
      style: pathStyle
    });
  }), indeterminateStyleAnimation);
};
if (true) {
  Line.displayName = "Line";
}

// node_modules/@rc-component/progress/es/Circle/index.js
var React493 = __toESM(require_react());

// node_modules/@rc-component/progress/es/Circle/PtgCircle.js
var React491 = __toESM(require_react());
var Block = ({
  bg,
  children
}) => React491.createElement("div", {
  style: {
    width: "100%",
    height: "100%",
    background: bg
  }
}, children);
function getPtgColors(color, scale) {
  return Object.keys(color).map((key) => {
    const parsedKey = parseFloat(key);
    const ptgKey = `${Math.floor(parsedKey * scale)}%`;
    return `${color[key]} ${ptgKey}`;
  });
}
var PtgCircle = React491.forwardRef((props, ref) => {
  const {
    prefixCls,
    color,
    gradientId,
    radius: radius2,
    className,
    style: circleStyleForStack,
    ptg,
    strokeLinecap,
    strokeWidth,
    size,
    gapDegree
  } = props;
  const isGradient = color && typeof color === "object";
  const stroke = isGradient ? `#FFF` : void 0;
  const halfSize = size / 2;
  const circleNode = React491.createElement("circle", {
    className: clsx(`${prefixCls}-circle-path`, className),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke,
    strokeLinecap,
    strokeWidth,
    opacity: ptg === 0 ? 0 : 1,
    style: circleStyleForStack,
    ref
  });
  if (!isGradient) {
    return circleNode;
  }
  const maskId = `${gradientId}-conic`;
  const fromDeg = gapDegree ? `${180 + gapDegree / 2}deg` : "0deg";
  const conicColors = getPtgColors(color, (360 - gapDegree) / 360);
  const linearColors = getPtgColors(color, 1);
  const conicColorBg = `conic-gradient(from ${fromDeg}, ${conicColors.join(", ")})`;
  const linearColorBg = `linear-gradient(to ${gapDegree ? "bottom" : "top"}, ${linearColors.join(", ")})`;
  return React491.createElement(React491.Fragment, null, React491.createElement("mask", {
    id: maskId
  }, circleNode), React491.createElement("foreignObject", {
    x: 0,
    y: 0,
    width: size,
    height: size,
    mask: `url(#${maskId})`
  }, React491.createElement(Block, {
    bg: linearColorBg
  }, React491.createElement(Block, {
    bg: conicColorBg
  }))));
});
if (true) {
  PtgCircle.displayName = "PtgCircle";
}
var PtgCircle_default = PtgCircle;

// node_modules/@rc-component/progress/es/Circle/util.js
var VIEW_BOX_SIZE = 100;
var getCircleStyle = (perimeter, perimeterWithoutGap, offset3, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth, stepSpace = 0) => {
  const offsetDeg = offset3 / 100 * 360 * ((360 - gapDegree) / 360);
  const positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition];
  let strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  if (strokeLinecap === "round" && percent !== 100) {
    strokeDashoffset += strokeWidth / 2;
    if (strokeDashoffset >= perimeterWithoutGap) {
      strokeDashoffset = perimeterWithoutGap - 0.01;
    }
  }
  const halfSize = VIEW_BOX_SIZE / 2;
  return {
    stroke: typeof strokeColor === "string" ? strokeColor : void 0,
    strokeDasharray: `${perimeterWithoutGap}px ${perimeter}`,
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: `rotate(${rotateDeg + offsetDeg + positionDeg}deg)`,
    transformOrigin: `${halfSize}px ${halfSize}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
    fillOpacity: 0
  };
};

// node_modules/@rc-component/progress/es/utils/getIndeterminateCircle.js
var import_react194 = __toESM(require_react());
var getIndeterminateCircle_default = ({
  id,
  loading
}) => {
  if (!loading) {
    return {
      indeterminateStyleProps: {},
      indeterminateStyleAnimation: null
    };
  }
  const animationName = `${id}-indeterminate-animate`;
  return {
    indeterminateStyleProps: {
      transform: "rotate(0deg)",
      animation: `${animationName} 1s linear infinite`
    },
    indeterminateStyleAnimation: import_react194.default.createElement("style", null, `@keyframes ${animationName} {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }`)
  };
};

// node_modules/@rc-component/progress/es/Circle/index.js
function _extends74() {
  _extends74 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends74.apply(this, arguments);
}
function toArray7(value) {
  const mergedValue = value ?? [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var Circle = (props) => {
  const {
    id,
    prefixCls,
    classNames = {},
    styles = {},
    steps,
    strokeWidth,
    railWidth,
    gapDegree = 0,
    gapPosition,
    railColor,
    strokeLinecap,
    style: style2,
    className,
    strokeColor,
    percent,
    loading,
    ...restProps
  } = {
    ...defaultProps2,
    ...props
  };
  const halfSize = VIEW_BOX_SIZE / 2;
  const mergedId = useId_default(id);
  const gradientId = `${mergedId}-gradient`;
  const radius2 = halfSize - strokeWidth / 2;
  const perimeter = Math.PI * 2 * radius2;
  const rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
  const perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
  const {
    count: stepCount,
    gap: stepGap
  } = typeof steps === "object" ? steps : {
    count: steps,
    gap: 2
  };
  const percentList = toArray7(percent);
  const strokeColorList = toArray7(strokeColor);
  const gradient = strokeColorList.find((color) => color && typeof color === "object");
  const isConicGradient = gradient && typeof gradient === "object";
  const mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap;
  const {
    indeterminateStyleProps,
    indeterminateStyleAnimation
  } = getIndeterminateCircle_default({
    id: mergedId,
    loading
  });
  const circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, railColor, mergedStrokeLinecap, strokeWidth);
  const paths = useTransitionDuration();
  const getStokeList = () => {
    let stackPtg = 0;
    return percentList.map((ptg, index2) => {
      const color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
      const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
      stackPtg += ptg;
      return React493.createElement(PtgCircle_default, {
        key: index2,
        color,
        ptg,
        radius: radius2,
        prefixCls,
        gradientId,
        className: classNames.track,
        style: {
          ...circleStyleForStack,
          ...indeterminateStyleProps,
          ...styles.track
        },
        strokeLinecap: mergedStrokeLinecap,
        strokeWidth,
        gapDegree,
        ref: (elem) => {
          paths[index2] = elem;
        },
        size: VIEW_BOX_SIZE
      });
    }).reverse();
  };
  const getStepStokeList = () => {
    const current = Math.round(stepCount * (percentList[0] / 100));
    const stepPtg = 100 / stepCount;
    let stackPtg = 0;
    return new Array(stepCount).fill(null).map((_, index2) => {
      const color = index2 <= current - 1 ? strokeColorList[0] : railColor;
      const stroke = color && typeof color === "object" ? `url(#${gradientId})` : void 0;
      const circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepGap);
      stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepGap) * 100 / perimeterWithoutGap;
      return React493.createElement("circle", {
        key: index2,
        className: clsx(`${prefixCls}-circle-path`, classNames.track),
        r: radius2,
        cx: halfSize,
        cy: halfSize,
        stroke,
        strokeWidth,
        opacity: 1,
        style: {
          ...circleStyleForStack,
          ...styles.track
        },
        ref: (elem) => {
          paths[index2] = elem;
        }
      });
    });
  };
  return React493.createElement("svg", _extends74({
    className: clsx(`${prefixCls}-circle`, classNames.root, className),
    viewBox: `0 0 ${VIEW_BOX_SIZE} ${VIEW_BOX_SIZE}`,
    style: {
      ...styles.root,
      ...style2
    },
    id,
    role: "presentation"
  }, restProps), !stepCount && React493.createElement("circle", {
    className: clsx(`${prefixCls}-circle-rail`, classNames.rail),
    r: radius2,
    cx: halfSize,
    cy: halfSize,
    stroke: railColor,
    strokeLinecap: mergedStrokeLinecap,
    strokeWidth: railWidth || strokeWidth,
    style: {
      ...circleStyle,
      ...styles.rail
    }
  }), stepCount ? getStepStokeList() : getStokeList(), indeterminateStyleAnimation);
};
if (true) {
  Circle.displayName = "Circle";
}
var Circle_default = Circle;

// node_modules/antd/es/progress/utils.js
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent({
  success
}) {
  let percent;
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
var getPercentage = ({
  percent,
  success
}) => {
  const realSuccessPercent = validProgress(getSuccessPercent({
    success
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
};
var getStrokeColor = ({
  success = {},
  strokeColor
}) => {
  const {
    strokeColor: successColor
  } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
};
var getSize2 = (size, type5, extra) => {
  let width = -1;
  let height = -1;
  if (type5 === "step") {
    const steps = extra.steps;
    const strokeWidth = extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      width = size === "small" ? 2 : 14;
      height = strokeWidth ?? 8;
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = 14, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
    }
    width *= steps;
  } else if (type5 === "line") {
    const strokeWidth = extra == null ? void 0 : extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      height = strokeWidth || (size === "small" ? 6 : 8);
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = -1, height = 8] = Array.isArray(size) ? size : [size.width, size.height];
    }
  } else if (type5 === "circle" || type5 === "dashboard") {
    if (typeof size === "string" || typeof size === "undefined") {
      [width, height] = size === "small" ? [60, 60] : [120, 120];
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else if (Array.isArray(size)) {
      width = size[0] ?? size[1] ?? 120;
      height = size[0] ?? size[1] ?? 120;
    }
  }
  return [width, height];
};

// node_modules/antd/es/progress/Circle.js
var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
var OMIT_SEMANTIC_NAMES = ["root", "body", "indicator"];
var Circle2 = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    railColor,
    trailColor,
    strokeLinecap = "round",
    gapPosition,
    gapPlacement,
    gapDegree,
    width: originWidth = 120,
    type: type5,
    children,
    success,
    size = originWidth,
    steps
  } = props;
  const {
    direction
  } = useComponentConfig("progress");
  const mergedRailColor = railColor ?? trailColor;
  const [width, height] = getSize2(size, "circle");
  let {
    strokeWidth
  } = props;
  if (strokeWidth === void 0) {
    strokeWidth = Math.max(getMinPercent(width), 6);
  }
  const circleStyle = {
    width,
    height,
    fontSize: width * 0.15 + 6
  };
  const realGapDegree = React494.useMemo(() => {
    if (gapDegree || gapDegree === 0) {
      return gapDegree;
    }
    if (type5 === "dashboard") {
      return 75;
    }
    return void 0;
  }, [gapDegree, type5]);
  const percentArray = getPercentage(props);
  const gapPos = React494.useMemo(() => {
    const mergedPlacement = (gapPlacement ?? gapPosition) || type5 === "dashboard" && "bottom" || void 0;
    const isRTL = direction === "rtl";
    switch (mergedPlacement) {
      case "start":
        return isRTL ? "right" : "left";
      case "end":
        return isRTL ? "left" : "right";
      default:
        return mergedPlacement;
    }
  }, [direction, gapPlacement, gapPosition, type5]);
  const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
  const strokeColor = getStrokeColor({
    success,
    strokeColor: props.strokeColor
  });
  const wrapperClassName = clsx(`${prefixCls}-body`, {
    [`${prefixCls}-circle-gradient`]: isGradient
  }, classNames.body);
  const circleContent = React494.createElement(Circle_default, {
    steps,
    percent: steps ? percentArray[1] : percentArray,
    strokeWidth,
    railWidth: strokeWidth,
    strokeColor: steps ? strokeColor[1] : strokeColor,
    strokeLinecap,
    railColor: mergedRailColor,
    prefixCls,
    gapDegree: realGapDegree,
    gapPosition: gapPos,
    classNames: omit(classNames, OMIT_SEMANTIC_NAMES),
    styles: omit(styles, OMIT_SEMANTIC_NAMES)
  });
  const smallCircle = width <= 20;
  const node2 = React494.createElement("div", {
    className: wrapperClassName,
    style: {
      ...circleStyle,
      ...styles.body
    }
  }, circleContent, !smallCircle && children);
  if (smallCircle) {
    return React494.createElement(tooltip_default, {
      title: children
    }, node2);
  }
  return node2;
};
var Circle_default2 = Circle2;

// node_modules/antd/es/progress/Line.js
var React495 = __toESM(require_react());

// node_modules/antd/es/progress/style/index.js
var LineStrokeColorVar = "--progress-line-stroke-color";
var genAntProgressActive = (isRtl) => {
  const direction = isRtl ? "100%" : "-100%";
  return new Keyframes_default(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
    "0%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.1
    },
    "20%": {
      transform: `translateX(${direction}) scaleX(0)`,
      opacity: 0.5
    },
    to: {
      transform: "translateX(0) scaleX(1)",
      opacity: 0
    }
  });
};
var genBaseStyle13 = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      ...resetComponent(token2),
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      [`${progressCls}-indicator`]: {
        color: token2.colorText,
        lineHeight: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token2.fontSize
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-indicator`]: {
          color: token2.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-indicator`]: {
          color: token2.colorSuccess
        }
      }
    }
  };
};
var genLineStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-line`]: {
      position: "relative",
      width: "100%",
      fontSize: token2.fontSize,
      [`${componentCls}-body`]: {
        display: "inline-flex",
        alignItems: "center",
        width: "100%",
        gap: token2.marginXS
      },
      [`${componentCls}-rail`]: {
        flex: "auto",
        background: token2.remainingColor,
        borderRadius: token2.lineBorderRadius,
        position: "relative",
        width: "100%"
      },
      [`&${componentCls}-status-active`]: {
        [`${componentCls}-track:after`]: {
          content: '""',
          position: "absolute",
          inset: 0,
          backgroundColor: token2.colorBgContainer,
          borderRadius: "inherit",
          opacity: 0,
          animationName: genAntProgressActive(),
          animationDuration: token2.progressActiveMotionDuration,
          animationTimingFunction: token2.motionEaseOutQuint,
          animationIterationCount: "infinite"
        }
      },
      [`${componentCls}-track`]: {
        position: "absolute",
        insetInlineStart: 0,
        insetBlock: 0,
        borderRadius: "inherit",
        background: token2.defaultColor,
        transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
        minWidth: "max-content",
        display: "flex",
        alignItems: "center",
        "&-success": {
          background: token2.colorSuccess
        }
      },
      [`&${componentCls}-status-exception`]: {
        [`${componentCls}-track`]: {
          background: token2.colorError
        }
      },
      [`&${componentCls}-status-success`]: {
        [`${componentCls}-track`]: {
          background: token2.colorSuccess
        }
      },
      // >>>>> indicator
      // >>> Outer
      [`${componentCls}-indicator-outer`]: {
        [`&${componentCls}-indicator-start`]: {
          order: -1
        }
      },
      [`${componentCls}-body-layout-bottom`]: {
        flexDirection: "column",
        alignItems: "center",
        gap: token2.marginXXS
      },
      // >>> Inner
      [`${componentCls}-indicator${componentCls}-indicator-inner`]: {
        color: token2.colorWhite,
        paddingInline: token2.paddingXXS,
        width: "100%",
        display: "flex",
        justifyContent: "center",
        [`&${componentCls}-indicator-end`]: {
          justifyContent: "end"
        },
        [`&${componentCls}-indicator-start`]: {
          justifyContent: "start"
        },
        [`&${componentCls}-indicator-bright`]: {
          color: "rgba(0, 0, 0, 0.45)"
        }
      }
    }
  };
};
var genCircleStyle = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [`${progressCls}-circle`]: {
      [`${progressCls}-circle-rail`]: {
        stroke: token2.remainingColor
      },
      [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.defaultColor
        }
      },
      [`${progressCls}-body`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`${progressCls}-indicator`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token2.circleTextColor,
        fontSize: token2.circleTextFontSize,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: token2.circleIconFontSize
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token2.colorError
          }
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-body:not(${progressCls}-circle-gradient)`]: {
          [`${progressCls}-circle-path`]: {
            stroke: token2.colorSuccess
          }
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
};
var genStepStyle = (token2) => {
  const {
    componentCls: progressCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-body": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          gap: token2.progressStepMarginInlineEnd,
          [`${progressCls}-indicator`]: {
            marginInlineStart: token2.marginXS
          }
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token2.progressStepMinWidth,
          backgroundColor: token2.remainingColor,
          transition: `all ${token2.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token2.defaultColor
          }
        }
      }
    }
  };
};
var genSmallLine = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-indicator ${iconPrefixCls}`]: {
        fontSize: token2.fontSizeSM
      }
    }
  };
};
var prepareComponentToken43 = (token2) => ({
  circleTextColor: token2.colorText,
  defaultColor: token2.colorInfo,
  remainingColor: token2.colorFillSecondary,
  lineBorderRadius: 100,
  // magic for capsule shape, should be a very large number
  circleTextFontSize: "1em",
  circleIconFontSize: `${token2.fontSize / token2.fontSizeSM}em`
});
var style_default50 = genStyleHooks("Progress", (token2) => {
  const progressStepMarginInlineEnd = token2.calc(token2.marginXXS).div(2).equal();
  const progressToken = merge2(token2, {
    progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: "2.4s"
  });
  return [genBaseStyle13(progressToken), genLineStyle(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
}, prepareComponentToken43);

// node_modules/antd/es/progress/Line.js
var sortGradient = (gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const formattedKey = Number.parseFloat(key.replace(/%/g, ""));
    if (!Number.isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort((a, b) => a.key - b.key);
  return tempArr.map(({
    key,
    value
  }) => `${value} ${key}%`).join(", ");
};
var handleGradient = (strokeColor, directionConfig) => {
  const {
    from: from2 = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right",
    ...rest
  } = strokeColor;
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest);
    const background2 = `linear-gradient(${direction}, ${sortedGradients})`;
    return {
      background: background2,
      [LineStrokeColorVar]: background2
    };
  }
  const background = `linear-gradient(${direction}, ${from2}, ${to})`;
  return {
    background,
    [LineStrokeColorVar]: background
  };
};
var Line2 = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    direction: directionConfig,
    percent,
    size,
    strokeWidth,
    strokeColor,
    strokeLinecap = "round",
    children,
    railColor,
    trailColor,
    percentPosition,
    success
  } = props;
  const {
    align: infoAlign,
    type: infoPosition
  } = percentPosition;
  const mergedRailColor = railColor ?? trailColor;
  const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
  if (true) {
    const warning5 = devUseWarning("Progress");
    warning5.deprecated(!("strokeWidth" in props), "strokeWidth", "size");
  }
  const mergedSize = size ?? [-1, strokeWidth || (size === "small" ? 6 : 8)];
  const [width, height] = getSize2(mergedSize, "line", {
    strokeWidth
  });
  const railStyle = {
    backgroundColor: mergedRailColor || void 0,
    borderRadius,
    height
  };
  const trackCls = `${prefixCls}-track`;
  const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
    [LineStrokeColorVar]: strokeColor,
    background: strokeColor
  };
  const percentTrackStyle = {
    width: `${validProgress(percent)}%`,
    height,
    borderRadius,
    ...backgroundProps
  };
  const successPercent = getSuccessPercent(props);
  const successTrackStyle = {
    width: `${validProgress(successPercent)}%`,
    height,
    borderRadius,
    backgroundColor: success == null ? void 0 : success.strokeColor
  };
  return React495.createElement("div", {
    className: clsx(`${prefixCls}-body`, classNames.body, {
      [`${prefixCls}-body-layout-bottom`]: infoAlign === "center" && infoPosition === "outer"
    }),
    style: {
      width: width > 0 ? width : "100%",
      ...styles.body
    }
  }, React495.createElement("div", {
    className: clsx(`${prefixCls}-rail`, classNames.rail),
    style: {
      ...railStyle,
      ...styles.rail
    }
  }, React495.createElement("div", {
    className: clsx(trackCls, classNames.track),
    style: {
      ...percentTrackStyle,
      ...styles.track
    }
  }, infoPosition === "inner" && children), successPercent !== void 0 && React495.createElement("div", {
    className: clsx(trackCls, `${trackCls}-success`, classNames.track),
    style: {
      ...successTrackStyle,
      ...styles.track
    }
  })), infoPosition === "outer" && children);
};
var Line_default2 = Line2;

// node_modules/antd/es/progress/Steps.js
var React496 = __toESM(require_react());
var Steps2 = (props) => {
  const {
    classNames,
    styles,
    size,
    steps,
    rounding: customRounding = Math.round,
    percent = 0,
    strokeWidth = 8,
    strokeColor,
    railColor,
    trailColor,
    prefixCls,
    children
  } = props;
  const current = customRounding(steps * (percent / 100));
  const stepWidth = size === "small" ? 2 : 14;
  const mergedSize = size ?? [stepWidth, strokeWidth];
  const [width, height] = getSize2(mergedSize, "step", {
    steps,
    strokeWidth
  });
  const unitWidth = width / steps;
  const styledSteps = Array.from({
    length: steps
  });
  const mergedRailColor = railColor ?? trailColor;
  for (let i = 0; i < steps; i++) {
    const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] = React496.createElement("div", {
      key: i,
      className: clsx(`${prefixCls}-steps-item`, {
        [`${prefixCls}-steps-item-active`]: i <= current - 1
      }, classNames.track),
      style: {
        backgroundColor: i <= current - 1 ? color : mergedRailColor,
        width: unitWidth,
        height,
        ...styles.track
      }
    });
  }
  return React496.createElement("div", {
    className: clsx(`${prefixCls}-steps-body`, classNames.body),
    style: styles.body
  }, styledSteps, children);
};
var Steps_default2 = Steps2;

// node_modules/antd/es/progress/progress.js
var ProgressStatuses = ["normal", "exception", "active", "success"];
var Progress2 = React497.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    styles,
    steps,
    strokeColor,
    percent = 0,
    size = "default",
    showInfo = true,
    type: type5 = "line",
    status,
    format: format3,
    style: style2,
    percentPosition = {},
    ...restProps
  } = props;
  const {
    align: infoAlign = "end",
    type: infoPosition = "outer"
  } = percentPosition;
  const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
  const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
  const strokeColorIsBright = React497.useMemo(() => {
    if (strokeColorNotArray) {
      const color = typeof strokeColorNotArray === "string" ? strokeColorNotArray : Object.values(strokeColorNotArray)[0];
      return new FastColor(color).isLight();
    }
    return false;
  }, [strokeColor]);
  const percentNumber = React497.useMemo(() => {
    var _a, _b;
    const successPercent = getSuccessPercent(props);
    return Number.parseInt(successPercent !== void 0 ? (_a = successPercent ?? 0) == null ? void 0 : _a.toString() : (_b = percent ?? 0) == null ? void 0 : _b.toString(), 10);
  }, [percent, props.success]);
  const progressStatus = React497.useMemo(() => {
    if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
      return "success";
    }
    return status || "normal";
  }, [status, percentNumber]);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("progress");
  const prefixCls = getPrefixCls("progress", customizePrefixCls);
  const [hashId, cssVarCls] = style_default50(prefixCls);
  const mergedProps = {
    ...props,
    percent,
    type: type5,
    size,
    showInfo,
    percentPosition
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const isLineType = type5 === "line";
  const isPureLineType = isLineType && !steps;
  const progressInfo = React497.useMemo(() => {
    if (!showInfo) {
      return null;
    }
    const successPercent = getSuccessPercent(props);
    let text;
    const textFormatter = format3 || ((number4) => `${number4}%`);
    const isBrightInnerColor = isLineType && strokeColorIsBright && infoPosition === "inner";
    if (infoPosition === "inner" || format3 || progressStatus !== "exception" && progressStatus !== "success") {
      text = textFormatter(validProgress(percent), validProgress(successPercent));
    } else if (progressStatus === "exception") {
      text = isLineType ? React497.createElement(CloseCircleFilled_default, null) : React497.createElement(CloseOutlined_default, null);
    } else if (progressStatus === "success") {
      text = isLineType ? React497.createElement(CheckCircleFilled_default, null) : React497.createElement(CheckOutlined_default, null);
    }
    return React497.createElement("span", {
      className: clsx(`${prefixCls}-indicator`, {
        [`${prefixCls}-indicator-bright`]: isBrightInnerColor,
        [`${prefixCls}-indicator-${infoAlign}`]: isPureLineType,
        [`${prefixCls}-indicator-${infoPosition}`]: isPureLineType
      }, mergedClassNames.indicator),
      style: mergedStyles.indicator,
      title: typeof text === "string" ? text : void 0
    }, text);
  }, [showInfo, percent, percentNumber, progressStatus, type5, prefixCls, format3, isLineType, strokeColorIsBright, infoPosition, infoAlign, isPureLineType, mergedClassNames.indicator, mergedStyles.indicator]);
  if (true) {
    const warning5 = devUseWarning("Progress");
    [["width", "size"], ["trailColor", "railColor"], ["gapPosition", "gapPlacement"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
    if (type5 === "circle" || type5 === "dashboard") {
      if (Array.isArray(size)) {
        true ? warning5(false, "usage", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.') : void 0;
      } else if (typeof size === "object") {
        true ? warning5(false, "usage", 'Type "circle" and "dashboard" do not accept object as `size`, please use number or preset size instead.') : void 0;
      }
    }
  }
  const sharedProps = {
    ...props,
    classNames: mergedClassNames,
    styles: mergedStyles
  };
  let progress;
  if (type5 === "line") {
    progress = steps ? React497.createElement(Steps_default2, {
      ...sharedProps,
      strokeColor: strokeColorNotGradient,
      prefixCls,
      steps: typeof steps === "object" ? steps.count : steps
    }, progressInfo) : React497.createElement(Line_default2, {
      ...sharedProps,
      strokeColor: strokeColorNotArray,
      prefixCls,
      direction,
      percentPosition: {
        align: infoAlign,
        type: infoPosition
      }
    }, progressInfo);
  } else if (type5 === "circle" || type5 === "dashboard") {
    progress = React497.createElement(Circle_default2, {
      ...sharedProps,
      strokeColor: strokeColorNotArray,
      prefixCls,
      progressStatus
    }, progressInfo);
  }
  const classString = clsx(prefixCls, `${prefixCls}-status-${progressStatus}`, {
    [`${prefixCls}-${type5 === "dashboard" && "circle" || type5}`]: type5 !== "line",
    [`${prefixCls}-inline-circle`]: type5 === "circle" && getSize2(size, "circle")[0] <= 20,
    [`${prefixCls}-line`]: isPureLineType,
    [`${prefixCls}-line-align-${infoAlign}`]: isPureLineType,
    [`${prefixCls}-line-position-${infoPosition}`]: isPureLineType,
    [`${prefixCls}-steps`]: steps,
    [`${prefixCls}-show-info`]: showInfo,
    [`${prefixCls}-${size}`]: typeof size === "string",
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  return React497.createElement("div", {
    ref,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style2
    },
    className: classString,
    role: "progressbar",
    "aria-valuenow": percentNumber,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    ...omit(restProps, ["railColor", "trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "gapPlacement", "strokeLinecap", "success"])
  }, progress);
});
if (true) {
  Progress2.displayName = "Progress";
}
var progress_default = Progress2;

// node_modules/antd/es/progress/index.js
var progress_default2 = progress_default;

// node_modules/antd/es/qr-code/index.js
var import_react199 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(r2, e3) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e3 && r2 && "number" == typeof r2.length) {
      t2 && (r2 = t2);
      var _n = 0, F = function F2() {
      };
      return {
        s: F,
        n: function n2() {
          return _n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[_n++]
          };
        },
        e: function e4(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o3, a = true, u = false;
  return {
    s: function s() {
      t2 = t2.call(r2);
    },
    n: function n2() {
      var r3 = t2.next();
      return a = r3.done, r3;
    },
    e: function e4(r3) {
      u = true, o3 = r3;
    },
    f: function f() {
      try {
        a || null == t2["return"] || t2["return"]();
      } finally {
        if (u)
          throw o3;
      }
    }
  };
}

// node_modules/@rc-component/qrcode/es/libs/qrcodegen.js
var _class;
var _class2;
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len != 0) {
    throw new RangeError("Value out of range");
  }
  for (var i = len - 1; i >= 0; i--) {
    bb.push(val >>> i & 1);
  }
}
function getBit(x, i) {
  return (x >>> i & 1) != 0;
}
function assert(cond) {
  if (!cond) {
    throw new Error("Assertion error");
  }
}
var Mode = function() {
  function Mode2(modeBits, numBitsCharCount) {
    _classCallCheck(this, Mode2);
    _defineProperty(this, "modeBits", void 0);
    _defineProperty(this, "numBitsCharCount", void 0);
    this.modeBits = modeBits;
    this.numBitsCharCount = numBitsCharCount;
  }
  _createClass(Mode2, [{
    key: "numCharCountBits",
    value: function numCharCountBits(ver) {
      return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
    }
  }]);
  return Mode2;
}();
_class = Mode;
_defineProperty(Mode, "NUMERIC", new _class(1, [10, 12, 14]));
_defineProperty(Mode, "ALPHANUMERIC", new _class(2, [9, 11, 13]));
_defineProperty(Mode, "BYTE", new _class(4, [8, 16, 16]));
_defineProperty(Mode, "KANJI", new _class(8, [8, 10, 12]));
_defineProperty(Mode, "ECI", new _class(7, [0, 0, 0]));
var Ecc = _createClass(function Ecc2(ordinal, formatBits) {
  _classCallCheck(this, Ecc2);
  _defineProperty(this, "ordinal", void 0);
  _defineProperty(this, "formatBits", void 0);
  this.ordinal = ordinal;
  this.formatBits = formatBits;
});
_class2 = Ecc;
_defineProperty(Ecc, "LOW", new _class2(0, 1));
_defineProperty(Ecc, "MEDIUM", new _class2(1, 0));
_defineProperty(Ecc, "QUARTILE", new _class2(2, 3));
_defineProperty(Ecc, "HIGH", new _class2(3, 2));
var QrSegment = function() {
  function QrSegment2(mode, numChars, bitData) {
    _classCallCheck(this, QrSegment2);
    _defineProperty(this, "mode", void 0);
    _defineProperty(this, "numChars", void 0);
    _defineProperty(this, "bitData", void 0);
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0) {
      throw new RangeError("Invalid argument");
    }
    this.bitData = bitData.slice();
  }
  _createClass(QrSegment2, [{
    key: "getData",
    value: function getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
  }], [{
    key: "makeBytes",
    value: (
      /*-- Static factory functions (mid level) --*/
      // Returns a segment representing the given binary data encoded in
      // byte mode. All input byte arrays are acceptable. Any text string
      // can be converted to UTF-8 bytes and encoded as a byte mode segment.
      function makeBytes(data) {
        var bb = [];
        var _iterator = _createForOfIteratorHelper(data), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var b = _step.value;
            appendBits(b, 8, bb);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return new QrSegment2(Mode.BYTE, data.length, bb);
      }
    )
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
  }, {
    key: "makeNumeric",
    value: function makeNumeric(digits) {
      if (!QrSegment2.isNumeric(digits)) {
        throw new RangeError("String contains non-numeric characters");
      }
      var bb = [];
      for (var i = 0; i < digits.length; ) {
        var n2 = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substring(i, i + n2), 10), n2 * 3 + 1, bb);
        i += n2;
      }
      return new QrSegment2(Mode.NUMERIC, digits.length, bb);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
  }, {
    key: "makeAlphanumeric",
    value: function makeAlphanumeric(text) {
      if (!QrSegment2.isAlphanumeric(text)) {
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      }
      var bb = [];
      var i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        var temp = QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length) {
        appendBits(QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      }
      return new QrSegment2(Mode.ALPHANUMERIC, text.length, bb);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
  }, {
    key: "makeSegments",
    value: function makeSegments(text) {
      if (text == "") {
        return [];
      } else if (QrSegment2.isNumeric(text)) {
        return [QrSegment2.makeNumeric(text)];
      } else if (QrSegment2.isAlphanumeric(text)) {
        return [QrSegment2.makeAlphanumeric(text)];
      } else {
        return [QrSegment2.makeBytes(QrSegment2.toUtf8ByteArray(text))];
      }
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
  }, {
    key: "makeEci",
    value: function makeEci(assignVal) {
      var bb = [];
      if (assignVal < 0) {
        throw new RangeError("ECI assignment value out of range");
      } else if (assignVal < 1 << 7) {
        appendBits(assignVal, 8, bb);
      } else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else {
        throw new RangeError("ECI assignment value out of range");
      }
      return new QrSegment2(Mode.ECI, 0, bb);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
  }, {
    key: "isNumeric",
    value: function isNumeric2(text) {
      return QrSegment2.NUMERIC_REGEX.test(text);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
  }, {
    key: "isAlphanumeric",
    value: function isAlphanumeric(text) {
      return QrSegment2.ALPHANUMERIC_REGEX.test(text);
    }
  }, {
    key: "getTotalBits",
    value: function getTotalBits(segs, version2) {
      var result = 0;
      var _iterator2 = _createForOfIteratorHelper(segs), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var seg = _step2.value;
          var ccbits = seg.mode.numCharCountBits(version2);
          if (seg.numChars >= 1 << ccbits) {
            return Infinity;
          }
          result += 4 + ccbits + seg.bitData.length;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
  }, {
    key: "toUtf8ByteArray",
    value: function toUtf8ByteArray(input) {
      var str = encodeURI(input);
      var result = [];
      for (var i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%") {
          result.push(str.charCodeAt(i));
        } else {
          result.push(parseInt(str.substring(i + 1, i + 3), 16));
          i += 2;
        }
      }
      return result;
    }
    /*-- Constants --*/
    // Describes precisely all strings that are encodable in numeric mode.
  }]);
  return QrSegment2;
}();
_defineProperty(QrSegment, "NUMERIC_REGEX", /^[0-9]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_REGEX", /^[A-Z0-9 $%*+.\/:-]*$/);
_defineProperty(QrSegment, "ALPHANUMERIC_CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
var QrCode = function() {
  function QrCode2(version2, errorCorrectionLevel, dataCodewords, oriMsk) {
    _classCallCheck(this, QrCode2);
    _defineProperty(this, "size", void 0);
    _defineProperty(this, "mask", void 0);
    _defineProperty(this, "modules", []);
    _defineProperty(this, "isFunction", []);
    _defineProperty(this, "version", void 0);
    _defineProperty(this, "errorCorrectionLevel", void 0);
    var msk = oriMsk;
    this.version = version2;
    this.errorCorrectionLevel = errorCorrectionLevel;
    if (version2 < QrCode2.MIN_VERSION || version2 > QrCode2.MAX_VERSION) {
      throw new RangeError("Version value out of range");
    }
    if (msk < -1 || msk > 7) {
      throw new RangeError("Mask value out of range");
    }
    this.size = version2 * 4 + 17;
    var row = [];
    for (var i = 0; i < this.size; i++) {
      row.push(false);
    }
    for (var _i = 0; _i < this.size; _i++) {
      this.modules.push(row.slice());
      this.isFunction.push(row.slice());
    }
    this.drawFunctionPatterns();
    var allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk == -1) {
      var minPenalty = 1e9;
      for (var _i2 = 0; _i2 < 8; _i2++) {
        this.applyMask(_i2);
        this.drawFormatBits(_i2);
        var penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = _i2;
          minPenalty = penalty;
        }
        this.applyMask(_i2);
      }
    }
    assert(0 <= msk && msk <= 7);
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
    this.isFunction = [];
  }
  _createClass(QrCode2, [{
    key: "getModule",
    value: function getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    // Modified to expose modules for easy access
  }, {
    key: "getModules",
    value: function getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
  }, {
    key: "drawFunctionPatterns",
    value: function drawFunctionPatterns() {
      for (var i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      var alignPatPos = this.getAlignmentPatternPositions();
      var numAlign = alignPatPos.length;
      for (var _i3 = 0; _i3 < numAlign; _i3++) {
        for (var j = 0; j < numAlign; j++) {
          if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) {
            this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);
          }
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
  }, {
    key: "drawFormatBits",
    value: function drawFormatBits(mask) {
      var data = this.errorCorrectionLevel.formatBits << 3 | mask;
      var rem = data;
      for (var i = 0; i < 10; i++) {
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      }
      var bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (var _i4 = 0; _i4 <= 5; _i4++) {
        this.setFunctionModule(8, _i4, getBit(bits, _i4));
      }
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (var _i5 = 9; _i5 < 15; _i5++) {
        this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));
      }
      for (var _i6 = 0; _i6 < 8; _i6++) {
        this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));
      }
      for (var _i7 = 8; _i7 < 15; _i7++) {
        this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));
      }
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
  }, {
    key: "drawVersion",
    value: function drawVersion() {
      if (this.version < 7) {
        return;
      }
      var rem = this.version;
      for (var i = 0; i < 12; i++) {
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      }
      var bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (var _i8 = 0; _i8 < 18; _i8++) {
        var color = getBit(bits, _i8);
        var a = this.size - 11 + _i8 % 3;
        var b = Math.floor(_i8 / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
  }, {
    key: "drawFinderPattern",
    value: function drawFinderPattern(x, y) {
      for (var dy = -4; dy <= 4; dy++) {
        for (var dx = -4; dx <= 4; dx++) {
          var dist = Math.max(Math.abs(dx), Math.abs(dy));
          var xx = x + dx;
          var yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) {
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
          }
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
  }, {
    key: "drawAlignmentPattern",
    value: function drawAlignmentPattern(x, y) {
      for (var dy = -2; dy <= 2; dy++) {
        for (var dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
  }, {
    key: "setFunctionModule",
    value: function setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
  }, {
    key: "addEccAndInterleave",
    value: function addEccAndInterleave(data) {
      var ver = this.version;
      var ecl = this.errorCorrectionLevel;
      if (data.length != QrCode2.getNumDataCodewords(ver, ecl)) {
        throw new RangeError("Invalid argument");
      }
      var numBlocks = QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      var blockEccLen = QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      var rawCodewords = Math.floor(QrCode2.getNumRawDataModules(ver) / 8);
      var numShortBlocks = numBlocks - rawCodewords % numBlocks;
      var shortBlockLen = Math.floor(rawCodewords / numBlocks);
      var blocks = [];
      var rsDiv = QrCode2.reedSolomonComputeDivisor(blockEccLen);
      for (var i = 0, k = 0; i < numBlocks; i++) {
        var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        var ecc = QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks) {
          dat.push(0);
        }
        blocks.push(dat.concat(ecc));
      }
      var result = [];
      var _loop = function _loop2(_i92) {
        blocks.forEach(function(block, j) {
          if (_i92 != shortBlockLen - blockEccLen || j >= numShortBlocks) {
            result.push(block[_i92]);
          }
        });
      };
      for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {
        _loop(_i9);
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
  }, {
    key: "drawCodewords",
    value: function drawCodewords(data) {
      if (data.length != Math.floor(QrCode2.getNumRawDataModules(this.version) / 8)) {
        throw new RangeError("Invalid argument");
      }
      var i = 0;
      for (var right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6) {
          right = 5;
        }
        for (var vert = 0; vert < this.size; vert++) {
          for (var j = 0; j < 2; j++) {
            var x = right - j;
            var upward = (right + 1 & 2) == 0;
            var y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
  }, {
    key: "applyMask",
    value: function applyMask(mask) {
      if (mask < 0 || mask > 7) {
        throw new RangeError("Mask value out of range");
      }
      for (var y = 0; y < this.size; y++) {
        for (var x = 0; x < this.size; x++) {
          var invert = void 0;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert) {
            this.modules[y][x] = !this.modules[y][x];
          }
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  }, {
    key: "getPenaltyScore",
    value: function getPenaltyScore() {
      var result = 0;
      for (var y = 0; y < this.size; y++) {
        var runColor = false;
        var runX = 0;
        var runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (var x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5) {
              result += QrCode2.PENALTY_N1;
            } else if (runX > 5) {
              result++;
            }
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor) {
              result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
            }
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode2.PENALTY_N3;
      }
      for (var _x = 0; _x < this.size; _x++) {
        var _runColor = false;
        var runY = 0;
        var _runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (var _y = 0; _y < this.size; _y++) {
          if (this.modules[_y][_x] == _runColor) {
            runY++;
            if (runY == 5) {
              result += QrCode2.PENALTY_N1;
            } else if (runY > 5) {
              result++;
            }
          } else {
            this.finderPenaltyAddHistory(runY, _runHistory);
            if (!_runColor) {
              result += this.finderPenaltyCountPatterns(_runHistory) * QrCode2.PENALTY_N3;
            }
            _runColor = this.modules[_y][_x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode2.PENALTY_N3;
      }
      for (var _y2 = 0; _y2 < this.size - 1; _y2++) {
        for (var _x2 = 0; _x2 < this.size - 1; _x2++) {
          var color = this.modules[_y2][_x2];
          if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) {
            result += QrCode2.PENALTY_N2;
          }
        }
      }
      var dark = 0;
      var _iterator3 = _createForOfIteratorHelper(this.modules), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var row = _step3.value;
          dark = row.reduce(function(sum, color2) {
            return sum + (color2 ? 1 : 0);
          }, dark);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      var total = this.size * this.size;
      var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * QrCode2.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of numberegers.
  }, {
    key: "getAlignmentPatternPositions",
    value: function getAlignmentPatternPositions() {
      if (this.version == 1) {
        return [];
      } else {
        var numAlign = Math.floor(this.version / 7) + 2;
        var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        var result = [6];
        for (var pos = this.size - 7; result.length < numAlign; pos -= step) {
          result.splice(1, 0, pos);
        }
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
  }, {
    key: "finderPenaltyCountPatterns",
    value: (
      // Can only be called immediately after a light run is added, and
      // returns either 0, 1, or 2. A helper function for getPenaltyScore().
      function finderPenaltyCountPatterns(runHistory) {
        var n2 = runHistory[1];
        assert(n2 <= this.size * 3);
        var core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
        return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
      }
    )
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  }, {
    key: "finderPenaltyTerminateAndCount",
    value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {
      var currentRunLength = oriCurrentRunLength;
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  }, {
    key: "finderPenaltyAddHistory",
    value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {
      var currentRunLength = oriCurrentRunLength;
      if (runHistory[0] == 0) {
        currentRunLength += this.size;
      }
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
    /*-- Constants and tables --*/
    // The minimum version number supported in the QR Code Model 2 standard.
  }], [{
    key: "encodeText",
    value: (
      /*-- Static factory functions (high level) --*/
      // Returns a QR Code representing the given Unicode text string at the given error correction level.
      // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
      // Unicode code ponumbers (not UTF-16 code units) if the low error correction level is used. The smallest possible
      // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
      // ecl argument if it can be done without increasing the version.
      function encodeText(text, ecl) {
        var segs = QrSegment.makeSegments(text);
        return QrCode2.encodeSegments(segs, ecl);
      }
    )
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
  }, {
    key: "encodeBinary",
    value: function encodeBinary(data, ecl) {
      var seg = QrSegment.makeBytes(data);
      return QrCode2.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
  }, {
    key: "encodeSegments",
    value: function encodeSegments(segs, oriEcl) {
      var minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
      var mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      var boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (!(QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode2.MAX_VERSION) || mask < -1 || mask > 7) {
        throw new RangeError("Invalid value");
      }
      var version2;
      var dataUsedBits;
      for (version2 = minVersion; ; version2++) {
        var _dataCapacityBits = QrCode2.getNumDataCodewords(version2, oriEcl) * 8;
        var usedBits = QrSegment.getTotalBits(segs, version2);
        if (usedBits <= _dataCapacityBits) {
          dataUsedBits = usedBits;
          break;
        }
        if (version2 >= maxVersion) {
          throw new RangeError("Data too long");
        }
      }
      var ecl = oriEcl;
      for (var _i10 = 0, _arr = [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]; _i10 < _arr.length; _i10++) {
        var newEcl = _arr[_i10];
        if (boostEcl && dataUsedBits <= QrCode2.getNumDataCodewords(version2, newEcl) * 8) {
          ecl = newEcl;
        }
      }
      var bb = [];
      var _iterator4 = _createForOfIteratorHelper(segs), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var seg = _step4.value;
          appendBits(seg.mode.modeBits, 4, bb);
          appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
          var _iterator5 = _createForOfIteratorHelper(seg.getData()), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var b = _step5.value;
              bb.push(b);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      assert(bb.length == dataUsedBits);
      var dataCapacityBits = QrCode2.getNumDataCodewords(version2, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {
        appendBits(padByte, 8, bb);
      }
      var dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length) {
        dataCodewords.push(0);
      }
      bb.forEach(function(b2, i) {
        dataCodewords[i >>> 3] |= b2 << 7 - (i & 7);
      });
      return new QrCode2(version2, ecl, dataCodewords, mask);
    }
  }, {
    key: "getNumRawDataModules",
    value: function getNumRawDataModules(ver) {
      if (ver < QrCode2.MIN_VERSION || ver > QrCode2.MAX_VERSION) {
        throw new RangeError("Version number out of range");
      }
      var result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        var numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7) {
          result -= 36;
        }
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
  }, {
    key: "getNumDataCodewords",
    value: function getNumDataCodewords(ver, ecl) {
      return Math.floor(QrCode2.getNumRawDataModules(ver) / 8) - QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
  }, {
    key: "reedSolomonComputeDivisor",
    value: function reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255) {
        throw new RangeError("Degree out of range");
      }
      var result = [];
      for (var i = 0; i < degree - 1; i++) {
        result.push(0);
      }
      result.push(1);
      var root = 1;
      for (var _i11 = 0; _i11 < degree; _i11++) {
        for (var j = 0; j < result.length; j++) {
          result[j] = QrCode2.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length) {
            result[j] ^= result[j + 1];
          }
        }
        root = QrCode2.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
  }, {
    key: "reedSolomonComputeRemainder",
    value: function reedSolomonComputeRemainder(data, divisor) {
      var result = divisor.map(function() {
        return 0;
      });
      var _iterator6 = _createForOfIteratorHelper(data), _step6;
      try {
        var _loop2 = function _loop22() {
          var b = _step6.value;
          var factor = b ^ result.shift();
          result.push(0);
          divisor.forEach(function(coef, i) {
            result[i] ^= QrCode2.reedSolomonMultiply(coef, factor);
          });
        };
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          _loop2();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit numberegers. This could be implemented as a lookup table of 256*256 entries of unumber8.
  }, {
    key: "reedSolomonMultiply",
    value: function reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0) {
        throw new RangeError("Byte out of range");
      }
      var z = 0;
      for (var i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
  }]);
  return QrCode2;
}();
_defineProperty(QrCode, "MIN_VERSION", 1);
_defineProperty(QrCode, "MAX_VERSION", 40);
_defineProperty(QrCode, "PENALTY_N1", 3);
_defineProperty(QrCode, "PENALTY_N2", 3);
_defineProperty(QrCode, "PENALTY_N3", 40);
_defineProperty(QrCode, "PENALTY_N4", 10);
_defineProperty(QrCode, "ECC_CODEWORDS_PER_BLOCK", [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
]);
_defineProperty(QrCode, "NUM_ERROR_CORRECTION_BLOCKS", [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
]);

// node_modules/@rc-component/qrcode/es/utils.js
var ERROR_LEVEL_MAP = {
  L: Ecc.LOW,
  M: Ecc.MEDIUM,
  Q: Ecc.QUARTILE,
  H: Ecc.HIGH
};
var DEFAULT_SIZE4 = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BACKGROUND_COLOR = "#FFFFFF";
var DEFAULT_FRONT_COLOR = "#000000";
var DEFAULT_NEED_MARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
var generatePath = function generatePath2(modules) {
  var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function(row, y) {
    var start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
};
var excavateModules = function excavateModules2(modules, excavation) {
  return modules.slice().map(function(row, y) {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map(function(cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
};
var getImageSettings = function getImageSettings2(cells, size, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w = (imageSettings.width || defaultSize) * scale;
  var h = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
  var excavation = null;
  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y);
    var ceilW = Math.ceil(w + x - floorX);
    var ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  var crossOrigin = imageSettings.crossOrigin;
  return {
    x,
    y,
    h,
    w,
    excavation,
    opacity,
    crossOrigin
  };
};
var getMarginSize = function getMarginSize2(needMargin, marginSize) {
  if (marginSize != null) {
    return Math.max(Math.floor(marginSize), 0);
  }
  return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
};
var isSupportPath2d = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (_unused) {
    return false;
  }
  return true;
}();

// node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var import_react196 = __toESM(require_react());

// node_modules/@rc-component/qrcode/es/hooks/useQRCode.js
var import_react195 = __toESM(require_react());
var useQRCode = function useQRCode2(opt) {
  var value = opt.value, level = opt.level, minVersion = opt.minVersion, includeMargin = opt.includeMargin, marginSize = opt.marginSize, imageSettings = opt.imageSettings, size = opt.size, boostLevel = opt.boostLevel;
  var memoizedQrcode = import_react195.default.useMemo(function() {
    var values = Array.isArray(value) ? value : [value];
    var segments = values.reduce(function(acc, val) {
      acc.push.apply(acc, _toConsumableArray(QrSegment.makeSegments(val)));
      return acc;
    }, []);
    return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);
  }, [value, level, minVersion, boostLevel]);
  return import_react195.default.useMemo(function() {
    var cs = memoizedQrcode.getModules();
    var mg = getMarginSize(includeMargin, marginSize);
    var ncs = cs.length + mg * 2;
    var cis = getImageSettings(cs, size, mg, imageSettings);
    return {
      cells: cs,
      margin: mg,
      numCells: ncs,
      calculatedImageSettings: cis,
      qrcode: memoizedQrcode
    };
  }, [memoizedQrcode, size, imageSettings, includeMargin, marginSize]);
};

// node_modules/@rc-component/qrcode/es/QRCodeCanvas.js
var _excluded7 = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "marginSize", "style", "imageSettings", "boostLevel"];
var QRCodeCanvas = import_react196.default.forwardRef(function(props, ref) {
  var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE4 : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, marginSize = props.marginSize, style2 = props.style, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties5(props, _excluded7);
  var imgSrc = imageSettings === null || imageSettings === void 0 ? void 0 : imageSettings.src;
  var _canvas = import_react196.default.useRef(null);
  var _image = import_react196.default.useRef(null);
  var setCanvasRef = import_react196.default.useCallback(function(node2) {
    _canvas.current = node2;
    if (typeof ref === "function") {
      ref(node2);
    } else if (ref) {
      ref.current = node2;
    }
  }, [ref]);
  var _React$useState = import_react196.default.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), setIsImageLoaded = _React$useState2[1];
  var _useQRCode = useQRCode({
    value,
    level,
    minVersion,
    includeMargin,
    marginSize,
    imageSettings,
    size,
    boostLevel
  }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
  import_react196.default.useEffect(function() {
    if (_canvas.current) {
      var canvas = _canvas.current;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      var cellsToDraw = cells;
      var image = _image.current;
      var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
      if (haveImageToRender) {
        if (calculatedImageSettings.excavation != null) {
          cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
        }
      }
      var pixelRatio = window.devicePixelRatio || 1;
      canvas.height = canvas.width = size * pixelRatio;
      var scale = size / numCells * pixelRatio;
      ctx.scale(scale, scale);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = fgColor;
      if (isSupportPath2d) {
        ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
      } else {
        cells.forEach(function(row, rdx) {
          row.forEach(function(cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
      if (calculatedImageSettings) {
        ctx.globalAlpha = calculatedImageSettings.opacity;
      }
      if (haveImageToRender) {
        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
      }
    }
  });
  import_react196.default.useEffect(function() {
    setIsImageLoaded(false);
  }, [imgSrc]);
  var canvasStyle = _objectSpread2({
    height: size,
    width: size
  }, style2);
  var img = null;
  if (imgSrc != null) {
    img = import_react196.default.createElement("img", {
      alt: "QR-Code",
      src: imgSrc,
      key: imgSrc,
      style: {
        display: "none"
      },
      onLoad: function onLoad() {
        setIsImageLoaded(true);
      },
      ref: _image,
      crossOrigin: calculatedImageSettings === null || calculatedImageSettings === void 0 ? void 0 : calculatedImageSettings.crossOrigin
    });
  }
  return import_react196.default.createElement(import_react196.default.Fragment, null, import_react196.default.createElement("canvas", _extends9({
    style: canvasStyle,
    height: size,
    width: size,
    ref: setCanvasRef,
    role: "img"
  }, otherProps)), img);
});
if (true) {
  QRCodeCanvas.displayName = "QRCodeCanvas";
}

// node_modules/@rc-component/qrcode/es/QRCodeSVG.js
var import_react197 = __toESM(require_react());
var _excluded8 = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "title", "marginSize", "imageSettings", "boostLevel"];
var QRCodeSVG = import_react197.default.forwardRef(function(props, ref) {
  var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE4 : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, title = props.title, marginSize = props.marginSize, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties5(props, _excluded8);
  var _useQRCode = useQRCode({
    value,
    level,
    minVersion,
    includeMargin,
    marginSize,
    imageSettings,
    size,
    boostLevel
  }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
  var cellsToDraw = cells;
  var image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image = import_react197.default.createElement("image", {
      href: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none",
      opacity: calculatedImageSettings.opacity,
      crossOrigin: calculatedImageSettings.crossOrigin
    });
  }
  var fgPath = generatePath(cellsToDraw, margin);
  return import_react197.default.createElement("svg", _extends9({
    height: size,
    width: size,
    viewBox: "0 0 ".concat(numCells, " ").concat(numCells),
    ref,
    role: "img"
  }, otherProps), !!title && import_react197.default.createElement("title", null, title), import_react197.default.createElement("path", {
    fill: bgColor,
    d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),
    shapeRendering: "crispEdges"
  }), import_react197.default.createElement("path", {
    fill: fgColor,
    d: fgPath,
    shapeRendering: "crispEdges"
  }), image);
});
if (true) {
  QRCodeSVG.displayName = "QRCodeSVG";
}

// node_modules/antd/es/qr-code/QrcodeStatus.js
var import_react198 = __toESM(require_react());
var defaultSpin = import_react198.default.createElement(spin_default, null);
function QRcodeStatus({
  prefixCls,
  locale: locale6,
  onRefresh,
  statusRender,
  status
}) {
  const defaultExpiredNode = import_react198.default.createElement(import_react198.default.Fragment, null, import_react198.default.createElement("p", {
    className: `${prefixCls}-expired`
  }, locale6 == null ? void 0 : locale6.expired), onRefresh && import_react198.default.createElement(Button_default, {
    type: "link",
    icon: import_react198.default.createElement(ReloadOutlined_default, null),
    onClick: onRefresh
  }, locale6 == null ? void 0 : locale6.refresh));
  const defaultScannedNode = import_react198.default.createElement("p", {
    className: `${prefixCls}-scanned`
  }, locale6 == null ? void 0 : locale6.scanned);
  const defaultNodes = {
    expired: defaultExpiredNode,
    loading: defaultSpin,
    scanned: defaultScannedNode
  };
  const defaultStatusRender = (info) => defaultNodes[info.status];
  const mergedStatusRender = statusRender ?? defaultStatusRender;
  return mergedStatusRender({
    status,
    locale: locale6,
    onRefresh
  });
}

// node_modules/antd/es/qr-code/style/index.js
var genQRCodeStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorSplit
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: token2.paddingSM,
      backgroundColor: token2.colorWhite,
      borderRadius: token2.borderRadiusLG,
      border: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
      position: "relative",
      overflow: "hidden",
      [`& > ${componentCls}-cover`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: token2.colorText,
        lineHeight: token2.lineHeight,
        background: token2.QRCodeCoverBackgroundColor,
        textAlign: "center",
        [`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: {
          color: token2.QRCodeTextColor
        }
      },
      "> canvas": {
        alignSelf: "stretch",
        flex: "auto",
        minWidth: 0
      },
      "&-icon": {
        marginBlockEnd: token2.marginXS,
        fontSize: token2.controlHeight
      }
    },
    [`${componentCls}-borderless`]: {
      borderColor: "transparent",
      padding: 0,
      borderRadius: 0
    }
  };
};
var prepareComponentToken44 = (token2) => ({
  QRCodeCoverBackgroundColor: new FastColor(token2.colorBgContainer).setA(0.96).toRgbString()
});
var style_default51 = genStyleHooks("QRCode", (token2) => {
  const mergedToken = merge2(token2, {
    QRCodeTextColor: token2.colorText
  });
  return genQRCodeStyle(mergedToken);
}, prepareComponentToken44);

// node_modules/antd/es/qr-code/index.js
var QRCode = (props) => {
  const [, token2] = useToken();
  const {
    value,
    type: type5 = "canvas",
    icon = "",
    size = 160,
    iconSize,
    color = token2.colorText,
    errorLevel = "M",
    status = "active",
    bordered = true,
    onRefresh,
    style: style2,
    className,
    rootClassName,
    prefixCls: customizePrefixCls,
    bgColor = "transparent",
    statusRender,
    classNames,
    styles,
    boostLevel,
    ...rest
  } = props;
  const {
    getPrefixCls,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("qrcode");
  const mergedProps = {
    ...props,
    bgColor,
    type: type5,
    size,
    status,
    bordered,
    errorLevel
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
  const [hashId, cssVarCls] = style_default51(prefixCls);
  const imageSettings = {
    src: icon,
    x: void 0,
    y: void 0,
    height: typeof iconSize === "number" ? iconSize : (iconSize == null ? void 0 : iconSize.height) ?? 40,
    width: typeof iconSize === "number" ? iconSize : (iconSize == null ? void 0 : iconSize.width) ?? 40,
    excavate: true,
    crossOrigin: "anonymous"
  };
  const a11yProps = pickAttrs(rest, true);
  const restProps = omit(rest, Object.keys(a11yProps));
  const qrCodeProps = {
    value,
    size,
    level: errorLevel,
    bgColor,
    fgColor: color,
    style: {
      width: style2 == null ? void 0 : style2.width,
      height: style2 == null ? void 0 : style2.height
    },
    imageSettings: icon ? imageSettings : void 0,
    boostLevel,
    ...a11yProps
  };
  const [locale6] = useLocale_default("QRCode");
  if (true) {
    const warning5 = devUseWarning("QRCode");
    true ? warning5(!!value, "usage", "need to receive `value` props") : void 0;
    true ? warning5(!(icon && errorLevel === "L"), "usage", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.") : void 0;
  }
  if (!value) {
    return null;
  }
  const rootClassNames = clsx(prefixCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-borderless`]: !bordered
  });
  const rootStyle = {
    backgroundColor: bgColor,
    ...mergedStyles.root,
    ...contextStyle,
    ...style2,
    width: (style2 == null ? void 0 : style2.width) ?? size,
    height: (style2 == null ? void 0 : style2.height) ?? size
  };
  return import_react199.default.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: rootStyle
  }, status !== "active" && import_react199.default.createElement("div", {
    className: clsx(`${prefixCls}-cover`, mergedClassNames.cover),
    style: mergedStyles.cover
  }, import_react199.default.createElement(QRcodeStatus, {
    prefixCls,
    locale: locale6,
    status,
    onRefresh,
    statusRender
  })), type5 === "canvas" ? import_react199.default.createElement(QRCodeCanvas, {
    ...qrCodeProps
  }) : import_react199.default.createElement(QRCodeSVG, {
    ...qrCodeProps
  }));
};
if (true) {
  QRCode.displayName = "QRCode";
}
var qr_code_default = QRCode;

// node_modules/antd/es/rate/index.js
var React506 = __toESM(require_react());

// node_modules/@rc-component/rate/es/Rate.js
var import_react201 = __toESM(require_react());

// node_modules/@rc-component/rate/es/Star.js
var import_react200 = __toESM(require_react());
function Star(props, ref) {
  const {
    disabled,
    prefixCls,
    character: character2,
    characterRender,
    index: index2,
    count,
    value,
    allowHalf,
    focused,
    onHover,
    onClick
  } = props;
  const onInternalHover = (e3) => {
    onHover(e3, index2);
  };
  const onInternalClick = (e3) => {
    onClick(e3, index2);
  };
  const onInternalKeyDown = (e3) => {
    if (e3.keyCode === KeyCode_default.ENTER) {
      onClick(e3, index2);
    }
  };
  const starValue = index2 + 1;
  const classNameList = /* @__PURE__ */ new Set([prefixCls]);
  if (value === 0 && index2 === 0 && focused) {
    classNameList.add(`${prefixCls}-focused`);
  } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
    classNameList.add(`${prefixCls}-half`);
    classNameList.add(`${prefixCls}-active`);
    if (focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  } else {
    if (starValue <= value) {
      classNameList.add(`${prefixCls}-full`);
    } else {
      classNameList.add(`${prefixCls}-zero`);
    }
    if (starValue === value && focused) {
      classNameList.add(`${prefixCls}-focused`);
    }
  }
  const characterNode = typeof character2 === "function" ? character2(props) : character2;
  let start = import_react200.default.createElement("li", {
    className: clsx(Array.from(classNameList)),
    ref
  }, import_react200.default.createElement("div", {
    onClick: disabled ? null : onInternalClick,
    onKeyDown: disabled ? null : onInternalKeyDown,
    onMouseMove: disabled ? null : onInternalHover,
    role: "radio",
    "aria-checked": value > index2 ? "true" : "false",
    "aria-posinset": index2 + 1,
    "aria-setsize": count,
    tabIndex: disabled ? -1 : 0
  }, import_react200.default.createElement("div", {
    className: `${prefixCls}-first`
  }, characterNode), import_react200.default.createElement("div", {
    className: `${prefixCls}-second`
  }, characterNode)));
  if (characterRender) {
    start = characterRender(start, props);
  }
  return start;
}
var Star_default = import_react200.default.forwardRef(Star);

// node_modules/@rc-component/rate/es/useRefs.js
var React504 = __toESM(require_react());
function useRefs2() {
  const nodeRef = React504.useRef({});
  function getRef(index2) {
    return nodeRef.current[index2];
  }
  function setRef(index2) {
    return (node2) => {
      nodeRef.current[index2] = node2;
    };
  }
  return [getRef, setRef];
}

// node_modules/@rc-component/rate/es/util.js
function getScroll3(w) {
  let ret = w.pageXOffset;
  const method4 = "scrollLeft";
  if (typeof ret !== "number") {
    const d = w.document;
    ret = d.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d.body[method4];
    }
  }
  return ret;
}
function getClientPosition(elem) {
  let x;
  let y;
  const doc = elem.ownerDocument;
  const {
    body
  } = doc;
  const docElem = doc && doc.documentElement;
  const box2 = elem.getBoundingClientRect();
  x = box2.left;
  y = box2.top;
  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getOffsetLeft(el) {
  const pos = getClientPosition(el);
  const doc = el.ownerDocument;
  const w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll3(w);
  return pos.left;
}

// node_modules/@rc-component/rate/es/Rate.js
function _extends75() {
  _extends75 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends75.apply(this, arguments);
}
function Rate(props, ref) {
  const {
    // Base
    prefixCls = "rc-rate",
    className,
    // Value
    defaultValue,
    value: propValue,
    count = 5,
    allowHalf = false,
    allowClear = true,
    keyboard = true,
    // Display
    character: character2 = "",
    characterRender,
    // Meta
    disabled,
    direction = "ltr",
    tabIndex = 0,
    autoFocus,
    // Events
    onHoverChange,
    onChange,
    onFocus,
    onBlur,
    onKeyDown: onKeyDown2,
    onMouseLeave,
    ...restProps
  } = props;
  const [getStarRef, setStarRef] = useRefs2();
  const rateRef = import_react201.default.useRef(null);
  const triggerFocus2 = () => {
    var _a;
    if (!disabled) {
      (_a = rateRef.current) == null ? void 0 : _a.focus();
    }
  };
  import_react201.default.useImperativeHandle(ref, () => ({
    focus: triggerFocus2,
    blur: () => {
      var _a;
      if (!disabled) {
        (_a = rateRef.current) == null ? void 0 : _a.blur();
      }
    }
  }));
  const [value, setValue] = useControlledState(defaultValue || 0, propValue);
  const [cleanedValue, setCleanedValue] = useControlledState(null);
  const getStarValue = (index2, x) => {
    const reverse = direction === "rtl";
    let starValue = index2 + 1;
    if (allowHalf) {
      const starEle = getStarRef(index2);
      const leftDis = getOffsetLeft(starEle);
      const width = starEle.clientWidth;
      if (reverse && x - leftDis > width / 2) {
        starValue -= 0.5;
      } else if (!reverse && x - leftDis < width / 2) {
        starValue -= 0.5;
      }
    }
    return starValue;
  };
  const changeValue = (nextValue) => {
    setValue(nextValue);
    onChange == null ? void 0 : onChange(nextValue);
  };
  const [focused, setFocused] = import_react201.default.useState(false);
  const onInternalFocus = () => {
    setFocused(true);
    onFocus == null ? void 0 : onFocus();
  };
  const onInternalBlur = () => {
    setFocused(false);
    onBlur == null ? void 0 : onBlur();
  };
  const [hoverValue, setHoverValue] = import_react201.default.useState(null);
  const onHover = (event, index2) => {
    const nextHoverValue = getStarValue(index2, event.pageX);
    if (nextHoverValue !== cleanedValue) {
      setHoverValue(nextHoverValue);
      setCleanedValue(null);
    }
    onHoverChange == null ? void 0 : onHoverChange(nextHoverValue);
  };
  const onMouseLeaveCallback = (event) => {
    if (!disabled) {
      setHoverValue(null);
      setCleanedValue(null);
      onHoverChange == null ? void 0 : onHoverChange(void 0);
    }
    if (event) {
      onMouseLeave == null ? void 0 : onMouseLeave(event);
    }
  };
  const onClick = (event, index2) => {
    const newValue = getStarValue(index2, event.pageX);
    let isReset = false;
    if (allowClear) {
      isReset = newValue === value;
    }
    onMouseLeaveCallback();
    changeValue(isReset ? 0 : newValue);
    setCleanedValue(isReset ? newValue : null);
  };
  const onInternalKeyDown = (event) => {
    const {
      keyCode
    } = event;
    const reverse = direction === "rtl";
    const step = allowHalf ? 0.5 : 1;
    if (keyboard) {
      if (keyCode === KeyCode_default.RIGHT && value < count && !reverse) {
        changeValue(value + step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && value > 0 && !reverse) {
        changeValue(value - step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.RIGHT && value > 0 && reverse) {
        changeValue(value - step);
        event.preventDefault();
      } else if (keyCode === KeyCode_default.LEFT && value < count && reverse) {
        changeValue(value + step);
        event.preventDefault();
      }
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(event);
  };
  import_react201.default.useEffect(() => {
    if (autoFocus && !disabled) {
      triggerFocus2();
    }
  }, []);
  const starNodes = new Array(count).fill(0).map((item, index2) => import_react201.default.createElement(Star_default, {
    ref: setStarRef(index2),
    index: index2,
    count,
    disabled,
    prefixCls: `${prefixCls}-star`,
    allowHalf,
    value: hoverValue === null ? value : hoverValue,
    onClick,
    onHover,
    key: item || index2,
    character: character2,
    characterRender,
    focused
  }));
  const classString = clsx(prefixCls, className, {
    [`${prefixCls}-disabled`]: disabled,
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  return import_react201.default.createElement("ul", _extends75({
    className: classString,
    onMouseLeave: onMouseLeaveCallback,
    tabIndex: disabled ? -1 : tabIndex,
    onFocus: disabled ? null : onInternalFocus,
    onBlur: disabled ? null : onInternalBlur,
    onKeyDown: disabled ? null : onInternalKeyDown,
    ref: rateRef
  }, pickAttrs(restProps, {
    aria: true,
    data: true,
    attr: true
  })), starNodes);
}
var Rate_default = import_react201.default.forwardRef(Rate);

// node_modules/@rc-component/rate/es/index.js
var es_default30 = Rate_default;

// node_modules/antd/es/rate/style/index.js
var genRateStarStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: token2.marginXS
      },
      "> div": {
        transition: `all ${token2.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: token2.starHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${unit(token2.lineWidth)} dashed ${token2.starColor}`,
          transform: token2.starHoverScale
        }
      },
      "&-first, &-second": {
        color: token2.starBg,
        transition: `all ${token2.motionDurationMid}`,
        userSelect: "none"
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: {
        opacity: 1
      },
      [`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: {
        color: "inherit"
      }
    }
  };
};
var genRateRtlStyle = (token2) => ({
  [`&-rtl${token2.componentCls}`]: {
    direction: "rtl"
  }
});
var genRateStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: token2.starColor,
      fontSize: token2.starSize,
      lineHeight: 1,
      listStyle: "none",
      outline: "none",
      "&-small": {
        fontSize: token2.starSizeSM
      },
      "&-large": {
        fontSize: token2.starSizeLG
      },
      // disable styles
      [`&-disabled${componentCls} ${componentCls}-star`]: {
        cursor: "default",
        "> div:hover": {
          transform: "scale(1)"
        }
      },
      // star styles
      ...genRateStarStyle(token2),
      // rtl styles
      ...genRateRtlStyle(token2)
    }
  };
};
var prepareComponentToken45 = (token2) => ({
  starColor: token2.yellow6,
  starSize: token2.controlHeight * 0.625,
  starSizeSM: token2.controlHeightSM * 0.625,
  starSizeLG: token2.controlHeightLG * 0.625,
  starHoverScale: "scale(1.1)",
  starBg: token2.colorFillContent
});
var style_default52 = genStyleHooks("Rate", (token2) => {
  const rateToken = merge2(token2, {});
  return genRateStyle(rateToken);
}, prepareComponentToken45);

// node_modules/antd/es/rate/index.js
var isTooltipProps = (item) => {
  return typeof item === "object" && item !== null;
};
var Rate2 = React506.forwardRef((props, ref) => {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    tooltips,
    character: character2 = React506.createElement(StarFilled_default, null),
    disabled: customDisabled,
    size = "middle",
    ...rest
  } = props;
  const characterRender = (node2, {
    index: index2
  }) => {
    if (!tooltips) {
      return node2;
    }
    const tooltipsItem = tooltips[index2];
    if (isTooltipProps(tooltipsItem)) {
      return React506.createElement(tooltip_default, {
        ...tooltipsItem
      }, node2);
    }
    return React506.createElement(tooltip_default, {
      title: tooltipsItem
    }, node2);
  };
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("rate");
  const ratePrefixCls = getPrefixCls("rate", prefixCls);
  const [hashId, cssVarCls] = style_default52(ratePrefixCls);
  const mergedStyle = {
    ...contextStyle,
    ...style2
  };
  const disabled = React506.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  return React506.createElement(es_default30, {
    ref,
    character: character2,
    characterRender,
    disabled: mergedDisabled,
    ...rest,
    className: clsx(`${ratePrefixCls}-${size}`, className, rootClassName, hashId, cssVarCls, contextClassName),
    style: mergedStyle,
    prefixCls: ratePrefixCls,
    direction
  });
});
if (true) {
  Rate2.displayName = "Rate";
}
var rate_default = Rate2;

// node_modules/antd/es/result/index.js
var React510 = __toESM(require_react());

// node_modules/antd/es/result/noFound.js
var React507 = __toESM(require_react());
var NoFound = () => React507.createElement("svg", {
  width: "252",
  height: "294"
}, React507.createElement("title", null, "No Found"), React507.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React507.createElement("circle", {
  cx: "126.75",
  cy: "128.1",
  r: "126",
  fill: "#E4EBF7"
}), React507.createElement("circle", {
  cx: "31.55",
  cy: "130.8",
  r: "8.3",
  fill: "#FFF"
}), React507.createElement("path", {
  stroke: "#FFF",
  d: "m37 134.3 10.5 6m.9 6.2-12.7 10.8",
  strokeWidth: "2"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M39.9 159.4a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m17.7-16.2a5.7 5.7 0 1 1-11.4-1.1 5.7 5.7 0 0 1 11.4 1.1M99 27h29.8a4.6 4.6 0 1 0 0-9.2H99a4.6 4.6 0 1 0 0 9.2m11.4 18.3h29.8a4.6 4.6 0 0 0 0-9.2h-29.8a4.6 4.6 0 1 0 0 9.2"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M112.8 26.9h15.8a4.6 4.6 0 1 0 0 9.1h-15.8a4.6 4.6 0 0 0 0-9.1m71.7 108.8a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), React507.createElement("path", {
  stroke: "#FFF",
  d: "m179.3 141.8 12.6 7.1m1.1 7.6-15.2 13",
  strokeWidth: "2"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M184.7 170a6.8 6.8 0 1 1-13.6-1.3 6.8 6.8 0 0 1 13.6 1.4m18.6-16.8a6.9 6.9 0 1 1-13.7-1.4 6.9 6.9 0 0 1 13.7 1.4"
}), React507.createElement("path", {
  stroke: "#FFF",
  d: "M152 192.3a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm73.3-76.2a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm-9 35a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.5 0zM177 107.6a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.4-15.4a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0zm6.8 88.5a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.5 0z",
  strokeWidth: "2"
}), React507.createElement("path", {
  stroke: "#FFF",
  d: "m214.4 153.3-2 20.2-10.8 6m-28-4.7-6.3 9.8H156l-4.5 6.5m23.5-66v-15.7m46 7.8-13 8-15.2-8V94.4",
  strokeWidth: "2"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M166.6 66h-4a4.8 4.8 0 0 1-4.7-4.8 4.8 4.8 0 0 1 4.7-4.7h4a4.8 4.8 0 0 1 4.7 4.7 4.8 4.8 0 0 1-4.7 4.7"
}), React507.createElement("circle", {
  cx: "204.3",
  cy: "30",
  r: "29.5",
  fill: "#1677ff"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M206 38.4c.5.5.7 1.1.7 2s-.2 1.4-.7 1.9a3 3 0 0 1-2 .7c-.8 0-1.5-.3-2-.8s-.8-1.1-.8-1.9.3-1.4.8-2c.5-.4 1.2-.7 2-.7.7 0 1.4.3 2 .8m4.2-19.5c1.5 1.3 2.2 3 2.2 5.2a7.2 7.2 0 0 1-1.5 4.5l-3 2.7a5 5 0 0 0-1.3 1.7 5.2 5.2 0 0 0-.6 2.4v.5h-4v-.5c0-1.4.1-2.5.6-3.5s1.9-2.5 4.2-4.5l.4-.5a4 4 0 0 0 1-2.6c0-1.2-.4-2-1-2.8-.7-.6-1.6-1-2.9-1-1.5 0-2.6.5-3.3 1.5-.4.5-.6 1-.8 1.9a2 2 0 0 1-2 1.6 2 2 0 0 1-2-2.4c.4-1.6 1-2.8 2.1-3.8a8.5 8.5 0 0 1 6.3-2.3c2.3 0 4.2.6 5.6 2"
}), React507.createElement("path", {
  fill: "#FFB594",
  d: "M52 76.1s21.8 5.4 27.3 16c5.6 10.7-6.3 9.2-15.7 5C52.8 92 39 85 52 76"
}), React507.createElement("path", {
  fill: "#FFC6A0",
  d: "m90.5 67.5-.5 2.9c-.7.5-4.7-2.7-4.7-2.7l-1.7.8-1.3-5.7s6.8-4.6 9-5c2.4-.5 9.8 1 10.6 2.3 0 0 1.3.4-2.2.6-3.6.3-5 .5-6.8 3.2l-2.4 3.6"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M128 111.4a36.7 36.7 0 0 0-8.9-15.5c-3.5-3-9.3-2.2-11.3-4.2-1.3-1.2-3.2-1.2-3.2-1.2L87.7 87c-2.3-.4-2.1-.7-6-1.4-1.6-1.9-3-1.1-3-1.1l-7-1.4c-1-1.5-2.5-1-2.5-1l-2.4-.9C65 91.2 59 95 59 95c1.8 1.1 15.7 8.3 15.7 8.3l5.1 37.1s-3.3 5.7 1.4 9.1c0 0 19.9-3.7 34.9-.3 0 0 3-2.6 1-8.8.5-3 1.4-8.3 1.7-11.6.4.7 2 1.9 3.1 3.4 0 0 9.4-7.3 11-14a17 17 0 0 1-2.2-2.4c-.5-.8-.3-2-.7-2.8-.7-1-1.8-1.3-2-1.6"
}), React507.createElement("path", {
  fill: "#CBD1D1",
  d: "M101 290s4.4 2 7.4 1c2.9-1 4.6.7 7.1 1.2 2.6.5 6.9 1.1 11.7-1.3 0-5.5-6.9-4-12-6.7-2.5-1.4-3.7-4.7-3.5-8.8h-9.5s-1.2 10.6-1 14.6"
}), React507.createElement("path", {
  fill: "#2B0849",
  d: "M101 289.8s2.5 1.3 6.8.7c3-.5 3.7.5 7.4 1 3.8.6 10.8 0 11.9-.9.4 1.1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.6-.5-1.8-1.4-5.2-1.9-5.7-.2-4 1-7.4-.3-7.4-.3l-.1-2.7z"
}), React507.createElement("path", {
  fill: "#A4AABA",
  d: "M108.3 276h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), React507.createElement("path", {
  fill: "#CBD1D1",
  d: "M57.5 272.4s-2 7.4-4.4 12.3c-1.8 3.7-4.3 7.5 5.4 7.5 6.7 0 9-.5 7.4-6.6-1.5-6.1.3-13.2.3-13.2h-8.7z"
}), React507.createElement("path", {
  fill: "#2B0849",
  d: "M51.5 289.8s2 1.2 6.6 1.2c6 0 8.3-1.7 8.3-1.7s.6 1.1-.7 2.2c-1 .8-3.6 1.6-7.4 1.5-4.1 0-5.8-.5-6.7-1.1-.8-.6-.7-1.6-.1-2.1"
}), React507.createElement("path", {
  fill: "#A4AABA",
  d: "M58.4 274.3s0 1.5-.3 3c-.3 1.4-1 3-1.1 4 0 1.2 4.5 1.7 5.1.1.6-1.5 1.3-6.4 2-7.2.6-.9-5-2.2-5.7.1"
}), React507.createElement("path", {
  fill: "#7BB2F9",
  d: "m99.7 278.5 13.3.1s1.3-54.5 1.9-64.4c.5-9.9 3.8-43.4 1-63.1l-12.6-.7-22.8.8-1.2 10c0 .5-.7.8-.7 1.4-.1.5.4 1.3.3 2-2.4 14-6.4 33-8.8 46.6 0 .7-1.2 1-1.4 2.7 0 .3.2 1.5 0 1.8-6.8 18.7-10.9 47.8-14.2 61.9h14.6s2.2-8.6 4-17c2.9-12.9 23.2-85 23.2-85l3-.5 1 46.3s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.8-1 11.8c-.4 4.8 0 39.2 0 39.2"
}), React507.createElement("path", {
  stroke: "#648BD8",
  d: "M76 221.6c1.2.1 4.1-2 7-5m23.4 8.5s2.7-1 6-3.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#648BD8",
  d: "M107.3 222.1s2.7-1.1 6-3.9",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}), React507.createElement("path", {
  stroke: "#648BD8",
  d: "M74.7 224.8s2.7-.6 6.5-3.4m4.8-69.8c-.2 3.1.3 8.6-4.3 9.2m22-11s0 14-1.4 15.1a15 15 0 0 1-3 2m.5-16.5s0 13-1.2 24.4m-5 1.1s7.3-1.7 9.5-1.7M74.3 206a212 212 0 0 1-1 4.5s-1.4 1.9-1 3.8c.5 2-1 2-5 15.4A353 353 0 0 0 61 257l-.2 1.2m14.9-60.5a321 321 0 0 1-.9 4.8m7.8-50.4-1.2 10.5s-1.1.1-.5 2.2c.1 1.4-2.7 15.8-5.2 30.5m-19.6 79h13.3",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  fill: "#192064",
  d: "M116.2 148.2s-17-3-35.9.2c.2 2.5 0 4.2 0 4.2s14.7-2.8 35.7-.3c.3-2.4.2-4 .2-4"
}), React507.createElement("path", {
  fill: "#FFF",
  d: "M106.3 151.2v-5a.8.8 0 0 0-.8-.8h-7.8a.8.8 0 0 0-.8.8v5a.8.8 0 0 0 .8.8h7.8a.8.8 0 0 0 .8-.8"
}), React507.createElement("path", {
  fill: "#192064",
  d: "M105.2 150.2v-3a.6.6 0 0 0-.6-.7 94.3 94.3 0 0 0-5.9 0 .7.7 0 0 0-.6.6v3.1a.6.6 0 0 0 .6.7 121.1 121.1 0 0 1 5.8 0c.4 0 .7-.3.7-.7"
}), React507.createElement("path", {
  stroke: "#648BD8",
  d: "M100.3 275.4h12.3m-11.2-4.9.1 6.5m0-12.5a915.8 915.8 0 0 0 0 4.4m-.5-94 .9 44.7s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.2 0 3.4-.6 1.5-1 21.1-1.1 35.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  fill: "#FFC6A0",
  d: "M46.9 83.4s-.5 6 7.2 5.6c11.2-.7 9.2-9.4 31.5-21.7-.7-2.7-2.4-4.7-2.4-4.7s-11 3-22.6 8c-6.8 3-13.4 6.4-13.7 12.8m57.6 7.7.9-5.4-8.9-11.4-5 5.3-1.8 7.9a.3.3 0 0 0 .1.3c1 .8 6.5 5 14.4 3.5a.3.3 0 0 0 .3-.2"
}), React507.createElement("path", {
  fill: "#FFC6A0",
  d: "M94 79.4s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.1-3.7c.6-1 1.6-4.1 1.6-4.1l13.5 3c0 5.3-2.3 19.5-7.8 20-8.9.6-12.5-9.5-12.5-9.5"
}), React507.createElement("path", {
  fill: "#520038",
  d: "M113.9 73.4c2.6-2 3.4-9.7 3.4-9.7s-2.4-.5-6.6-2c-4.7-2.1-12.8-4.8-17.5 1-9.6 3.2-2 19.8-2 19.8l2.7-3s-4-3.3-2-6.3c2-3.5 3.8 1 3.8 1s.7-2.3 3.6-3.3c.4-.7 1-2.6 1.4-3.8a1 1 0 0 1 1.3-.7l11.4 2.6c.5.2.8.7.8 1.2l-.3 3.2z"
}), React507.createElement("path", {
  fill: "#552950",
  d: "M105 76c-.1.7-.6 1.1-1 1-.6 0-.9-.6-.8-1.2.1-.6.6-1 1-1 .6 0 .9.7.8 1.3m7.1 1.6c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.5-1 1-1 .5.1.8.7.7 1.3"
}), React507.createElement("path", {
  stroke: "#DB836E",
  d: "m110.1 74.8-.9 1.7-.3 4.3h-2.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#5C2552",
  d: "M110.8 74.5s1.8-.7 2.6.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#DB836E",
  d: "M92.4 74.3s.5-1.1 1.1-.7c.6.4 1.3 1.4.6 2-.8.5.1 1.6.1 1.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#5C2552",
  d: "M103.3 73s1.8 1 4.1.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#DB836E",
  d: "M103.7 81.8s2.2 1.2 4.4 1.2m-3.5 1.3s1 .4 1.6.3m-11.5-3.4s2.3 7.4 10.4 7.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#E4EBF7",
  d: "M81.5 89.4s.4 5.6-5 12.8M69 82.7s-.7 9.2-8.2 14.2m68.6 26s-5.3 7.4-9.4 10.7m-.7-26.3s.5 4.4-2.1 32",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  fill: "#F2D7AD",
  d: "M150 151.2h-49.8a1 1 0 0 1-1-1v-31.7c0-.5.4-1 1-1H150c.6 0 1 .5 1 1v31.7a1 1 0 0 1-1 1"
}), React507.createElement("path", {
  fill: "#F4D19D",
  d: "M150.3 151.2h-19.9v-33.7h20.8v32.8a1 1 0 0 1-1 1"
}), React507.createElement("path", {
  fill: "#F2D7AD",
  d: "M123.6 127.9H92.9a.5.5 0 0 1-.4-.8l6.4-9.1c.2-.3.5-.5.8-.5h31.1l-7.2 10.4z"
}), React507.createElement("path", {
  fill: "#CC9B6E",
  d: "M123.7 128.4H99.2v-.5h24.2l7.2-10.2.4.3z"
}), React507.createElement("path", {
  fill: "#F4D19D",
  d: "M158.3 127.9h-18.7a2 2 0 0 1-1.6-.8l-7.2-9.6h20c.5 0 1 .3 1.2.6l6.7 9a.5.5 0 0 1-.4.8"
}), React507.createElement("path", {
  fill: "#CC9B6E",
  d: "M157.8 128.5h-19.3l-7.9-10.5.4-.3 7.7 10.3h19.1zm-27.2 22.2v-8.2h.4v8.2zm-.1-10.9v-21.4h.4l.1 21.4zm-18.6 1.1-.5-.1 1.5-5.2.5.2zm-3.5.2-2.6-3 2.6-3.4.4.3-2.4 3.1 2.4 2.6zm8.2 0-.4-.4 2.4-2.6-2.4-3 .4-.4 2.7 3.4z"
}), React507.createElement("path", {
  fill: "#FFC6A0",
  d: "m154.3 131.9-3.1-2v3.5l-1 .1a85 85 0 0 1-4.8.3c-1.9 0-2.7 2.2 2.2 2.6l-2.6-.6s-2.2 1.3.5 2.3c0 0-1.6 1.2.6 2.6-.6 3.5 5.2 4 7 3.6a6.1 6.1 0 0 0 4.6-5.2 8 8 0 0 0-3.4-7.2"
}), React507.createElement("path", {
  stroke: "#DB836E",
  d: "M153.7 133.6s-6.5.4-8.4.3c-1.8 0-1.9 2.2 2.4 2.3 3.7.2 5.4 0 5.4 0",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  stroke: "#DB836E",
  d: "M145.2 135.9c-1.9 1.3.5 2.3.5 2.3s3.5 1 6.8.6m-.6 2.9s-6.3.1-6.7-2.1c-.3-1.4.4-1.4.4-1.4m.5 2.7s-1 3.1 5.5 3.5m-.4-14.5v3.5M52.8 89.3a18 18 0 0 0 13.6-7.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React507.createElement("path", {
  fill: "#5BA02E",
  d: "M168.6 248.3a6.6 6.6 0 0 1-6.7-6.6v-66.5a6.6 6.6 0 1 1 13.3 0v66.5a6.6 6.6 0 0 1-6.6 6.6"
}), React507.createElement("path", {
  fill: "#92C110",
  d: "M176.5 247.7a6.6 6.6 0 0 1-6.6-6.7v-33.2a6.6 6.6 0 1 1 13.3 0V241a6.6 6.6 0 0 1-6.7 6.7"
}), React507.createElement("path", {
  fill: "#F2D7AD",
  d: "M186.4 293.6H159a3.2 3.2 0 0 1-3.2-3.2v-46.1a3.2 3.2 0 0 1 3.2-3.2h27.5a3.2 3.2 0 0 1 3.2 3.2v46.1a3.2 3.2 0 0 1-3.2 3.2"
}), React507.createElement("path", {
  stroke: "#E4EBF7",
  d: "M89 89.5s7.8 5.4 16.6 2.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
})));
var noFound_default = NoFound;

// node_modules/antd/es/result/serverError.js
var React508 = __toESM(require_react());
var ServerError = () => React508.createElement("svg", {
  width: "254",
  height: "294"
}, React508.createElement("title", null, "Server Error"), React508.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React508.createElement("path", {
  fill: "#E4EBF7",
  d: "M0 128.1v-2C0 56.5 56.3.2 125.7.2h2.1C197.2.3 253.5 56.6 253.5 126v2.1c0 69.5-56.3 125.7-125.7 125.7h-2.1A125.7 125.7 0 0 1 0 128.1"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M40 132.1a8.3 8.3 0 1 1-16.6-1.7 8.3 8.3 0 0 1 16.6 1.7"
}), React508.createElement("path", {
  stroke: "#FFF",
  d: "m37.2 135.6 10.5 6m1 6.3-12.8 10.8",
  strokeWidth: "2"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M40.1 160.8a5.7 5.7 0 1 1-11.3-1.1 5.7 5.7 0 0 1 11.3 1.1M58 144.6a5.7 5.7 0 1 1-11.4-1.2 5.7 5.7 0 0 1 11.4 1.2M99.7 27.4h30a4.6 4.6 0 1 0 0-9.2h-30a4.6 4.6 0 0 0 0 9.2M111 46h30a4.6 4.6 0 1 0 0-9.3h-30a4.6 4.6 0 1 0 0 9.3m2.5-18.6h16a4.6 4.6 0 1 0 0 9.3h-16a4.6 4.6 0 0 0 0-9.3m36.7 42.7h-4a4.8 4.8 0 0 1-4.8-4.8 4.8 4.8 0 0 1 4.8-4.8h4a4.8 4.8 0 0 1 4.7 4.8 4.8 4.8 0 0 1-4.7 4.8"
}), React508.createElement("circle", {
  cx: "201.35",
  cy: "30.2",
  r: "29.7",
  fill: "#FF603B"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "m203.6 19.4-.7 15a1.5 1.5 0 0 1-3 0l-.7-15a2.2 2.2 0 1 1 4.4 0m-.3 19.4c.5.5.8 1.1.8 1.9s-.3 1.4-.8 1.9a3 3 0 0 1-2 .7 2.5 2.5 0 0 1-1.8-.7c-.6-.6-.8-1.2-.8-2 0-.7.2-1.3.8-1.8.5-.5 1.1-.7 1.8-.7.8 0 1.5.2 2 .7"
}), React508.createElement("path", {
  fill: "#FFB594",
  d: "M119.3 133.3c4.4-.6 3.6-1.2 4-4.8.8-5.2-3-17-8.2-25.1-1-10.7-12.6-11.3-12.6-11.3s4.3 5 4.2 16.2c1.4 5.3.8 14.5.8 14.5s5.3 11.4 11.8 10.5"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M101 91.6s1.4-.6 3.2.6c8 1.4 10.3 6.7 11.3 11.4 1.8 1.2 1.8 2.3 1.8 3.5l1.5 3s-7.2 1.7-11 6.7c-1.3-6.4-6.9-25.2-6.9-25.2"
}), React508.createElement("path", {
  fill: "#FFB594",
  d: "m94 90.5 1-5.8-9.2-11.9-5.2 5.6-2.6 9.9s8.4 5 16 2.2"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M83 78.2s-4.6-2.9-2.5-6.9c1.6-3 4.5 1.2 4.5 1.2s.5-3.7 3.2-3.7c.5-1 1.5-4.2 1.5-4.2l13.6 3.2c0 5.2-2.3 19.5-7.9 20-8.9.6-12.5-9.6-12.5-9.6"
}), React508.createElement("path", {
  fill: "#520038",
  d: "M103 72.2c2.6-2 3.5-9.7 3.5-9.7s-2.5-.5-6.7-2c-4.7-2.2-12.9-4.9-17.6.9-9.5 4.4-2 20-2 20l2.7-3.1s-4-3.3-2.1-6.3c2.2-3.5 4 1 4 1s.6-2.3 3.5-3.3c.4-.7 1-2.7 1.5-3.8A1 1 0 0 1 91 65l11.5 2.7c.5.1.8.6.8 1.2l-.3 3.2z"
}), React508.createElement("path", {
  fill: "#552950",
  d: "M101.2 76.5c0 .6-.6 1-1 1-.5-.1-.9-.7-.8-1.3.1-.6.6-1 1.1-1 .5.1.8.7.7 1.3m-7-1.4c0 .6-.5 1-1 1-.5-.1-.8-.7-.7-1.3 0-.6.6-1 1-1 .5.1.9.7.8 1.3"
}), React508.createElement("path", {
  stroke: "#DB836E",
  d: "m99.2 73.6-.9 1.7-.3 4.3h-2.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#5C2552",
  d: "M100 73.3s1.7-.7 2.4.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#DB836E",
  d: "M81.4 73s.4-1 1-.6c.7.4 1.4 1.4.6 2s.2 1.6.2 1.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#5C2552",
  d: "M92.3 71.7s1.9 1.1 4.2 1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#DB836E",
  d: "M92.7 80.6s2.3 1.2 4.4 1.2m-3.4 1.4s1 .4 1.5.3M83.7 80s1.8 6.6 9.2 8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#E4EBF7",
  d: "M95.5 91.7s-1 2.8-8.2 2c-7.3-.6-10.3-5-10.3-5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M78.1 87.5s6.6 5 16.5 2.5c0 0 9.6 1 11.5 5.3 5.4 11.8.6 36.8 0 40 3.5 4-.4 8.4-.4 8.4-15.7-3.5-35.8-.6-35.8-.6-4.9-3.5-1.3-9-1.3-9l-6.2-23.8c-2.5-15.2.8-19.8 3.5-20.7 3-1 8-1.3 8-1.3.6 0 1.1 0 1.4-.2 2.4-1.3 2.8-.6 2.8-.6"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M65.8 89.8s-6.8.5-7.6 8.2c-.4 8.8 3 11 3 11s6.1 22 16.9 22.9c8.4-2.2 4.7-6.7 4.6-11.4-.2-11.3-7-17-7-17s-4.3-13.7-9.9-13.7"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M71.7 124.2s.9 11.3 9.8 6.5c4.8-2.5 7.6-13.8 9.8-22.6A201 201 0 0 0 94 96l-5-1.7s-2.4 5.6-7.7 12.3c-4.4 5.5-9.2 11.1-9.5 17.7"
}), React508.createElement("path", {
  stroke: "#E4EBF7",
  d: "M108.5 105.2s1.7 2.7-2.4 30.5c2.4 2.2 1 6-.2 7.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M123.3 131.5s-.5 2.8-11.8 2c-15.2-1-25.3-3.2-25.3-3.2l.9-5.8s.7.2 9.7-.1c11.9-.4 18.7-6 25-1 4 3.2 1.5 8.1 1.5 8.1"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M70.2 91s-5.6-4.8-11 2.7c-3.3 7.2.5 15.2 2.6 19.5-.3 3.8 2.4 4.3 2.4 4.3s0 1 1.5 2.7c4-7 6.7-9.1 13.7-12.5-.3-.7-1.9-3.3-1.8-3.8.2-1.7-1.3-2.6-1.3-2.6s-.3-.2-1.2-2.8c-.8-2.3-2-5.1-4.9-7.5"
}), React508.createElement("path", {
  fill: "#CBD1D1",
  d: "M90.2 288s4.9 2.3 8.3 1.2c3.2-1 5.2.7 8 1.3a20 20 0 0 0 13.3-1.4c-.2-6.2-7.8-4.5-13.6-7.6-2.9-1.6-4.2-5.3-4-10H91.5s-1.5 12-1.3 16.5"
}), React508.createElement("path", {
  fill: "#2B0849",
  d: "M90.2 287.8s2.8 1.5 7.6.8c3.5-.5 3.3.6 7.5 1.3 4.2.6 13-.2 14.3-1.2.5 1.3-.4 2.4-.4 2.4s-1.7.6-5.4.9c-2.3.1-8.1.3-10.2-.6-2-1.6-4.9-1.5-6-.3-4.5 1.1-7.2-.3-7.2-.3l-.2-3z"
}), React508.createElement("path", {
  fill: "#A4AABA",
  d: "M98.4 272.3h3.5s0 7.5 5.2 9.6c-5.3.7-9.7-2.6-8.7-9.6"
}), React508.createElement("path", {
  fill: "#CBD1D1",
  d: "M44.4 272s-2.2 7.8-4.7 13c-1.9 3.8-4.4 7.8 5.8 7.8 7 0 9.3-.5 7.7-7-1.6-6.3.3-13.8.3-13.8h-9z"
}), React508.createElement("path", {
  fill: "#2B0849",
  d: "M38 290.3s2.3 1.2 7 1.2c6.4 0 8.7-1.7 8.7-1.7s.6 1.1-.7 2.2c-1 1-3.8 1.7-7.7 1.7-4.4 0-6.1-.6-7-1.3-1-.5-.8-1.6-.2-2.1"
}), React508.createElement("path", {
  fill: "#A4AABA",
  d: "M45.3 274s0 1.6-.3 3.1-1.1 3.3-1.2 4.4c0 1.2 4.8 1.6 5.4 0 .7-1.6 1.4-6.8 2-7.6.7-.9-5.1-2.2-5.9.1"
}), React508.createElement("path", {
  fill: "#7BB2F9",
  d: "M89.5 277.6h13.9s1.3-56.6 1.9-66.8c.6-10.3 4-45.1 1-65.6l-13-.7-23.7.8-1.3 10.4c0 .5-.7.9-.8 1.4 0 .6.5 1.4.4 2L59.6 206c-.1.7-1.3 1-1.5 2.8 0 .3.2 1.6.1 1.8-7.1 19.5-12.2 52.6-15.6 67.2h15.1L62 259c3-13.3 24-88.3 24-88.3l3.2-1-.2 48.6s-.2 1.3.4 2.1c.5.8-.6 1.2-.4 2.4l.4 1.8-1 12.4c-.4 4.9 1.2 40.7 1.2 40.7"
}), React508.createElement("path", {
  stroke: "#648BD8",
  d: "M64.6 218.9c1.2 0 4.2-2.1 7.2-5.1m24.2 8.7s3-1.1 6.4-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#648BD8",
  d: "M97 219.4s2.9-1.2 6.3-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1"
}), React508.createElement("path", {
  stroke: "#648BD8",
  d: "M63.2 222.1s2.7-.6 6.7-3.5m5-72.4c-.3 3.2.3 8.8-4.5 9.4m22.8-11.3s.1 14.6-1.4 15.7c-2.3 1.7-3 2-3 2m.4-17s.3 13-1 25m-4.7.7s6.8-1 9.1-1M46 270l-.9 4.6m1.8-11.3-.8 4.1m16.6-64.9c-.3 1.6 0 2-.4 3.4 0 0-2.8 2-2.3 4s-.3 3.4-4.5 17.2c-1.8 5.8-4.3 19-6.2 28.3l-1.1 5.8m16-67-1 4.9m8.1-52.3-1.2 10.9s-1.2.1-.5 2.3c0 1.4-2.8 16.4-5.4 31.6m-20 82.1h13.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#192064",
  d: "M106.2 142.1c-3-.5-18.8-2.7-36.2.2a.6.6 0 0 0-.6.7v3a.6.6 0 0 0 .8.6c3.3-.5 17-2.4 35.6-.3.4 0 .7-.2.7-.5.2-1.4.2-2.5.2-3a.6.6 0 0 0-.5-.7"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M96.4 145.3v-5.1a.8.8 0 0 0-.8-.9 114.1 114.1 0 0 0-8.1 0 .8.8 0 0 0-.9.8v5.1c0 .5.4.9.9.9h8a.8.8 0 0 0 .9-.8"
}), React508.createElement("path", {
  fill: "#192064",
  d: "M95.2 144.3v-3.2a.7.7 0 0 0-.6-.7h-6.1a.7.7 0 0 0-.6.7v3.2c0 .4.3.7.6.7h6c.4 0 .7-.3.7-.7"
}), React508.createElement("path", {
  stroke: "#648BD8",
  d: "M90.1 273.5h12.8m-11.7-3.7v6.3m-.3-12.6v4.5m-.5-97.6 1 46.4s.7 1.6-.3 2.8c-.9 1.1 2.6.7 1 2.3-1.7 1.6.9 1.2 0 3.5-.6 1.6-1 22-1.2 36.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#E4EBF7",
  d: "M73.7 98.7 76 103s2 .8 1.8 2.7l.8 2.2m-14.3 8.7c.2-1 2.2-7.1 12.6-10.5m.7-16s7.7 6 16.5 2.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M92 87s5.5-.9 7.5-4.6c1.3-.3.8 2.2-.3 3.7l-1 1.5s.2.3.2.9c0 .6-.2.6-.3 1v1l-.4 1c-.1.2 0 .6-.2.9-.2.4-1.6 1.8-2.6 2.8-3.8 3.6-5 1.7-6-.4-1-1.8-.7-5.1-.9-6.9-.3-2.9-2.6-3-2-4.4.4-.7 3 .7 3.4 1.8.7 2 2.9 1.8 2.6 1.7"
}), React508.createElement("path", {
  stroke: "#DB836E",
  d: "M99.8 82.4c-.5.1-.3.3-1 1.3-.6 1-4.8 2.9-6.4 3.2-2.5.5-2.2-1.6-4.2-2.9-1.7-1-3.6-.6-1.4 1.4 1 1 1 1.1 1.4 3.2.3 1.5-.7 3.7.7 5.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React508.createElement("path", {
  stroke: "#E59788",
  d: "M79.5 108.7c-2 2.9-4.2 6.1-5.5 8.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React508.createElement("path", {
  fill: "#FFC6A0",
  d: "M87.7 124.8s-2-2-5.1-2.8c-3-.7-3.6-.1-5.5.1-2 .3-4-.9-3.7.7.3 1.7 5 1 5.2 2.1.2 1.1-6.3 2.8-8.3 2.2-.8.8.5 1.9 2 2.2.3 1.5 2.3 1.5 2.3 1.5s.7 1 2.6 1.1c2.5 1.3 9-.7 11-1.5 2-.9-.5-5.6-.5-5.6"
}), React508.createElement("path", {
  stroke: "#E59788",
  d: "M73.4 122.8s.7 1.2 3.2 1.4c2.3.3 2.6.6 2.6.6s-2.6 3-9.1 2.3m2.3 2.2s3.8 0 5-.7m-2.4 2.2s2 0 3.3-.6m-1 1.7s1.7 0 2.8-.5m-6.8-9s-.6-1.1 1.3-.5c1.7.5 2.8 0 5.1.1 1.4.1 3-.2 4 .2 1.6.8 3.6 2.2 3.6 2.2s10.6 1.2 19-1.1M79 108s-8.4 2.8-13.2 12.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React508.createElement("path", {
  stroke: "#E4EBF7",
  d: "M109.3 112.5s3.4-3.6 7.6-4.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  stroke: "#E59788",
  d: "M107.4 123s9.7-2.7 11.4-.9",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React508.createElement("path", {
  stroke: "#BFCDDD",
  d: "m194.6 83.7 4-4M187.2 91l3.7-3.6m.9-3-4.5-4.7m11.2 11.5-4.2-4.3m-65 76.3 3.7-3.7M122.3 170l3.5-3.5m.8-2.9-4.3-4.2M133 170l-4-4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "2"
}), React508.createElement("path", {
  fill: "#A3B4C6",
  d: "M190.2 211.8h-1.6a4 4 0 0 1-4-4v-32.1a4 4 0 0 1 4-4h1.6a4 4 0 0 1 4 4v32a4 4 0 0 1-4 4"
}), React508.createElement("path", {
  fill: "#A3B4C6",
  d: "M237.8 213a4.8 4.8 0 0 1-4.8 4.8h-86.6a4.8 4.8 0 0 1 0-9.6H233a4.8 4.8 0 0 1 4.8 4.8"
}), React508.createElement("path", {
  fill: "#A3B4C6",
  d: "M154.1 190.1h70.5v-84.6h-70.5z"
}), React508.createElement("path", {
  fill: "#BFCDDD",
  d: "M225 190.1h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2m0-59.3h-71.1a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.3v19a3.2 3.2 0 0 1-3.2 3.1"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M159.6 120.5a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8v-3.2c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8"
}), React508.createElement("path", {
  fill: "#BFCDDD",
  d: "M225 160.5h-71.2a3.2 3.2 0 0 1-3.2-3.2v-19a3.2 3.2 0 0 1 3.2-3.2h71.1a3.2 3.2 0 0 1 3.2 3.2v19a3.2 3.2 0 0 1-3.2 3.2"
}), React508.createElement("path", {
  stroke: "#7C90A5",
  d: "M173.5 130.8h49.3m-57.8 0h6m-15 0h6.7m11.1 29.8h49.3m-57.7 0h6m-15.8 0h6.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#FFF",
  d: "M159.6 151a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V147c0-.4.3-.8.8-.8h22.4c.5 0 .8.4.8.8v3.2c0 .5-.3.8-.8.8m-63 29a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.5 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m7.4 0a2.4 2.4 0 1 1 0-4.8 2.4 2.4 0 0 1 0 4.8m48.1 0h-22.4a.8.8 0 0 1-.8-.8V176c0-.5.3-.8.8-.8h22.4c.5 0 .8.3.8.8v3.2c0 .4-.3.8-.8.8"
}), React508.createElement("path", {
  fill: "#BFCDDD",
  d: "M203 221.1h-27.3a2.4 2.4 0 0 1-2.4-2.4v-11.4a2.4 2.4 0 0 1 2.4-2.5H203a2.4 2.4 0 0 1 2.4 2.5v11.4a2.4 2.4 0 0 1-2.4 2.4"
}), React508.createElement("path", {
  stroke: "#A3B4C6",
  d: "M177.3 207.2v11.5m23.8-11.5v11.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React508.createElement("path", {
  fill: "#5BA02E",
  d: "M162.9 267.9a9.4 9.4 0 0 1-9.4-9.4v-14.8a9.4 9.4 0 0 1 18.8 0v14.8a9.4 9.4 0 0 1-9.4 9.4"
}), React508.createElement("path", {
  fill: "#92C110",
  d: "M171.2 267.8a9.4 9.4 0 0 1-9.4-9.4V255a9.4 9.4 0 0 1 18.8 0v3.4a9.4 9.4 0 0 1-9.4 9.4"
}), React508.createElement("path", {
  fill: "#F2D7AD",
  d: "M181.3 293.7h-27.7a3.2 3.2 0 0 1-3.2-3.2v-20.7a3.2 3.2 0 0 1 3.2-3.2h27.7a3.2 3.2 0 0 1 3.2 3.2v20.7a3.2 3.2 0 0 1-3.2 3.2"
})));
var serverError_default = ServerError;

// node_modules/antd/es/result/style/index.js
var genBaseStyle14 = (token2) => {
  const {
    componentCls,
    lineHeightHeading3,
    iconCls,
    padding,
    paddingXL,
    paddingXS,
    paddingLG,
    marginXS,
    lineHeight
  } = token2;
  return {
    // Result
    [componentCls]: {
      padding: `${unit(token2.calc(paddingLG).mul(2).equal())} ${unit(paddingXL)}`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${componentCls} ${componentCls}-image`]: {
      width: token2.imageWidth,
      height: token2.imageHeight,
      margin: "auto"
    },
    [`${componentCls} ${componentCls}-icon`]: {
      marginBottom: paddingLG,
      textAlign: "center",
      [`& > ${iconCls}`]: {
        fontSize: token2.iconFontSize
      }
    },
    [`${componentCls} ${componentCls}-title`]: {
      color: token2.colorTextHeading,
      fontSize: token2.titleFontSize,
      lineHeight: lineHeightHeading3,
      marginBlock: marginXS,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-subtitle`]: {
      color: token2.colorTextDescription,
      fontSize: token2.subtitleFontSize,
      lineHeight,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-body`]: {
      marginTop: paddingLG,
      padding: `${unit(paddingLG)} ${unit(token2.calc(padding).mul(2.5).equal())}`,
      backgroundColor: token2.colorFillAlter
    },
    [`${componentCls} ${componentCls}-extra`]: {
      margin: token2.extraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: paddingXS,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
};
var genStatusIconStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultSuccessIconColor
    },
    [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultErrorIconColor
    },
    [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultInfoIconColor
    },
    [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultWarningIconColor
    }
  };
};
var genResultStyle = (token2) => [genBaseStyle14(token2), genStatusIconStyle(token2)];
var getStyle2 = (token2) => genResultStyle(token2);
var prepareComponentToken46 = (token2) => ({
  titleFontSize: token2.fontSizeHeading3,
  subtitleFontSize: token2.fontSize,
  iconFontSize: token2.fontSizeHeading3 * 3,
  extraMargin: `${token2.paddingLG}px 0 0 0`
});
var style_default53 = genStyleHooks("Result", (token2) => {
  const resultInfoIconColor = token2.colorInfo;
  const resultErrorIconColor = token2.colorError;
  const resultSuccessIconColor = token2.colorSuccess;
  const resultWarningIconColor = token2.colorWarning;
  const resultToken = merge2(token2, {
    resultInfoIconColor,
    resultErrorIconColor,
    resultSuccessIconColor,
    resultWarningIconColor,
    imageWidth: 250,
    imageHeight: 295
  });
  return [getStyle2(resultToken)];
}, prepareComponentToken46);

// node_modules/antd/es/result/unauthorized.js
var React509 = __toESM(require_react());
var Unauthorized = () => React509.createElement("svg", {
  width: "251",
  height: "294"
}, React509.createElement("title", null, "Unauthorized"), React509.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React509.createElement("path", {
  fill: "#E4EBF7",
  d: "M0 129v-2C0 58.3 55.6 2.7 124.2 2.7h2c68.6 0 124.2 55.6 124.2 124.1v2.1c0 68.6-55.6 124.2-124.1 124.2h-2.1A124.2 124.2 0 0 1 0 129"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M41.4 133a8.2 8.2 0 1 1-16.4-1.7 8.2 8.2 0 0 1 16.4 1.6"
}), React509.createElement("path", {
  stroke: "#FFF",
  d: "m38.7 136.4 10.4 5.9m.9 6.2-12.6 10.7",
  strokeWidth: "2"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M41.5 161.3a5.6 5.6 0 1 1-11.2-1.2 5.6 5.6 0 0 1 11.2 1.2m17.7-16a5.7 5.7 0 1 1-11.3-1.2 5.7 5.7 0 0 1 11.3 1.2m41.2-115.8H130a4.6 4.6 0 1 0 0-9.1h-29.6a4.6 4.6 0 0 0 0 9.1m11.3 18.3h29.7a4.6 4.6 0 1 0 0-9.2h-29.7a4.6 4.6 0 1 0 0 9.2"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M114 29.5h15.8a4.6 4.6 0 1 0 0 9.1H114a4.6 4.6 0 0 0 0-9.1m71.3 108.2a10 10 0 1 1-19.8-2 10 10 0 0 1 19.8 2"
}), React509.createElement("path", {
  stroke: "#FFF",
  d: "m180.2 143.8 12.5 7.1m1.1 7.5-15.1 13",
  strokeWidth: "2"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M185.6 172a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.5 1.3m18.6-16.6a6.8 6.8 0 1 1-13.6-1.4 6.8 6.8 0 0 1 13.6 1.4"
}), React509.createElement("path", {
  stroke: "#FFF",
  d: "M153 194a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm73-75.8a2.2 2.2 0 1 1-4.5 0 2.2 2.2 0 0 1 4.4 0zm-9 34.9a2.2 2.2 0 1 1-4.3 0 2.2 2.2 0 0 1 4.4 0zm-39.2-43.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm18.3-15.3a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0zm6.7 88a2.2 2.2 0 1 1-4.4 0 2.2 2.2 0 0 1 4.4 0z",
  strokeWidth: "2"
}), React509.createElement("path", {
  stroke: "#FFF",
  d: "m215.1 155.3-1.9 20-10.8 6m-27.8-4.7-6.3 9.8H157l-4.5 6.4m23.4-65.5v-15.7m45.6 7.8-12.8 7.9-15.2-7.9V96.7",
  strokeWidth: "2"
}), React509.createElement("path", {
  fill: "#A26EF4",
  d: "M180.7 29.3a29.3 29.3 0 1 1 58.6 0 29.3 29.3 0 0 1-58.6 0"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "m221.4 41.7-21.5-.1a1.7 1.7 0 0 1-1.7-1.8V27.6a1.7 1.7 0 0 1 1.8-1.7h21.5c1 0 1.8.9 1.8 1.8l-.1 12.3a1.7 1.7 0 0 1-1.7 1.7"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M215.1 29.2c0 2.6-2 4.6-4.5 4.6a4.6 4.6 0 0 1-4.5-4.7v-6.9c0-2.6 2-4.6 4.6-4.6 2.5 0 4.5 2 4.4 4.7v6.9zm-4.5-14a6.9 6.9 0 0 0-7 6.8v7.3a6.9 6.9 0 0 0 13.8.1V22a6.9 6.9 0 0 0-6.8-6.9zm-43 53.2h-4a4.7 4.7 0 0 1-4.7-4.8 4.7 4.7 0 0 1 4.7-4.7h4a4.7 4.7 0 0 1 4.7 4.8 4.7 4.7 0 0 1-4.7 4.7"
}), React509.createElement("path", {
  fill: "#5BA02E",
  d: "M168.2 248.8a6.6 6.6 0 0 1-6.6-6.6v-66a6.6 6.6 0 0 1 13.2 0v66a6.6 6.6 0 0 1-6.6 6.6"
}), React509.createElement("path", {
  fill: "#92C110",
  d: "M176.1 248.2a6.6 6.6 0 0 1-6.6-6.6v-33a6.6 6.6 0 1 1 13.3 0v33a6.6 6.6 0 0 1-6.7 6.6"
}), React509.createElement("path", {
  fill: "#F2D7AD",
  d: "M186 293.9h-27.4a3.2 3.2 0 0 1-3.2-3.2v-45.9a3.2 3.2 0 0 1 3.2-3.1H186a3.2 3.2 0 0 1 3.2 3.1v46a3.2 3.2 0 0 1-3.2 3"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M82 147.7s6.3-1 17.5-1.3c11.8-.4 17.6 1 17.6 1s3.7-3.8 1-8.3c1.3-12.1 6-32.9.3-48.3-1.1-1.4-3.7-1.5-7.5-.6-1.4.3-7.2-.2-8-.1l-15.3-.4-8-.5c-1.6-.1-4.3-1.7-5.5-.3-.4.4-2.4 5.6-2 16l8.7 35.7s-3.2 3.6 1.2 7"
}), React509.createElement("path", {
  fill: "#FFC6A0",
  d: "m75.8 73.3-1-6.4 12-6.5s7.4-.1 8 1.2c.8 1.3-5.5 1-5.5 1s-1.9 1.4-2.6 2.5c-1.7 2.4-1 6.5-8.4 6-1.7.3-2.5 2.2-2.5 2.2"
}), React509.createElement("path", {
  fill: "#FFB594",
  d: "M52.4 77.7S66.7 87 77.4 92c1 .5-2 16.2-11.9 11.8-7.4-3.3-20.1-8.4-21.5-14.5-.7-3.2 2.6-7.6 8.4-11.7M142 80s-6.7 3-13.9 6.9c-3.9 2.1-10.1 4.7-12.3 8-6.2 9.3 3.5 11.2 13 7.5 6.6-2.7 29-12.1 13.2-22.4"
}), React509.createElement("path", {
  fill: "#FFC6A0",
  d: "m76.2 66.4 3 3.8S76.4 73 73 76c-7 6.2-12.8 14.3-16 16.4-4 2.7-9.7 3.3-12.2 0-3.5-5.1.5-14.7 31.5-26"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M64.7 85.1s-2.4 8.4-9 14.5c.7.5 18.6 10.5 22.2 10 5.2-.6 6.4-19 1.2-20.5-.8-.2-6-1.3-8.9-2.2-.9-.2-1.6-1.7-3.5-1l-2-.8zm63.7.7s5.3 2 7.3 13.8c-.6.2-17.6 12.3-21.8 7.8-6.6-7-.8-17.4 4.2-18.6 4.7-1.2 5-1.4 10.3-3"
}), React509.createElement("path", {
  stroke: "#E4EBF7",
  d: "M78.2 94.7s.9 7.4-5 13",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  stroke: "#E4EBF7",
  d: "M87.4 94.7s3.1 2.6 10.3 2.6c7.1 0 9-3.5 9-3.5",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".9"
}), React509.createElement("path", {
  fill: "#FFC6A0",
  d: "m117.2 68.6-6.8-6.1s-5.4-4.4-9.2-1c-3.9 3.5 4.4 2.2 5.6 4.2 1.2 2.1.9 1.2-2 .5-5.7-1.4-2.1.9 3 5.3 2 1.9 7 1 7 1l2.4-3.9z"
}), React509.createElement("path", {
  fill: "#FFB594",
  d: "m105.3 91.3-.3-11H89l-.5 10.5c0 .4.2.8.6 1 2 1.3 9.3 5 15.8.4.2-.2.4-.5.4-.9"
}), React509.createElement("path", {
  fill: "#5C2552",
  d: "M107.6 74.2c.8-1.1 1-9 1-11.9a1 1 0 0 0-1-1l-4.6-.4c-7.7-1-17 .6-18.3 6.3-5.4 5.9-.4 13.3-.4 13.3s2 3.5 4.3 6.8c.8 1 .4-3.8 3-6a47.9 47.9 0 0 1 16-7"
}), React509.createElement("path", {
  fill: "#FFC6A0",
  d: "M88.4 83.2s2.7 6.2 11.6 6.5c7.8.3 9-7 7.5-17.5l-1-5.5c-6-2.9-15.4.6-15.4.6s-.6 2-.2 5.5c-2.3 2-1.8 5.6-1.8 5.6s-1-2-2-2.3c-.9-.3-2 0-2.3 2-1 4.6 3.6 5.1 3.6 5.1"
}), React509.createElement("path", {
  stroke: "#DB836E",
  d: "m100.8 77.1 1.7-1-1-4.3.7-1.4",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  fill: "#552950",
  d: "M105.5 74c0 .8-.4 1.4-1 1.4-.4 0-.8-.7-.8-1.4s.5-1.2 1-1.2.9.6.8 1.3m-8 .2c0 .8-.4 1.3-.9 1.3s-.9-.6-.9-1.3c0-.7.5-1.3 1-1.3s1 .6.9 1.3"
}), React509.createElement("path", {
  stroke: "#DB836E",
  d: "M91.1 86.8s5.3 5 12.7 2.3",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  fill: "#DB836E",
  d: "M99.8 81.9s-3.6.2-1.5-2.8c1.6-1.5 5-.4 5-.4s1 3.9-3.5 3.2"
}), React509.createElement("path", {
  stroke: "#5C2552",
  d: "M102.9 70.6s2.5.8 3.4.7m-12.4.7s2.5-1.2 4.8-1.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.5"
}), React509.createElement("path", {
  stroke: "#DB836E",
  d: "M86.3 77.4s1 .9 1.5 2c-.4.6-1 1.2-.3 1.9m11.8 2.4s2 .2 2.5-.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  stroke: "#E4EBF7",
  d: "m87.8 115.8 15.7-3m-3.3 3 10-2m-43.7-27s-1.6 8.8-6.7 14M128.3 88s3 4 4 11.7",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  stroke: "#DB836E",
  d: "M64 84.8s-6 10-13.5 10",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React509.createElement("path", {
  fill: "#FFC6A0",
  d: "m112.4 66-.2 5.2 12 9.2c4.5 3.6 8.9 7.5 11 8.7 4.8 2.8 8.9 3.3 11 1.8 4.1-2.9 4.4-9.9-8.1-15.3-4.3-1.8-16.1-6.3-25.7-9.7"
}), React509.createElement("path", {
  stroke: "#DB836E",
  d: "M130.5 85.5s4.6 5.7 11.7 6.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".8"
}), React509.createElement("path", {
  stroke: "#E4EBF7",
  d: "M121.7 105.7s-.4 8.6-1.3 13.6",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  stroke: "#648BD8",
  d: "M115.8 161.5s-3.6-1.5-2.7-7.1",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  fill: "#CBD1D1",
  d: "M101.5 290.2s4.3 2.1 7.4 1c2.9-.9 4.6.7 7.2 1.3 2.5.5 6.9 1 11.7-1.3 0-5.6-7-4-12-6.8-2.6-1.4-3.8-4.7-3.6-8.8h-9.5s-1.4 10.6-1.2 14.6"
}), React509.createElement("path", {
  fill: "#2B0849",
  d: "M101.5 290s2.4 1.4 6.8.7c3-.4 3.7.5 7.5 1 3.7.6 10.8 0 11.9-.8.4 1-.4 2-.4 2s-1.5.7-4.8.9c-2 .1-5.8.3-7.7-.5-1.8-1.4-5.2-2-5.7-.3-4 1-7.4-.3-7.4-.3l-.2-2.6z"
}), React509.createElement("path", {
  fill: "#A4AABA",
  d: "M108.8 276.2h3.1s0 6.7 4.6 8.6c-4.7.6-8.6-2.3-7.7-8.6"
}), React509.createElement("path", {
  fill: "#CBD1D1",
  d: "M57.6 272.5s-2 7.5-4.5 12.4c-1.8 3.7-4.2 7.6 5.5 7.6 6.7 0 9-.5 7.5-6.7-1.5-6.1.3-13.3.3-13.3h-8.8z"
}), React509.createElement("path", {
  fill: "#2B0849",
  d: "M51.5 290s2.2 1.2 6.7 1.2c6.1 0 8.3-1.6 8.3-1.6s.6 1-.6 2.1c-1 .9-3.6 1.6-7.4 1.6-4.2 0-6-.6-6.8-1.2-.9-.5-.7-1.6-.2-2"
}), React509.createElement("path", {
  fill: "#A4AABA",
  d: "M58.5 274.4s0 1.6-.3 3-1 3.1-1.1 4.2c0 1.1 4.5 1.5 5.2 0 .6-1.6 1.3-6.5 1.9-7.3.6-.8-5-2.1-5.7.1"
}), React509.createElement("path", {
  fill: "#7BB2F9",
  d: "m100.9 277 13.3.1s1.3-54.2 1.8-64c.6-9.9 3.8-43.2 1-62.8l-12.4-.7-22.8.8-1.2 10c0 .4-.6.8-.7 1.3 0 .6.4 1.3.3 2-2.3 14-6.3 32.9-8.7 46.4-.1.6-1.2 1-1.4 2.6 0 .3.2 1.6 0 1.8-6.8 18.7-10.8 47.6-14.1 61.6h14.5s2.2-8.6 4-17a3984 3984 0 0 1 23-84.5l3-.5 1 46.1s-.2 1.2.4 2c.5.8-.6 1.1-.4 2.3l.4 1.7-1 11.9c-.4 4.6 0 39 0 39"
}), React509.createElement("path", {
  stroke: "#648BD8",
  d: "M77.4 220.4c1.2.1 4-2 7-4.9m23.1 8.4s2.8-1 6.1-3.8",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  stroke: "#648BD8",
  d: "M108.5 221s2.7-1.2 6-4",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}), React509.createElement("path", {
  stroke: "#648BD8",
  d: "M76.1 223.6s2.6-.6 6.5-3.4m4.7-69.4c-.2 3.1.3 8.5-4.3 9m21.8-10.7s.1 14-1.3 15c-2.2 1.6-3 1.9-3 1.9m.5-16.4s0 12.8-1.2 24.3m-4.9 1s7.2-1.6 9.4-1.6m-28.6 31.5-1 4.5s-1.5 1.8-1 3.7c.4 2-1 2-5 15.3-1.7 5.6-4.4 18.5-6.3 27.5l-4 18.4M77 196.7a313.3 313.3 0 0 1-.8 4.8m7.7-50-1.2 10.3s-1 .2-.5 2.3c.1 1.3-2.6 15.6-5.1 30.2M57.6 273h13.2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
}), React509.createElement("path", {
  fill: "#192064",
  d: "M117.4 147.4s-17-3-35.7.2v4.2s14.6-2.9 35.5-.4l.2-4"
}), React509.createElement("path", {
  fill: "#FFF",
  d: "M107.5 150.4v-5a.8.8 0 0 0-.8-.7H99a.8.8 0 0 0-.7.8v4.8c0 .5.3.9.8.8a140.8 140.8 0 0 1 7.7 0 .8.8 0 0 0 .8-.7"
}), React509.createElement("path", {
  fill: "#192064",
  d: "M106.4 149.4v-3a.6.6 0 0 0-.6-.7 94.1 94.1 0 0 0-5.8 0 .6.6 0 0 0-.7.7v3c0 .4.3.7.7.7h5.7c.4 0 .7-.3.7-.7"
}), React509.createElement("path", {
  stroke: "#648BD8",
  d: "M101.5 274h12.3m-11.1-5v6.5m0-12.4v4.3m-.5-93.4.9 44.4s.7 1.6-.2 2.7c-1 1.1 2.4.7.9 2.2-1.6 1.6.9 1.1 0 3.4-.6 1.5-1 21-1.1 35",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "1.1"
})));
var unauthorized_default = Unauthorized;

// node_modules/antd/es/result/index.js
var IconMap = {
  success: CheckCircleFilled_default,
  error: CloseCircleFilled_default,
  info: ExclamationCircleFilled_default,
  warning: WarningFilled_default
};
var ExceptionMap = {
  "404": noFound_default,
  "500": serverError_default,
  "403": unauthorized_default
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon3 = ({
  icon,
  status,
  className,
  style: style2
}) => {
  if (true) {
    const warning5 = devUseWarning("Result");
    true ? warning5(!(typeof icon === "string" && icon.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${icon}\` at https://ant.design/components/icon`) : void 0;
  }
  if (ExceptionStatus.includes(`${status}`)) {
    const SVGComponent = ExceptionMap[status];
    return React510.createElement("div", {
      className,
      style: style2
    }, React510.createElement(SVGComponent, null));
  }
  const iconNode = React510.createElement(IconMap[status]);
  if (icon === null || icon === false) {
    return null;
  }
  return React510.createElement("div", {
    className,
    style: style2
  }, icon || iconNode);
};
var Extra = ({
  className,
  extra,
  style: style2
}) => {
  if (!extra) {
    return null;
  }
  return React510.createElement("div", {
    className,
    style: style2
  }, extra);
};
var Result = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className: customizeClassName,
    rootClassName,
    subTitle,
    title,
    style: style2,
    children,
    status = "info",
    icon,
    extra,
    styles,
    classNames
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("result");
  const mergedProps = {
    ...props,
    status
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const prefixCls = getPrefixCls("result", customizePrefixCls);
  const [hashId, cssVarCls] = style_default53(prefixCls);
  const rootClassNames = clsx(prefixCls, `${prefixCls}-${status}`, customizeClassName, contextClassName, rootClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, cssVarCls, mergedClassNames.root);
  const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
  const subTitleClassNames = clsx(`${prefixCls}-subtitle`, mergedClassNames.subTitle);
  const extraClassNames = clsx(`${prefixCls}-extra`, mergedClassNames.extra);
  const bodyClassNames = clsx(`${prefixCls}-body`, mergedClassNames.body);
  const iconClassNames = clsx(`${prefixCls}-icon`, {
    [`${prefixCls}-image`]: ExceptionStatus.includes(`${status}`)
  }, mergedClassNames.icon);
  const rootStyles = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return React510.createElement("div", {
    className: rootClassNames,
    style: rootStyles
  }, React510.createElement(Icon3, {
    className: iconClassNames,
    style: mergedStyles.icon,
    status,
    icon
  }), React510.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title), subTitle && React510.createElement("div", {
    className: subTitleClassNames,
    style: mergedStyles.subTitle
  }, subTitle), React510.createElement(Extra, {
    className: extraClassNames,
    extra,
    style: mergedStyles.extra
  }), children && React510.createElement("div", {
    className: bodyClassNames,
    style: mergedStyles.body
  }, children));
};
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
if (true) {
  Result.displayName = "Result";
}
var result_default = Result;

// node_modules/antd/es/row/index.js
var row_default2 = row_default;

// node_modules/antd/es/splitter/Panel.js
var import_react202 = __toESM(require_react());
var InternalPanel = (0, import_react202.forwardRef)((props, ref) => {
  const {
    prefixCls,
    className,
    children,
    size,
    style: style2 = {}
  } = props;
  const panelClassName = clsx(`${prefixCls}-panel`, {
    [`${prefixCls}-panel-hidden`]: size === 0
  }, className);
  const hasSize = size !== void 0;
  return import_react202.default.createElement("div", {
    ref,
    className: panelClassName,
    style: {
      ...style2,
      // Use auto when start from ssr
      flexBasis: hasSize ? size : "auto",
      flexGrow: hasSize ? 0 : 1
    }
  }, children);
});
if (true) {
  InternalPanel.displayName = "Panel";
}
var Panel4 = () => null;
var Panel_default4 = Panel4;

// node_modules/antd/es/splitter/Splitter.js
var import_react205 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/useItems.js
var React512 = __toESM(require_react());
function getCollapsible(collapsible) {
  if (collapsible && typeof collapsible === "object") {
    return {
      ...collapsible,
      showCollapsibleIcon: collapsible.showCollapsibleIcon === void 0 ? "auto" : collapsible.showCollapsibleIcon
    };
  }
  const mergedCollapsible = !!collapsible;
  return {
    start: mergedCollapsible,
    end: mergedCollapsible,
    showCollapsibleIcon: "auto"
  };
}
function useItems4(children) {
  const items = React512.useMemo(() => toArray(children).filter((item) => React512.isValidElement(item)).map((node2) => {
    const {
      props
    } = node2;
    const {
      collapsible,
      ...restProps
    } = props;
    return {
      ...restProps,
      collapsible: getCollapsible(collapsible)
    };
  }), [children]);
  return items;
}
var useItems_default2 = useItems4;

// node_modules/antd/es/splitter/hooks/useResizable.js
var React513 = __toESM(require_react());
function getShowCollapsibleIcon(prev2, next2) {
  if (prev2.collapsible && next2.collapsible) {
    if (prev2.showCollapsibleIcon === true || next2.showCollapsibleIcon === true) {
      return true;
    }
    if (prev2.showCollapsibleIcon === "auto" || next2.showCollapsibleIcon === "auto") {
      return "auto";
    }
    return false;
  }
  if (prev2.collapsible) {
    return prev2.showCollapsibleIcon;
  }
  if (next2.collapsible) {
    return next2.showCollapsibleIcon;
  }
  return false;
}
function useResizable(items, pxSizes, isRTL) {
  return React513.useMemo(() => {
    const resizeInfos = [];
    for (let i = 0; i < items.length - 1; i += 1) {
      const prevItem = items[i];
      const nextItem = items[i + 1];
      const prevSize = pxSizes[i];
      const nextSize = pxSizes[i + 1];
      const {
        resizable: prevResizable = true,
        min: prevMin,
        collapsible: prevCollapsible
      } = prevItem;
      const {
        resizable: nextResizable = true,
        min: nextMin,
        collapsible: nextCollapsible
      } = nextItem;
      const mergedResizable = (
        // Both need to be resizable
        prevResizable && nextResizable && // Prev is not collapsed and limit min size
        (prevSize !== 0 || !prevMin) && // Next is not collapsed and limit min size
        (nextSize !== 0 || !nextMin)
      );
      const prevEndCollapsible = !!prevCollapsible.end && prevSize > 0;
      const nextStartExpandable = !!nextCollapsible.start && nextSize === 0 && prevSize > 0;
      const startCollapsible = prevEndCollapsible || nextStartExpandable;
      const nextStartCollapsible = !!nextCollapsible.start && nextSize > 0;
      const prevEndExpandable = !!prevCollapsible.end && prevSize === 0 && nextSize > 0;
      const endCollapsible = nextStartCollapsible || prevEndExpandable;
      const showStartCollapsibleIcon = getShowCollapsibleIcon({
        collapsible: prevEndCollapsible,
        showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
      }, {
        collapsible: nextStartExpandable,
        showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
      });
      const showEndCollapsibleIcon = getShowCollapsibleIcon({
        collapsible: nextStartCollapsible,
        showCollapsibleIcon: nextCollapsible.showCollapsibleIcon
      }, {
        collapsible: prevEndExpandable,
        showCollapsibleIcon: prevCollapsible.showCollapsibleIcon
      });
      resizeInfos[i] = {
        resizable: mergedResizable,
        startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),
        endCollapsible: !!(isRTL ? startCollapsible : endCollapsible),
        showStartCollapsibleIcon: isRTL ? showEndCollapsibleIcon : showStartCollapsibleIcon,
        showEndCollapsibleIcon: isRTL ? showStartCollapsibleIcon : showEndCollapsibleIcon
      };
    }
    return resizeInfos;
  }, [pxSizes, items, isRTL]);
}

// node_modules/antd/es/splitter/hooks/useResize.js
var React515 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/useSizes.js
var import_react203 = __toESM(require_react());

// node_modules/antd/es/splitter/hooks/sizeUtil.js
function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {
  let currentTotalPtg = 0;
  const undefinedIndexes = [];
  ptgSizes.forEach((size, index2) => {
    if (size === void 0) {
      undefinedIndexes.push(index2);
    } else {
      currentTotalPtg += size;
    }
  });
  const restPtg = 1 - currentTotalPtg;
  const undefinedCount = undefinedIndexes.length;
  if (ptgSizes.length && !undefinedIndexes.length && currentTotalPtg !== 1) {
    if (currentTotalPtg === 0) {
      const avg = 1 / ptgSizes.length;
      return ptgSizes.map(() => avg);
    }
    const scale = 1 / currentTotalPtg;
    return ptgSizes.map((size) => size * scale);
  }
  if (restPtg < 0) {
    const scale = 1 / currentTotalPtg;
    return ptgSizes.map((size) => size === void 0 ? 0 : size * scale);
  }
  let sumMin = 0;
  let sumMax = 0;
  let limitMin = 0;
  let limitMax = 1;
  for (const index2 of undefinedIndexes) {
    const min = minPtgSizes[index2] || 0;
    const max = maxPtgSizes[index2] || 1;
    sumMin += min;
    sumMax += max;
    limitMin = Math.max(limitMin, min);
    limitMax = Math.min(limitMax, max);
  }
  if (sumMin > 1 && sumMax < 1) {
    const avg = 1 / undefinedCount;
    return ptgSizes.map((size) => size === void 0 ? avg : size);
  }
  const restAvg = restPtg / undefinedCount;
  if (limitMin <= restAvg && restAvg <= limitMax) {
    return ptgSizes.map((size) => size === void 0 ? restAvg : size);
  }
  const result = _toConsumableArray(ptgSizes);
  let remain = restPtg - sumMin;
  for (let i = 0; i < undefinedCount; i += 1) {
    const index2 = undefinedIndexes[i];
    const min = minPtgSizes[index2] || 0;
    const max = maxPtgSizes[index2] || 1;
    result[index2] = min;
    const canAdd = max - min;
    const add = Math.min(canAdd, remain);
    result[index2] += add;
    remain -= add;
  }
  return result;
}

// node_modules/antd/es/splitter/hooks/useSizes.js
function getPtg(str) {
  return Number(str.slice(0, -1)) / 100;
}
function isPtg(itemSize) {
  return typeof itemSize === "string" && itemSize.endsWith("%");
}
function useSizes(items, containerSize) {
  const propSizes = items.map((item) => item.size);
  const itemsCount = items.length;
  const mergedContainerSize = containerSize || 0;
  const ptg2px = (ptg) => ptg * mergedContainerSize;
  const [innerSizes, setInnerSizes] = import_react203.default.useState(() => items.map((item) => item.defaultSize));
  const sizes2 = import_react203.default.useMemo(() => {
    const mergedSizes = [];
    for (let i = 0; i < itemsCount; i += 1) {
      mergedSizes[i] = propSizes[i] ?? innerSizes[i];
    }
    return mergedSizes;
  }, [itemsCount, innerSizes, propSizes]);
  const postPercentMinSizes = import_react203.default.useMemo(() => items.map((item) => {
    if (isPtg(item.min)) {
      return getPtg(item.min);
    }
    return (item.min || 0) / mergedContainerSize;
  }), [items, mergedContainerSize]);
  const postPercentMaxSizes = import_react203.default.useMemo(() => items.map((item) => {
    if (isPtg(item.max)) {
      return getPtg(item.max);
    }
    return (item.max || mergedContainerSize) / mergedContainerSize;
  }), [items, mergedContainerSize]);
  const postPercentSizes = import_react203.default.useMemo(() => {
    const ptgList = [];
    for (let i = 0; i < itemsCount; i += 1) {
      const itemSize = sizes2[i];
      if (isPtg(itemSize)) {
        ptgList[i] = getPtg(itemSize);
      } else if (itemSize || itemSize === 0) {
        const num = Number(itemSize);
        if (!Number.isNaN(num)) {
          ptgList[i] = num / mergedContainerSize;
        }
      } else {
        ptgList[i] = void 0;
      }
    }
    return autoPtgSizes(ptgList, postPercentMinSizes, postPercentMaxSizes);
  }, [itemsCount, sizes2, mergedContainerSize, postPercentMinSizes, postPercentMaxSizes]);
  const postPxSizes = import_react203.default.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);
  const panelSizes = import_react203.default.useMemo(() => containerSize ? postPxSizes : sizes2, [postPxSizes, sizes2, containerSize]);
  return [panelSizes, postPxSizes, postPercentSizes, postPercentMinSizes, postPercentMaxSizes, setInnerSizes];
}

// node_modules/antd/es/splitter/hooks/useResize.js
function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {
  const limitSizes = items.map((item) => [item.min, item.max]);
  const mergedContainerSize = containerSize || 0;
  const ptg2px = (ptg) => ptg * mergedContainerSize;
  function getLimitSize(str, defaultLimit) {
    if (typeof str === "string") {
      return ptg2px(getPtg(str));
    }
    return str ?? defaultLimit;
  }
  const [cacheSizes, setCacheSizes] = React515.useState([]);
  const cacheCollapsedSize = React515.useRef([]);
  const [movingIndex, setMovingIndex] = React515.useState(null);
  const getPxSizes = () => percentSizes.map(ptg2px);
  const onOffsetStart = (index2) => {
    setCacheSizes(getPxSizes());
    setMovingIndex({
      index: index2,
      confirmed: false
    });
  };
  const onOffsetUpdate = (index2, offset3) => {
    let confirmedIndex = null;
    if ((!movingIndex || !movingIndex.confirmed) && offset3 !== 0) {
      if (offset3 > 0) {
        confirmedIndex = index2;
        setMovingIndex({
          index: index2,
          confirmed: true
        });
      } else {
        for (let i = index2; i >= 0; i -= 1) {
          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {
            confirmedIndex = i;
            setMovingIndex({
              index: i,
              confirmed: true
            });
            break;
          }
        }
      }
    }
    const mergedIndex = confirmedIndex ?? (movingIndex == null ? void 0 : movingIndex.index) ?? index2;
    const numSizes = _toConsumableArray(cacheSizes);
    const nextIndex = mergedIndex + 1;
    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);
    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);
    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);
    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);
    let mergedOffset = offset3;
    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {
      mergedOffset = startMinSize - numSizes[mergedIndex];
    }
    if (numSizes[nextIndex] - mergedOffset < endMinSize) {
      mergedOffset = numSizes[nextIndex] - endMinSize;
    }
    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {
      mergedOffset = startMaxSize - numSizes[mergedIndex];
    }
    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {
      mergedOffset = numSizes[nextIndex] - endMaxSize;
    }
    numSizes[mergedIndex] += mergedOffset;
    numSizes[nextIndex] -= mergedOffset;
    updateSizes(numSizes);
    return numSizes;
  };
  const onOffsetEnd = () => {
    setMovingIndex(null);
  };
  const onCollapse = (index2, type5) => {
    const currentSizes = getPxSizes();
    const adjustedType = isRTL ? type5 === "start" ? "end" : "start" : type5;
    const currentIndex = adjustedType === "start" ? index2 : index2 + 1;
    const targetIndex = adjustedType === "start" ? index2 + 1 : index2;
    const currentSize = currentSizes[currentIndex];
    const targetSize = currentSizes[targetIndex];
    if (currentSize !== 0 && targetSize !== 0) {
      currentSizes[currentIndex] = 0;
      currentSizes[targetIndex] += currentSize;
      cacheCollapsedSize.current[index2] = currentSize;
    } else {
      const totalSize = currentSize + targetSize;
      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);
      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);
      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);
      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);
      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);
      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);
      const halfOffset = targetSizeMin || (limitEnd - limitStart) / 2;
      const targetCacheCollapsedSize = cacheCollapsedSize.current[index2];
      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;
      if (shouldUseCache) {
        currentSizes[targetIndex] = targetCacheCollapsedSize;
        currentSizes[currentIndex] = currentCacheCollapsedSize;
      } else {
        currentSizes[currentIndex] -= halfOffset;
        currentSizes[targetIndex] += halfOffset;
      }
    }
    updateSizes(currentSizes);
    return currentSizes;
  };
  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex == null ? void 0 : movingIndex.index];
}

// node_modules/antd/es/splitter/SplitBar.js
var import_react204 = __toESM(require_react());
function getValidNumber(num) {
  return typeof num === "number" && !Number.isNaN(num) && Number.isFinite(num) ? Math.round(num) : 0;
}
var SplitBar = (props) => {
  const {
    prefixCls,
    vertical,
    index: index2,
    active,
    ariaNow,
    ariaMin,
    ariaMax,
    resizable,
    draggerIcon,
    draggerStyle,
    draggerClassName,
    collapsibleIcon,
    startCollapsible,
    endCollapsible,
    onOffsetStart,
    onOffsetUpdate,
    onOffsetEnd,
    onCollapse,
    lazy,
    containerSize,
    showStartCollapsibleIcon,
    showEndCollapsibleIcon
  } = props;
  const splitBarPrefixCls = `${prefixCls}-bar`;
  const [startPos, setStartPos] = (0, import_react204.useState)(null);
  const [constrainedOffset, setConstrainedOffset] = (0, import_react204.useState)(0);
  const constrainedOffsetX = vertical ? 0 : constrainedOffset;
  const constrainedOffsetY = vertical ? constrainedOffset : 0;
  const onMouseDown = (e3) => {
    if (resizable && e3.currentTarget) {
      setStartPos([e3.pageX, e3.pageY]);
      onOffsetStart(index2);
    }
  };
  const onTouchStart = (e3) => {
    if (resizable && e3.touches.length === 1) {
      const touch = e3.touches[0];
      setStartPos([touch.pageX, touch.pageY]);
      onOffsetStart(index2);
    }
  };
  const getConstrainedOffset = (rawOffset) => {
    const currentPos = containerSize * ariaNow / 100;
    const newPos = currentPos + rawOffset;
    const minAllowed = Math.max(0, containerSize * ariaMin / 100);
    const maxAllowed = Math.min(containerSize, containerSize * ariaMax / 100);
    const clampedPos = Math.max(minAllowed, Math.min(maxAllowed, newPos));
    return clampedPos - currentPos;
  };
  const handleLazyMove = useEvent_default((offsetX, offsetY) => {
    const constrainedOffsetValue = getConstrainedOffset(vertical ? offsetY : offsetX);
    setConstrainedOffset(constrainedOffsetValue);
  });
  const handleLazyEnd = useEvent_default(() => {
    onOffsetUpdate(index2, constrainedOffsetX, constrainedOffsetY, true);
    setConstrainedOffset(0);
    onOffsetEnd(true);
  });
  const getVisibilityClass = (mode) => {
    switch (mode) {
      case true:
        return `${splitBarPrefixCls}-collapse-bar-always-visible`;
      case false:
        return `${splitBarPrefixCls}-collapse-bar-always-hidden`;
      case "auto":
        return `${splitBarPrefixCls}-collapse-bar-hover-only`;
    }
  };
  useLayoutEffect_default(() => {
    if (!startPos) {
      return;
    }
    const onMouseMove = (e3) => {
      const {
        pageX,
        pageY
      } = e3;
      const offsetX = pageX - startPos[0];
      const offsetY = pageY - startPos[1];
      if (lazy) {
        handleLazyMove(offsetX, offsetY);
      } else {
        onOffsetUpdate(index2, offsetX, offsetY);
      }
    };
    const onMouseUp = () => {
      if (lazy) {
        handleLazyEnd();
      } else {
        onOffsetEnd();
      }
      setStartPos(null);
    };
    const handleTouchMove = (e3) => {
      if (e3.touches.length === 1) {
        const touch = e3.touches[0];
        const offsetX = touch.pageX - startPos[0];
        const offsetY = touch.pageY - startPos[1];
        if (lazy) {
          handleLazyMove(offsetX, offsetY);
        } else {
          onOffsetUpdate(index2, offsetX, offsetY);
        }
      }
    };
    const handleTouchEnd = () => {
      if (lazy) {
        handleLazyEnd();
      } else {
        onOffsetEnd();
      }
      setStartPos(null);
    };
    const eventHandlerMap = {
      mousemove: onMouseMove,
      mouseup: onMouseUp,
      touchmove: handleTouchMove,
      touchend: handleTouchEnd
    };
    for (const [event, handler] of Object.entries(eventHandlerMap)) {
      window.addEventListener(event, handler);
    }
    return () => {
      for (const [event, handler] of Object.entries(eventHandlerMap)) {
        window.removeEventListener(event, handler);
      }
    };
  }, [startPos, index2, lazy]);
  const transformStyle = {
    [`--${splitBarPrefixCls}-preview-offset`]: `${constrainedOffset}px`
  };
  const [startIcon, endIcon, startCustomize, endCustomize] = import_react204.default.useMemo(() => {
    let startIcon2 = null;
    let endIcon2 = null;
    const startCustomize2 = (collapsibleIcon == null ? void 0 : collapsibleIcon.start) !== void 0;
    const endCustomize2 = (collapsibleIcon == null ? void 0 : collapsibleIcon.end) !== void 0;
    if (vertical) {
      startIcon2 = startCustomize2 ? collapsibleIcon.start : import_react204.default.createElement(UpOutlined_default, null);
      endIcon2 = endCustomize2 ? collapsibleIcon.end : import_react204.default.createElement(DownOutlined_default, null);
    } else {
      startIcon2 = startCustomize2 ? collapsibleIcon.start : import_react204.default.createElement(LeftOutlined_default, null);
      endIcon2 = endCustomize2 ? collapsibleIcon.end : import_react204.default.createElement(RightOutlined_default, null);
    }
    return [startIcon2, endIcon2, startCustomize2, endCustomize2];
  }, [collapsibleIcon, vertical]);
  return import_react204.default.createElement("div", {
    className: splitBarPrefixCls,
    role: "separator",
    "aria-valuenow": getValidNumber(ariaNow),
    "aria-valuemin": getValidNumber(ariaMin),
    "aria-valuemax": getValidNumber(ariaMax)
  }, lazy && import_react204.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-preview`, {
      [`${splitBarPrefixCls}-preview-active`]: !!constrainedOffset
    }),
    style: transformStyle
  }), import_react204.default.createElement("div", {
    style: draggerStyle,
    className: clsx(`${splitBarPrefixCls}-dragger`, {
      [`${splitBarPrefixCls}-dragger-disabled`]: !resizable,
      [`${splitBarPrefixCls}-dragger-active`]: active,
      [`${splitBarPrefixCls}-dragger-customize`]: draggerIcon !== void 0
    }, draggerClassName == null ? void 0 : draggerClassName.default, active && (draggerClassName == null ? void 0 : draggerClassName.active)),
    onMouseDown,
    onTouchStart
  }, draggerIcon !== void 0 ? import_react204.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-dragger-icon`)
  }, draggerIcon) : null), startCollapsible && import_react204.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-start`, {
      [`${splitBarPrefixCls}-collapse-bar-customize`]: startCustomize
    }, getVisibilityClass(showStartCollapsibleIcon)),
    onClick: () => onCollapse(index2, "start")
  }, import_react204.default.createElement("span", {
    className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-start`)
  }, startIcon)), endCollapsible && import_react204.default.createElement("div", {
    className: clsx(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-end`, {
      [`${splitBarPrefixCls}-collapse-bar-customize`]: endCustomize
    }, getVisibilityClass(showEndCollapsibleIcon)),
    onClick: () => onCollapse(index2, "end")
  }, import_react204.default.createElement("span", {
    className: clsx(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-end`)
  }, endIcon)));
};
var SplitBar_default = SplitBar;

// node_modules/antd/es/splitter/style/index.js
var genRtlStyle3 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&-rtl${componentCls}-horizontal`]: {
      [`> ${componentCls}-bar`]: {
        [`${componentCls}-bar-collapse-previous`]: {
          insetInlineEnd: 0,
          insetInlineStart: "unset"
        },
        [`${componentCls}-bar-collapse-next`]: {
          insetInlineEnd: "unset",
          insetInlineStart: 0
        }
      }
    },
    [`&-rtl${componentCls}-vertical`]: {
      [`> ${componentCls}-bar`]: {
        [`${componentCls}-bar-collapse-previous`]: {
          insetInlineEnd: "50%",
          insetInlineStart: "unset"
        },
        [`${componentCls}-bar-collapse-next`]: {
          insetInlineEnd: "50%",
          insetInlineStart: "unset"
        }
      }
    }
  };
};
var centerStyle = {
  position: "absolute",
  top: "50%",
  left: {
    _skip_check_: true,
    value: "50%"
  },
  transform: "translate(-50%, -50%)"
};
var genSplitterStyle = (token2) => {
  const {
    componentCls,
    colorFill,
    splitBarDraggableSize,
    splitBarSize,
    splitTriggerSize,
    controlItemBgHover,
    controlItemBgActive,
    controlItemBgActiveHover,
    prefixCls,
    colorPrimary
  } = token2;
  const splitBarCls = `${componentCls}-bar`;
  const splitMaskCls = `${componentCls}-mask`;
  const splitPanelCls = `${componentCls}-panel`;
  const halfTriggerSize = token2.calc(splitTriggerSize).div(2).equal();
  const splitterBarPreviewOffsetVar = `${prefixCls}-bar-preview-offset`;
  const splitterBarPreviewStyle = {
    position: "absolute",
    background: token2.colorPrimary,
    opacity: 0.2,
    pointerEvents: "none",
    transition: "none",
    zIndex: 1,
    display: "none"
  };
  return {
    [componentCls]: {
      ...resetComponent(token2),
      display: "flex",
      width: "100%",
      height: "100%",
      alignItems: "stretch",
      // ======================== SplitBar ========================
      // Use `>` to avoid conflict with mix layout
      [`> ${splitBarCls}`]: {
        flex: "none",
        position: "relative",
        userSelect: "none",
        // ======================= Dragger =======================
        [`${splitBarCls}-dragger`]: {
          ...centerStyle,
          zIndex: 1,
          // Hover background
          "&::before": {
            content: '""',
            background: controlItemBgHover,
            ...centerStyle
          },
          // Spinner
          "&::after": {
            content: '""',
            background: colorFill,
            ...centerStyle
          },
          // Hover
          [`&:hover:not(${splitBarCls}-dragger-active)`]: {
            "&::before": {
              background: controlItemBgActive
            }
          },
          // Active
          "&-active": {
            zIndex: 2,
            "&::before": {
              background: controlItemBgActiveHover
            }
          },
          [`&-active${splitBarCls}-dragger-customize`]: {
            [`${splitBarCls}-dragger-icon`]: {
              color: colorPrimary
            }
          },
          // Disabled, not use `pointer-events: none` since still need trigger collapse
          [`&-disabled${splitBarCls}-dragger`]: {
            zIndex: 0,
            "&, &:hover, &-active": {
              cursor: "default",
              "&::before": {
                background: controlItemBgHover
              }
            },
            "&::after": {
              display: "none"
            },
            [`${splitBarCls}-dragger-icon`]: {
              display: "none"
            }
          },
          // customize dragger icon
          "&-customize": {
            [`${splitBarCls}-dragger-icon`]: {
              ...centerStyle,
              display: "flex",
              alignItems: "center",
              color: colorFill
            },
            "&::after": {
              display: "none"
            }
          }
        },
        // ======================= Collapse =======================
        [`${splitBarCls}-collapse-bar`]: {
          ...centerStyle,
          zIndex: token2.zIndexPopupBase,
          background: controlItemBgHover,
          fontSize: token2.fontSizeSM,
          borderRadius: token2.borderRadiusXS,
          color: token2.colorText,
          cursor: "pointer",
          opacity: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          // Hover
          [`&:hover:not(${splitBarCls}-collapse-bar-customize)`]: {
            background: controlItemBgActive
          },
          // Active
          [`&:active:not(${splitBarCls}-collapse-bar-customize)`]: {
            background: controlItemBgActiveHover
          },
          [`${splitBarCls}-collapse-icon`]: {
            display: "flex",
            alignItems: "center"
          }
        },
        [`${splitBarCls}-collapse-bar-customize`]: {
          background: "transparent"
        },
        "&:hover, &:active": {
          [`${splitBarCls}-collapse-bar-hover-only`]: {
            opacity: 1
          }
        },
        [`${splitBarCls}-collapse-bar-hover-only`]: {
          "@media(hover:none)": {
            opacity: 1
          }
        },
        [`${splitBarCls}-collapse-bar-always-hidden`]: {
          display: "none"
        },
        [`${splitBarCls}-collapse-bar-always-visible`]: {
          opacity: 1
        }
      },
      // =========================== Mask =========================
      // Util dom for handle cursor
      [splitMaskCls]: {
        position: "fixed",
        zIndex: token2.zIndexPopupBase,
        inset: 0,
        "&-horizontal": {
          cursor: "col-resize"
        },
        "&-vertical": {
          cursor: "row-resize"
        }
      },
      // ==========================================================
      // ==                        Layout                        ==
      // ==========================================================
      "&-horizontal": {
        flexDirection: "row",
        [`> ${splitBarCls}`]: {
          width: 0,
          // ======================= Preview =======================
          [`${splitBarCls}-preview`]: {
            height: "100%",
            width: splitBarSize,
            ...splitterBarPreviewStyle,
            [`&${splitBarCls}-preview-active`]: {
              display: "block",
              transform: `translateX(var(--${splitterBarPreviewOffsetVar}))`
            }
          },
          // ======================= Dragger =======================
          [`${splitBarCls}-dragger`]: {
            cursor: "col-resize",
            height: "100%",
            width: splitTriggerSize,
            "&::before": {
              height: "100%",
              width: splitBarSize
            },
            "&::after": {
              height: splitBarDraggableSize,
              width: splitBarSize
            }
          },
          // ======================= Collapse =======================
          [`${splitBarCls}-collapse-bar`]: {
            width: token2.fontSizeSM,
            height: token2.controlHeightSM,
            "&-start": {
              left: {
                _skip_check_: true,
                value: "auto"
              },
              right: {
                _skip_check_: true,
                value: halfTriggerSize
              },
              transform: "translateY(-50%)"
            },
            "&-end": {
              left: {
                _skip_check_: true,
                value: halfTriggerSize
              },
              right: {
                _skip_check_: true,
                value: "auto"
              },
              transform: "translateY(-50%)"
            }
          }
        }
      },
      "&-vertical": {
        flexDirection: "column",
        [`> ${splitBarCls}`]: {
          height: 0,
          // ======================= Preview =======================
          [`${splitBarCls}-preview`]: {
            height: splitBarSize,
            width: "100%",
            ...splitterBarPreviewStyle,
            [`&${splitBarCls}-preview-active`]: {
              display: "block",
              transform: `translateY(var(--${splitterBarPreviewOffsetVar}))`
            }
          },
          // ======================= Dragger =======================
          [`${splitBarCls}-dragger`]: {
            cursor: "row-resize",
            width: "100%",
            height: splitTriggerSize,
            "&::before": {
              width: "100%",
              height: splitBarSize
            },
            "&::after": {
              width: splitBarDraggableSize,
              height: splitBarSize
            }
          },
          // ======================= Collapse =======================
          [`${splitBarCls}-collapse-bar`]: {
            height: token2.fontSizeSM,
            width: token2.controlHeightSM,
            "&-start": {
              top: "auto",
              bottom: halfTriggerSize,
              transform: "translateX(-50%)"
            },
            "&-end": {
              top: halfTriggerSize,
              bottom: "auto",
              transform: "translateX(-50%)"
            }
          }
        }
      },
      // ========================= Panels =========================
      [splitPanelCls]: {
        overflow: "auto",
        padding: "0 1px",
        scrollbarWidth: "thin",
        boxSizing: "border-box",
        "&-hidden": {
          padding: 0,
          overflow: "hidden"
        },
        [`&:has(${componentCls}:only-child)`]: {
          overflow: "hidden"
        }
      },
      ...genRtlStyle3(token2)
    }
  };
};
var prepareComponentToken47 = (token2) => {
  const splitBarSize = token2.splitBarSize || 2;
  const splitTriggerSize = token2.splitTriggerSize || 6;
  const resizeSpinnerSize = token2.resizeSpinnerSize || 20;
  const splitBarDraggableSize = token2.splitBarDraggableSize ?? resizeSpinnerSize;
  return {
    splitBarSize,
    splitTriggerSize,
    splitBarDraggableSize,
    resizeSpinnerSize
  };
};
var style_default54 = genStyleHooks("Splitter", genSplitterStyle, prepareComponentToken47);

// node_modules/antd/es/splitter/Splitter.js
var Splitter = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    classNames,
    style: style2,
    styles,
    layout,
    orientation,
    vertical,
    children,
    draggerIcon,
    collapsibleIcon,
    rootClassName,
    onResizeStart,
    onResize: onResize2,
    onResizeEnd,
    lazy
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("splitter");
  const prefixCls = getPrefixCls("splitter", customizePrefixCls);
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default54(prefixCls, rootCls);
  const [mergedOrientation, isVertical] = useOrientation(orientation, vertical, layout);
  const isRTL = direction === "rtl";
  const reverse = !isVertical && isRTL;
  const items = useItems_default2(children);
  if (true) {
    const warning5 = devUseWarning("Splitter");
    const existSize = items.some((item) => item.size !== void 0);
    const existUndefinedSize = items.some((item) => item.size === void 0);
    if (existSize && existUndefinedSize && !onResize2) {
      true ? warning5(false, "usage", "When part of `Splitter.Panel` has `size`, `onResize` is required or change `size` to `defaultSize`.") : void 0;
    }
    warning5.deprecated(!layout, "layout", "orientation");
  }
  const [containerSize, setContainerSize] = (0, import_react205.useState)();
  const onContainerResize = (size) => {
    const {
      offsetWidth,
      offsetHeight
    } = size;
    const containerSize2 = isVertical ? offsetHeight : offsetWidth;
    if (containerSize2 === 0) {
      return;
    }
    setContainerSize(containerSize2);
  };
  const [panelSizes, itemPxSizes, itemPtgSizes, itemPtgMinSizes, itemPtgMaxSizes, updateSizes] = useSizes(items, containerSize);
  const resizableInfos = useResizable(items, itemPxSizes, isRTL);
  const [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex] = useResize(items, resizableInfos, itemPtgSizes, containerSize, updateSizes, isRTL);
  const onInternalResizeStart = useEvent_default((index2) => {
    onOffsetStart(index2);
    onResizeStart == null ? void 0 : onResizeStart(itemPxSizes);
  });
  const onInternalResizeUpdate = useEvent_default((index2, offset3, lazyEnd) => {
    const nextSizes = onOffsetUpdate(index2, offset3);
    if (lazyEnd) {
      onResizeEnd == null ? void 0 : onResizeEnd(nextSizes);
    } else {
      onResize2 == null ? void 0 : onResize2(nextSizes);
    }
  });
  const onInternalResizeEnd = useEvent_default((lazyEnd) => {
    onOffsetEnd();
    if (!lazyEnd) {
      onResizeEnd == null ? void 0 : onResizeEnd(itemPxSizes);
    }
  });
  const onInternalCollapse = useEvent_default((index2, type5) => {
    var _a;
    const nextSizes = onCollapse(index2, type5);
    onResize2 == null ? void 0 : onResize2(nextSizes);
    onResizeEnd == null ? void 0 : onResizeEnd(nextSizes);
    const collapsed = nextSizes.map((size) => Math.abs(size) < Number.EPSILON);
    (_a = props.onCollapse) == null ? void 0 : _a.call(props, collapsed, nextSizes);
  });
  const mergedProps = {
    ...props,
    vertical: isVertical,
    orientation: mergedOrientation
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    // Convert `classNames.dragger: 'a'` to
    // `classNames.dragger: { default: 'a' }`
    dragger: {
      _default: "default"
    }
  });
  const containerClassName = clsx(prefixCls, className, `${prefixCls}-${mergedOrientation}`, {
    [`${prefixCls}-rtl`]: isRTL
  }, rootClassName, mergedClassNames.root, contextClassName, cssVarCls, rootCls, hashId);
  const maskCls = `${prefixCls}-mask`;
  const stackSizes = import_react205.default.useMemo(() => {
    const mergedSizes = [];
    let stack = 0;
    const len = items.length;
    for (let i = 0; i < len; i += 1) {
      stack += itemPtgSizes[i];
      mergedSizes.push(stack);
    }
    return mergedSizes;
  }, [itemPtgSizes, items.length]);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  return import_react205.default.createElement(es_default, {
    onResize: onContainerResize
  }, import_react205.default.createElement("div", {
    style: mergedStyle,
    className: containerClassName
  }, items.map((item, idx) => {
    const panelProps = {
      ...item,
      className: clsx(mergedClassNames.panel, item.className),
      style: {
        ...mergedStyles.panel,
        ...item.style
      }
    };
    const panel = import_react205.default.createElement(InternalPanel, {
      ...panelProps,
      prefixCls,
      size: panelSizes[idx]
    });
    let splitBar = null;
    const resizableInfo = resizableInfos[idx];
    if (resizableInfo) {
      const ariaMinStart = (stackSizes[idx - 1] || 0) + itemPtgMinSizes[idx];
      const ariaMinEnd = (stackSizes[idx + 1] || 100) - itemPtgMaxSizes[idx + 1];
      const ariaMaxStart = (stackSizes[idx - 1] || 0) + itemPtgMaxSizes[idx];
      const ariaMaxEnd = (stackSizes[idx + 1] || 100) - itemPtgMinSizes[idx + 1];
      splitBar = import_react205.default.createElement(SplitBar_default, {
        lazy,
        index: idx,
        active: movingIndex === idx,
        prefixCls,
        vertical: isVertical,
        resizable: resizableInfo.resizable,
        draggerStyle: mergedStyles.dragger,
        draggerClassName: mergedClassNames.dragger,
        draggerIcon,
        collapsibleIcon,
        ariaNow: stackSizes[idx] * 100,
        ariaMin: Math.max(ariaMinStart, ariaMinEnd) * 100,
        ariaMax: Math.min(ariaMaxStart, ariaMaxEnd) * 100,
        startCollapsible: resizableInfo.startCollapsible,
        endCollapsible: resizableInfo.endCollapsible,
        showStartCollapsibleIcon: resizableInfo.showStartCollapsibleIcon,
        showEndCollapsibleIcon: resizableInfo.showEndCollapsibleIcon,
        onOffsetStart: onInternalResizeStart,
        onOffsetUpdate: (index2, offsetX, offsetY, lazyEnd) => {
          let offset3 = isVertical ? offsetY : offsetX;
          if (reverse) {
            offset3 = -offset3;
          }
          onInternalResizeUpdate(index2, offset3, lazyEnd);
        },
        onOffsetEnd: onInternalResizeEnd,
        onCollapse: onInternalCollapse,
        containerSize: containerSize || 0
      });
    }
    return import_react205.default.createElement(import_react205.default.Fragment, {
      key: `split-panel-${idx}`
    }, panel, splitBar);
  }), typeof movingIndex === "number" && import_react205.default.createElement("div", {
    "aria-hidden": true,
    className: clsx(maskCls, `${maskCls}-${mergedOrientation}`)
  })));
};
if (true) {
  Splitter.displayName = "Splitter";
}
var Splitter_default = Splitter;

// node_modules/antd/es/splitter/index.js
var Splitter2 = Splitter_default;
Splitter2.Panel = Panel_default4;
var splitter_default = Splitter2;

// node_modules/antd/es/statistic/Countdown.js
var React521 = __toESM(require_react());

// node_modules/antd/es/statistic/Timer.js
var React520 = __toESM(require_react());

// node_modules/antd/es/statistic/Statistic.js
var React519 = __toESM(require_react());

// node_modules/antd/es/statistic/Number.js
var React518 = __toESM(require_react());
var StatisticNumber = (props) => {
  const {
    value,
    formatter,
    precision,
    decimalSeparator,
    groupSeparator = "",
    prefixCls
  } = props;
  let valueNode;
  if (typeof formatter === "function") {
    valueNode = formatter(value);
  } else {
    const val = String(value);
    const cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!cells || val === "-") {
      valueNode = val;
    } else {
      const negative = cells[1];
      let int = cells[2] || "0";
      let decimal = cells[4] || "";
      int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      if (typeof precision === "number") {
        decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
      }
      if (decimal) {
        decimal = `${decimalSeparator}${decimal}`;
      }
      valueNode = [React518.createElement("span", {
        key: "int",
        className: `${prefixCls}-content-value-int`
      }, negative, int), decimal && React518.createElement("span", {
        key: "decimal",
        className: `${prefixCls}-content-value-decimal`
      }, decimal)];
    }
  }
  return React518.createElement("span", {
    className: `${prefixCls}-content-value`
  }, valueNode);
};
var Number_default = StatisticNumber;

// node_modules/antd/es/statistic/style/index.js
var genStatisticStyle = (token2) => {
  const {
    componentCls,
    marginXXS,
    padding,
    colorTextDescription,
    titleFontSize,
    colorTextHeading,
    contentFontSize,
    fontFamily
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      [`${componentCls}-header`]: {
        paddingBottom: marginXXS,
        [`${componentCls}-title`]: {
          color: colorTextDescription,
          fontSize: titleFontSize
        }
      },
      [`${componentCls}-skeleton`]: {
        paddingTop: padding
      },
      [`${componentCls}-content`]: {
        color: colorTextHeading,
        fontSize: contentFontSize,
        fontFamily,
        [`${componentCls}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${componentCls}-content-prefix, ${componentCls}-content-suffix`]: {
          display: "inline-block"
        },
        [`${componentCls}-content-prefix`]: {
          marginInlineEnd: marginXXS
        },
        [`${componentCls}-content-suffix`]: {
          marginInlineStart: marginXXS
        }
      }
    }
  };
};
var prepareComponentToken48 = (token2) => {
  const {
    fontSizeHeading3,
    fontSize
  } = token2;
  return {
    titleFontSize: fontSize,
    contentFontSize: fontSizeHeading3
  };
};
var style_default55 = genStyleHooks("Statistic", (token2) => {
  const statisticToken3 = merge2(token2, {});
  return genStatisticStyle(statisticToken3);
}, prepareComponentToken48);

// node_modules/antd/es/statistic/Statistic.js
var Statistic = React519.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    valueStyle,
    value = 0,
    title,
    valueRender,
    prefix: prefix2,
    suffix,
    loading = false,
    /* --- FormatConfig starts --- */
    formatter,
    precision,
    decimalSeparator = ".",
    groupSeparator = ",",
    /* --- FormatConfig starts --- */
    onMouseEnter,
    onMouseLeave,
    styles,
    classNames,
    ...rest
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("statistic");
  const prefixCls = getPrefixCls("statistic", customizePrefixCls);
  const [hashId, cssVarCls] = style_default55(prefixCls);
  const mergedProps = {
    ...props,
    decimalSeparator,
    groupSeparator,
    loading,
    value
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  if (true) {
    const warning5 = devUseWarning("Statistic");
    [["valueStyle", "styles.content"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  const valueNode = React519.createElement(Number_default, {
    decimalSeparator,
    groupSeparator,
    prefixCls,
    formatter,
    precision,
    value
  });
  const rootClassNames = clsx(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const headerClassNames = clsx(`${prefixCls}-header`, mergedClassNames.header);
  const titleClassNames = clsx(`${prefixCls}-title`, mergedClassNames.title);
  const contentClassNames = clsx(`${prefixCls}-content`, mergedClassNames.content);
  const prefixClassNames = clsx(`${prefixCls}-content-prefix`, mergedClassNames.prefix);
  const suffixClassNames = clsx(`${prefixCls}-content-suffix`, mergedClassNames.suffix);
  const internalRef = React519.useRef(null);
  React519.useImperativeHandle(ref, () => ({
    nativeElement: internalRef.current
  }));
  const restProps = pickAttrs(rest, {
    aria: true,
    data: true
  });
  return React519.createElement("div", {
    ...restProps,
    className: rootClassNames,
    style: {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    },
    ref: internalRef,
    onMouseEnter,
    onMouseLeave
  }, title && React519.createElement("div", {
    className: headerClassNames,
    style: mergedStyles.header
  }, React519.createElement("div", {
    className: titleClassNames,
    style: mergedStyles.title
  }, title)), React519.createElement(skeleton_default, {
    paragraph: false,
    loading,
    className: `${prefixCls}-skeleton`,
    active: true
  }, React519.createElement("div", {
    className: contentClassNames,
    style: {
      ...valueStyle,
      ...mergedStyles.content
    }
  }, prefix2 && React519.createElement("span", {
    className: prefixClassNames,
    style: mergedStyles.prefix
  }, prefix2), valueRender ? valueRender(valueNode) : valueNode, suffix && React519.createElement("span", {
    className: suffixClassNames,
    style: mergedStyles.suffix
  }, suffix))));
});
if (true) {
  Statistic.displayName = "Statistic";
}
var Statistic_default = Statistic;

// node_modules/antd/es/statistic/utils.js
var timeUnits = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  // years
  ["M", 1e3 * 60 * 60 * 24 * 30],
  // months
  ["D", 1e3 * 60 * 60 * 24],
  // days
  ["H", 1e3 * 60 * 60],
  // hours
  ["m", 1e3 * 60],
  // minutes
  ["s", 1e3],
  // seconds
  ["S", 1]
  // million seconds
];
function formatTimeStr(duration, format3) {
  let leftDuration = duration;
  const escapeRegex = /\[[^\]]*]/g;
  const keepList = (format3.match(escapeRegex) || []).map((str) => str.slice(1, -1));
  const templateText = format3.replace(escapeRegex, "[]");
  const replacedText = timeUnits.reduce((current, [name, unit3]) => {
    if (current.includes(name)) {
      const value = Math.floor(leftDuration / unit3);
      leftDuration -= value * unit3;
      return current.replace(new RegExp(`${name}+`, "g"), (match3) => {
        const len = match3.length;
        return value.toString().padStart(len, "0");
      });
    }
    return current;
  }, templateText);
  let index2 = 0;
  return replacedText.replace(escapeRegex, () => {
    const match3 = keepList[index2];
    index2 += 1;
    return match3;
  });
}
function formatCounter(value, config, down) {
  const {
    format: format3 = ""
  } = config;
  const target = new Date(value).getTime();
  const current = Date.now();
  const diff = down ? Math.max(target - current, 0) : Math.max(current - target, 0);
  return formatTimeStr(diff, format3);
}

// node_modules/antd/es/statistic/Timer.js
var UPDATE_INTERVAL = 1e3 / 60;
function getTime(value) {
  return new Date(value).getTime();
}
var StatisticTimer = (props) => {
  const {
    value,
    format: format3 = "HH:mm:ss",
    onChange,
    onFinish,
    type: type5,
    ...rest
  } = props;
  const down = type5 === "countdown";
  const [showTime, setShowTime] = React520.useState(null);
  const update = useEvent_default(() => {
    const now2 = Date.now();
    const timestamp = getTime(value);
    setShowTime({});
    const timeDiff = !down ? now2 - timestamp : timestamp - now2;
    onChange == null ? void 0 : onChange(timeDiff);
    if (down && timestamp < now2) {
      onFinish == null ? void 0 : onFinish();
      return false;
    }
    return true;
  });
  React520.useEffect(() => {
    let intervalId;
    const tick = () => {
      if (!update()) {
        window.clearInterval(intervalId);
      }
    };
    const startTimer = () => {
      intervalId = window.setInterval(tick, UPDATE_INTERVAL);
    };
    const stopTimer = () => {
      window.clearInterval(intervalId);
    };
    startTimer();
    return () => {
      stopTimer();
    };
  }, [value, down]);
  React520.useEffect(() => {
    setShowTime({});
  }, []);
  const formatter = (formatValue2, config) => showTime ? formatCounter(formatValue2, {
    ...config,
    format: format3
  }, down) : "-";
  const valueRender = (node2) => cloneElement3(node2, {
    title: void 0
  });
  return React520.createElement(Statistic_default, {
    ...rest,
    value,
    valueRender,
    formatter
  });
};
var Timer_default = StatisticTimer;

// node_modules/antd/es/statistic/Countdown.js
var Countdown = (props) => {
  if (true) {
    const warning5 = devUseWarning("Countdown");
    warning5.deprecated(false, "<Statistic.Countdown />", '<Statistic.Timer type="countdown" />');
  }
  return React521.createElement(Timer_default, {
    ...props,
    type: "countdown"
  });
};
var Countdown_default = React521.memo(Countdown);

// node_modules/antd/es/statistic/index.js
Statistic_default.Timer = Timer_default;
Statistic_default.Countdown = Countdown_default;
var statistic_default2 = Statistic_default;

// node_modules/antd/es/steps/index.js
var React531 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Steps.js
var import_react206 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Step.js
var React526 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Rail.js
var React522 = __toESM(require_react());
function Rail(props) {
  const {
    prefixCls,
    className,
    style: style2,
    status
  } = props;
  const railCls = `${prefixCls}-rail`;
  return React522.createElement("div", {
    className: clsx(railCls, `${railCls}-${status}`, className),
    style: style2
  });
}

// node_modules/@rc-component/steps/es/UnstableContext.js
var React523 = __toESM(require_react());
var UnstableContext3 = React523.createContext({});

// node_modules/@rc-component/steps/es/StepIcon.js
var React525 = __toESM(require_react());

// node_modules/@rc-component/steps/es/Context.js
var React524 = __toESM(require_react());
var StepsContext = React524.createContext(null);

// node_modules/@rc-component/steps/es/StepIcon.js
function _extends76() {
  _extends76 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends76.apply(this, arguments);
}
var StepIconSemanticContext = React525.createContext({});
var StepIcon = React525.forwardRef((props, ref) => {
  const {
    className,
    style: style2,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    classNames,
    styles
  } = React525.useContext(StepsContext);
  const {
    className: itemClassName,
    style: itemStyle
  } = React525.useContext(StepIconSemanticContext);
  const itemCls = `${prefixCls}-item`;
  return React525.createElement("div", _extends76({}, pickAttrs(restProps, false), {
    ref,
    className: clsx(`${itemCls}-icon`, classNames.itemIcon, itemClassName, className),
    style: {
      ...styles.itemIcon,
      ...itemStyle,
      ...style2
    }
  }), children);
});
var StepIcon_default = StepIcon;

// node_modules/@rc-component/steps/es/Step.js
function _extends77() {
  _extends77 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends77.apply(this, arguments);
}
function hasContent(value) {
  return value !== void 0 && value !== null;
}
function Step(props) {
  const {
    // style
    prefixCls,
    classNames,
    styles,
    // data
    data,
    last,
    nextStatus,
    active,
    index: index2,
    // render
    itemRender,
    iconRender,
    itemWrapperRender,
    // events
    onClick
  } = props;
  const itemCls = `${prefixCls}-item`;
  const {
    railFollowPrevStatus
  } = React526.useContext(UnstableContext3);
  const {
    ItemComponent
  } = React526.useContext(StepsContext);
  const {
    onClick: onItemClick,
    title,
    subTitle,
    content,
    description,
    disabled,
    icon,
    status,
    className,
    style: style2,
    classNames: itemClassNames = {},
    styles: itemStyles = {},
    ...restItemProps
  } = data;
  const mergedContent = content ?? description;
  const renderInfo = {
    item: {
      ...data,
      content: mergedContent
    },
    index: index2,
    active
  };
  const clickable = !!(onClick || onItemClick) && !disabled;
  const accessibilityProps = {};
  if (clickable) {
    accessibilityProps.role = "button";
    accessibilityProps.tabIndex = 0;
    accessibilityProps.onClick = (e3) => {
      onItemClick == null ? void 0 : onItemClick(e3);
      onClick(index2);
    };
    accessibilityProps.onKeyDown = (e3) => {
      const {
        which
      } = e3;
      if (which === KeyCode_default.ENTER || which === KeyCode_default.SPACE) {
        onClick(index2);
      }
    };
  }
  const mergedStatus = status || "wait";
  const hasTitle = hasContent(title);
  const hasSubTitle = hasContent(subTitle);
  const classString = clsx(itemCls, `${itemCls}-${mergedStatus}`, {
    [`${itemCls}-custom`]: icon,
    [`${itemCls}-active`]: active,
    [`${itemCls}-disabled`]: disabled === true,
    [`${itemCls}-empty-header`]: !hasTitle && !hasSubTitle
  }, className, classNames.item, itemClassNames.root);
  let iconNode = React526.createElement(StepIcon_default, null);
  if (iconRender) {
    iconNode = iconRender(iconNode, {
      ...renderInfo,
      components: {
        Icon: StepIcon_default
      }
    });
  }
  const wrapperNode = React526.createElement("div", {
    className: clsx(`${itemCls}-wrapper`, classNames.itemWrapper, itemClassNames.wrapper),
    style: {
      ...styles.itemWrapper,
      ...itemStyles.wrapper
    }
  }, React526.createElement(StepIconSemanticContext.Provider, {
    value: {
      className: itemClassNames.icon,
      style: itemStyles.icon
    }
  }, iconNode), React526.createElement("div", {
    className: clsx(`${itemCls}-section`, classNames.itemSection, itemClassNames.section),
    style: {
      ...styles.itemSection,
      ...itemStyles.section
    }
  }, React526.createElement("div", {
    className: clsx(`${itemCls}-header`, classNames.itemHeader, itemClassNames.header),
    style: {
      ...styles.itemHeader,
      ...itemStyles.header
    }
  }, hasTitle && React526.createElement("div", {
    className: clsx(`${itemCls}-title`, classNames.itemTitle, itemClassNames.title),
    style: {
      ...styles.itemTitle,
      ...itemStyles.title
    }
  }, title), hasSubTitle && React526.createElement("div", {
    title: typeof subTitle === "string" ? subTitle : void 0,
    className: clsx(`${itemCls}-subtitle`, classNames.itemSubtitle, itemClassNames.subtitle),
    style: {
      ...styles.itemSubtitle,
      ...itemStyles.subtitle
    }
  }, subTitle), !last && React526.createElement(Rail, {
    prefixCls: itemCls,
    className: clsx(classNames.itemRail, itemClassNames.rail),
    style: {
      ...styles.itemRail,
      ...itemStyles.rail
    },
    status: railFollowPrevStatus ? status : nextStatus
  })), hasContent(mergedContent) && React526.createElement("div", {
    className: clsx(`${itemCls}-content`, classNames.itemContent, itemClassNames.content),
    style: {
      ...styles.itemContent,
      ...itemStyles.content
    }
  }, mergedContent)));
  let stepNode = React526.createElement(ItemComponent, _extends77({}, restItemProps, accessibilityProps, {
    className: classString,
    style: {
      ...styles.item,
      ...itemStyles.root,
      ...style2
    }
  }), itemWrapperRender ? itemWrapperRender(wrapperNode) : wrapperNode);
  if (itemRender) {
    stepNode = itemRender(stepNode, renderInfo) || null;
  }
  return stepNode;
}

// node_modules/@rc-component/steps/es/Steps.js
function _extends78() {
  _extends78 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends78.apply(this, arguments);
}
var EmptyObject = {};
function Steps3(props) {
  const {
    // style
    prefixCls = "rc-steps",
    style: style2,
    className,
    classNames = EmptyObject,
    styles = EmptyObject,
    rootClassName,
    // layout
    orientation,
    titlePlacement,
    components: components2,
    // data
    status = "process",
    current = 0,
    initial = 0,
    onChange,
    items,
    // render
    iconRender,
    itemRender,
    itemWrapperRender,
    ...restProps
  } = props;
  const isVertical = orientation === "vertical";
  const mergedOrientation = isVertical ? "vertical" : "horizontal";
  const mergeTitlePlacement = !isVertical && titlePlacement === "vertical" ? "vertical" : "horizontal";
  const classString = clsx(prefixCls, `${prefixCls}-${mergedOrientation}`, `${prefixCls}-title-${mergeTitlePlacement}`, rootClassName, className, classNames.root);
  const mergedItems = import_react206.default.useMemo(() => (items || []).filter(Boolean), [items]);
  const statuses = import_react206.default.useMemo(() => mergedItems.map(({
    status: itemStatus
  }, index2) => {
    const stepNumber = initial + index2;
    if (!itemStatus) {
      if (stepNumber === current) {
        return status;
      } else if (stepNumber < current) {
        return "finish";
      }
      return "wait";
    }
    return itemStatus;
  }), [mergedItems, status, current, initial]);
  const onStepClick = (next2) => {
    if (onChange && current !== next2) {
      onChange(next2);
    }
  };
  const {
    root: RootComponent = "div",
    item: ItemComponent = "div"
  } = components2 || {};
  const stepIconContext = import_react206.default.useMemo(() => ({
    prefixCls,
    classNames,
    styles,
    ItemComponent
  }), [prefixCls, classNames, styles, ItemComponent]);
  const renderStep = (item, index2) => {
    const stepIndex = initial + index2;
    const itemStatus = statuses[index2];
    const nextStatus = statuses[index2 + 1];
    const data = {
      ...item,
      status: itemStatus
    };
    return import_react206.default.createElement(Step, {
      key: stepIndex,
      prefixCls,
      classNames,
      styles,
      data,
      nextStatus,
      active: stepIndex === current,
      index: stepIndex,
      last: mergedItems.length - 1 === index2,
      iconRender,
      itemRender,
      itemWrapperRender,
      onClick: onChange && onStepClick
    });
  };
  return import_react206.default.createElement(RootComponent, _extends78({
    className: classString,
    style: {
      ...style2,
      ...styles == null ? void 0 : styles.root
    }
  }, restProps), import_react206.default.createElement(StepsContext.Provider, {
    value: stepIconContext
  }, mergedItems.map(renderStep)));
}

// node_modules/@rc-component/steps/es/index.js
var es_default31 = Steps3;

// node_modules/antd/es/steps/context.js
var React528 = __toESM(require_react());
var InternalContext = React528.createContext(null);

// node_modules/antd/es/steps/PanelArrow.js
var React529 = __toESM(require_react());
function PanelArrow(props) {
  const {
    prefixCls
  } = props;
  return React529.createElement("svg", {
    className: `${prefixCls}-panel-arrow`,
    viewBox: "0 0 100 100",
    xmlns: "http://www.w3.org/2000/svg",
    preserveAspectRatio: "none"
  }, React529.createElement("title", null, "Arrow"), React529.createElement("path", {
    d: "M 0 0 L 100 50 L 0 100"
  }));
}

// node_modules/antd/es/steps/ProgressIcon.js
var React530 = __toESM(require_react());
function ProgressIcon(props) {
  const {
    prefixCls,
    children,
    percent
  } = props;
  const progressCls = `${prefixCls}-item-progress-icon`;
  const circleCls = `${progressCls}-circle`;
  const dashArray = `calc(var(--progress-r) * 2 * ${Math.PI * percent / 100}) 9999`;
  return React530.createElement(React530.Fragment, null, React530.createElement("svg", {
    className: `${progressCls}-svg`,
    viewBox: "0 0 100 100",
    width: "100%",
    height: "100%",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-valuemax": 100,
    "aria-valuemin": 0,
    "aria-valuenow": percent
  }, React530.createElement("title", null, "Progress"), React530.createElement("circle", {
    className: clsx(circleCls, `${circleCls}-rail`)
  }), React530.createElement("circle", {
    className: clsx(circleCls, `${circleCls}-ptg`),
    strokeDasharray: dashArray,
    transform: "rotate(-90 50 50)"
  })), children);
}

// node_modules/antd/es/steps/style/horizontal.js
var genHorizontalStyle3 = (token2) => {
  const {
    componentCls
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-horizontal`]: {
      [`> ${itemCls}`]: {
        flex: "1 1 auto",
        minWidth: token2.iconSize,
        [`${itemCls}-rail`]: {
          "--steps-horizontal-rail-margin": "calc(var(--steps-icon-size-max) / 2 + var(--steps-item-wrapper-padding-top))",
          position: "static",
          marginTop: "var(--steps-horizontal-rail-margin)",
          width: "auto",
          borderBlockStartWidth: "var(--steps-rail-size)",
          flex: 1,
          minWidth: 0,
          alignSelf: "flex-start",
          transform: "translateY(-50%)"
        }
      }
    }
  };
};
var horizontal_default2 = genHorizontalStyle3;

// node_modules/antd/es/steps/style/icon.js
var genIconStyle2 = (token2) => {
  const {
    componentCls,
    customIconFontSize,
    motionDurationSlow
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      "--steps-icon-size": token2.iconSize,
      "--steps-icon-border-width": token2.lineWidth,
      [`${itemCls}-icon`]: {
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)",
        margin: 0,
        flex: "none",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: token2.iconFontSize,
        fontFamily: token2.fontFamily,
        lineHeight: "var(--steps-icon-size)",
        textAlign: "center",
        borderRadius: "var(--steps-icon-size)",
        border: `var(--steps-icon-border-width) ${token2.lineType} transparent`,
        transition: ["background", "border", "color", "inset", "transform"].map((key) => `${key} ${motionDurationSlow}`).join(", "),
        zIndex: 1
      },
      // ==================== Custom ====================
      [`${itemCls}-custom ${itemCls}-icon`]: {
        background: "none",
        border: 0,
        fontSize: customIconFontSize
      }
    }
  };
};
var icon_default = genIconStyle2;

// node_modules/antd/es/steps/style/inline.js
var genInlineStyle2 = (token2) => {
  const {
    componentCls,
    inlineDotSize
  } = token2;
  const containerPaddingTop = token2.calc(token2.paddingXS).add(token2.lineWidth).equal();
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-inline`]: {
      "--steps-items-offset": "0",
      "--steps-item-wrapper-padding-top": containerPaddingTop,
      display: "inline-flex",
      "&:before": {
        content: '""',
        flex: "var(--steps-items-offset)"
      },
      [itemCls]: {
        // ========================= Variable =========================
        // Item
        "--steps-title-vertical-row-gap": token2.paddingXS,
        // Icon
        "--steps-icon-size": inlineDotSize,
        "--steps-icon-size-active": inlineDotSize,
        // Title
        "--steps-title-font-size": token2.fontSizeSM,
        "--steps-title-line-height": token2.lineHeightSM,
        "--steps-item-title-color": token2.colorTextSecondary,
        "--steps-subtitle-font-size": token2.fontSizeSM,
        "--steps-subtitle-line-height": token2.lineHeightSM,
        "--steps-item-subtitle-color": token2.colorTextQuaternary,
        // Rail
        "--steps-rail-size": token2.lineWidth,
        "--steps-title-horizontal-rail-gap": "0px",
        // ========================== Styles ==========================
        flex: 1,
        "&-wrapper": {
          paddingInline: token2.paddingXXS,
          marginInline: token2.calc(token2.marginXXS).div(2).equal(),
          borderRadius: token2.borderRadiusSM,
          cursor: "pointer",
          transition: `background ${token2.motionDurationMid}`,
          "&:hover": {
            background: token2.controlItemBgHover
          }
        },
        // Icon
        "&-icon": {
          [`${itemCls}-icon-dot`]: {
            "&:after": {
              display: "none"
            }
          }
        },
        // Header
        "&-title": {
          fontWeight: "normal",
          whiteSpace: "nowrap"
        },
        "&-content": {
          display: "none"
        }
      }
    }
  };
};
var inline_default = genInlineStyle2;

// node_modules/antd/es/steps/style/util.js
function withoutVar(cssVar) {
  return (cssVar || "--ant-not-exist").replace(/var\((.*)\)/, "$1");
}
function getItemWithWidthStyle(token2, marginSize, optionalStyle) {
  const {
    calc,
    componentCls,
    descriptionMaxWidth
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`@container style(${withoutVar(descriptionMaxWidth)})`]: [{
      // Icon
      [`${itemCls}-icon`]: {
        marginInlineStart: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).equal()
      },
      // >>> Rail
      [`${itemCls}-rail`]: {
        width: "auto",
        insetInlineStart: calc(descriptionMaxWidth).add(`var(--steps-icon-size)`).div(2).add(marginSize).equal(),
        insetInlineEnd: calc(descriptionMaxWidth).sub(`var(--steps-icon-size)`).div(2).sub(marginSize).mul(-1).equal()
      }
    }, optionalStyle]
  };
}

// node_modules/antd/es/steps/style/label-placement.js
var genLabelPlacementStyle = (token2) => {
  const {
    componentCls,
    descriptionMaxWidth,
    marginXS,
    fontHeightLG,
    calc
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    // ====================== Shared ======================
    [componentCls]: {
      // Dot Steps active icon size is 2px larger than the default icon size
      "--steps-icon-size-max": "max(var(--steps-icon-size), var(--steps-icon-size-active, var(--steps-icon-size)))",
      // Icon
      [`${itemCls}-icon`]: {
        marginBlockStart: `calc((var(--steps-heading-height) - var(--steps-icon-size)) / 2)`
      }
    },
    // ==================== Horizontal ====================
    [`${componentCls}-title-horizontal`]: {
      "--steps-title-horizontal-item-margin": token2.margin,
      "--steps-title-horizontal-rail-margin": token2.margin,
      "--steps-title-horizontal-title-height": fontHeightLG,
      "--steps-heading-height": `max(var(--steps-icon-size), var(--steps-title-horizontal-title-height))`,
      // Horizontal only
      [`&${componentCls}-horizontal, &${componentCls}-horizontal-alternate`]: {
        [`${itemCls}:not(:first-child)`]: {
          marginInlineStart: `var(--steps-title-horizontal-item-margin)`
        },
        [`${itemCls}:last-child`]: {
          flex: "0 1 auto"
        },
        [`${itemCls}-wrapper`]: {
          columnGap: token2.marginXS
        }
      },
      // Vertical only
      [`&${componentCls}-vertical`]: {
        [`${itemCls}-wrapper`]: {
          columnGap: token2.margin
        },
        [`${itemCls}-empty-header`]: {
          [`${itemCls}-header`]: {
            minHeight: "auto"
          },
          [`${itemCls}-content`]: {
            marginTop: calc("var(--steps-heading-height)").sub(token2.fontHeight).div(2).equal()
          }
        }
      },
      // Shared
      [`${itemCls}-section`]: {
        flex: 1,
        minWidth: 0
      },
      [`${itemCls}-header`]: {
        minHeight: "var(--steps-heading-height)"
      },
      [`${itemCls}-title`]: {
        flex: "0 1 auto"
      },
      [`${itemCls}-content`]: {
        maxWidth: descriptionMaxWidth
      },
      [`${itemCls}-subtitle`]: {
        flex: "0 9999 auto"
      },
      [`&${componentCls}-horizontal ${itemCls}-rail`]: {
        "--steps-item-wrapper-padding-top": "0px",
        flex: 1,
        marginInlineStart: `var(--steps-title-horizontal-rail-margin)`
      }
    },
    // ===================== Vertical =====================
    [`${componentCls}-title-vertical`]: {
      "--steps-title-vertical-row-gap": token2.paddingSM,
      "--steps-title-horizontal-rail-gap": token2.marginXXS,
      "--steps-heading-height": "var(--steps-icon-size-max)",
      [`> ${itemCls}`]: {
        flex: 1,
        [`${itemCls}-wrapper`]: {
          flexDirection: "column",
          rowGap: `var(--steps-title-vertical-row-gap)`,
          alignItems: "center"
        },
        // Section
        [`${itemCls}-section`]: {
          alignSelf: "stretch"
        },
        // Header
        [`${itemCls}-header`]: {
          flexDirection: "column",
          alignItems: "center"
        },
        // >>> title & subtitle & Content
        [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
          textAlign: "center",
          maxWidth: "100%"
        },
        [`${itemCls}-subtitle`]: {
          margin: 0
        },
        // >>> rail
        [`${itemCls}-rail`]: {
          position: "absolute",
          top: 0,
          width: `calc(100% - var(--steps-icon-size) - var(--steps-title-horizontal-rail-gap) * 2)`,
          insetInlineStart: `calc(50% + var(--steps-icon-size) / 2 + var(--steps-title-horizontal-rail-gap))`
        }
      },
      // With descriptionMaxWidth
      ...getItemWithWidthStyle(token2, marginXS, {
        [`${itemCls}:last-child`]: {
          flex: "none"
        },
        // Icon
        [`${itemCls}-icon`]: {
          alignSelf: "flex-start"
        },
        // Section
        [`${itemCls}-section`]: {
          width: descriptionMaxWidth
        }
      })
    }
  };
};
var label_placement_default = genLabelPlacementStyle;

// node_modules/antd/es/steps/style/nav.js
var genLegacyNavStyle = (token2) => {
  const {
    componentCls,
    fontSizeIcon,
    calc,
    navContentMaxWidth,
    navArrowColor,
    colorPrimary,
    motionDurationSlow
  } = token2;
  const itemCls = `${componentCls}-item`;
  const stepsNavActiveColor = colorPrimary;
  return {
    [`${componentCls}${componentCls}-navigation`]: {
      // ==========================================================
      // ==                        Shared                        ==
      // ==========================================================
      // ========================== Item ==========================
      [itemCls.repeat(4)]: {
        display: "flex",
        justifyContent: "center",
        position: "relative",
        flex: 1,
        marginInlineStart: 0,
        [`${itemCls}-wrapper`]: {
          paddingBlock: token2.paddingSM
        },
        // Section
        [`${itemCls}-section`]: {
          maxWidth: navContentMaxWidth
        },
        // Rail
        [`${itemCls}-rail`]: {
          display: "none"
        },
        // ======================== Active ========================
        "&:before": {
          position: "absolute",
          display: "block",
          backgroundColor: stepsNavActiveColor,
          transition: `all ${motionDurationSlow}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        },
        "&:not(:last-child):after": {
          position: "absolute",
          display: "block",
          borderTop: `${unit(token2.lineWidth)} ${token2.lineType} ${navArrowColor}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${unit(token2.lineWidth)} ${token2.lineType} ${navArrowColor}`,
          content: '""'
        },
        // Reset active item style to same as default
        [`&${itemCls}-active`]: {
          "--steps-item-content-active-color": `var(--steps-item-content-color)`,
          "--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
          "--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
          "--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)"
        }
      },
      // ==========================================================
      // ==                       Horizontal                     ==
      // ==========================================================
      [`&${componentCls}-horizontal`]: {
        [itemCls]: {
          "&:before": {
            bottom: 0,
            insetInlineStart: "50%",
            width: 0,
            height: token2.lineWidthBold
          },
          [`&${itemCls}-active:before`]: {
            insetInlineStart: 0,
            width: "100%"
          },
          "&:not(:last-child):after": {
            top: `50%`,
            insetInlineStart: calc(fontSizeIcon).div(2).mul(-1).add("100%").equal(),
            width: fontSizeIcon,
            height: fontSizeIcon,
            transform: "translateY(-50%) rotate(45deg)"
          }
        }
      },
      // ==========================================================
      // ==                        Vertical                      ==
      // ==========================================================
      [`&${componentCls}-vertical`]: {
        [itemCls.repeat(4)]: {
          [`${itemCls}-content`]: {
            padding: 0
          },
          "&:before": {
            insetInlineEnd: 0,
            top: "50%",
            width: token2.lineWidthBold,
            height: 0
          },
          [`&${itemCls}-active::before`]: {
            top: 0,
            height: "100%"
          },
          "&:not(:last-child):after": {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            top: "100%",
            width: calc(fontSizeIcon).div(3).mul(2).equal(),
            height: calc(fontSizeIcon).div(3).mul(2).equal(),
            transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
          }
        }
      }
      // ========================= Legacy =========================
    }
  };
};
var nav_default = genLegacyNavStyle;

// node_modules/antd/es/steps/style/panel.js
var genPanelStyle3 = (token2) => {
  const {
    componentCls,
    calc,
    lineWidthBold,
    borderRadius,
    borderRadiusSM,
    motionDurationMid
  } = token2;
  const itemCls = `${componentCls}-item`;
  const borderStyle = `${unit(lineWidthBold)} ${token2.lineType} var(--steps-panel-border-color)`;
  return {
    [`${componentCls}${componentCls}-panel`]: [
      // ==========================================================
      // ==                       Clean up                       ==
      // ==========================================================
      {
        // ====================== Shared ======================
        [`${itemCls}-rail`]: {
          display: "none"
        },
        // ==================== Horizontal ====================
        [`&${componentCls}-horizontal`]: {
          alignItems: "stretch",
          [itemCls]: {
            flex: 1,
            margin: 0
          }
        }
      },
      // ==========================================================
      // ==                       Template                       ==
      // ==========================================================
      {
        "&": {
          "--steps-panel-padding": token2.paddingSM,
          "--steps-item-border-radius": borderRadius,
          [itemCls]: {
            // Panel background
            "--steps-panel-bg-color": "var(--steps-item-icon-bg-color)",
            "--steps-panel-border-color": "var(--steps-item-icon-border-color)",
            "--steps-panel-active-bg-color": "var(--steps-item-icon-active-bg-color)",
            "--steps-panel-active-border-color": "var(--steps-item-icon-active-border-color)",
            "--steps-panel-title-height": `calc(var(--steps-title-font-size) * var(--steps-title-line-height))`,
            // Base height = padding * 2 + iconSize + contentHeight
            "--steps-item-base-height": calc("var(--steps-panel-padding)").mul(2).add("var(--steps-icon-size)").add("var(--steps-panel-title-height)").equal(),
            "--steps-item-base-width": "calc(var(--steps-item-base-height) * 0.7071)",
            transition: `background ${motionDurationMid}`
          }
        },
        // ======================= Icon =======================
        [`${itemCls}-icon`]: {
          display: "none"
        },
        // ====================== Header ======================
        [`${itemCls}-header`]: {
          minHeight: "auto"
        },
        // ====================== Arrow =======================
        [`${componentCls}-panel-arrow`]: {
          position: "absolute",
          top: calc(lineWidthBold).mul(-1).equal(),
          insetInlineStart: "100%",
          zIndex: 1,
          height: calc(lineWidthBold).mul(2).add("100%").equal(),
          width: "var(--steps-item-base-width)",
          overflow: "visible",
          strokeLinecap: "round",
          path: {
            fill: "var(--steps-panel-bg-color)",
            stroke: "var(--steps-panel-border-color)",
            strokeWidth: lineWidthBold,
            vectorEffect: "non-scaling-stroke",
            transition: `fill ${motionDurationMid}`
          }
        },
        [`${itemCls}:last-child ${componentCls}-panel-arrow`]: {
          display: "none"
        },
        // ======================= Item =======================
        [itemCls]: {
          padding: "var(--steps-panel-padding)",
          background: "var(--steps-panel-bg-color)",
          position: "relative",
          borderBlock: borderStyle,
          "&:not(:first-child)": {
            paddingInlineStart: `calc(var(--steps-panel-padding) + var(--steps-item-base-width))`
          },
          "&:first-child": {
            borderInlineStart: borderStyle,
            borderStartStartRadius: "var(--steps-item-border-radius)",
            borderEndStartRadius: "var(--steps-item-border-radius)"
          },
          "&:last-child": {
            borderInlineEnd: borderStyle,
            borderStartEndRadius: "var(--steps-item-border-radius)",
            borderEndEndRadius: "var(--steps-item-border-radius)"
          },
          "&-active": {
            background: "var(--steps-panel-active-bg-color)",
            borderColor: "var(--steps-panel-active-border-color)",
            [`${componentCls}-panel-arrow`]: {
              path: {
                fill: "var(--steps-panel-active-bg-color)",
                stroke: "var(--steps-panel-active-border-color)"
              }
            },
            [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
              color: "var(--steps-item-icon-active-text-color)"
            }
          }
        }
      },
      // ==========================================================
      // ==                         Size                         ==
      // ==========================================================
      {
        [`&${componentCls}-small`]: {
          "--steps-panel-padding": token2.paddingXS,
          "--steps-item-border-radius": borderRadiusSM
        }
      },
      // ==========================================================
      // ==                        Filled                        ==
      // ==========================================================
      {
        [`&${componentCls}-filled`]: {
          [itemCls]: {
            "&:not(:first-child)": {
              clipPath: `polygon(${[`${unit(lineWidthBold)} 0`, "calc(100% + var(--steps-item-base-width)) 0", "calc(100% + var(--steps-item-base-width)) 100%", `${unit(lineWidthBold)} 100%`, `calc(var(--steps-item-base-width) + ${unit(lineWidthBold)}) 50%`].join(",")})`
            }
          }
        }
      },
      // ==========================================================
      // ==                       Outlined                       ==
      // ==========================================================
      {
        [`&${componentCls}-outlined`]: {
          [`${componentCls}-panel-arrow`]: {
            top: calc(lineWidthBold).div(2).mul(-1).equal(),
            height: calc(lineWidthBold).add("100%").equal()
          }
        }
      }
    ]
  };
};
var panel_default3 = genPanelStyle3;

// node_modules/antd/es/steps/style/progress.js
var genStepsProgressStyle = (token2) => {
  const {
    calc,
    antCls,
    componentCls,
    iconSize,
    iconSizeSM,
    lineWidthBold,
    paddingXXS
  } = token2;
  const itemCls = `${componentCls}-item`;
  const progressSize = token2.calc(iconSize).add(token2.calc(lineWidthBold).mul(4).equal()).equal();
  const progressSizeSM = token2.calc(iconSizeSM).add(token2.calc(token2.lineWidth).mul(4).equal()).equal();
  const enhanceSize = calc(lineWidthBold).add(lineWidthBold).equal();
  return {
    [`${componentCls}${componentCls}-with-progress`]: {
      "--steps-item-wrapper-padding-top": enhanceSize,
      [`${itemCls}${itemCls}-process`]: {
        [`${itemCls}-icon`]: {
          position: "relative"
        }
      },
      [`${itemCls}-progress-icon`]: {
        "&-svg": {
          "--steps-svg-size": calc(enhanceSize).mul(2).add(`var(--steps-icon-size)`).equal(),
          "--icon-size-ptg-unitless": `calc(100 / tan(atan2(var(--steps-svg-size),1px)))`,
          fontSize: `var(--steps-svg-size)`,
          lineHeight: `var(--icon-size-ptg-unitless)`,
          position: "absolute",
          inset: calc(enhanceSize).mul(-1).equal(),
          width: "auto",
          height: "auto"
        },
        "&-circle": {
          lineHeight: `var(--icon-size-ptg-unitless)`,
          strokeWidth: calc(`var(--icon-size-ptg-unitless)`).mul(lineWidthBold).equal(),
          "--progress-r": calc(`var(--steps-svg-size)`).sub(lineWidthBold).mul(`var(--icon-size-ptg-unitless)`).div(2).equal(),
          r: `var(--progress-r)`,
          fill: "none",
          cx: 50,
          cy: 50,
          transition: `all ${token2.motionDurationSlow} ease-in-out`,
          "&-rail": {
            stroke: token2.colorSplit
          },
          "&-ptg": {
            stroke: token2.colorPrimary
          }
        }
      }
    },
    [`&${componentCls}-with-progress11`]: {
      // ==========================================================
      // ==                        Shared                        ==
      // ==========================================================
      [itemCls]: {
        paddingTop: paddingXXS,
        paddingInlineStart: paddingXXS
      },
      [`${itemCls}-icon`]: {
        position: "relative",
        [`${antCls}-progress`]: {
          position: "absolute",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          top: "50%",
          transform: "translate(-50%, -50%)",
          "&-body": {
            width: `${unit(progressSize)} !important`,
            height: `${unit(progressSize)} !important`
          }
        }
      },
      [`&${componentCls}-small`]: {
        [`${itemCls}-icon ${antCls}-progress-body`]: {
          width: `${unit(progressSizeSM)} !important`,
          height: `${unit(progressSizeSM)} !important`
        }
      }
    }
  };
};
var progress_default3 = genStepsProgressStyle;

// node_modules/antd/es/steps/style/progress-dot.js
var genDotStyle = (token2) => {
  const {
    componentCls,
    iconSize,
    dotSize,
    dotCurrentSize,
    marginXXS,
    lineWidthBold,
    fontSizeSM
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}${componentCls}-dot`]: {
      "--steps-icon-size-active": dotCurrentSize,
      "--steps-icon-size": dotSize,
      "--steps-dot-icon-size": dotSize,
      "--steps-dot-icon-border-width": token2.lineWidthBold,
      "--steps-rail-size": lineWidthBold,
      "--steps-icon-border-width": lineWidthBold,
      // ========================= Shared ==========================
      // Icon
      [`${itemCls}-custom ${itemCls}-icon`]: {
        fontSize: fontSizeSM
      },
      [`${itemCls}-icon`]: {
        position: "relative",
        "&:after": {
          content: '""',
          width: iconSize,
          height: iconSize,
          display: "block",
          position: "absolute",
          top: "50%",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translate(-50%, -50%)"
        }
      },
      // // >>> active
      [`${itemCls}-active ${itemCls}-icon`]: {
        "--steps-icon-size": "var(--steps-icon-size-active)"
      },
      // ======================= Horizontal ========================
      [`&${componentCls}-horizontal`]: {
        // With descriptionMaxWidth
        [`&, &${componentCls}-small`]: getItemWithWidthStyle(token2, marginXXS)
      }
    }
  };
};
var progress_dot_default = genDotStyle;

// node_modules/antd/es/steps/style/rtl.js
var genRTLStyle2 = (token2) => {
  const {
    componentCls,
    lineWidthBold
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}${componentCls}-rtl`]: {
      direction: "rtl",
      // nav
      [`&${componentCls}-navigation${componentCls}-horizontal`]: {
        [`${itemCls}:after`]: {
          transform: "translateY(-50%) rotate(-45deg)"
        }
      },
      // panel
      [`&${componentCls}-panel`]: {
        [`${componentCls}-panel-arrow`]: {
          transform: `scaleX(-1)`
        },
        [`&${componentCls}-filled`]: {
          [itemCls]: {
            "&:not(:first-child)": {
              clipPath: `polygon(${[`calc(0px - var(--steps-item-base-width)) 0px`, `calc(100% - ${unit(lineWidthBold)}) 0px`, `calc(100% - var(--steps-item-base-width) - ${unit(lineWidthBold)}) 50%`, `calc(100% - ${unit(lineWidthBold)}) 100%`, `calc(0px - var(--steps-item-base-width)) 100%`].join(",")})`
            }
          }
        }
      }
    }
  };
};
var rtl_default2 = genRTLStyle2;

// node_modules/antd/es/steps/style/small.js
var genSmallStyle = (token2) => {
  const {
    componentCls,
    iconSizeSM,
    fontSize,
    lineHeight,
    marginXS
  } = token2;
  return {
    [`${componentCls}${componentCls}-small`]: {
      "--steps-icon-size": iconSizeSM,
      "--steps-title-horizontal-item-margin": token2.marginSM,
      "--steps-title-vertical-row-gap": token2.paddingXS,
      "--steps-title-font-size": fontSize,
      "--steps-title-line-height": lineHeight,
      "--steps-title-horizontal-rail-margin": token2.marginXS,
      "--steps-title-horizontal-title-height": token2.fontHeight,
      // Horizontal: label vertical
      [`&${componentCls}-horizontal${componentCls}-title-vertical`]: getItemWithWidthStyle(token2, marginXS)
    }
  };
};
var small_default = genSmallStyle;

// node_modules/antd/es/steps/style/status.js
var STATUS_WAIT = "wait";
var STATUS_PROCESS = "process";
var STATUS_FINISH = "finish";
var STATUS_ERROR = "error";
var genStatusStyle3 = (token2) => {
  const {
    componentCls,
    colorTextDisabled,
    colorTextLightSolid,
    colorPrimary,
    colorTextLabel,
    colorError,
    colorText,
    colorTextDescription,
    colorBgContainer,
    colorPrimaryHover
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: [{
      // ========================= Variable =========================
      [itemCls]: {
        // Normal
        // >>> line
        "--steps-item-solid-line-color": "#000",
        // >>> text
        "--steps-item-title-color": "#000",
        "--steps-item-content-color": "#000",
        "--steps-item-subtitle-color": "var(--steps-item-content-color)",
        // >>> icon
        "--steps-item-icon-custom-color": "#000",
        "--steps-item-icon-bg-color": "#000",
        "--steps-item-icon-border-color": "#000",
        "--steps-item-icon-text-color": "#fff",
        // >>> dot
        "--steps-item-icon-dot-color": "#000",
        "--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-color)",
        "--steps-item-icon-dot-border-color": "var(--steps-item-icon-dot-color)",
        // Hover
        // >>> text
        "--steps-item-text-hover-color": "#000",
        // >>> icon
        "--steps-item-icon-bg-hover-color": `var(--steps-item-icon-bg-color)`,
        "--steps-item-icon-border-hover-color": `var(--steps-item-icon-border-color)`,
        "--steps-item-icon-text-hover-color": `var(--steps-item-icon-text-color)`,
        // Active
        // >>> text
        "--steps-item-content-active-color": `var(--steps-item-content-color)`,
        // >>> icon
        "--steps-item-icon-active-bg-color": "var(--steps-item-icon-bg-color)",
        "--steps-item-icon-active-border-color": "var(--steps-item-icon-border-color)",
        "--steps-item-icon-active-text-color": "var(--steps-item-icon-text-color)",
        // Status
        "--steps-item-process-rail-line-style": token2.lineType
      },
      // ========================= Template =========================
      // Normal
      // >>> line
      [`${itemCls}-rail`]: {
        borderColor: `var(--steps-item-solid-line-color)`
      },
      // >>> icon
      [`${itemCls}-custom ${itemCls}-icon`]: {
        color: `var(--steps-item-icon-custom-color)`
      },
      // >>> text
      [`${itemCls}-title`]: {
        color: `var(--steps-item-title-color)`
      },
      [`${itemCls}-subtitle`]: {
        color: `var(--steps-item-subtitle-color)`
      },
      [`${itemCls}-content`]: {
        color: `var(--steps-item-content-color)`
      },
      // Active
      // >>> icon
      [`${itemCls}-active ${itemCls}-icon`]: {},
      // >>> text
      [`${itemCls}-active ${itemCls}-content`]: {
        color: `var(--steps-item-content-active-color)`
      },
      // Hover
      // >>> text
      [`${itemCls}[role='button']:not(${itemCls}-active):hover`]: {
        [`${itemCls}-title, ${itemCls}-content`]: {
          color: `var(--steps-item-text-hover-color)`
        }
      },
      // Not dot
      [`&:not(${componentCls}-dot)`]: {
        [`${itemCls}:not(${itemCls}-custom)`]: {
          [`${itemCls}-icon`]: {
            background: `var(--steps-item-icon-bg-color)`,
            borderColor: `var(--steps-item-icon-border-color)`,
            color: `var(--steps-item-icon-text-color)`
          },
          // Hover
          [`&[role='button']:not(${itemCls}-active):hover`]: {
            [`${itemCls}-icon`]: {
              background: `var(--steps-item-icon-bg-hover-color)`,
              borderColor: `var(--steps-item-icon-border-hover-color)`,
              color: `var(--steps-item-icon-text-hover-color)`
            }
          },
          // Active
          [`&${itemCls}-active`]: {
            [`${itemCls}-icon`]: {
              background: `var(--steps-item-icon-active-bg-color)`,
              borderColor: `var(--steps-item-icon-active-border-color)`,
              color: `var(--steps-item-icon-active-text-color)`
            }
          }
        }
      },
      // Dot
      [`&${componentCls}-dot`]: {
        [`${itemCls}-icon`]: {
          background: `var(--steps-item-icon-dot-bg-color)`,
          borderColor: `var(--steps-item-icon-dot-border-color)`,
          color: `var(--steps-item-icon-dot-color)`,
          [`&${itemCls}-icon-dot-custom`]: {
            background: "transparent",
            border: "none"
          }
        }
      }
    }, {
      // ========================== Shared ==========================
      // Wait
      [`${itemCls}-${STATUS_WAIT}`]: {
        "--steps-item-icon-custom-color": colorTextDisabled,
        "--steps-item-title-color": colorTextDescription,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_WAIT}`]: {
        "--steps-item-solid-line-color": colorTextDisabled
      },
      // Process
      [`${itemCls}-${STATUS_PROCESS}`]: {
        "--steps-item-icon-custom-color": colorPrimary,
        "--steps-item-title-color": colorText,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_PROCESS}`]: {
        "--steps-item-solid-line-color": colorPrimary,
        // Special for Timeline usage
        "--steps-rail-line-style": "var(--steps-item-process-rail-line-style)"
      },
      // Finish
      [`${itemCls}-${STATUS_FINISH}`]: {
        "--steps-item-icon-custom-color": colorPrimary,
        "--steps-item-title-color": colorText,
        "--steps-item-content-color": colorTextDescription,
        "--steps-item-content-active-color": colorText,
        "--steps-item-text-hover-color": colorPrimaryHover
      },
      [`${itemCls}-rail-${STATUS_FINISH}`]: {
        "--steps-item-solid-line-color": colorPrimary
      },
      // Error
      [`${itemCls}-${STATUS_ERROR}`]: {
        "--steps-item-icon-custom-color": colorError,
        "--steps-item-title-color": colorError,
        "--steps-item-content-color": colorError,
        "--steps-item-content-active-color": colorError,
        "--steps-item-text-hover-color": token2.colorErrorHover
      },
      [`${itemCls}-rail-${STATUS_ERROR}`]: {
        "--steps-item-solid-line-color": colorError
      }
    }, {
      // ========================== Filled ==========================
      [`&${componentCls}-filled`]: {
        [itemCls]: {
          "--steps-item-icon-dot-border-color": "transparent"
        },
        // Wait
        [`${itemCls}-${STATUS_WAIT}`]: {
          "--steps-item-icon-bg-color": token2.colorFillTertiary,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorTextLabel,
          "--steps-item-icon-dot-bg-color": colorTextDisabled,
          // Hover
          "--steps-item-icon-bg-hover-color": token2.colorPrimaryBgHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorPrimary,
          // Active
          "--steps-item-icon-active-bg-color": colorPrimary,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        },
        // Finish & Process
        [`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
          "--steps-item-icon-bg-color": token2.colorPrimaryBg,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorPrimary,
          "--steps-item-icon-dot-bg-color": colorPrimary,
          // Hover
          "--steps-item-icon-bg-hover-color": token2.colorPrimaryBgHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorPrimary,
          // Active
          "--steps-item-icon-active-bg-color": colorPrimary,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        },
        // Error
        [`${itemCls}-${STATUS_ERROR}`]: {
          "--steps-item-icon-bg-color": token2.colorErrorBg,
          "--steps-item-icon-border-color": "transparent",
          "--steps-item-icon-text-color": colorError,
          "--steps-item-icon-dot-bg-color": colorError,
          // Hover
          "--steps-item-icon-bg-hover-color": token2.colorErrorBgFilledHover,
          "--steps-item-icon-border-hover-color": "transparent",
          "--steps-item-icon-text-hover-color": colorError,
          // Active
          "--steps-item-icon-active-bg-color": colorError,
          "--steps-item-icon-active-border-color": "transparent",
          "--steps-item-icon-active-text-color": colorTextLightSolid
        }
      }
    }, {
      // ========================= Outlined =========================
      [`&${componentCls}-outlined`]: {
        [itemCls]: {
          "--steps-item-icon-dot-bg-color": "transparent"
        },
        // Wait
        [`${itemCls}-${STATUS_WAIT}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorTextDisabled,
          "--steps-item-icon-text-color": colorTextDisabled,
          "--steps-item-icon-dot-color": colorTextDisabled,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": colorPrimaryHover,
          "--steps-item-icon-text-hover-color": colorPrimaryHover,
          // Active
          "--steps-item-icon-active-bg-color": token2.colorFillTertiary
        },
        // Finish & Process
        [`${itemCls}-${STATUS_PROCESS}, ${itemCls}-${STATUS_FINISH}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorPrimary,
          "--steps-item-icon-text-color": colorPrimary,
          "--steps-item-icon-dot-color": colorPrimary,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": token2.colorPrimaryHover,
          "--steps-item-icon-text-hover-color": token2.colorPrimaryHover,
          // Active
          "--steps-item-icon-active-bg-color": token2.colorPrimaryBg
        },
        // Error
        [`${itemCls}-${STATUS_ERROR}`]: {
          "--steps-item-icon-bg-color": colorBgContainer,
          "--steps-item-icon-border-color": colorError,
          "--steps-item-icon-text-color": colorError,
          "--steps-item-icon-dot-color": colorError,
          // Hover
          "--steps-item-icon-bg-hover-color": "transparent",
          "--steps-item-icon-border-hover-color": token2.colorErrorHover,
          "--steps-item-icon-text-hover-color": token2.colorErrorHover,
          // Active
          "--steps-item-icon-active-bg-color": token2.colorErrorBg
        }
      }
    }]
  };
};
var status_default2 = genStatusStyle3;

// node_modules/antd/es/steps/style/vertical.js
var genVerticalStyle3 = (token2) => {
  const {
    componentCls,
    calc
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-vertical`]: {
      "--steps-vertical-rail-margin": calc(token2.marginXXS).mul(1.5).equal(),
      flexDirection: "column",
      alignItems: "stretch",
      // Item
      [`> ${itemCls}`]: {
        minHeight: calc(token2.controlHeight).mul(1.5).equal(),
        paddingBottom: token2.paddingSM,
        "&:last-child": {
          paddingBottom: 0
        },
        // Icon
        [`${itemCls}-icon`]: {
          marginInlineStart: "calc((var(--steps-icon-size-max) - var(--steps-icon-size)) / 2)"
        },
        // >>> Rail
        [`${itemCls}-rail`]: {
          "--steps-rail-offset": calc("var(--steps-heading-height)").sub("var(--steps-icon-size)").div(2).equal(),
          borderInlineStartWidth: "var(--steps-rail-size)",
          position: "absolute",
          top: calc(`var(--steps-icon-size)`).add("var(--steps-item-wrapper-padding-top)").add("var(--steps-rail-offset)").add("var(--steps-vertical-rail-margin)").equal(),
          insetInlineStart: calc(`var(--steps-icon-size-max)`).div(2).equal(),
          bottom: calc("var(--steps-vertical-rail-margin)").sub("var(--steps-rail-offset)").equal(),
          marginInlineStart: `calc(var(--steps-rail-size) / -2)`
        }
      }
    }
  };
};
var vertical_default2 = genVerticalStyle3;

// node_modules/antd/es/steps/style/index.js
var genBasicStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: {
      // TODO: use `genCssVar` hook to generate css variables
      "--steps-title-font-size": token2.fontSizeLG,
      "--steps-title-line-height": token2.lineHeightLG,
      "--steps-subtitle-font-size": token2.fontSize,
      "--steps-subtitle-line-height": token2.lineHeight,
      "--steps-item-wrapper-padding-top": "0px",
      "--steps-rail-size": token2.lineWidth,
      "--steps-rail-line-style": token2.lineType,
      ...resetComponent(token2),
      display: "flex",
      flexWrap: "nowrap",
      alignItems: "flex-start",
      [itemCls]: {
        flex: "none",
        position: "relative"
      },
      [`${itemCls}-wrapper`]: {
        display: "flex",
        flexWrap: "nowrap",
        paddingTop: `var(--steps-item-wrapper-padding-top)`
      },
      // Icon
      // Check `./icon.ts`
      // Header
      [`${itemCls}-header`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "center"
      },
      // >>> Title
      [`${itemCls}-title`]: {
        color: token2.colorText,
        fontSize: `var(--steps-title-font-size)`,
        lineHeight: `var(--steps-title-line-height)`,
        wordBreak: "break-word"
      },
      // >>> Sub Title
      [`${itemCls}-subtitle`]: {
        color: token2.colorTextDescription,
        fontWeight: "normal",
        fontSize: `var(--steps-subtitle-font-size)`,
        lineHeight: `var(--steps-subtitle-line-height)`,
        marginInlineStart: token2.marginXS,
        wordBreak: "break-word"
      },
      // Content
      [`${itemCls}-content`]: {
        color: token2.colorTextDescription,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        wordBreak: "break-word"
      },
      // Rail
      [`${itemCls}-rail`]: {
        borderStyle: "var(--steps-rail-line-style)",
        borderWidth: 0
      },
      // Motion
      [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content, ${itemCls}-rail`]: {
        transition: `all ${token2.motionDurationSlow}`
      },
      // ========================== Ellipsis ==========================
      [`&${componentCls}-ellipsis`]: {
        [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: textEllipsis
      },
      // ========================= Clickable ==========================
      [`${itemCls}[role='button']:not(${itemCls}-active):hover`]: {
        cursor: "pointer"
      }
    }
  };
};
var prepareComponentToken49 = (token2) => ({
  titleLineHeight: token2.controlHeight,
  customIconSize: token2.controlHeight,
  customIconTop: 0,
  customIconFontSize: token2.controlHeightSM,
  iconSize: token2.controlHeight,
  iconTop: -0.5,
  // magic for ui experience
  iconFontSize: token2.fontSize,
  iconSizeSM: token2.fontSizeHeading3,
  dotSize: token2.controlHeight / 4,
  dotCurrentSize: token2.controlHeightLG / 4,
  navArrowColor: token2.colorTextDisabled,
  navContentMaxWidth: "unset",
  descriptionMaxWidth: void 0,
  // should be `undefined` to create css var
  waitIconColor: token2.wireframe ? token2.colorTextDisabled : token2.colorTextLabel,
  waitIconBgColor: token2.wireframe ? token2.colorBgContainer : token2.colorFillContent,
  waitIconBorderColor: token2.wireframe ? token2.colorTextDisabled : "transparent",
  finishIconBgColor: token2.wireframe ? token2.colorBgContainer : token2.controlItemBgActive,
  finishIconBorderColor: token2.wireframe ? token2.colorPrimary : token2.controlItemBgActive
});
var style_default56 = genStyleHooks("Steps", (token2) => {
  const stepsToken = merge2(token2, {
    inlineDotSize: 6
  });
  return [genBasicStyle(stepsToken), icon_default(stepsToken), vertical_default2(stepsToken), horizontal_default2(stepsToken), label_placement_default(stepsToken), small_default(stepsToken), progress_dot_default(stepsToken), status_default2(stepsToken), nav_default(stepsToken), panel_default3(stepsToken), inline_default(stepsToken), progress_default3(stepsToken), rtl_default2(stepsToken)];
}, prepareComponentToken49);

// node_modules/antd/es/steps/index.js
var waveEffectClassNames = {
  itemIcon: TARGET_CLS
};
var Steps4 = (props) => {
  const {
    // Style
    size,
    className,
    rootClassName,
    style: style2,
    variant = "filled",
    type: type5,
    classNames,
    styles,
    // Layout
    direction,
    orientation,
    responsive = true,
    progressDot,
    labelPlacement,
    titlePlacement,
    ellipsis,
    offset: offset3 = 0,
    // Data
    items,
    percent,
    current = 0,
    onChange,
    // Render
    iconRender,
    // MISC
    ...restProps
  } = props;
  const internalContent = React531.useContext(InternalContext);
  const contextContent = useComponentConfig("steps");
  const {
    getPrefixCls,
    direction: rtlDirection,
    className: contextClassName,
    style: contextStyle
  } = contextContent;
  let contextClassNames;
  let contextStyles;
  let components2 = {};
  if (internalContent) {
    components2 = {
      root: internalContent.rootComponent,
      item: internalContent.itemComponent
    };
  } else {
    ({
      classNames: contextClassNames,
      styles: contextStyles
    } = contextContent);
  }
  const prefixCls = getPrefixCls("steps", props.prefixCls);
  const itemIconCls = `${prefixCls}-item-icon`;
  const [hashId, cssVarCls] = style_default56(prefixCls);
  const mergedSize = useSize_default(size);
  const mergedItems = React531.useMemo(() => (items || []).filter(Boolean), [items]);
  const {
    xs
  } = useBreakpoint_default(responsive);
  const mergedType = React531.useMemo(() => {
    if (type5 && type5 !== "default") {
      return type5;
    }
    if (progressDot) {
      return "dot";
    }
    return type5;
  }, [progressDot, type5]);
  const isInline = mergedType === "inline";
  const isDot = mergedType === "dot" || mergedType === "inline";
  const legacyProgressDotRender = React531.useMemo(() => {
    return mergedType === "dot" && typeof progressDot === "function" ? progressDot : void 0;
  }, [mergedType, progressDot]);
  const mergedOrientation = React531.useMemo(() => {
    const nextOrientation = orientation || direction;
    if (mergedType === "panel") {
      return "horizontal";
    }
    return responsive && xs || nextOrientation === "vertical" ? "vertical" : "horizontal";
  }, [orientation, direction, mergedType, responsive, xs]);
  const mergedTitlePlacement = React531.useMemo(() => {
    if (isDot || mergedOrientation === "vertical") {
      return mergedOrientation === "vertical" ? "horizontal" : "vertical";
    }
    if (type5 === "navigation") {
      return "horizontal";
    }
    return titlePlacement || labelPlacement || "horizontal";
  }, [isDot, labelPlacement, mergedOrientation, titlePlacement, type5]);
  const mergedPercent = isInline ? void 0 : percent;
  const mergedProps = {
    ...props,
    variant,
    size: mergedSize,
    type: mergedType,
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    current,
    percent: mergedPercent,
    responsive,
    offset: offset3
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([waveEffectClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const internalIconRender = (_, info) => {
    const {
      item,
      index: index2,
      active,
      components: {
        Icon: StepIcon2
      }
    } = info;
    const {
      status,
      icon
    } = item;
    let iconContent = null;
    if (isDot || icon) {
      iconContent = icon;
    } else {
      switch (status) {
        case "finish":
          iconContent = React531.createElement(CheckOutlined_default, {
            className: `${itemIconCls}-finish`
          });
          break;
        case "error":
          iconContent = React531.createElement(CloseOutlined_default, {
            className: `${itemIconCls}-error`
          });
          break;
        default: {
          let numNode = React531.createElement("span", {
            className: `${itemIconCls}-number`
          }, info.index + 1);
          if (status === "process" && mergedPercent !== void 0) {
            numNode = React531.createElement(ProgressIcon, {
              prefixCls,
              percent: mergedPercent
            }, numNode);
          }
          iconContent = numNode;
        }
      }
    }
    let iconNode = React531.createElement(StepIcon2, null, iconContent);
    if (iconRender) {
      iconNode = iconRender(iconNode, {
        index: index2,
        active,
        item,
        components: {
          Icon: StepIcon2
        }
      });
    } else if (typeof legacyProgressDotRender === "function") {
      iconNode = legacyProgressDotRender(iconNode, {
        index: index2,
        ...item
      });
    }
    return iconNode;
  };
  const itemRender = (itemNode, itemInfo) => {
    let content = itemNode;
    if (isInline && itemInfo.item.content) {
      content = React531.createElement(tooltip_default, {
        destroyOnHidden: true,
        title: itemInfo.item.content
      }, itemNode);
    }
    return React531.createElement(wave_default, {
      component: "Steps",
      disabled: itemInfo.item.disabled || !onChange,
      colorSource: variant === "filled" ? "color" : null
    }, content);
  };
  const itemWrapperRender = mergedType === "panel" ? (itemNode) => {
    return React531.createElement(React531.Fragment, null, itemNode, React531.createElement(PanelArrow, {
      prefixCls
    }));
  } : void 0;
  const mergedStyle = {
    "--steps-items-offset": `${offset3}`,
    ...contextStyle,
    ...style2
  };
  const stepsClassName = clsx(contextClassName, `${prefixCls}-${variant}`, {
    [`${prefixCls}-${mergedType}`]: mergedType !== "dot" ? mergedType : false,
    [`${prefixCls}-rtl`]: rtlDirection === "rtl",
    [`${prefixCls}-dot`]: isDot,
    [`${prefixCls}-ellipsis`]: ellipsis,
    [`${prefixCls}-with-progress`]: mergedPercent !== void 0,
    [`${prefixCls}-${mergedSize}`]: mergedSize
  }, className, rootClassName, hashId, cssVarCls);
  if (true) {
    const warning5 = devUseWarning("Steps");
    warning5.deprecated(!labelPlacement, "labelPlacement", "titlePlacement");
    warning5.deprecated(!progressDot, "progressDot", 'type="dot"');
    warning5.deprecated(!direction, "direction", "orientation");
    warning5.deprecated(mergedItems.every((item) => !item.description), "items.description", "items.content");
  }
  return React531.createElement(es_default31, {
    ...restProps,
    // Style
    prefixCls,
    className: stepsClassName,
    style: mergedStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    // Layout
    orientation: mergedOrientation,
    titlePlacement: mergedTitlePlacement,
    components: components2,
    // Data
    current,
    items: mergedItems,
    onChange,
    // Render
    iconRender: internalIconRender,
    itemRender,
    itemWrapperRender
  });
};
if (true) {
  Steps4.displayName = "Steps";
}
var steps_default = Steps4;

// node_modules/antd/es/switch/index.js
var React533 = __toESM(require_react());

// node_modules/@rc-component/switch/es/index.js
var React532 = __toESM(require_react());
function _extends79() {
  _extends79 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends79.apply(this, arguments);
}
var Switch = React532.forwardRef(({
  prefixCls = "rc-switch",
  className,
  checked,
  defaultChecked,
  disabled,
  loadingIcon,
  checkedChildren,
  unCheckedChildren,
  onClick,
  onChange,
  onKeyDown: onKeyDown2,
  styles,
  classNames: switchClassNames,
  ...restProps
}, ref) => {
  const [innerChecked, setInnerChecked] = useControlledState(defaultChecked ?? false, checked);
  function triggerChange(newChecked, event) {
    let mergedChecked = innerChecked;
    if (!disabled) {
      mergedChecked = newChecked;
      setInnerChecked(mergedChecked);
      onChange == null ? void 0 : onChange(mergedChecked, event);
    }
    return mergedChecked;
  }
  function onInternalKeyDown(e3) {
    if (e3.which === KeyCode_default.LEFT) {
      triggerChange(false, e3);
    } else if (e3.which === KeyCode_default.RIGHT) {
      triggerChange(true, e3);
    }
    onKeyDown2 == null ? void 0 : onKeyDown2(e3);
  }
  function onInternalClick(e3) {
    const ret = triggerChange(!innerChecked, e3);
    onClick == null ? void 0 : onClick(ret, e3);
  }
  const switchClassName = clsx(prefixCls, className, {
    [`${prefixCls}-checked`]: innerChecked,
    [`${prefixCls}-disabled`]: disabled
  });
  return React532.createElement("button", _extends79({}, restProps, {
    type: "button",
    role: "switch",
    "aria-checked": innerChecked,
    disabled,
    className: switchClassName,
    ref,
    onKeyDown: onInternalKeyDown,
    onClick: onInternalClick
  }), loadingIcon, React532.createElement("span", {
    className: `${prefixCls}-inner`
  }, React532.createElement("span", {
    className: clsx(`${prefixCls}-inner-checked`, switchClassNames == null ? void 0 : switchClassNames.content),
    style: styles == null ? void 0 : styles.content
  }, checkedChildren), React532.createElement("span", {
    className: clsx(`${prefixCls}-inner-unchecked`, switchClassNames == null ? void 0 : switchClassNames.content),
    style: styles == null ? void 0 : styles.content
  }, unCheckedChildren)));
});
Switch.displayName = "Switch";
var es_default32 = Switch;

// node_modules/antd/es/switch/style/index.js
var genSwitchSmallStyle = (token2) => {
  const {
    componentCls,
    trackHeightSM,
    trackPadding,
    trackMinWidthSM,
    innerMinMarginSM,
    innerMaxMarginSM,
    handleSizeSM,
    calc
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMarginSM).mul(2).equal());
  return {
    [componentCls]: {
      [`&${componentCls}-small`]: {
        minWidth: trackMinWidthSM,
        height: trackHeightSM,
        lineHeight: unit(trackHeightSM),
        [`${componentCls}-inner`]: {
          paddingInlineStart: innerMaxMarginSM,
          paddingInlineEnd: innerMinMarginSM,
          [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
            minHeight: trackHeightSM
          },
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
            marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: calc(trackHeightSM).mul(-1).equal(),
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${componentCls}-handle`]: {
          width: handleSizeSM,
          height: handleSizeSM
        },
        [`${componentCls}-loading-icon`]: {
          top: calc(calc(handleSizeSM).sub(token2.switchLoadingIconSize)).div(2).equal(),
          fontSize: token2.switchLoadingIconSize
        },
        [`&${componentCls}-checked`]: {
          [`${componentCls}-inner`]: {
            paddingInlineStart: innerMinMarginSM,
            paddingInlineEnd: innerMaxMarginSM,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
            }
          },
          [`${componentCls}-handle`]: {
            insetInlineStart: `calc(100% - ${unit(calc(handleSizeSM).add(trackPadding).equal())})`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: calc(token2.marginXXS).div(2).equal(),
              marginInlineEnd: calc(token2.marginXXS).mul(-1).div(2).equal()
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: calc(token2.marginXXS).mul(-1).div(2).equal(),
              marginInlineEnd: calc(token2.marginXXS).div(2).equal()
            }
          }
        }
      }
    }
  };
};
var genSwitchLoadingStyle = (token2) => {
  const {
    componentCls,
    handleSize,
    calc
  } = token2;
  return {
    [componentCls]: {
      [`${componentCls}-loading-icon${token2.iconCls}`]: {
        position: "relative",
        top: calc(calc(handleSize).sub(token2.fontSize)).div(2).equal(),
        color: token2.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
        color: token2.switchColor
      }
    }
  };
};
var genSwitchHandleStyle = (token2) => {
  const {
    componentCls,
    trackPadding,
    handleBg,
    handleShadow,
    handleSize,
    calc
  } = token2;
  const switchHandleCls = `${componentCls}-handle`;
  return {
    [componentCls]: {
      [switchHandleCls]: {
        position: "absolute",
        top: trackPadding,
        insetInlineStart: trackPadding,
        width: handleSize,
        height: handleSize,
        transition: `all ${token2.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: handleBg,
          borderRadius: calc(handleSize).div(2).equal(),
          boxShadow: handleShadow,
          transition: `all ${token2.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${componentCls}-checked ${switchHandleCls}`]: {
        insetInlineStart: `calc(100% - ${unit(calc(handleSize).add(trackPadding).equal())})`
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`${switchHandleCls}::before`]: {
          insetInlineEnd: token2.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${componentCls}-checked ${switchHandleCls}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: token2.switchHandleActiveInset
        }
      }
    }
  };
};
var genSwitchInnerStyle = (token2) => {
  const {
    componentCls,
    trackHeight,
    trackPadding,
    innerMinMargin,
    innerMaxMargin,
    handleSize,
    calc
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  const trackPaddingCalc = unit(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
  const innerMaxMarginCalc = unit(calc(innerMaxMargin).mul(2).equal());
  return {
    [componentCls]: {
      [switchInnerCls]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: innerMaxMargin,
        paddingInlineEnd: innerMinMargin,
        transition: `padding-inline-start ${token2.switchDuration} ease-in-out, padding-inline-end ${token2.switchDuration} ease-in-out`,
        [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
          display: "block",
          color: token2.colorTextLightSolid,
          fontSize: token2.fontSizeSM,
          transition: `margin-inline-start ${token2.switchDuration} ease-in-out, margin-inline-end ${token2.switchDuration} ease-in-out`,
          pointerEvents: "none",
          minHeight: trackHeight
        },
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
        },
        [`${switchInnerCls}-unchecked`]: {
          marginTop: calc(trackHeight).mul(-1).equal(),
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${componentCls}-checked ${switchInnerCls}`]: {
        paddingInlineStart: innerMinMargin,
        paddingInlineEnd: innerMaxMargin,
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${switchInnerCls}-unchecked`]: {
          marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
          marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
        }
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: calc(trackPadding).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
            marginInlineEnd: calc(trackPadding).mul(2).equal()
          }
        }
      }
    }
  };
};
var genSwitchStyle = (token2) => {
  const {
    componentCls,
    trackHeight,
    trackMinWidth
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: trackMinWidth,
      height: trackHeight,
      lineHeight: unit(trackHeight),
      verticalAlign: "middle",
      background: token2.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${componentCls}-disabled)`]: {
        background: token2.colorTextTertiary
      },
      ...genFocusStyle(token2),
      [`&${componentCls}-checked`]: {
        background: token2.switchColor,
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token2.colorPrimaryHover
        }
      },
      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
        cursor: "not-allowed",
        opacity: token2.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken50 = (token2) => {
  const {
    fontSize,
    lineHeight,
    controlHeight,
    colorWhite
  } = token2;
  const height = fontSize * lineHeight;
  const heightSM = controlHeight / 2;
  const padding = 2;
  const handleSize = height - padding * 2;
  const handleSizeSM = heightSM - padding * 2;
  return {
    trackHeight: height,
    trackHeightSM: heightSM,
    trackMinWidth: handleSize * 2 + padding * 4,
    trackMinWidthSM: handleSizeSM * 2 + padding * 2,
    trackPadding: padding,
    // Fixed value
    handleBg: colorWhite,
    handleSize,
    handleSizeSM,
    handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(0.2).toRgbString()}`,
    innerMinMargin: handleSize / 2,
    innerMaxMargin: handleSize + padding + padding * 2,
    innerMinMarginSM: handleSizeSM / 2,
    innerMaxMarginSM: handleSizeSM + padding + padding * 2
  };
};
var style_default57 = genStyleHooks("Switch", (token2) => {
  const switchToken = merge2(token2, {
    switchDuration: token2.motionDurationMid,
    switchColor: token2.colorPrimary,
    switchDisabledOpacity: token2.opacityLoading,
    switchLoadingIconSize: token2.calc(token2.fontSizeIcon).mul(0.75).equal(),
    switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    genSwitchStyle(switchToken),
    // inner style
    genSwitchInnerStyle(switchToken),
    // handle style
    genSwitchHandleStyle(switchToken),
    // loading style
    genSwitchLoadingStyle(switchToken),
    // small style
    genSwitchSmallStyle(switchToken)
  ];
}, prepareComponentToken50);

// node_modules/antd/es/switch/index.js
var InternalSwitch = React533.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    loading,
    className,
    rootClassName,
    style: style2,
    checked: checkedProp,
    value,
    defaultChecked: defaultCheckedProp,
    defaultValue,
    onChange,
    styles,
    classNames,
    ...restProps
  } = props;
  const [checked, setChecked] = useControlledState(defaultCheckedProp ?? defaultValue ?? false, checkedProp ?? value);
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("switch");
  const disabled = React533.useContext(DisabledContext_default);
  const mergedDisabled = (customDisabled ?? disabled) || loading;
  const prefixCls = getPrefixCls("switch", customizePrefixCls);
  const loadingIcon = React533.createElement("div", {
    className: `${prefixCls}-handle`
  }, loading && React533.createElement(LoadingOutlined_default, {
    className: `${prefixCls}-loading-icon`
  }));
  const [hashId, cssVarCls] = style_default57(prefixCls);
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const classes = clsx(contextClassName, {
    [`${prefixCls}-small`]: mergedSize === "small",
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const changeHandler = (...args) => {
    setChecked(args[0]);
    onChange == null ? void 0 : onChange(...args);
  };
  return React533.createElement(wave_default, {
    component: "Switch",
    disabled: mergedDisabled
  }, React533.createElement(es_default32, {
    ...restProps,
    classNames: mergedClassNames,
    styles: mergedStyles,
    checked,
    onChange: changeHandler,
    prefixCls,
    className: classes,
    style: mergedStyle,
    disabled: mergedDisabled,
    ref,
    loadingIcon
  }));
});
var Switch2 = InternalSwitch;
Switch2.__ANT_SWITCH = true;
if (true) {
  Switch2.displayName = "Switch";
}
var switch_default = Switch2;

// node_modules/antd/es/table/Table.js
var React591 = __toESM(require_react());

// node_modules/@rc-component/table/es/constant.js
var EXPAND_COLUMN = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";

// node_modules/@rc-component/context/es/context.js
var React534 = __toESM(require_react());
var import_react_dom7 = __toESM(require_react_dom());
function createContext51(defaultValue) {
  const Context3 = React534.createContext(void 0);
  const Provider = ({
    value,
    children
  }) => {
    const valueRef = React534.useRef(value);
    valueRef.current = value;
    const [context] = React534.useState(() => ({
      getValue: () => valueRef.current,
      listeners: /* @__PURE__ */ new Set()
    }));
    useLayoutEffect_default(() => {
      (0, import_react_dom7.unstable_batchedUpdates)(() => {
        context.listeners.forEach((listener) => {
          listener(value);
        });
      });
    }, [value]);
    return React534.createElement(Context3.Provider, {
      value: context
    }, children);
  };
  return {
    Context: Context3,
    Provider,
    defaultValue
  };
}
function useContext180(holder, selector) {
  const eventSelector = useEvent_default(typeof selector === "function" ? selector : (ctx) => {
    if (selector === void 0) {
      return ctx;
    }
    if (!Array.isArray(selector)) {
      return ctx[selector];
    }
    const obj = {};
    selector.forEach((key) => {
      obj[key] = ctx[key];
    });
    return obj;
  });
  const context = React534.useContext(holder == null ? void 0 : holder.Context);
  const {
    listeners,
    getValue: getValue2
  } = context || {};
  const valueRef = React534.useRef();
  valueRef.current = eventSelector(context ? getValue2() : holder == null ? void 0 : holder.defaultValue);
  const [, forceUpdate] = React534.useState({});
  useLayoutEffect_default(() => {
    if (!context) {
      return;
    }
    function trigger(nextValue) {
      const nextSelectorValue = eventSelector(nextValue);
      if (!isEqual_default(valueRef.current, nextSelectorValue, true)) {
        forceUpdate({});
      }
    }
    listeners.add(trigger);
    return () => {
      listeners.delete(trigger);
    };
  }, [context]);
  return valueRef.current;
}

// node_modules/@rc-component/context/es/Immutable.js
var React535 = __toESM(require_react());
function _extends80() {
  _extends80 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends80.apply(this, arguments);
}
function createImmutable() {
  const ImmutableContext = React535.createContext(null);
  function useImmutableMark3() {
    return React535.useContext(ImmutableContext);
  }
  function makeImmutable3(Component8, shouldTriggerRender) {
    const refAble = supportRef(Component8);
    const ImmutableComponent = (props, ref) => {
      const refProps = refAble ? {
        ref
      } : {};
      const renderTimesRef = React535.useRef(0);
      const prevProps = React535.useRef(props);
      const mark = useImmutableMark3();
      if (mark !== null) {
        return React535.createElement(Component8, _extends80({}, props, refProps));
      }
      if (
        // Always trigger re-render if `shouldTriggerRender` is not provided
        !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
      ) {
        renderTimesRef.current += 1;
      }
      prevProps.current = props;
      return React535.createElement(ImmutableContext.Provider, {
        value: renderTimesRef.current
      }, React535.createElement(Component8, _extends80({}, props, refProps)));
    };
    if (true) {
      ImmutableComponent.displayName = `ImmutableRoot(${Component8.displayName || Component8.name})`;
    }
    return refAble ? React535.forwardRef(ImmutableComponent) : ImmutableComponent;
  }
  function responseImmutable3(Component8, propsAreEqual) {
    const refAble = supportRef(Component8);
    const ImmutableComponent = (props, ref) => {
      const refProps = refAble ? {
        ref
      } : {};
      useImmutableMark3();
      return React535.createElement(Component8, _extends80({}, props, refProps));
    };
    if (true) {
      ImmutableComponent.displayName = `ImmutableResponse(${Component8.displayName || Component8.name})`;
    }
    return React535.memo(refAble ? React535.forwardRef(ImmutableComponent) : ImmutableComponent, propsAreEqual);
  }
  return {
    makeImmutable: makeImmutable3,
    responseImmutable: responseImmutable3,
    useImmutableMark: useImmutableMark3
  };
}

// node_modules/@rc-component/context/es/index.js
var {
  makeImmutable,
  responseImmutable,
  useImmutableMark
} = createImmutable();

// node_modules/@rc-component/table/es/Footer/index.js
var React543 = __toESM(require_react());

// node_modules/@rc-component/table/es/context/TableContext.js
var {
  makeImmutable: makeImmutable2,
  responseImmutable: responseImmutable2,
  useImmutableMark: useImmutableMark2
} = createImmutable();
var TableContext = createContext51();
var TableContext_default = TableContext;

// node_modules/@rc-component/table/es/hooks/useRenderTimes.js
var React536 = __toESM(require_react());
function useRenderTimes(props, debug) {
  const timesRef = React536.useRef(0);
  timesRef.current += 1;
  const propsRef = React536.useRef(props);
  const keys2 = [];
  Object.keys(props || {}).map((key) => {
    var _a;
    if ((props == null ? void 0 : props[key]) !== ((_a = propsRef.current) == null ? void 0 : _a[key])) {
      keys2.push(key);
    }
  });
  propsRef.current = props;
  const keysRef = React536.useRef([]);
  if (keys2.length) {
    keysRef.current = keys2;
  }
  React536.useDebugValue(timesRef.current);
  React536.useDebugValue(keysRef.current.join(", "));
  if (debug) {
    console.log(`${debug}:`, timesRef.current, keysRef.current);
  }
  return timesRef.current;
}
var useRenderTimes_default = true ? useRenderTimes : () => {
};
var RenderBlock = React536.memo(() => {
  const times = useRenderTimes();
  return React536.createElement("h1", null, "Render Times: ", times);
});
if (true) {
  RenderBlock.displayName = "RenderBlock";
}

// node_modules/@rc-component/table/es/Footer/Cell.js
var React541 = __toESM(require_react());

// node_modules/@rc-component/table/es/Cell/index.js
var React539 = __toESM(require_react());

// node_modules/@rc-component/table/es/Cell/useCellRender.js
var React538 = __toESM(require_react());

// node_modules/@rc-component/table/es/context/PerfContext.js
var React537 = __toESM(require_react());
var PerfContext = React537.createContext({
  renderWithProps: false
});
var PerfContext_default = PerfContext;

// node_modules/@rc-component/table/es/utils/valueUtil.js
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray8(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getColumnsKey(columns) {
  const columnKeys = [];
  const keys2 = {};
  columns.forEach((column2) => {
    const {
      key,
      dataIndex
    } = column2 || {};
    let mergedKey = key || toArray8(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = `${mergedKey}_next`;
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
function validNumberValue(value) {
  return typeof value === "number" && !Number.isNaN(value);
}

// node_modules/@rc-component/table/es/Cell/useCellRender.js
function isRenderCell(data) {
  return data && typeof data === "object" && !Array.isArray(data) && !React538.isValidElement(data);
}
function useCellRender2(record, dataIndex, renderIndex, children, render2, shouldCellUpdate) {
  const perfRecord = React538.useContext(PerfContext_default);
  const mark = useImmutableMark2();
  const retData = useMemo(() => {
    if (validateValue(children)) {
      return [children];
    }
    const path2 = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
    const value = get(record, path2);
    let returnChildNode = value;
    let returnCellProps = void 0;
    if (render2) {
      const renderData = render2(value, record, renderIndex);
      if (isRenderCell(renderData)) {
        if (true) {
          warning_default(false, "`columns.render` return cell props is deprecated with perf issue, please use `onCell` instead.");
        }
        returnChildNode = renderData.children;
        returnCellProps = renderData.props;
        perfRecord.renderWithProps = true;
      } else {
        returnChildNode = renderData;
      }
    }
    return [returnChildNode, returnCellProps];
  }, [
    // Force update deps
    mark,
    // Normal deps
    record,
    children,
    dataIndex,
    render2,
    renderIndex
  ], (prev2, next2) => {
    if (shouldCellUpdate) {
      const [, prevRecord] = prev2;
      const [, nextRecord] = next2;
      return shouldCellUpdate(nextRecord, prevRecord);
    }
    if (perfRecord.renderWithProps) {
      return true;
    }
    return !isEqual_default(prev2, next2, true);
  });
  return retData;
}

// node_modules/@rc-component/table/es/Cell/useHoverState.js
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  const cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function useHoverState(rowIndex, rowSpan) {
  return useContext180(TableContext_default, (ctx) => {
    const hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
    return [hovering, ctx.onHover];
  });
}

// node_modules/@rc-component/table/es/Cell/index.js
function _extends81() {
  _extends81 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends81.apply(this, arguments);
}
var getTitleFromCellRenderChildren = ({
  ellipsis,
  rowType,
  children
}) => {
  var _a, _b;
  let title;
  const ellipsisConfig = ellipsis === true ? {
    showTitle: true
  } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
    if (typeof children === "string" || typeof children === "number") {
      title = children.toString();
    } else if (React539.isValidElement(children) && typeof ((_a = children.props) == null ? void 0 : _a.children) === "string") {
      title = (_b = children.props) == null ? void 0 : _b.children;
    }
  }
  return title;
};
var Cell2 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    component: Component8,
    children,
    ellipsis,
    scope,
    // Style
    prefixCls,
    className,
    style: style2,
    align,
    // Value
    record,
    render: render2,
    dataIndex,
    renderIndex,
    shouldCellUpdate,
    // Row
    index: index2,
    rowType,
    // Span
    colSpan,
    rowSpan,
    // Fixed
    fixStart,
    fixEnd,
    fixedStartShadow,
    fixedEndShadow,
    offsetFixedStartShadow,
    offsetFixedEndShadow,
    zIndex,
    zIndexReverse,
    // Private
    appendNode,
    additionalProps = {},
    isSticky
  } = props;
  const cellPrefixCls = `${prefixCls}-cell`;
  const {
    allColumnsFixedLeft,
    rowHoverable
  } = useContext180(TableContext_default, ["allColumnsFixedLeft", "rowHoverable"]);
  const [childNode, legacyCellProps] = useCellRender2(record, dataIndex, renderIndex, children, render2, shouldCellUpdate);
  const fixedStyle2 = {};
  const isFixStart = typeof fixStart === "number" && !allColumnsFixedLeft;
  const isFixEnd = typeof fixEnd === "number" && !allColumnsFixedLeft;
  const [showFixStartShadow, showFixEndShadow] = useContext180(TableContext_default, ({
    scrollInfo
  }) => {
    if (!isFixStart && !isFixEnd) {
      return [false, false];
    }
    const [absScroll, scrollWidth] = scrollInfo;
    const showStartShadow = (isFixStart && fixedStartShadow && absScroll) - // For precision, we not show shadow by default which has better user experience.
    offsetFixedStartShadow >= 1;
    const showEndShadow = (isFixEnd && fixedEndShadow && scrollWidth - absScroll) - // Same as above
    offsetFixedEndShadow > 1;
    return [showStartShadow, showEndShadow];
  });
  if (isFixStart) {
    fixedStyle2.insetInlineStart = fixStart;
    fixedStyle2["--z-offset"] = zIndex;
    fixedStyle2["--z-offset-reverse"] = zIndexReverse;
  }
  if (isFixEnd) {
    fixedStyle2.insetInlineEnd = fixEnd;
    fixedStyle2["--z-offset"] = zIndex;
    fixedStyle2["--z-offset-reverse"] = zIndexReverse;
  }
  const mergedColSpan = (legacyCellProps == null ? void 0 : legacyCellProps.colSpan) ?? additionalProps.colSpan ?? colSpan ?? 1;
  const mergedRowSpan = (legacyCellProps == null ? void 0 : legacyCellProps.rowSpan) ?? additionalProps.rowSpan ?? rowSpan ?? 1;
  const [hovering, onHover] = useHoverState(index2, mergedRowSpan);
  const onMouseEnter = useEvent_default((event) => {
    var _a;
    if (record) {
      onHover(index2, index2 + mergedRowSpan - 1);
    }
    (_a = additionalProps == null ? void 0 : additionalProps.onMouseEnter) == null ? void 0 : _a.call(additionalProps, event);
  });
  const onMouseLeave = useEvent_default((event) => {
    var _a;
    if (record) {
      onHover(-1, -1);
    }
    (_a = additionalProps == null ? void 0 : additionalProps.onMouseLeave) == null ? void 0 : _a.call(additionalProps, event);
  });
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  }
  const title = additionalProps.title ?? getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  });
  const mergedClassName = clsx(cellPrefixCls, className, {
    // Fixed
    [`${cellPrefixCls}-fix`]: isFixStart || isFixEnd,
    [`${cellPrefixCls}-fix-start`]: isFixStart,
    [`${cellPrefixCls}-fix-end`]: isFixEnd,
    // Fixed shadow
    [`${cellPrefixCls}-fix-start-shadow`]: fixedStartShadow,
    [`${cellPrefixCls}-fix-start-shadow-show`]: fixedStartShadow && showFixStartShadow,
    [`${cellPrefixCls}-fix-end-shadow`]: fixedEndShadow,
    [`${cellPrefixCls}-fix-end-shadow-show`]: fixedEndShadow && showFixEndShadow,
    [`${cellPrefixCls}-ellipsis`]: ellipsis,
    [`${cellPrefixCls}-with-append`]: appendNode,
    [`${cellPrefixCls}-fix-sticky`]: (isFixStart || isFixEnd) && isSticky,
    [`${cellPrefixCls}-row-hover`]: !legacyCellProps && hovering
  }, additionalProps.className, legacyCellProps == null ? void 0 : legacyCellProps.className);
  const alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  }
  const mergedStyle = {
    ...legacyCellProps == null ? void 0 : legacyCellProps.style,
    ...fixedStyle2,
    ...alignStyle,
    ...additionalProps.style,
    ...style2
  };
  let mergedChildNode = childNode;
  if (typeof mergedChildNode === "object" && !Array.isArray(mergedChildNode) && !React539.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (fixedStartShadow || fixedEndShadow)) {
    mergedChildNode = React539.createElement("span", {
      className: `${cellPrefixCls}-content`
    }, mergedChildNode);
  }
  return React539.createElement(Component8, _extends81({}, legacyCellProps, additionalProps, {
    className: mergedClassName,
    style: mergedStyle,
    title,
    scope,
    onMouseEnter: rowHoverable ? onMouseEnter : void 0,
    onMouseLeave: rowHoverable ? onMouseLeave : void 0,
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
  }), appendNode, mergedChildNode);
};
var Cell_default2 = React539.memo(Cell2);

// node_modules/@rc-component/table/es/utils/fixUtil.js
function isFixedStart(column2) {
  return column2.fixed === "start";
}
function isFixedEnd(column2) {
  return column2.fixed === "end";
}
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets) {
  const startColumn = columns[colStart] || {};
  const endColumn = columns[colEnd] || {};
  let fixStart = null;
  let fixEnd = null;
  if (isFixedStart(startColumn) && isFixedStart(endColumn)) {
    fixStart = stickyOffsets.start[colStart];
  } else if (isFixedEnd(endColumn) && isFixedEnd(startColumn)) {
    fixEnd = stickyOffsets.end[colEnd];
  }
  let fixedStartShadow = false;
  let fixedEndShadow = false;
  let zIndex = 0;
  let zIndexReverse = 0;
  if (fixStart !== null) {
    fixedStartShadow = !columns[colEnd + 1] || !isFixedStart(columns[colEnd + 1]);
    zIndex = columns.length * 2 - colStart;
    zIndexReverse = columns.length + colStart;
  }
  if (fixEnd !== null) {
    fixedEndShadow = !columns[colStart - 1] || !isFixedEnd(columns[colStart - 1]);
    zIndex = colEnd;
    zIndexReverse = columns.length - colEnd;
  }
  let offsetFixedStartShadow = 0;
  let offsetFixedEndShadow = 0;
  if (fixedStartShadow) {
    for (let i = 0; i < colStart; i += 1) {
      if (!isFixedStart(columns[i])) {
        offsetFixedStartShadow += stickyOffsets.widths[i] || 0;
      }
    }
  }
  if (fixedEndShadow) {
    for (let i = columns.length - 1; i > colEnd; i -= 1) {
      if (!isFixedEnd(columns[i])) {
        offsetFixedEndShadow += stickyOffsets.widths[i] || 0;
      }
    }
  }
  return {
    fixStart,
    fixEnd,
    fixedStartShadow,
    fixedEndShadow,
    offsetFixedStartShadow,
    offsetFixedEndShadow,
    isSticky: stickyOffsets.isSticky,
    zIndex,
    zIndexReverse
  };
}

// node_modules/@rc-component/table/es/Footer/SummaryContext.js
var React540 = __toESM(require_react());
var SummaryContext = React540.createContext({});
var SummaryContext_default = SummaryContext;

// node_modules/@rc-component/table/es/Footer/Cell.js
function _extends82() {
  _extends82 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends82.apply(this, arguments);
}
var SummaryCell = (props) => {
  const {
    className,
    index: index2,
    children,
    colSpan = 1,
    rowSpan,
    align
  } = props;
  const {
    prefixCls
  } = useContext180(TableContext_default, ["prefixCls"]);
  const {
    scrollColumnIndex,
    stickyOffsets,
    flattenColumns
  } = React541.useContext(SummaryContext_default);
  const lastIndex = index2 + colSpan - 1;
  const mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  const fixedInfo = React541.useMemo(() => getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets), [index2, mergedColSpan, flattenColumns, stickyOffsets]);
  return React541.createElement(Cell_default2, _extends82({
    className,
    index: index2,
    component: "td",
    prefixCls,
    record: null,
    dataIndex: null,
    align,
    colSpan: mergedColSpan,
    rowSpan,
    render: () => children
  }, fixedInfo));
};
var Cell_default3 = SummaryCell;

// node_modules/@rc-component/table/es/Footer/Row.js
var React542 = __toESM(require_react());
var FooterRow = (props) => {
  const {
    children,
    ...restProps
  } = props;
  return React542.createElement("tr", restProps, children);
};
var Row_default2 = FooterRow;

// node_modules/@rc-component/table/es/Footer/Summary.js
var Summary = (props) => {
  const {
    children
  } = props;
  return children;
};
Summary.Row = Row_default2;
Summary.Cell = Cell_default3;
var Summary_default = Summary;

// node_modules/@rc-component/table/es/Footer/index.js
var Footer5 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    children,
    stickyOffsets,
    flattenColumns
  } = props;
  const prefixCls = useContext180(TableContext_default, "prefixCls");
  const lastColumnIndex = flattenColumns.length - 1;
  const scrollColumn = flattenColumns[lastColumnIndex];
  const summaryContext = React543.useMemo(() => ({
    stickyOffsets,
    flattenColumns,
    scrollColumnIndex: (scrollColumn == null ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null
  }), [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return React543.createElement(SummaryContext_default.Provider, {
    value: summaryContext
  }, React543.createElement("tfoot", {
    className: `${prefixCls}-summary`
  }, children));
};
var Footer_default = responseImmutable2(Footer5);
var FooterComponents = Summary_default;

// node_modules/@rc-component/table/es/sugar/Column.js
function Column2(_) {
  return null;
}
var Column_default = Column2;

// node_modules/@rc-component/table/es/sugar/ColumnGroup.js
function ColumnGroup(_) {
  return null;
}
var ColumnGroup_default = ColumnGroup;

// node_modules/@rc-component/table/es/Table.js
var React563 = __toESM(require_react());

// node_modules/@rc-component/table/es/Body/index.js
var React550 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useFlattenRecords.js
var React544 = __toESM(require_react());
function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  const key = getRowKey(record, index2);
  list.push({
    record,
    indent,
    index: index2,
    rowKey: key
  });
  const expanded = expandedKeys == null ? void 0 : expandedKeys.has(key);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (let i = 0; i < record[childrenColumnName].length; i += 1) {
      fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
    }
  }
}
function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
  const arr = React544.useMemo(() => {
    if (expandedKeys == null ? void 0 : expandedKeys.size) {
      const list = [];
      for (let i = 0; i < (data == null ? void 0 : data.length); i += 1) {
        const record = data[i];
        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
      }
      return list;
    }
    return data == null ? void 0 : data.map((item, index2) => {
      return {
        record: item,
        indent: 0,
        index: index2,
        rowKey: getRowKey(item, index2)
      };
    });
  }, [data, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}

// node_modules/@rc-component/table/es/Body/BodyRow.js
var React547 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useRowInfo.js
function useRowInfo(record, rowKey, recordIndex, indent) {
  const context = useContext180(TableContext_default, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex", "expandedKeys", "childrenColumnName", "rowExpandable", "onRow"]);
  const {
    flattenColumns,
    expandableType,
    expandedKeys,
    childrenColumnName,
    onTriggerExpand,
    rowExpandable,
    onRow,
    expandRowByClick,
    rowClassName
  } = context;
  const nestExpandable = expandableType === "nest";
  const rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
  const mergedExpandable = rowSupportExpand || nestExpandable;
  const expanded = expandedKeys && expandedKeys.has(rowKey);
  const hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  const onInternalTriggerExpand = useEvent_default(onTriggerExpand);
  const rowProps = onRow == null ? void 0 : onRow(record, recordIndex);
  const onRowClick = rowProps == null ? void 0 : rowProps.onClick;
  const onClick = (event, ...args) => {
    if (expandRowByClick && mergedExpandable) {
      onTriggerExpand(record, event);
    }
    onRowClick == null ? void 0 : onRowClick(event, ...args);
  };
  let computeRowClassName;
  if (typeof rowClassName === "string") {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === "function") {
    computeRowClassName = rowClassName(record, recordIndex, indent);
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return {
    ...context,
    columnsKey,
    nestExpandable,
    expanded,
    hasNestChildren,
    record,
    onTriggerExpand: onInternalTriggerExpand,
    rowSupportExpand,
    expandable: mergedExpandable,
    rowProps: {
      ...rowProps,
      className: clsx(computeRowClassName, rowProps == null ? void 0 : rowProps.className),
      onClick
    }
  };
}

// node_modules/@rc-component/table/es/Body/ExpandedRow.js
var React545 = __toESM(require_react());
var ExpandedRow = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    prefixCls,
    children,
    component: Component8,
    cellComponent,
    className,
    expanded,
    colSpan,
    isEmpty: isEmpty2,
    stickyOffset = 0
  } = props;
  const {
    scrollbarSize,
    fixHeader,
    fixColumn,
    componentWidth,
    horizonScroll
  } = useContext180(TableContext_default, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]);
  let contentNode = children;
  if (isEmpty2 ? horizonScroll && componentWidth : fixColumn) {
    contentNode = React545.createElement("div", {
      style: {
        width: componentWidth - stickyOffset - (fixHeader && !isEmpty2 ? scrollbarSize : 0),
        position: "sticky",
        left: stickyOffset,
        overflow: "hidden"
      },
      className: `${prefixCls}-expanded-row-fixed`
    }, contentNode);
  }
  return React545.createElement(Component8, {
    className,
    style: {
      display: expanded ? null : "none"
    }
  }, React545.createElement(Cell_default2, {
    component: cellComponent,
    prefixCls,
    colSpan
  }, contentNode));
};
var ExpandedRow_default = ExpandedRow;

// node_modules/@rc-component/table/es/utils/expandUtil.js
var React546 = __toESM(require_react());
function renderExpandIcon({
  prefixCls,
  record,
  onExpand,
  expanded,
  expandable
}) {
  const expandClassName = `${prefixCls}-row-expand-icon`;
  if (!expandable) {
    return React546.createElement("span", {
      className: clsx(expandClassName, `${prefixCls}-row-spaced`)
    });
  }
  const onClick = (event) => {
    onExpand(record, event);
    event.stopPropagation();
  };
  return React546.createElement("span", {
    className: clsx(expandClassName, {
      [`${prefixCls}-row-expanded`]: expanded,
      [`${prefixCls}-row-collapsed`]: !expanded
    }),
    onClick
  });
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  const keys2 = [];
  function dig(list) {
    (list || []).forEach((item, index2) => {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data);
  return keys2;
}
function computedExpandedClassName(cls, record, index2, indent) {
  if (typeof cls === "string") {
    return cls;
  }
  if (typeof cls === "function") {
    return cls(record, index2, indent);
  }
  return "";
}

// node_modules/@rc-component/table/es/Body/BodyRow.js
function _extends83() {
  _extends83 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends83.apply(this, arguments);
}
function getCellProps(rowInfo, column2, colIndex, indent, index2, rowKeys = [], expandedRowOffset = 0) {
  var _a;
  const {
    record,
    prefixCls,
    columnsKey,
    fixedInfoList,
    expandIconColumnIndex,
    nestExpandable,
    indentSize,
    expandIcon,
    expanded,
    hasNestChildren,
    onTriggerExpand,
    expandable,
    expandedKeys
  } = rowInfo;
  const key = columnsKey[colIndex];
  const fixedInfo = fixedInfoList[colIndex];
  let appendCellNode;
  if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
    appendCellNode = React547.createElement(React547.Fragment, null, React547.createElement("span", {
      style: {
        paddingLeft: `${indentSize * indent}px`
      },
      className: `${prefixCls}-row-indent indent-level-${indent}`
    }), expandIcon({
      prefixCls,
      expanded,
      expandable: hasNestChildren,
      record,
      onExpand: onTriggerExpand
    }));
  }
  const additionalCellProps = ((_a = column2.onCell) == null ? void 0 : _a.call(column2, record, index2)) || {};
  if (expandedRowOffset) {
    const {
      rowSpan = 1
    } = additionalCellProps;
    if (expandable && rowSpan && colIndex < expandedRowOffset) {
      let currentRowSpan = rowSpan;
      for (let i = index2; i < index2 + rowSpan; i += 1) {
        const rowKey = rowKeys[i];
        if (expandedKeys.has(rowKey)) {
          currentRowSpan += 1;
        }
      }
      additionalCellProps.rowSpan = currentRowSpan;
    }
  }
  return {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps
  };
}
var BodyRow = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    style: style2,
    classNames,
    styles,
    record,
    index: index2,
    renderIndex,
    rowKey,
    rowKeys,
    indent = 0,
    rowComponent: RowComponent,
    cellComponent,
    scopeCellComponent,
    expandedRowInfo
  } = props;
  const rowInfo = useRowInfo(record, rowKey, index2, indent);
  const {
    prefixCls,
    flattenColumns,
    expandedRowClassName,
    expandedRowRender,
    rowProps,
    // Misc
    expanded,
    rowSupportExpand
  } = rowInfo;
  const expandedRef = React547.useRef(false);
  expandedRef.current || (expandedRef.current = expanded);
  if (true) {
    useRenderTimes_default(props);
  }
  const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent);
  const baseRowNode = React547.createElement(RowComponent, _extends83({}, rowProps, {
    "data-row-key": rowKey,
    className: clsx(className, `${prefixCls}-row`, `${prefixCls}-row-level-${indent}`, rowProps == null ? void 0 : rowProps.className, classNames.row, {
      [expandedClsName]: indent >= 1
    }),
    style: {
      ...style2,
      ...rowProps == null ? void 0 : rowProps.style,
      ...styles.row
    }
  }), flattenColumns.map((column2, colIndex) => {
    const {
      render: render2,
      dataIndex,
      className: columnClassName
    } = column2;
    const {
      key,
      fixedInfo,
      appendCellNode,
      additionalCellProps
    } = getCellProps(rowInfo, column2, colIndex, indent, index2, rowKeys, expandedRowInfo == null ? void 0 : expandedRowInfo.offset);
    return React547.createElement(Cell_default2, _extends83({
      className: clsx(columnClassName, classNames.cell),
      style: styles.cell,
      ellipsis: column2.ellipsis,
      align: column2.align,
      scope: column2.rowScope,
      component: column2.rowScope ? scopeCellComponent : cellComponent,
      prefixCls,
      key,
      record,
      index: index2,
      renderIndex,
      dataIndex,
      render: render2,
      shouldCellUpdate: column2.shouldCellUpdate
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: additionalCellProps
    }));
  }));
  let expandRowNode;
  if (rowSupportExpand && (expandedRef.current || expanded)) {
    const expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    expandRowNode = React547.createElement(ExpandedRow_default, {
      expanded,
      className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName),
      prefixCls,
      component: RowComponent,
      cellComponent,
      colSpan: expandedRowInfo ? expandedRowInfo.colSpan : flattenColumns.length,
      isEmpty: false,
      stickyOffset: expandedRowInfo == null ? void 0 : expandedRowInfo.sticky
    }, expandContent);
  }
  return React547.createElement(React547.Fragment, null, baseRowNode, expandRowNode);
};
if (true) {
  BodyRow.displayName = "BodyRow";
}
var BodyRow_default = responseImmutable2(BodyRow);

// node_modules/@rc-component/table/es/Body/MeasureRow.js
var React549 = __toESM(require_react());

// node_modules/@rc-component/table/es/Body/MeasureCell.js
var React548 = __toESM(require_react());
var MeasureCell = (props) => {
  const {
    columnKey,
    onColumnResize,
    title
  } = props;
  const cellRef = React548.useRef(null);
  useLayoutEffect_default(() => {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return React548.createElement(es_default, {
    data: columnKey
  }, React548.createElement("td", {
    ref: cellRef,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      borderTop: 0,
      borderBottom: 0,
      height: 0
    }
  }, React548.createElement("div", {
    style: {
      height: 0,
      overflow: "hidden",
      fontWeight: "bold"
    }
  }, title || "")));
};
var MeasureCell_default = MeasureCell;

// node_modules/@rc-component/table/es/Body/MeasureRow.js
var MeasureRow = ({
  prefixCls,
  columnsKey,
  onColumnResize,
  columns
}) => {
  const ref = React549.useRef(null);
  const {
    measureRowRender
  } = useContext180(TableContext_default, ["measureRowRender"]);
  const measureRow = React549.createElement("tr", {
    "aria-hidden": "true",
    className: `${prefixCls}-measure-row`,
    style: {
      height: 0
    },
    ref
  }, React549.createElement(es_default.Collection, {
    onBatchResize: (infoList) => {
      if (isVisible_default(ref.current)) {
        infoList.forEach(({
          data: columnKey,
          size
        }) => {
          onColumnResize(columnKey, size.offsetWidth);
        });
      }
    }
  }, columnsKey.map((columnKey) => {
    const column2 = columns.find((col) => col.key === columnKey);
    const rawTitle = column2 == null ? void 0 : column2.title;
    const titleForMeasure = React549.isValidElement(rawTitle) ? React549.cloneElement(rawTitle, {
      ref: null
    }) : rawTitle;
    return React549.createElement(MeasureCell_default, {
      key: columnKey,
      columnKey,
      onColumnResize,
      title: titleForMeasure
    });
  })));
  return typeof measureRowRender === "function" ? measureRowRender(measureRow) : measureRow;
};
var MeasureRow_default = MeasureRow;

// node_modules/@rc-component/table/es/Body/index.js
var Body = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    data,
    measureColumnWidth
  } = props;
  const {
    prefixCls,
    getComponent,
    onColumnResize,
    flattenColumns,
    getRowKey,
    expandedKeys,
    childrenColumnName,
    emptyNode,
    classNames,
    styles,
    expandedRowOffset = 0,
    colWidths
  } = useContext180(TableContext_default, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns", "getRowKey", "expandedKeys", "childrenColumnName", "emptyNode", "classNames", "styles", "expandedRowOffset", "fixedInfoList", "colWidths"]);
  const {
    body: bodyCls = {}
  } = classNames || {};
  const {
    body: bodyStyles = {}
  } = styles || {};
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const rowKeys = React550.useMemo(() => flattenData2.map((item) => item.rowKey), [flattenData2]);
  const perfRef = React550.useRef({
    renderWithProps: false
  });
  const expandedRowInfo = React550.useMemo(() => {
    const expandedColSpan = flattenColumns.length - expandedRowOffset;
    let expandedStickyStart = 0;
    for (let i = 0; i < expandedRowOffset; i += 1) {
      expandedStickyStart += colWidths[i] || 0;
    }
    return {
      offset: expandedRowOffset,
      colSpan: expandedColSpan,
      sticky: expandedStickyStart
    };
  }, [flattenColumns.length, expandedRowOffset, colWidths]);
  const WrapperComponent = getComponent(["body", "wrapper"], "tbody");
  const trComponent = getComponent(["body", "row"], "tr");
  const tdComponent = getComponent(["body", "cell"], "td");
  const thComponent = getComponent(["body", "cell"], "th");
  let rows;
  if (data.length) {
    rows = flattenData2.map((item, idx) => {
      const {
        record,
        indent,
        index: renderIndex,
        rowKey
      } = item;
      return React550.createElement(BodyRow_default, {
        classNames: bodyCls,
        styles: bodyStyles,
        key: rowKey,
        rowKey,
        rowKeys,
        record,
        index: idx,
        renderIndex,
        rowComponent: trComponent,
        cellComponent: tdComponent,
        scopeCellComponent: thComponent,
        indent,
        expandedRowInfo
      });
    });
  } else {
    rows = React550.createElement(ExpandedRow_default, {
      expanded: true,
      className: `${prefixCls}-placeholder`,
      prefixCls,
      component: trComponent,
      cellComponent: tdComponent,
      colSpan: flattenColumns.length,
      isEmpty: true
    }, emptyNode);
  }
  const columnsKey = getColumnsKey(flattenColumns);
  return React550.createElement(PerfContext_default.Provider, {
    value: perfRef.current
  }, React550.createElement(WrapperComponent, {
    style: bodyStyles.wrapper,
    className: clsx(`${prefixCls}-tbody`, bodyCls.wrapper)
  }, measureColumnWidth && React550.createElement(MeasureRow_default, {
    prefixCls,
    columnsKey,
    onColumnResize,
    columns: flattenColumns
  }), rows));
};
if (true) {
  Body.displayName = "Body";
}
var Body_default = responseImmutable2(Body);

// node_modules/@rc-component/table/es/ColGroup.js
var React551 = __toESM(require_react());

// node_modules/@rc-component/table/es/utils/legacyUtil.js
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  const {
    expandable,
    ...legacyExpandableConfig
  } = props;
  let config;
  if ("expandable" in props) {
    config = {
      ...legacyExpandableConfig,
      ...expandable
    };
  } else {
    if (["indentSize", "expandedRowKeys", "defaultExpandedRowKeys", "defaultExpandAllRows", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "expandedRowClassName", "expandIconColumnIndex", "showExpandColumn", "title"].some((prop) => prop in props)) {
      warning_default(false, "expanded related props have been moved into `expandable`.");
    }
    config = legacyExpandableConfig;
  }
  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }
  return config;
}

// node_modules/@rc-component/table/es/ColGroup.js
function _extends84() {
  _extends84 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends84.apply(this, arguments);
}
var ColGroup = (props) => {
  const {
    colWidths,
    columns,
    columCount
  } = props;
  const {
    tableLayout
  } = useContext180(TableContext_default, ["tableLayout"]);
  const cols = [];
  const len = columCount || columns.length;
  let mustInsert = false;
  for (let i = len - 1; i >= 0; i -= 1) {
    const width = colWidths[i];
    const column2 = columns && columns[i];
    let additionalProps;
    let minWidth;
    if (column2) {
      additionalProps = column2[INTERNAL_COL_DEFINE];
      if (tableLayout === "auto") {
        minWidth = column2.minWidth;
      }
    }
    if (width || minWidth || additionalProps || mustInsert) {
      const {
        columnType,
        ...restAdditionalProps
      } = additionalProps || {};
      cols.unshift(React551.createElement("col", _extends84({
        key: i,
        style: {
          width,
          minWidth
        }
      }, restAdditionalProps)));
      mustInsert = true;
    }
  }
  return cols.length > 0 ? React551.createElement("colgroup", null, cols) : null;
};
var ColGroup_default = ColGroup;

// node_modules/@rc-component/table/es/FixedHolder/index.js
var React552 = __toESM(require_react());
var import_react207 = __toESM(require_react());
function useColumnWidth(colWidths, columCount) {
  return (0, import_react207.useMemo)(() => {
    const cloneColumns = [];
    for (let i = 0; i < columCount; i += 1) {
      const val = colWidths[i];
      if (val !== void 0) {
        cloneColumns[i] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
var FixedHolder = React552.forwardRef((props, ref) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    className,
    style: style2,
    noData,
    columns,
    flattenColumns,
    colWidths,
    colGroup,
    columCount,
    stickyOffsets,
    direction,
    fixHeader,
    stickyTopOffset,
    stickyBottomOffset,
    stickyClassName,
    scrollX,
    tableLayout = "fixed",
    onScroll,
    maxContentScroll,
    children,
    ...restProps
  } = props;
  const {
    prefixCls,
    scrollbarSize,
    isSticky,
    getComponent
  } = useContext180(TableContext_default, ["prefixCls", "scrollbarSize", "isSticky", "getComponent"]);
  const TableComponent = getComponent(["header", "table"], "table");
  const combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
  const scrollRef = React552.useRef(null);
  const setScrollRef = React552.useCallback((element) => {
    fillRef(ref, element);
    fillRef(scrollRef, element);
  }, []);
  React552.useEffect(() => {
    function onWheel(e3) {
      const {
        currentTarget,
        deltaX
      } = e3;
      if (deltaX) {
        const {
          scrollLeft,
          scrollWidth,
          clientWidth
        } = currentTarget;
        const maxScrollWidth = scrollWidth - clientWidth;
        let nextScroll = scrollLeft + deltaX;
        if (direction === "rtl") {
          nextScroll = Math.max(-maxScrollWidth, nextScroll);
          nextScroll = Math.min(0, nextScroll);
        } else {
          nextScroll = Math.min(maxScrollWidth, nextScroll);
          nextScroll = Math.max(0, nextScroll);
        }
        onScroll({
          currentTarget,
          scrollLeft: nextScroll
        });
        e3.preventDefault();
      }
    }
    const scrollEle = scrollRef.current;
    scrollEle == null ? void 0 : scrollEle.addEventListener("wheel", onWheel, {
      passive: false
    });
    return () => {
      scrollEle == null ? void 0 : scrollEle.removeEventListener("wheel", onWheel);
    };
  }, []);
  const lastColumn = flattenColumns[flattenColumns.length - 1];
  const ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: () => ({
      className: `${prefixCls}-cell-scrollbar`
    })
  };
  const columnsWithScrollbar = (0, import_react207.useMemo)(() => combinationScrollBarSize ? [...columns, ScrollBarColumn] : columns, [combinationScrollBarSize, columns]);
  const flattenColumnsWithScrollbar = (0, import_react207.useMemo)(() => combinationScrollBarSize ? [...flattenColumns, ScrollBarColumn] : flattenColumns, [combinationScrollBarSize, flattenColumns]);
  const headerStickyOffsets = (0, import_react207.useMemo)(() => {
    const {
      start,
      end
    } = stickyOffsets;
    return {
      ...stickyOffsets,
      // left:
      //   direction === 'rtl' ? [...left.map(width => width + combinationScrollBarSize), 0] : left,
      // right:
      //   direction === 'rtl' ? right : [...right.map(width => width + combinationScrollBarSize), 0],
      start,
      end: [...end.map((width) => width + combinationScrollBarSize), 0],
      isSticky
    };
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  const mergedColumnWidth = useColumnWidth(colWidths, columCount);
  const isColGroupEmpty = (0, import_react207.useMemo)(() => {
    const noWidth = !mergedColumnWidth || !mergedColumnWidth.length || mergedColumnWidth.every((w) => !w);
    return noData || noWidth;
  }, [noData, mergedColumnWidth]);
  return React552.createElement("div", {
    style: {
      overflow: "hidden",
      ...isSticky ? {
        top: stickyTopOffset,
        bottom: stickyBottomOffset
      } : {},
      ...style2
    },
    ref: setScrollRef,
    className: clsx(className, {
      [stickyClassName]: !!stickyClassName
    })
  }, React552.createElement(TableComponent, {
    style: {
      tableLayout,
      minWidth: "100%",
      // https://github.com/ant-design/ant-design/issues/54894
      width: scrollX
    }
  }, isColGroupEmpty ? colGroup : React552.createElement(ColGroup_default, {
    colWidths: [...mergedColumnWidth, combinationScrollBarSize],
    columCount: columCount + 1,
    columns: flattenColumnsWithScrollbar
  }), children({
    ...restProps,
    stickyOffsets: headerStickyOffsets,
    columns: columnsWithScrollbar,
    flattenColumns: flattenColumnsWithScrollbar
  })));
});
if (true) {
  FixedHolder.displayName = "FixedHolder";
}
var FixedHolder_default = React552.memo(FixedHolder);

// node_modules/@rc-component/table/es/Header/Header.js
var React554 = __toESM(require_react());

// node_modules/@rc-component/table/es/Header/HeaderRow.js
var React553 = __toESM(require_react());
function _extends85() {
  _extends85 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends85.apply(this, arguments);
}
var HeaderRow = (props) => {
  const {
    cells,
    stickyOffsets,
    flattenColumns,
    rowComponent: RowComponent,
    cellComponent: CellComponent,
    onHeaderRow,
    index: index2,
    classNames,
    styles
  } = props;
  const {
    prefixCls
  } = useContext180(TableContext_default, ["prefixCls"]);
  let rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(cells.map((cell) => cell.column), index2);
  }
  const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
  return React553.createElement(RowComponent, _extends85({}, rowProps, {
    className: classNames.row,
    style: styles.row
  }), cells.map((cell, cellIndex) => {
    var _a;
    const {
      column: column2,
      colStart,
      colEnd,
      colSpan
    } = cell;
    const fixedInfo = getCellFixedInfo(colStart, colEnd, flattenColumns, stickyOffsets);
    const additionalProps = ((_a = column2 == null ? void 0 : column2.onHeaderCell) == null ? void 0 : _a.call(column2, column2)) || {};
    return React553.createElement(Cell_default2, _extends85({}, cell, {
      scope: column2.title ? colSpan > 1 ? "colgroup" : "col" : null,
      ellipsis: column2.ellipsis,
      align: column2.align,
      component: CellComponent,
      prefixCls,
      key: columnsKey[cellIndex]
    }, fixedInfo, {
      additionalProps,
      rowType: "header"
    }));
  }));
};
if (true) {
  HeaderRow.displayName = "HeaderRow";
}
var HeaderRow_default = HeaderRow;

// node_modules/@rc-component/table/es/Header/Header.js
function parseHeaderRows(rootColumns, classNames, styles) {
  const rows = [];
  function fillRowCells(columns, colIndex, rowIndex = 0) {
    rows[rowIndex] = rows[rowIndex] || [];
    let currentColIndex = colIndex;
    const colSpans = columns.filter(Boolean).map((column2) => {
      const cell = {
        key: column2.key,
        className: clsx(column2.className, classNames.cell) || "",
        style: styles.cell,
        children: column2.title,
        column: column2,
        colStart: currentColIndex
      };
      let colSpan = 1;
      const subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total, count) => total + count, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column2) {
        ({
          colSpan
        } = column2);
      }
      if ("rowSpan" in column2) {
        cell.rowSpan = column2.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  const rowCount = rows.length;
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    rows[rowIndex].forEach((cell) => {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  }
  return rows;
}
var Header2 = (props) => {
  if (true) {
    useRenderTimes_default(props);
  }
  const {
    stickyOffsets,
    columns,
    flattenColumns,
    onHeaderRow
  } = props;
  const {
    prefixCls,
    getComponent,
    classNames,
    styles
  } = useContext180(TableContext_default, ["prefixCls", "getComponent", "classNames", "styles"]);
  const {
    header: headerCls = {}
  } = classNames || {};
  const {
    header: headerStyles = {}
  } = styles || {};
  const rows = React554.useMemo(() => parseHeaderRows(columns, headerCls, headerStyles), [columns, headerCls, headerStyles]);
  const WrapperComponent = getComponent(["header", "wrapper"], "thead");
  const trComponent = getComponent(["header", "row"], "tr");
  const thComponent = getComponent(["header", "cell"], "th");
  return React554.createElement(WrapperComponent, {
    className: clsx(`${prefixCls}-thead`, headerCls.wrapper),
    style: headerStyles.wrapper
  }, rows.map((row, rowIndex) => {
    const rowNode = React554.createElement(HeaderRow_default, {
      classNames: headerCls,
      styles: headerStyles,
      key: rowIndex,
      flattenColumns,
      cells: row,
      stickyOffsets,
      rowComponent: trComponent,
      cellComponent: thComponent,
      onHeaderRow,
      index: rowIndex
    });
    return rowNode;
  }));
};
var Header_default2 = responseImmutable2(Header2);

// node_modules/@rc-component/table/es/hooks/useColumns/index.js
var React556 = __toESM(require_react());

// node_modules/@rc-component/table/es/hooks/useColumns/useWidthColumns.js
var React555 = __toESM(require_react());
function parseColWidth(totalWidth, width = "") {
  if (typeof width === "number") {
    return width;
  }
  if (width.endsWith("%")) {
    return totalWidth * parseFloat(width) / 100;
  }
  return null;
}
function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
  return React555.useMemo(() => {
    if (scrollWidth && scrollWidth > 0) {
      let totalWidth = 0;
      let missWidthCount = 0;
      flattenColumns.forEach((col) => {
        const colWidth = parseColWidth(scrollWidth, col.width);
        if (colWidth) {
          totalWidth += colWidth;
        } else {
          missWidthCount += 1;
        }
      });
      const maxFitWidth = Math.max(scrollWidth, clientWidth);
      let restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
      let restCount = missWidthCount;
      const avgWidth = restWidth / missWidthCount;
      let realTotal = 0;
      const filledColumns = flattenColumns.map((col) => {
        const clone = {
          ...col
        };
        const colWidth = parseColWidth(scrollWidth, clone.width);
        if (colWidth) {
          clone.width = colWidth;
        } else {
          const colAvgWidth = Math.floor(avgWidth);
          clone.width = restCount === 1 ? restWidth : colAvgWidth;
          restWidth -= colAvgWidth;
          restCount -= 1;
        }
        realTotal += clone.width;
        return clone;
      });
      if (realTotal < maxFitWidth) {
        const scale = maxFitWidth / realTotal;
        restWidth = maxFitWidth;
        filledColumns.forEach((col, index2) => {
          const colWidth = Math.floor(col.width * scale);
          col.width = index2 === filledColumns.length - 1 ? restWidth : colWidth;
          restWidth -= colWidth;
        });
      }
      return [filledColumns, Math.max(realTotal, maxFitWidth)];
    }
    return [flattenColumns, scrollWidth];
  }, [flattenColumns, scrollWidth, clientWidth]);
}

// node_modules/@rc-component/table/es/hooks/useColumns/index.js
function convertChildrenToColumns(children) {
  return toArray(children).filter((node2) => React556.isValidElement(node2)).map((node2) => {
    const {
      key,
      props
    } = node2;
    const {
      children: nodeChildren,
      ...restProps
    } = props;
    const column2 = {
      key,
      ...restProps
    };
    if (nodeChildren) {
      column2.children = convertChildrenToColumns(nodeChildren);
    }
    return column2;
  });
}
function filterHiddenColumns(columns) {
  return columns.filter((column2) => column2 && typeof column2 === "object" && !column2.hidden).map((column2) => {
    const subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return {
        ...column2,
        children: filterHiddenColumns(subColumns)
      };
    }
    return column2;
  });
}
function flatColumns(columns, parentKey = "key") {
  return columns.filter((column2) => column2 && typeof column2 === "object").reduce((list, column2, index2) => {
    const {
      fixed
    } = column2;
    const parsedFixed = fixed === true || fixed === "left" ? "start" : fixed === "right" ? "end" : fixed;
    const mergedKey = `${parentKey}-${index2}`;
    const subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return [...list, ...flatColumns(subColumns, mergedKey).map((subColum) => ({
        ...subColum,
        fixed: subColum.fixed ?? parsedFixed
      }))];
    }
    return [...list, {
      key: mergedKey,
      ...column2,
      fixed: parsedFixed
    }];
  }, []);
}
function useColumns({
  prefixCls,
  columns,
  children,
  expandable,
  expandedKeys,
  columnTitle,
  getRowKey,
  onTriggerExpand,
  expandIcon,
  rowExpandable,
  expandIconColumnIndex,
  expandedRowOffset = 0,
  direction,
  expandRowByClick,
  columnWidth,
  fixed,
  scrollWidth,
  clientWidth
}, transformColumns) {
  const baseColumns = React556.useMemo(() => {
    const newColumns = columns || convertChildrenToColumns(children) || [];
    return filterHiddenColumns(newColumns.slice());
  }, [columns, children]);
  const withExpandColumns = React556.useMemo(() => {
    if (expandable) {
      let cloneColumns = baseColumns.slice();
      if (expandIconColumnIndex >= 0) {
        warning_default(false, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead.");
      }
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        const expandColIndex = expandIconColumnIndex || 0;
        const insertIndex = expandColIndex === 0 && (fixed === "right" || fixed === "end") ? baseColumns.length : expandColIndex;
        if (insertIndex >= 0) {
          cloneColumns.splice(insertIndex, 0, EXPAND_COLUMN);
        }
      }
      if (cloneColumns.filter((c) => c === EXPAND_COLUMN).length > 1) {
        warning_default(false, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      }
      const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter((column2, index2) => column2 !== EXPAND_COLUMN || index2 === expandColumnIndex);
      const prevColumn = baseColumns[expandColumnIndex];
      let fixedColumn;
      if (fixed) {
        fixedColumn = fixed;
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      const expandColumn = {
        [INTERNAL_COL_DEFINE]: {
          className: `${prefixCls}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: columnTitle,
        fixed: fixedColumn,
        className: `${prefixCls}-row-expand-icon-cell`,
        width: columnWidth,
        render: (_, record, index2) => {
          const rowKey = getRowKey(record, index2);
          const expanded = expandedKeys.has(rowKey);
          const recordExpandable = rowExpandable ? rowExpandable(record) : true;
          const icon = expandIcon({
            prefixCls,
            expanded,
            expandable: recordExpandable,
            record,
            onExpand: onTriggerExpand
          });
          if (expandRowByClick) {
            return React556.createElement("span", {
              onClick: (e3) => e3.stopPropagation()
            }, icon);
          }
          return icon;
        }
      };
      return cloneColumns.map((col, index2) => {
        const column2 = col === EXPAND_COLUMN ? expandColumn : col;
        if (index2 < expandedRowOffset) {
          return {
            ...column2,
            fixed: column2.fixed || "start"
          };
        }
        return column2;
      });
    }
    if (baseColumns.includes(EXPAND_COLUMN)) {
      warning_default(false, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`.");
    }
    return baseColumns.filter((col) => col !== EXPAND_COLUMN);
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction, expandedRowOffset]);
  const mergedColumns = React556.useMemo(() => {
    let finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        render: () => null
      }];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction]);
  const flattenColumns = React556.useMemo(
    () => flatColumns(mergedColumns),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [mergedColumns, direction, scrollWidth]
  );
  const [filledColumns, realScrollWidth] = useWidthColumns(flattenColumns, scrollWidth, clientWidth);
  return [mergedColumns, filledColumns, realScrollWidth];
}
var useColumns_default = useColumns;

// node_modules/@rc-component/table/es/hooks/useExpand.js
var React557 = __toESM(require_react());
function useExpand(props, mergedData, getRowKey) {
  const expandableConfig = getExpandableProps(props);
  const {
    expandIcon,
    expandedRowKeys,
    defaultExpandedRowKeys,
    defaultExpandAllRows,
    expandedRowRender,
    onExpand,
    onExpandedRowsChange,
    childrenColumnName
  } = expandableConfig;
  const mergedExpandIcon = expandIcon || renderExpandIcon;
  const mergedChildrenColumnName = childrenColumnName || "children";
  const expandableType = React557.useMemo(() => {
    if (expandedRowRender) {
      return "row";
    }
    if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some((record) => record && typeof record === "object" && record[mergedChildrenColumnName])) {
      return "nest";
    }
    return false;
  }, [!!expandedRowRender, mergedData]);
  const [innerExpandedKeys, setInnerExpandedKeys] = React557.useState(() => {
    if (defaultExpandedRowKeys) {
      return defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows) {
      return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
    }
    return [];
  });
  const mergedExpandedKeys = React557.useMemo(() => new Set(expandedRowKeys || innerExpandedKeys || []), [expandedRowKeys, innerExpandedKeys]);
  const onTriggerExpand = React557.useCallback((record) => {
    const key = getRowKey(record, mergedData.indexOf(record));
    let newExpandedKeys;
    const hasKey = mergedExpandedKeys.has(key);
    if (hasKey) {
      mergedExpandedKeys.delete(key);
      newExpandedKeys = [...mergedExpandedKeys];
    } else {
      newExpandedKeys = [...mergedExpandedKeys, key];
    }
    setInnerExpandedKeys(newExpandedKeys);
    if (onExpand) {
      onExpand(!hasKey, record);
    }
    if (onExpandedRowsChange) {
      onExpandedRowsChange(newExpandedKeys);
    }
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
  if (expandedRowRender && mergedData.some((record) => {
    return Array.isArray(record == null ? void 0 : record[mergedChildrenColumnName]);
  })) {
    warning_default(false, "`expandedRowRender` should not use with nested Table");
  }
  return [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
}

// node_modules/@rc-component/table/es/hooks/useFixedInfo.js
var React558 = __toESM(require_react());
function useFixedInfo(flattenColumns, stickyOffsets) {
  const fixedInfoList = React558.useMemo(() => flattenColumns.map((_, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets)), [flattenColumns, stickyOffsets]);
  return useMemo(() => fixedInfoList, [fixedInfoList], (prev2, next2) => !isEqual_default(prev2, next2));
}

// node_modules/@rc-component/table/es/hooks/useFrame.js
var import_react208 = __toESM(require_react());
function useLayoutState(defaultState) {
  const stateRef = (0, import_react208.useRef)(defaultState);
  const [, forceUpdate] = (0, import_react208.useState)({});
  const lastPromiseRef = (0, import_react208.useRef)(null);
  const updateBatchRef = (0, import_react208.useRef)([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    const promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(() => {
      if (lastPromiseRef.current === promise) {
        const prevBatch = updateBatchRef.current;
        const prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach((batchUpdater) => {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;
        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }
  (0, import_react208.useEffect)(() => () => {
    lastPromiseRef.current = null;
  }, []);
  return [stateRef.current, setFrameState];
}
function useTimeoutLock(defaultState) {
  const frameRef = (0, import_react208.useRef)(defaultState || null);
  const timeoutRef = (0, import_react208.useRef)(null);
  function cleanUp() {
    clearTimeout(timeoutRef.current);
  }
  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = setTimeout(() => {
      frameRef.current = null;
      timeoutRef.current = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.current;
  }
  (0, import_react208.useEffect)(() => cleanUp, []);
  return [setState, getState];
}

// node_modules/@rc-component/table/es/hooks/useHover.js
var React559 = __toESM(require_react());
function useHover() {
  const [startRow, setStartRow] = React559.useState(-1);
  const [endRow, setEndRow] = React559.useState(-1);
  const onHover = React559.useCallback((start, end) => {
    setStartRow(start);
    setEndRow(end);
  }, []);
  return [startRow, endRow, onHover];
}

// node_modules/@rc-component/table/es/hooks/useSticky.js
var React560 = __toESM(require_react());
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  const {
    offsetHeader = 0,
    offsetSummary = 0,
    offsetScroll = 0,
    getContainer = () => defaultContainer
  } = typeof sticky === "object" ? sticky : {};
  const container = getContainer() || defaultContainer;
  const isSticky = !!sticky;
  return React560.useMemo(() => {
    return {
      isSticky,
      stickyClassName: isSticky ? `${prefixCls}-sticky-holder` : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  }, [isSticky, offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}

// node_modules/@rc-component/table/es/hooks/useStickyOffsets.js
var import_react209 = __toESM(require_react());
function useStickyOffsets(colWidths, flattenColumns) {
  const stickyOffsets = (0, import_react209.useMemo)(() => {
    const columnCount = flattenColumns.length;
    const getOffsets = (startIndex, endIndex, offset3) => {
      const offsets = [];
      let total = 0;
      for (let i = startIndex; i !== endIndex; i += offset3) {
        offsets.push(total);
        if (flattenColumns[i].fixed) {
          total += colWidths[i] || 0;
        }
      }
      return offsets;
    };
    const startOffsets = getOffsets(0, columnCount, 1);
    const endOffsets = getOffsets(columnCount - 1, -1, -1).reverse();
    return {
      start: startOffsets,
      end: endOffsets,
      widths: colWidths
    };
  }, [colWidths, flattenColumns]);
  return stickyOffsets;
}
var useStickyOffsets_default = useStickyOffsets;

// node_modules/@rc-component/table/es/Panel/index.js
var React561 = __toESM(require_react());
var Panel5 = (props) => {
  const {
    children,
    className,
    style: style2
  } = props;
  return React561.createElement("div", {
    className,
    style: style2
  }, children);
};
var Panel_default5 = Panel5;

// node_modules/@rc-component/table/es/stickyScrollBar.js
var React562 = __toESM(require_react());

// node_modules/@rc-component/table/es/utils/offsetUtil.js
function getOffset4(node2) {
  const element = getDOM(node2);
  const box2 = element.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}

// node_modules/@rc-component/table/es/stickyScrollBar.js
var MOUSEUP_EVENT = "mouseup";
var MOUSEMOVE_EVENT = "mousemove";
var SCROLL_EVENT = "scroll";
var RESIZE_EVENT = "resize";
var StickyScrollBar = (props, ref) => {
  var _a, _b;
  const {
    scrollBodyRef,
    onScroll,
    offsetScroll,
    container,
    direction
  } = props;
  const prefixCls = useContext180(TableContext_default, "prefixCls");
  const bodyScrollWidth = ((_a = scrollBodyRef.current) == null ? void 0 : _a.scrollWidth) || 0;
  const bodyWidth = ((_b = scrollBodyRef.current) == null ? void 0 : _b.clientWidth) || 0;
  const scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  const scrollBarRef = React562.useRef(null);
  const [scrollState, setScrollState] = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: true
  });
  const refState = React562.useRef({
    delta: 0,
    x: 0
  });
  const [isActive2, setActive] = React562.useState(false);
  const rafRef = React562.useRef(null);
  React562.useEffect(() => () => {
    raf_default.cancel(rafRef.current);
  }, []);
  const onMouseUp = () => {
    setActive(false);
  };
  const onMouseDown = (event) => {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  };
  const onMouseMove = (event) => {
    const {
      buttons
    } = event || (window == null ? void 0 : window.event);
    if (!isActive2 || buttons === 0) {
      if (isActive2) {
        setActive(false);
      }
      return;
    }
    let left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    const isRTL = direction === "rtl";
    left = Math.max(isRTL ? scrollBarWidth - bodyWidth : 0, Math.min(isRTL ? 0 : bodyWidth - scrollBarWidth, left));
    const shouldScroll = !isRTL || Math.abs(left) + Math.abs(scrollBarWidth) < bodyWidth;
    if (shouldScroll) {
      onScroll({
        scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
      });
      refState.current.x = event.pageX;
    }
  };
  const checkScrollBarVisible = () => {
    raf_default.cancel(rafRef.current);
    rafRef.current = raf_default(() => {
      if (!scrollBodyRef.current) {
        return;
      }
      const tableOffsetTop = getOffset4(scrollBodyRef.current).top;
      const tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
      const currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset4(container).top + container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: true
        }));
      } else {
        setScrollState((state) => ({
          ...state,
          isHiddenScrollBar: false
        }));
      }
    });
  };
  const setScrollLeft = (left) => {
    setScrollState((state) => {
      return {
        ...state,
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      };
    });
  };
  React562.useImperativeHandle(ref, () => ({
    setScrollLeft,
    checkScrollBarVisible
  }));
  React562.useEffect(() => {
    document.body.addEventListener(MOUSEUP_EVENT, onMouseUp, false);
    document.body.addEventListener(MOUSEMOVE_EVENT, onMouseMove, false);
    checkScrollBarVisible();
    return () => {
      document.body.removeEventListener(MOUSEUP_EVENT, onMouseUp);
      document.body.removeEventListener(MOUSEMOVE_EVENT, onMouseMove);
    };
  }, [scrollBarWidth, isActive2]);
  React562.useEffect(() => {
    if (scrollBodyRef.current) {
      const scrollParents = [];
      let parent = getDOM(scrollBodyRef.current);
      while (parent) {
        scrollParents.push(parent);
        parent = parent.parentElement;
      }
      scrollParents.forEach((p) => {
        p.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      });
      window.addEventListener(RESIZE_EVENT, checkScrollBarVisible, false);
      window.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      container.addEventListener(SCROLL_EVENT, checkScrollBarVisible, false);
      return () => {
        scrollParents.forEach((p) => {
          p.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
        });
        window.removeEventListener(RESIZE_EVENT, checkScrollBarVisible);
        window.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
        container.removeEventListener(SCROLL_EVENT, checkScrollBarVisible);
      };
    }
  }, [container]);
  React562.useEffect(() => {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState((state) => {
        const bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state;
        }
        return {
          ...state,
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        };
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return React562.createElement("div", {
    style: {
      height: getScrollBarSize(),
      width: bodyWidth,
      bottom: offsetScroll
    },
    className: `${prefixCls}-sticky-scroll`
  }, React562.createElement("div", {
    onMouseDown,
    ref: scrollBarRef,
    className: clsx(`${prefixCls}-sticky-scroll-bar`, {
      [`${prefixCls}-sticky-scroll-bar-active`]: isActive2
    }),
    style: {
      width: `${scrollBarWidth}px`,
      transform: `translate3d(${scrollState.scrollLeft}px, 0, 0)`
    }
  }));
};
var stickyScrollBar_default = React562.forwardRef(StickyScrollBar);

// node_modules/@rc-component/table/es/Table.js
function _extends86() {
  _extends86 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends86.apply(this, arguments);
}
var DEFAULT_PREFIX = "rc-table";
var EMPTY_DATA2 = [];
var EMPTY_SCROLL_TARGET = {};
function defaultEmpty() {
  return "No Data";
}
var Table = (tableProps, ref) => {
  var _a, _b;
  const props = {
    rowKey: "key",
    prefixCls: DEFAULT_PREFIX,
    emptyText: defaultEmpty,
    ...tableProps
  };
  const {
    prefixCls,
    className,
    rowClassName,
    style: style2,
    classNames,
    styles,
    data,
    rowKey,
    scroll,
    tableLayout,
    direction,
    // Additional Part
    title,
    footer,
    summary,
    caption,
    // Customize
    id,
    showHeader,
    components: components2,
    emptyText,
    onRow,
    onHeaderRow,
    // Measure Row
    measureRowRender,
    // Events
    onScroll,
    // Internal
    internalHooks,
    transformColumns,
    internalRefs,
    tailor,
    getContainerWidth,
    sticky,
    rowHoverable = true
  } = props;
  const mergedData = data || EMPTY_DATA2;
  const hasData = !!mergedData.length;
  const useInternalHooks = internalHooks === INTERNAL_HOOKS;
  if (true) {
    ["onRowClick", "onRowDoubleClick", "onRowContextMenu", "onRowMouseEnter", "onRowMouseLeave"].forEach((name) => {
      warning_default(props[name] === void 0, `\`${name}\` is removed, please use \`onRow\` instead.`);
    });
    warning_default(!("getBodyWrapper" in props), "`getBodyWrapper` is deprecated, please use custom `components` instead.");
  }
  const getComponent = React563.useCallback((path2, defaultComponent) => get(components2, path2) || defaultComponent, [components2]);
  const getRowKey = React563.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => {
      const key = record && record[rowKey];
      if (true) {
        warning_default(key !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key.");
      }
      return key;
    };
  }, [rowKey]);
  const customizeScrollBody = getComponent(["body"]);
  const [startRow, endRow, onHover] = useHover();
  const [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand] = useExpand(props, mergedData, getRowKey);
  const scrollX = scroll == null ? void 0 : scroll.x;
  const [componentWidth, setComponentWidth] = React563.useState(0);
  const [columns, flattenColumns, flattenScrollX] = useColumns_default({
    ...props,
    ...expandableConfig,
    expandable: !!expandableConfig.expandedRowRender,
    columnTitle: expandableConfig.columnTitle,
    expandedKeys: mergedExpandedKeys,
    getRowKey,
    // https://github.com/ant-design/ant-design/issues/23894
    onTriggerExpand,
    expandIcon: mergedExpandIcon,
    expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
    direction,
    scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
    clientWidth: componentWidth
  }, useInternalHooks ? transformColumns : null);
  const mergedScrollX = flattenScrollX ?? scrollX;
  const columnContext = React563.useMemo(() => ({
    columns,
    flattenColumns
  }), [columns, flattenColumns]);
  const fullTableRef = React563.useRef(null);
  const scrollHeaderRef = React563.useRef(null);
  const scrollBodyRef = React563.useRef(null);
  const scrollBodyContainerRef = React563.useRef(null);
  React563.useImperativeHandle(ref, () => {
    return {
      nativeElement: fullTableRef.current,
      scrollTo: (config) => {
        var _a2, _b2;
        if (scrollBodyRef.current instanceof HTMLElement) {
          const {
            index: index2,
            top,
            key,
            offset: offset3
          } = config;
          if (validNumberValue(top)) {
            (_a2 = scrollBodyRef.current) == null ? void 0 : _a2.scrollTo({
              top
            });
          } else {
            const mergedKey = key ?? getRowKey(mergedData[index2]);
            const targetElement = scrollBodyRef.current.querySelector(`[data-row-key="${mergedKey}"]`);
            if (targetElement) {
              if (!offset3) {
                targetElement.scrollIntoView();
              } else {
                const elementTop = targetElement.offsetTop;
                scrollBodyRef.current.scrollTo({
                  top: elementTop + offset3
                });
              }
            }
          }
        } else if ((_b2 = scrollBodyRef.current) == null ? void 0 : _b2.scrollTo) {
          scrollBodyRef.current.scrollTo(config);
        }
      }
    };
  });
  const scrollSummaryRef = React563.useRef(null);
  const [shadowStart, setShadowStart] = React563.useState(false);
  const [shadowEnd, setShadowEnd] = React563.useState(false);
  const [colsWidths, updateColsWidths] = React563.useState(/* @__PURE__ */ new Map());
  const colsKeys = getColumnsKey(flattenColumns);
  const pureColWidths = colsKeys.map((columnKey) => colsWidths.get(columnKey));
  const colWidths = React563.useMemo(() => pureColWidths, [pureColWidths.join("_")]);
  const stickyOffsets = useStickyOffsets_default(colWidths, flattenColumns);
  const fixHeader = scroll && validateValue(scroll.y);
  const horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
  const fixColumn = horizonScroll && flattenColumns.some(({
    fixed
  }) => fixed);
  const stickyRef = React563.useRef(null);
  const {
    isSticky,
    offsetHeader,
    offsetSummary,
    offsetScroll,
    stickyClassName,
    container
  } = useSticky(sticky, prefixCls);
  const summaryNode = React563.useMemo(() => summary == null ? void 0 : summary(mergedData), [summary, mergedData]);
  const fixFooter = (fixHeader || isSticky) && React563.isValidElement(summaryNode) && summaryNode.type === Summary_default && summaryNode.props.fixed;
  let scrollXStyle;
  let scrollYStyle;
  let scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: hasData ? "scroll" : "auto",
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = {
      overflowX: "auto"
    };
    if (!fixHeader) {
      scrollYStyle = {
        overflowY: "hidden"
      };
    }
    scrollTableStyle = {
      width: mergedScrollX === true ? "auto" : mergedScrollX,
      minWidth: "100%"
    };
  }
  const onColumnResize = React563.useCallback((columnKey, width) => {
    updateColsWidths((widths) => {
      if (widths.get(columnKey) !== width) {
        const newWidths = new Map(widths);
        newWidths.set(columnKey, width);
        return newWidths;
      }
      return widths;
    });
  }, []);
  const [setScrollTarget, getScrollTarget] = useTimeoutLock(null);
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === "function") {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
      if (target.scrollLeft !== scrollLeft) {
        setTimeout(() => {
          target.scrollLeft = scrollLeft;
        }, 0);
      }
    }
  }
  const [scrollInfo, setScrollInfo] = React563.useState([0, 0]);
  const onInternalScroll = useEvent_default(({
    currentTarget,
    scrollLeft
  }) => {
    var _a2;
    const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
    const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      setScrollTarget(compareTarget);
      forceScroll(mergedScrollLeft, scrollHeaderRef.current);
      forceScroll(mergedScrollLeft, scrollBodyRef.current);
      forceScroll(mergedScrollLeft, scrollSummaryRef.current);
      forceScroll(mergedScrollLeft, (_a2 = stickyRef.current) == null ? void 0 : _a2.setScrollLeft);
    }
    const measureTarget = currentTarget || scrollHeaderRef.current;
    if (measureTarget) {
      const scrollWidth = (
        // Should use mergedScrollX in virtual table(useInternalHooks && tailor === true)
        useInternalHooks && tailor && typeof mergedScrollX === "number" ? mergedScrollX : measureTarget.scrollWidth
      );
      const clientWidth = measureTarget.clientWidth;
      const absScrollStart = Math.abs(mergedScrollLeft);
      setScrollInfo((ori) => {
        const nextScrollInfo = [absScrollStart, scrollWidth - clientWidth];
        return isEqual_default(ori, nextScrollInfo) ? ori : nextScrollInfo;
      });
      if (scrollWidth === clientWidth) {
        setShadowStart(false);
        setShadowEnd(false);
        return;
      }
      setShadowStart(absScrollStart > 0);
      setShadowEnd(absScrollStart < scrollWidth - clientWidth - 1);
    }
  });
  const onBodyScroll = useEvent_default((e3) => {
    onInternalScroll(e3);
    onScroll == null ? void 0 : onScroll(e3);
  });
  const triggerOnScroll = () => {
    var _a2;
    if (horizonScroll && scrollBodyRef.current) {
      onInternalScroll({
        currentTarget: getDOM(scrollBodyRef.current),
        scrollLeft: (_a2 = scrollBodyRef.current) == null ? void 0 : _a2.scrollLeft
      });
    } else {
      setShadowStart(false);
      setShadowEnd(false);
    }
  };
  const onFullTableResize = (offsetWidth) => {
    var _a2, _b2;
    (_a2 = stickyRef.current) == null ? void 0 : _a2.checkScrollBarVisible();
    let mergedWidth = offsetWidth ?? ((_b2 = fullTableRef.current) == null ? void 0 : _b2.offsetWidth) ?? 0;
    if (useInternalHooks && getContainerWidth && fullTableRef.current) {
      mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
    }
    if (mergedWidth !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(mergedWidth);
    }
  };
  useLayoutEffect_default(() => {
    if (horizonScroll) {
      onFullTableResize();
    }
  }, [horizonScroll]);
  const mounted = React563.useRef(false);
  React563.useEffect(() => {
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data, columns.length]);
  React563.useEffect(() => {
    mounted.current = true;
  }, []);
  const [scrollbarSize, setScrollbarSize] = React563.useState(0);
  useLayoutEffect_default(() => {
    if (!tailor || !useInternalHooks) {
      if (scrollBodyRef.current instanceof Element) {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
      } else {
        setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
      }
    }
  }, []);
  React563.useEffect(() => {
    if (useInternalHooks && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  });
  const renderFixedHeaderTable = React563.useCallback((fixedHolderPassProps) => React563.createElement(React563.Fragment, null, React563.createElement(Header_default2, fixedHolderPassProps), fixFooter === "top" && React563.createElement(Footer_default, fixedHolderPassProps, summaryNode)), [fixFooter, summaryNode]);
  const renderFixedFooterTable = React563.useCallback((fixedHolderPassProps) => React563.createElement(Footer_default, fixedHolderPassProps, summaryNode), [summaryNode]);
  const TableComponent = getComponent(["table"], "table");
  const mergedTableLayout = React563.useMemo(() => {
    if (tableLayout) {
      return tableLayout;
    }
    if (fixColumn) {
      return mergedScrollX === "max-content" ? "auto" : "fixed";
    }
    if (fixHeader || isSticky || flattenColumns.some(({
      ellipsis
    }) => ellipsis)) {
      return "fixed";
    }
    return "auto";
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  let groupTableNode;
  const headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  };
  const emptyNode = React563.useMemo(() => {
    if (hasData) {
      return null;
    }
    if (typeof emptyText === "function") {
      return emptyText();
    }
    return emptyText;
  }, [hasData, emptyText]);
  const bodyTable = React563.createElement(Body_default, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky
  });
  const bodyColGroup = React563.createElement(ColGroup_default, {
    colWidths: flattenColumns.map(({
      width
    }) => width),
    columns: flattenColumns
  });
  const captionElement = caption !== null && caption !== void 0 ? React563.createElement("caption", {
    className: `${prefixCls}-caption`
  }, caption) : void 0;
  const dataProps = pickAttrs(props, {
    data: true
  });
  const ariaProps = pickAttrs(props, {
    aria: true
  });
  if (fixHeader || isSticky) {
    let bodyContent;
    if (typeof customizeScrollBody === "function") {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize,
        ref: scrollBodyRef,
        onScroll: onInternalScroll
      });
      headerProps.colWidths = flattenColumns.map(({
        width
      }, index2) => {
        const colWidth = index2 === flattenColumns.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        if (true) {
          warning_default(props.columns.length === 0, "When use `components.body` with render props. Each column should have a fixed `width` value.");
        }
        return 0;
      });
    } else {
      bodyContent = React563.createElement("div", {
        style: {
          ...scrollXStyle,
          ...scrollYStyle
        },
        onScroll: onBodyScroll,
        ref: scrollBodyRef,
        className: `${prefixCls}-body`
      }, React563.createElement(TableComponent, _extends86({
        style: {
          ...scrollTableStyle,
          tableLayout: mergedTableLayout
        }
      }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && React563.createElement(Footer_default, {
        stickyOffsets,
        flattenColumns
      }, summaryNode)));
    }
    const fixedHolderProps = {
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && mergedScrollX === "max-content",
      ...headerProps,
      ...columnContext,
      direction,
      stickyClassName,
      scrollX: mergedScrollX,
      tableLayout: mergedTableLayout,
      onScroll: onInternalScroll
    };
    groupTableNode = React563.createElement(React563.Fragment, null, showHeader !== false && React563.createElement(FixedHolder_default, _extends86({}, fixedHolderProps, {
      stickyTopOffset: offsetHeader,
      className: `${prefixCls}-header`,
      ref: scrollHeaderRef,
      colGroup: bodyColGroup
    }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && React563.createElement(FixedHolder_default, _extends86({}, fixedHolderProps, {
      stickyBottomOffset: offsetSummary,
      className: `${prefixCls}-summary`,
      ref: scrollSummaryRef,
      colGroup: bodyColGroup
    }), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && React563.createElement(stickyScrollBar_default, {
      ref: stickyRef,
      offsetScroll,
      scrollBodyRef,
      onScroll: onInternalScroll,
      container,
      direction
    }));
  } else {
    groupTableNode = React563.createElement("div", {
      style: {
        ...scrollXStyle,
        ...scrollYStyle,
        ...styles == null ? void 0 : styles.content
      },
      className: clsx(`${prefixCls}-content`, classNames == null ? void 0 : classNames.content),
      onScroll: onInternalScroll,
      ref: scrollBodyRef
    }, React563.createElement(TableComponent, _extends86({
      style: {
        ...scrollTableStyle,
        tableLayout: mergedTableLayout
      }
    }, ariaProps), captionElement, bodyColGroup, showHeader !== false && React563.createElement(Header_default2, _extends86({}, headerProps, columnContext)), bodyTable, summaryNode && React563.createElement(Footer_default, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
  }
  const tableStyle = {
    ...style2
  };
  if (isSticky) {
    tableStyle["--columns-count"] = flattenColumns.length;
  }
  let fullTable = React563.createElement("div", _extends86({
    className: clsx(prefixCls, className, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-fix-start-shadow`]: horizonScroll,
      [`${prefixCls}-fix-end-shadow`]: horizonScroll,
      [`${prefixCls}-fix-start-shadow-show`]: horizonScroll && shadowStart,
      [`${prefixCls}-fix-end-shadow-show`]: horizonScroll && shadowEnd,
      [`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
      [`${prefixCls}-fixed-header`]: fixHeader,
      /** No used but for compatible */
      [`${prefixCls}-fixed-column`]: fixColumn,
      [`${prefixCls}-scroll-horizontal`]: horizonScroll,
      [`${prefixCls}-has-fix-start`]: (_a = flattenColumns[0]) == null ? void 0 : _a.fixed,
      [`${prefixCls}-has-fix-end`]: ((_b = flattenColumns[flattenColumns.length - 1]) == null ? void 0 : _b.fixed) === "end"
    }),
    style: tableStyle,
    id,
    ref: fullTableRef
  }, dataProps), title && React563.createElement(Panel_default5, {
    className: clsx(`${prefixCls}-title`, classNames == null ? void 0 : classNames.title),
    style: styles == null ? void 0 : styles.title
  }, title(mergedData)), React563.createElement("div", {
    ref: scrollBodyContainerRef,
    className: clsx(`${prefixCls}-container`, classNames == null ? void 0 : classNames.section),
    style: styles == null ? void 0 : styles.section
  }, groupTableNode), footer && React563.createElement(Panel_default5, {
    className: clsx(`${prefixCls}-footer`, classNames == null ? void 0 : classNames.footer),
    style: styles == null ? void 0 : styles.footer
  }, footer(mergedData)));
  if (horizonScroll) {
    fullTable = React563.createElement(es_default, {
      onResize: ({
        offsetWidth
      }) => onFullTableResize(offsetWidth)
    }, fullTable);
  }
  const fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets);
  const TableContextValue = React563.useMemo(() => ({
    // Scroll
    scrollX: mergedScrollX,
    scrollInfo,
    classNames,
    styles,
    // Table
    prefixCls,
    getComponent,
    scrollbarSize,
    direction,
    fixedInfoList,
    isSticky,
    componentWidth,
    fixHeader,
    fixColumn,
    horizonScroll,
    // Body
    tableLayout: mergedTableLayout,
    rowClassName,
    expandedRowClassName: expandableConfig.expandedRowClassName,
    expandIcon: mergedExpandIcon,
    expandableType,
    expandRowByClick: expandableConfig.expandRowByClick,
    expandedRowRender: expandableConfig.expandedRowRender,
    expandedRowOffset: expandableConfig.expandedRowOffset,
    onTriggerExpand,
    expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
    indentSize: expandableConfig.indentSize,
    allColumnsFixedLeft: flattenColumns.every((col) => col.fixed === "start"),
    emptyNode,
    // Column
    columns,
    flattenColumns,
    onColumnResize,
    colWidths,
    // Row
    hoverStartRow: startRow,
    hoverEndRow: endRow,
    onHover,
    rowExpandable: expandableConfig.rowExpandable,
    onRow,
    getRowKey,
    expandedKeys: mergedExpandedKeys,
    childrenColumnName: mergedChildrenColumnName,
    rowHoverable,
    // Measure Row
    measureRowRender
  }), [
    // Scroll
    mergedScrollX,
    scrollInfo,
    classNames,
    styles,
    // Table
    prefixCls,
    getComponent,
    scrollbarSize,
    direction,
    fixedInfoList,
    isSticky,
    componentWidth,
    fixHeader,
    fixColumn,
    horizonScroll,
    // Body
    mergedTableLayout,
    rowClassName,
    expandableConfig.expandedRowClassName,
    mergedExpandIcon,
    expandableType,
    expandableConfig.expandRowByClick,
    expandableConfig.expandedRowRender,
    expandableConfig.expandedRowOffset,
    onTriggerExpand,
    expandableConfig.expandIconColumnIndex,
    expandableConfig.indentSize,
    emptyNode,
    // Column
    columns,
    flattenColumns,
    onColumnResize,
    colWidths,
    // Row
    startRow,
    endRow,
    onHover,
    expandableConfig.rowExpandable,
    onRow,
    getRowKey,
    mergedExpandedKeys,
    mergedChildrenColumnName,
    rowHoverable,
    measureRowRender
  ]);
  return React563.createElement(TableContext_default.Provider, {
    value: TableContextValue
  }, fullTable);
};
var RefTable = React563.forwardRef(Table);
if (true) {
  RefTable.displayName = "Table";
}
var genTable = (shouldTriggerRender) => {
  return makeImmutable2(RefTable, shouldTriggerRender);
};
var ImmutableTable = genTable();
ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
ImmutableTable.Column = Column_default;
ImmutableTable.ColumnGroup = ColumnGroup_default;
ImmutableTable.Summary = FooterComponents;
var Table_default = ImmutableTable;

// node_modules/@rc-component/table/es/VirtualTable/index.js
var React567 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/BodyGrid.js
var React566 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/BodyLine.js
var React565 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/VirtualCell.js
var React564 = __toESM(require_react());

// node_modules/@rc-component/table/es/VirtualTable/context.js
var StaticContext = createContext51(null);
var GridContext = createContext51(null);

// node_modules/@rc-component/table/es/VirtualTable/VirtualCell.js
function _extends87() {
  _extends87 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends87.apply(this, arguments);
}
function getColumnWidth(colIndex, colSpan, columnsOffset) {
  const mergedColSpan = colSpan || 1;
  return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
}
var VirtualCell = (props) => {
  const {
    rowInfo,
    column: column2,
    colIndex,
    indent,
    index: index2,
    component,
    renderIndex,
    record,
    style: style2,
    className,
    inverse,
    getHeight: getHeight3
  } = props;
  const {
    render: render2,
    dataIndex,
    className: columnClassName,
    width: colWidth
  } = column2;
  const {
    columnsOffset
  } = useContext180(GridContext, ["columnsOffset"]);
  const {
    key,
    fixedInfo,
    appendCellNode,
    additionalCellProps
  } = getCellProps(rowInfo, column2, colIndex, indent, index2);
  const {
    style: cellStyle,
    colSpan = 1,
    rowSpan = 1
  } = additionalCellProps;
  const startColIndex = colIndex - 1;
  const concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
  const marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
  const mergedStyle = {
    ...cellStyle,
    ...style2,
    flex: `0 0 ${concatColWidth}px`,
    width: `${concatColWidth}px`,
    marginRight: marginOffset,
    pointerEvents: "auto"
  };
  const needHide = React564.useMemo(() => {
    if (inverse) {
      return rowSpan <= 1;
    } else {
      return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
    }
  }, [rowSpan, colSpan, inverse]);
  if (needHide) {
    mergedStyle.visibility = "hidden";
  } else if (inverse) {
    mergedStyle.height = getHeight3 == null ? void 0 : getHeight3(rowSpan);
  }
  const mergedRender = needHide ? () => null : render2;
  const cellSpan = {};
  if (rowSpan === 0 || colSpan === 0) {
    cellSpan.rowSpan = 1;
    cellSpan.colSpan = 1;
  }
  return React564.createElement(Cell_default2, _extends87({
    className: clsx(columnClassName, className),
    ellipsis: column2.ellipsis,
    align: column2.align,
    scope: column2.rowScope,
    component,
    prefixCls: rowInfo.prefixCls,
    key,
    record,
    index: index2,
    renderIndex,
    dataIndex,
    render: mergedRender,
    shouldCellUpdate: column2.shouldCellUpdate
  }, fixedInfo, {
    appendNode: appendCellNode,
    additionalProps: {
      ...additionalCellProps,
      style: mergedStyle,
      ...cellSpan
    }
  }));
};
var VirtualCell_default = VirtualCell;

// node_modules/@rc-component/table/es/VirtualTable/BodyLine.js
function _extends88() {
  _extends88 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends88.apply(this, arguments);
}
var BodyLine = React565.forwardRef((props, ref) => {
  const {
    data,
    index: index2,
    className,
    rowKey,
    style: style2,
    extra,
    getHeight: getHeight3,
    ...restProps
  } = props;
  const {
    record,
    indent,
    index: renderIndex
  } = data;
  const {
    scrollX,
    flattenColumns,
    prefixCls,
    fixColumn,
    componentWidth
  } = useContext180(TableContext_default, ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]);
  const {
    getComponent
  } = useContext180(StaticContext, ["getComponent"]);
  const rowInfo = useRowInfo(record, rowKey, index2, indent);
  const RowComponent = getComponent(["body", "row"], "div");
  const cellComponent = getComponent(["body", "cell"], "div");
  const {
    rowSupportExpand,
    expanded,
    rowProps,
    expandedRowRender,
    expandedRowClassName
  } = rowInfo;
  let expandRowNode;
  if (rowSupportExpand && expanded) {
    const expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    const expandedClsName = computedExpandedClassName(expandedRowClassName, record, index2, indent);
    let additionalProps = {};
    if (fixColumn) {
      additionalProps = {
        style: {
          ["--virtual-width"]: `${componentWidth}px`
        }
      };
    }
    const rowCellCls = `${prefixCls}-expanded-row-cell`;
    expandRowNode = React565.createElement(RowComponent, {
      className: clsx(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, expandedClsName)
    }, React565.createElement(Cell_default2, {
      component: cellComponent,
      prefixCls,
      className: clsx(rowCellCls, {
        [`${rowCellCls}-fixed`]: fixColumn
      }),
      additionalProps
    }, expandContent));
  }
  const rowStyle = {
    ...style2,
    width: scrollX
  };
  if (extra) {
    rowStyle.position = "absolute";
    rowStyle.pointerEvents = "none";
  }
  const rowNode = React565.createElement(RowComponent, _extends88({}, rowProps, restProps, {
    "data-row-key": rowKey,
    ref: rowSupportExpand ? null : ref,
    className: clsx(className, `${prefixCls}-row`, rowProps == null ? void 0 : rowProps.className, {
      [`${prefixCls}-row-extra`]: extra
    }),
    style: {
      ...rowStyle,
      ...rowProps == null ? void 0 : rowProps.style
    }
  }), flattenColumns.map((column2, colIndex) => {
    return React565.createElement(VirtualCell_default, {
      key: colIndex,
      component: cellComponent,
      rowInfo,
      column: column2,
      colIndex,
      indent,
      index: index2,
      renderIndex,
      record,
      inverse: extra,
      getHeight: getHeight3
    });
  }));
  if (rowSupportExpand) {
    return React565.createElement("div", {
      ref
    }, rowNode, expandRowNode);
  }
  return rowNode;
});
var ResponseBodyLine = responseImmutable2(BodyLine);
if (true) {
  ResponseBodyLine.displayName = "BodyLine";
}
var BodyLine_default = ResponseBodyLine;

// node_modules/@rc-component/table/es/VirtualTable/BodyGrid.js
var Grid = React566.forwardRef((props, ref) => {
  const {
    data,
    onScroll
  } = props;
  const {
    flattenColumns,
    onColumnResize,
    getRowKey,
    expandedKeys,
    prefixCls,
    childrenColumnName,
    scrollX,
    direction
  } = useContext180(TableContext_default, ["flattenColumns", "onColumnResize", "getRowKey", "prefixCls", "expandedKeys", "childrenColumnName", "scrollX", "direction"]);
  const {
    sticky,
    scrollY,
    listItemHeight,
    getComponent,
    onScroll: onTablePropScroll
  } = useContext180(StaticContext);
  const listRef = React566.useRef(null);
  const flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
  const columnsWidth = React566.useMemo(() => {
    let total = 0;
    return flattenColumns.map(({
      width,
      minWidth,
      key
    }) => {
      const finalWidth = Math.max(width || 0, minWidth || 0);
      total += finalWidth;
      return [key, finalWidth, total];
    });
  }, [flattenColumns]);
  const columnsOffset = React566.useMemo(() => columnsWidth.map((colWidth) => colWidth[2]), [columnsWidth]);
  React566.useEffect(() => {
    columnsWidth.forEach(([key, width]) => {
      onColumnResize(key, width);
    });
  }, [columnsWidth]);
  React566.useImperativeHandle(ref, () => {
    var _a;
    const obj = {
      scrollTo: (config) => {
        var _a2, _b;
        const {
          offset: offset3,
          ...restConfig
        } = config;
        if (offset3) {
          (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo({
            ...restConfig,
            offset: offset3,
            align: "top"
          });
        } else {
          (_b = listRef.current) == null ? void 0 : _b.scrollTo(config);
        }
      },
      nativeElement: (_a = listRef.current) == null ? void 0 : _a.nativeElement
    };
    Object.defineProperty(obj, "scrollLeft", {
      get: () => {
        var _a2;
        return ((_a2 = listRef.current) == null ? void 0 : _a2.getScrollInfo().x) || 0;
      },
      set: (value) => {
        var _a2;
        (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo({
          left: value
        });
      }
    });
    Object.defineProperty(obj, "scrollTop", {
      get: () => {
        var _a2;
        return ((_a2 = listRef.current) == null ? void 0 : _a2.getScrollInfo().y) || 0;
      },
      set: (value) => {
        var _a2;
        (_a2 = listRef.current) == null ? void 0 : _a2.scrollTo({
          top: value
        });
      }
    });
    return obj;
  });
  const getRowSpan = (column2, index2) => {
    var _a;
    const record = (_a = flattenData2[index2]) == null ? void 0 : _a.record;
    const {
      onCell
    } = column2;
    if (onCell) {
      const cellProps = onCell(record, index2);
      return (cellProps == null ? void 0 : cellProps.rowSpan) ?? 1;
    }
    return 1;
  };
  const extraRender = (info) => {
    const {
      start,
      end,
      getSize: getSize3,
      offsetY
    } = info;
    if (end < 0) {
      return null;
    }
    let firstRowSpanColumns = flattenColumns.filter(
      // rowSpan is 0
      (column2) => getRowSpan(column2, start) === 0
    );
    let startIndex = start;
    for (let i = start; i >= 0; i -= 1) {
      firstRowSpanColumns = firstRowSpanColumns.filter((column2) => getRowSpan(column2, i) === 0);
      if (!firstRowSpanColumns.length) {
        startIndex = i;
        break;
      }
    }
    let lastRowSpanColumns = flattenColumns.filter(
      // rowSpan is not 1
      (column2) => getRowSpan(column2, end) !== 1
    );
    let endIndex = end;
    for (let i = end; i < flattenData2.length; i += 1) {
      lastRowSpanColumns = lastRowSpanColumns.filter((column2) => getRowSpan(column2, i) !== 1);
      if (!lastRowSpanColumns.length) {
        endIndex = Math.max(i - 1, end);
        break;
      }
    }
    const spanLines = [];
    for (let i = startIndex; i <= endIndex; i += 1) {
      const item = flattenData2[i];
      if (!item) {
        continue;
      }
      if (flattenColumns.some((column2) => getRowSpan(column2, i) > 1)) {
        spanLines.push(i);
      }
    }
    const nodes = spanLines.map((index2) => {
      const item = flattenData2[index2];
      const rowKey = getRowKey(item.record, index2);
      const getHeight3 = (rowSpan) => {
        const endItemIndex = index2 + rowSpan - 1;
        const endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex);
        const sizeInfo2 = getSize3(rowKey, endItemKey);
        return sizeInfo2.bottom - sizeInfo2.top;
      };
      const sizeInfo = getSize3(rowKey);
      return React566.createElement(BodyLine_default, {
        key: index2,
        data: item,
        rowKey,
        index: index2,
        style: {
          top: -offsetY + sizeInfo.top
        },
        extra: true,
        getHeight: getHeight3
      });
    });
    return nodes;
  };
  const gridContext = React566.useMemo(() => ({
    columnsOffset
  }), [columnsOffset]);
  const tblPrefixCls = `${prefixCls}-tbody`;
  const wrapperComponent = getComponent(["body", "wrapper"]);
  const horizontalScrollBarStyle = {};
  if (sticky) {
    horizontalScrollBarStyle.position = "sticky";
    horizontalScrollBarStyle.bottom = 0;
    if (typeof sticky === "object" && sticky.offsetScroll) {
      horizontalScrollBarStyle.bottom = sticky.offsetScroll;
    }
  }
  return React566.createElement(GridContext.Provider, {
    value: gridContext
  }, React566.createElement(es_default11, {
    fullHeight: false,
    ref: listRef,
    prefixCls: `${tblPrefixCls}-virtual`,
    styles: {
      horizontalScrollBar: horizontalScrollBarStyle
    },
    className: tblPrefixCls,
    height: scrollY,
    itemHeight: listItemHeight || 24,
    data: flattenData2,
    itemKey: (item) => getRowKey(item.record),
    component: wrapperComponent,
    scrollWidth: scrollX,
    direction,
    onVirtualScroll: ({
      x
    }) => {
      var _a;
      onScroll({
        currentTarget: (_a = listRef.current) == null ? void 0 : _a.nativeElement,
        scrollLeft: x
      });
    },
    onScroll: onTablePropScroll,
    extraRender
  }, (item, index2, itemProps) => {
    const rowKey = getRowKey(item.record, index2);
    return React566.createElement(BodyLine_default, {
      data: item,
      rowKey,
      index: index2,
      style: itemProps.style
    });
  }));
});
var ResponseGrid = responseImmutable2(Grid);
if (true) {
  ResponseGrid.displayName = "ResponseGrid";
}
var BodyGrid_default = ResponseGrid;

// node_modules/@rc-component/table/es/VirtualTable/index.js
function _extends89() {
  _extends89 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends89.apply(this, arguments);
}
var renderBody = (rawData, props) => {
  const {
    ref,
    onScroll
  } = props;
  return React567.createElement(BodyGrid_default, {
    ref,
    data: rawData,
    onScroll
  });
};
var VirtualTable = (props, ref) => {
  const {
    data,
    columns,
    scroll,
    sticky,
    prefixCls = DEFAULT_PREFIX,
    className,
    listItemHeight,
    components: components2,
    onScroll
  } = props;
  let {
    x: scrollX,
    y: scrollY
  } = scroll || {};
  if (typeof scrollX !== "number") {
    if (true) {
      warning_default(!scrollX, "`scroll.x` in virtual table must be number.");
    }
    scrollX = 1;
  }
  if (typeof scrollY !== "number") {
    scrollY = 500;
    if (true) {
      warning_default(false, "`scroll.y` in virtual table must be number.");
    }
  }
  const getComponent = useEvent_default((path2, defaultComponent) => get(components2, path2) || defaultComponent);
  const onInternalScroll = useEvent_default(onScroll);
  const context = React567.useMemo(() => ({
    sticky,
    scrollY,
    listItemHeight,
    getComponent,
    onScroll: onInternalScroll
  }), [sticky, scrollY, listItemHeight, getComponent, onInternalScroll]);
  return React567.createElement(StaticContext.Provider, {
    value: context
  }, React567.createElement(Table_default, _extends89({}, props, {
    className: clsx(className, `${prefixCls}-virtual`),
    scroll: {
      ...scroll,
      x: scrollX
    },
    components: {
      ...components2,
      // fix https://github.com/ant-design/ant-design/issues/48991
      body: (data == null ? void 0 : data.length) ? renderBody : void 0
    },
    columns,
    internalHooks: INTERNAL_HOOKS,
    tailor: true,
    ref
  })));
};
var RefVirtualTable = React567.forwardRef(VirtualTable);
if (true) {
  RefVirtualTable.displayName = "VirtualTable";
}
var genVirtualTable = (shouldTriggerRender) => {
  return makeImmutable2(RefVirtualTable, shouldTriggerRender);
};
var VirtualTable_default = genVirtualTable();

// node_modules/antd/es/table/Column.js
var Column3 = (_) => null;
var Column_default2 = Column3;

// node_modules/antd/es/table/ColumnGroup.js
var ColumnGroup2 = (_) => null;
var ColumnGroup_default2 = ColumnGroup2;

// node_modules/antd/es/table/hooks/useSelection.js
var React572 = __toESM(require_react());
var import_react212 = __toESM(require_react());

// node_modules/@rc-component/tree/es/util.js
var import_react211 = __toESM(require_react());

// node_modules/@rc-component/tree/es/TreeNode.js
var import_react210 = __toESM(require_react());

// node_modules/@rc-component/tree/es/contextTypes.js
var React568 = __toESM(require_react());
var TreeContext = React568.createContext(null);
var UnstableContext4 = React568.createContext({});

// node_modules/@rc-component/tree/es/Indent.js
var React569 = __toESM(require_react());
var Indent = ({
  prefixCls,
  level,
  isStart,
  isEnd
}) => {
  const baseClassName = `${prefixCls}-indent-unit`;
  const list = [];
  for (let i = 0; i < level; i += 1) {
    list.push(React569.createElement("span", {
      key: i,
      className: clsx(baseClassName, {
        [`${baseClassName}-start`]: isStart[i],
        [`${baseClassName}-end`]: isEnd[i]
      })
    }));
  }
  return React569.createElement("span", {
    "aria-hidden": "true",
    className: `${prefixCls}-indent`
  }, list);
};
var Indent_default = React569.memo(Indent);

// node_modules/@rc-component/tree/es/TreeNode.js
function _extends90() {
  _extends90 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends90.apply(this, arguments);
}
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var TreeNode = (props) => {
  var _a, _b;
  const {
    eventKey,
    className,
    style: style2,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    isLeaf: isLeaf2,
    isStart,
    isEnd,
    expanded,
    selected,
    checked,
    halfChecked,
    loading,
    domRef,
    active,
    data,
    onMouseMove,
    selectable,
    ...otherProps
  } = props;
  const context = import_react210.default.useContext(TreeContext);
  const {
    classNames: treeClassNames,
    styles
  } = context || {};
  const unstableContext = import_react210.default.useContext(UnstableContext4);
  const selectHandleRef = import_react210.default.useRef(null);
  const [dragNodeHighlight, setDragNodeHighlight] = import_react210.default.useState(false);
  const isDisabled = !!(context.disabled || props.disabled || ((_a = unstableContext.nodeDisabled) == null ? void 0 : _a.call(unstableContext, data)));
  const isCheckable = import_react210.default.useMemo(() => {
    if (!context.checkable || props.checkable === false) {
      return false;
    }
    return context.checkable;
  }, [context.checkable, props.checkable]);
  const onSelect = (e3) => {
    if (isDisabled) {
      return;
    }
    context.onNodeSelect(e3, convertNodePropsToEventData(props));
  };
  const onCheck = (e3) => {
    if (isDisabled) {
      return;
    }
    if (!isCheckable || props.disableCheckbox) {
      return;
    }
    context.onNodeCheck(e3, convertNodePropsToEventData(props), !checked);
  };
  const isSelectable = import_react210.default.useMemo(() => {
    if (typeof selectable === "boolean") {
      return selectable;
    }
    return context.selectable;
  }, [selectable, context.selectable]);
  const onSelectorClick = (e3) => {
    context.onNodeClick(e3, convertNodePropsToEventData(props));
    if (isSelectable) {
      onSelect(e3);
    } else {
      onCheck(e3);
    }
  };
  const onSelectorDoubleClick = (e3) => {
    context.onNodeDoubleClick(e3, convertNodePropsToEventData(props));
  };
  const onMouseEnter = (e3) => {
    context.onNodeMouseEnter(e3, convertNodePropsToEventData(props));
  };
  const onMouseLeave = (e3) => {
    context.onNodeMouseLeave(e3, convertNodePropsToEventData(props));
  };
  const onContextMenu = (e3) => {
    context.onNodeContextMenu(e3, convertNodePropsToEventData(props));
  };
  const isDraggable = import_react210.default.useMemo(() => {
    return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
  }, [context.draggable, data]);
  const onDragStart = (e3) => {
    e3.stopPropagation();
    setDragNodeHighlight(true);
    context.onNodeDragStart(e3, props);
    try {
      e3.dataTransfer.setData("text/plain", "");
    } catch {
    }
  };
  const onDragEnter = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    context.onNodeDragEnter(e3, props);
  };
  const onDragOver = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    context.onNodeDragOver(e3, props);
  };
  const onDragLeave = (e3) => {
    e3.stopPropagation();
    context.onNodeDragLeave(e3, props);
  };
  const onDragEnd = (e3) => {
    e3.stopPropagation();
    setDragNodeHighlight(false);
    context.onNodeDragEnd(e3, props);
  };
  const onDrop = (e3) => {
    e3.preventDefault();
    e3.stopPropagation();
    setDragNodeHighlight(false);
    context.onNodeDrop(e3, props);
  };
  const onExpand = (e3) => {
    if (loading) {
      return;
    }
    context.onNodeExpand(e3, convertNodePropsToEventData(props));
  };
  const hasChildren = import_react210.default.useMemo(() => {
    const {
      children
    } = getEntity(context.keyEntities, eventKey) || {};
    return Boolean((children || []).length);
  }, [context.keyEntities, eventKey]);
  const memoizedIsLeaf = import_react210.default.useMemo(() => {
    if (isLeaf2 === false) {
      return false;
    }
    return isLeaf2 || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
  }, [isLeaf2, context.loadData, hasChildren, props.loaded]);
  import_react210.default.useEffect(() => {
    if (loading) {
      return;
    }
    if (typeof context.loadData === "function" && expanded && !memoizedIsLeaf && !props.loaded) {
      context.onNodeLoad(convertNodePropsToEventData(props));
    }
  }, [loading, context.loadData, context.onNodeLoad, expanded, memoizedIsLeaf, props]);
  const dragHandlerNode = import_react210.default.useMemo(() => {
    var _a2;
    if (!((_a2 = context.draggable) == null ? void 0 : _a2.icon)) {
      return null;
    }
    return import_react210.default.createElement("span", {
      className: `${context.prefixCls}-draggable-icon`
    }, context.draggable.icon);
  }, [context.draggable]);
  const renderSwitcherIconDom = (isInternalLeaf) => {
    const switcherIcon = props.switcherIcon || context.switcherIcon;
    if (typeof switcherIcon === "function") {
      return switcherIcon({
        ...props,
        isLeaf: isInternalLeaf
      });
    }
    return switcherIcon;
  };
  const renderSwitcher = () => {
    if (memoizedIsLeaf) {
      const switcherIconDom2 = renderSwitcherIconDom(true);
      return switcherIconDom2 !== false ? import_react210.default.createElement("span", {
        className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher-noop`)
      }, switcherIconDom2) : null;
    }
    const switcherIconDom = renderSwitcherIconDom(false);
    return switcherIconDom !== false ? import_react210.default.createElement("span", {
      onClick: onExpand,
      className: clsx(`${context.prefixCls}-switcher`, `${context.prefixCls}-switcher_${expanded ? ICON_OPEN : ICON_CLOSE}`)
    }, switcherIconDom) : null;
  };
  const checkboxNode = import_react210.default.useMemo(() => {
    if (!isCheckable) {
      return null;
    }
    const $custom = typeof isCheckable !== "boolean" ? isCheckable : null;
    return import_react210.default.createElement("span", {
      className: clsx(`${context.prefixCls}-checkbox`, {
        [`${context.prefixCls}-checkbox-checked`]: checked,
        [`${context.prefixCls}-checkbox-indeterminate`]: !checked && halfChecked,
        [`${context.prefixCls}-checkbox-disabled`]: isDisabled || props.disableCheckbox
      }),
      onClick: onCheck,
      role: "checkbox",
      "aria-checked": halfChecked ? "mixed" : checked,
      "aria-disabled": isDisabled || props.disableCheckbox,
      "aria-label": `Select ${typeof props.title === "string" ? props.title : "tree node"}`
    }, $custom);
  }, [isCheckable, checked, halfChecked, isDisabled, props.disableCheckbox, props.title]);
  const nodeState = import_react210.default.useMemo(() => {
    if (memoizedIsLeaf) {
      return null;
    }
    return expanded ? ICON_OPEN : ICON_CLOSE;
  }, [memoizedIsLeaf, expanded]);
  const iconNode = import_react210.default.useMemo(() => {
    return import_react210.default.createElement("span", {
      className: clsx(treeClassNames == null ? void 0 : treeClassNames.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__${nodeState || "docu"}`, {
        [`${context.prefixCls}-icon_loading`]: loading
      }),
      style: styles == null ? void 0 : styles.itemIcon
    });
  }, [context.prefixCls, nodeState, loading]);
  const dropIndicatorNode = import_react210.default.useMemo(() => {
    const rootDraggable = Boolean(context.draggable);
    const showIndicator = !props.disabled && rootDraggable && context.dragOverNodeKey === eventKey;
    if (!showIndicator) {
      return null;
    }
    return context.dropIndicatorRender({
      dropPosition: context.dropPosition,
      dropLevelOffset: context.dropLevelOffset,
      indent: context.indent,
      prefixCls: context.prefixCls,
      direction: context.direction
    });
  }, [context.dropPosition, context.dropLevelOffset, context.indent, context.prefixCls, context.direction, context.draggable, context.dragOverNodeKey, context.dropIndicatorRender]);
  const selectorNode = import_react210.default.useMemo(() => {
    const {
      title = defaultTitle
    } = props;
    const wrapClass = `${context.prefixCls}-node-content-wrapper`;
    let $icon;
    if (context.showIcon) {
      const currentIcon = props.icon || context.icon;
      $icon = currentIcon ? import_react210.default.createElement("span", {
        className: clsx(treeClassNames == null ? void 0 : treeClassNames.itemIcon, `${context.prefixCls}-iconEle`, `${context.prefixCls}-icon__customize`),
        style: styles == null ? void 0 : styles.itemIcon
      }, typeof currentIcon === "function" ? currentIcon(props) : currentIcon) : iconNode;
    } else if (context.loadData && loading) {
      $icon = iconNode;
    }
    let titleNode;
    if (typeof title === "function") {
      titleNode = title(data);
    } else if (context.titleRender) {
      titleNode = context.titleRender(data);
    } else {
      titleNode = title;
    }
    return import_react210.default.createElement("span", {
      ref: selectHandleRef,
      title: typeof title === "string" ? title : "",
      className: clsx(wrapClass, `${wrapClass}-${nodeState || "normal"}`, {
        [`${context.prefixCls}-node-selected`]: !isDisabled && (selected || dragNodeHighlight)
      }),
      onMouseEnter,
      onMouseLeave,
      onContextMenu,
      onClick: onSelectorClick,
      onDoubleClick: onSelectorDoubleClick
    }, $icon, import_react210.default.createElement("span", {
      className: clsx(`${context.prefixCls}-title`, treeClassNames == null ? void 0 : treeClassNames.itemTitle),
      style: styles == null ? void 0 : styles.itemTitle
    }, titleNode), dropIndicatorNode);
  }, [context.prefixCls, context.showIcon, props, context.icon, iconNode, context.titleRender, data, nodeState, onMouseEnter, onMouseLeave, onContextMenu, onSelectorClick, onSelectorDoubleClick]);
  const dataOrAriaAttributeProps = pickAttrs(otherProps, {
    aria: true,
    data: true
  });
  const {
    level
  } = getEntity(context.keyEntities, eventKey) || {};
  const isEndNode = isEnd[isEnd.length - 1];
  const draggableWithoutDisabled = !isDisabled && isDraggable;
  const dragging = context.draggingNodeKey === eventKey;
  const ariaSelected = selectable !== void 0 ? {
    "aria-selected": !!selectable
  } : void 0;
  return import_react210.default.createElement("div", _extends90({
    ref: domRef,
    role: "treeitem",
    "aria-expanded": isLeaf2 ? void 0 : expanded,
    className: clsx(className, `${context.prefixCls}-treenode`, treeClassNames == null ? void 0 : treeClassNames.item, {
      [`${context.prefixCls}-treenode-disabled`]: isDisabled,
      [`${context.prefixCls}-treenode-switcher-${expanded ? "open" : "close"}`]: !isLeaf2,
      [`${context.prefixCls}-treenode-checkbox-checked`]: checked,
      [`${context.prefixCls}-treenode-checkbox-indeterminate`]: halfChecked,
      [`${context.prefixCls}-treenode-selected`]: selected,
      [`${context.prefixCls}-treenode-loading`]: loading,
      [`${context.prefixCls}-treenode-active`]: active,
      [`${context.prefixCls}-treenode-leaf-last`]: isEndNode,
      [`${context.prefixCls}-treenode-draggable`]: isDraggable,
      dragging,
      "drop-target": context.dropTargetKey === eventKey,
      "drop-container": context.dropContainerKey === eventKey,
      "drag-over": !isDisabled && dragOver,
      "drag-over-gap-top": !isDisabled && dragOverGapTop,
      "drag-over-gap-bottom": !isDisabled && dragOverGapBottom,
      "filter-node": (_b = context.filterTreeNode) == null ? void 0 : _b.call(context, convertNodePropsToEventData(props)),
      [`${context.prefixCls}-treenode-leaf`]: memoizedIsLeaf
    }),
    style: {
      ...style2,
      ...styles == null ? void 0 : styles.item
    },
    draggable: draggableWithoutDisabled,
    onDragStart: draggableWithoutDisabled ? onDragStart : void 0,
    onDragEnter: isDraggable ? onDragEnter : void 0,
    onDragOver: isDraggable ? onDragOver : void 0,
    onDragLeave: isDraggable ? onDragLeave : void 0,
    onDrop: isDraggable ? onDrop : void 0,
    onDragEnd: isDraggable ? onDragEnd : void 0,
    onMouseMove
  }, ariaSelected, dataOrAriaAttributeProps), import_react210.default.createElement(Indent_default, {
    prefixCls: context.prefixCls,
    level,
    isStart,
    isEnd
  }), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
};
TreeNode.isTreeNode = 1;
if (true) {
  TreeNode.displayName = "TreeNode";
}
var TreeNode_default = TreeNode;

// node_modules/@rc-component/tree/es/util.js
function arrDel(list, value) {
  if (!list)
    return [];
  const clone = list.slice();
  const index2 = clone.indexOf(value);
  if (index2 >= 0) {
    clone.splice(index2, 1);
  }
  return clone;
}
function arrAdd(list, value) {
  const clone = (list || []).slice();
  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }
  return clone;
}
function posToArr(pos) {
  return pos.split("-");
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  const dragChildrenKeys = [];
  const entity = getEntity(keyEntities, dragNodeKey);
  function dig(list = []) {
    list.forEach(({
      key,
      children
    }) => {
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    const posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  const posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
  var _a;
  const {
    clientX,
    clientY
  } = event;
  const {
    top,
    height
  } = event.target.getBoundingClientRect();
  const horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition == null ? void 0 : startMousePosition.x) || 0) - clientX);
  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  const filteredExpandKeys = expandKeys.filter((key) => {
    var _a2, _b;
    return (_b = (_a2 = keyEntities[key]) == null ? void 0 : _a2.children) == null ? void 0 : _b.length;
  });
  let abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);
  if (clientY < top + height / 2) {
    const nodeIndex = flattenedNodes.findIndex((flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key);
    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    const prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
  }
  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  const abstractDragOverEntity = abstractDropNodeEntity;
  const dragOverNodeKey = abstractDropNodeEntity.key;
  let dropPosition = 0;
  let dropLevelOffset = 0;
  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {
    for (let i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  const abstractDragDataNode = dragNodeProps.data;
  const abstractDropDataNode = abstractDropNodeEntity.node;
  let dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_a = abstractDropNodeEntity.parent) == null ? void 0 : _a.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys)
    return void 0;
  const {
    multiple
  } = props;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  let keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (typeof keys2 === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    warning_default(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  const expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key) {
    if (expandedKeys.has(key))
      return;
    const entity = getEntity(keyEntities, key);
    if (!entity)
      return;
    expandedKeys.add(key);
    const {
      parent,
      node: node2
    } = entity;
    if (node2.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach((key) => {
    conductUp(key);
  });
  return [...expandedKeys];
}

// node_modules/antd/es/table/hooks/useSelection.js
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST5 = [];
var flattenData = (childrenColumnName, data, list = []) => {
  (data || []).forEach((record) => {
    list.push(record);
    if (record && typeof record === "object" && childrenColumnName in record) {
      flattenData(childrenColumnName, record[childrenColumnName], list);
    }
  });
  return list;
};
var useSelection = (config, rowSelection) => {
  const {
    preserveSelectedRowKeys,
    selectedRowKeys,
    defaultSelectedRowKeys,
    getCheckboxProps,
    getTitleCheckboxProps,
    onChange: onSelectionChange,
    onSelect,
    onSelectAll,
    onSelectInvert,
    onSelectNone,
    onSelectMultiple,
    columnWidth: selectionColWidth,
    type: selectionType,
    selections,
    fixed,
    renderCell: customizeRenderCell,
    hideSelectAll,
    checkStrictly = true
  } = rowSelection || {};
  const {
    prefixCls,
    data,
    pageData,
    getRecordByKey,
    getRowKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  } = config;
  const warning5 = devUseWarning("Table");
  const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
  const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(defaultSelectedRowKeys || EMPTY_LIST5, selectedRowKeys);
  const preserveRecordsRef = React572.useRef(/* @__PURE__ */ new Map());
  const updatePreserveRecordsCache = (0, import_react212.useCallback)((keys2) => {
    if (preserveSelectedRowKeys) {
      const newCache = /* @__PURE__ */ new Map();
      keys2.forEach((key) => {
        let record = getRecordByKey(key);
        if (!record && preserveRecordsRef.current.has(key)) {
          record = preserveRecordsRef.current.get(key);
        }
        newCache.set(key, record);
      });
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  React572.useEffect(() => {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  const flattedData = (0, import_react212.useMemo)(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
  const {
    keyEntities
  } = (0, import_react212.useMemo)(() => {
    if (checkStrictly) {
      return {
        keyEntities: null
      };
    }
    let convertData = data;
    if (preserveSelectedRowKeys) {
      const keysSet = new Set(flattedData.map(getRowKey));
      const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, [key, value]) => keysSet.has(key) ? total : total.concat(value), []);
      convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
    }
    return convertDataToEntities(convertData, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys, flattedData]);
  const checkboxPropsMap = (0, import_react212.useMemo)(() => {
    const map = /* @__PURE__ */ new Map();
    flattedData.forEach((record, index2) => {
      const key = getRowKey(record, index2);
      const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps);
      true ? warning5(!("checked" in checkboxProps || "defaultChecked" in checkboxProps), "usage", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.") : void 0;
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  const isCheckboxDisabled = (0, import_react212.useCallback)((r2) => {
    const rowKey = getRowKey(r2);
    let checkboxProps;
    if (checkboxPropsMap.has(rowKey)) {
      checkboxProps = checkboxPropsMap.get(getRowKey(r2));
    } else {
      checkboxProps = getCheckboxProps ? getCheckboxProps(r2) : void 0;
    }
    return !!(checkboxProps == null ? void 0 : checkboxProps.disabled);
  }, [checkboxPropsMap, getRowKey]);
  const [derivedSelectedKeys, derivedHalfSelectedKeys] = (0, import_react212.useMemo)(() => {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
  const derivedSelectedKeySet = (0, import_react212.useMemo)(() => {
    const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys2);
  }, [derivedSelectedKeys, selectionType]);
  const derivedHalfSelectedKeySet = (0, import_react212.useMemo)(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
  React572.useEffect(() => {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST5);
    }
  }, [!!rowSelection]);
  const setSelectedKeys = (0, import_react212.useCallback)((keys2, method4) => {
    let availableKeys;
    let records;
    updatePreserveRecordsCache(keys2);
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map((key) => preserveRecordsRef.current.get(key));
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach((key) => {
        const record = getRecordByKey(key);
        if (record !== void 0) {
          availableKeys.push(key);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange == null ? void 0 : onSelectionChange(availableKeys, records, {
      type: method4
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  const triggerSingleSelection = (0, import_react212.useCallback)((key, selected, keys2, event) => {
    if (onSelect) {
      const rows = keys2.map((k) => getRecordByKey(k));
      onSelect(getRecordByKey(key), selected, rows, event);
    }
    setSelectedKeys(keys2, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  const mergedSelections = (0, import_react212.useMemo)(() => {
    if (!selections || hideSelectAll) {
      return null;
    }
    const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map((selection) => {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect() {
            setSelectedKeys(data.map((record, index2) => getRowKey(record, index2)).filter((key) => {
              const checkProps = checkboxPropsMap.get(key);
              return !(checkProps == null ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
            }), "all");
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect() {
            const keySet = new Set(derivedSelectedKeySet);
            pageData.forEach((record, index2) => {
              const key = getRowKey(record, index2);
              const checkProps = checkboxPropsMap.get(key);
              if (!(checkProps == null ? void 0 : checkProps.disabled)) {
                if (keySet.has(key)) {
                  keySet.delete(key);
                } else {
                  keySet.add(key);
                }
              }
            });
            const keys2 = Array.from(keySet);
            if (onSelectInvert) {
              warning5.deprecated(false, "onSelectInvert", "onChange");
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect() {
            onSelectNone == null ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
              const checkProps = checkboxPropsMap.get(key);
              return checkProps == null ? void 0 : checkProps.disabled;
            }), "none");
          }
        };
      }
      return selection;
    }).map((selection) => ({
      ...selection,
      onSelect: (...rest) => {
        var _a;
        (_a = selection.onSelect) == null ? void 0 : _a.call(selection, ...rest);
        updatePrevSelectedIndex(null);
      }
    }));
  }, [selections, hideSelectAll, tableLocale.selectionAll, tableLocale.selectInvert, tableLocale.selectNone, checkboxPropsMap, derivedSelectedKeySet, data, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  const transformColumns = (0, import_react212.useCallback)((columns) => {
    var _a;
    if (!rowSelection) {
      true ? warning5(!columns.includes(SELECTION_COLUMN), "usage", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`.") : void 0;
      return columns.filter((col) => col !== SELECTION_COLUMN);
    }
    let cloneColumns = _toConsumableArray(columns);
    const keySet = new Set(derivedSelectedKeySet);
    const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
    const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
    const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
    const onSelectAllChange = () => {
      const changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach((key) => {
          keySet.delete(key);
          changeKeys.push(key);
        });
      } else {
        recordKeys.forEach((key) => {
          if (!keySet.has(key)) {
            keySet.add(key);
            changeKeys.push(key);
          }
        });
      }
      const keys2 = Array.from(keySet);
      onSelectAll == null ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k) => getRecordByKey(k)), changeKeys.map((k) => getRecordByKey(k)));
      setSelectedKeys(keys2, "all");
      updatePrevSelectedIndex(null);
    };
    let title;
    let columnTitleCheckbox;
    if (selectionType !== "radio") {
      let customizeSelections;
      if (mergedSelections) {
        const menu = {
          getPopupContainer,
          items: mergedSelections.map((selection, index2) => {
            const {
              key,
              text,
              onSelect: onSelectionClick
            } = selection;
            return {
              key: key ?? index2,
              onClick: () => {
                onSelectionClick == null ? void 0 : onSelectionClick(recordKeys);
              },
              label: text
            };
          })
        };
        customizeSelections = React572.createElement("div", {
          className: `${prefixCls}-selection-extra`
        }, React572.createElement(dropdown_default3, {
          menu,
          getPopupContainer
        }, React572.createElement("span", null, React572.createElement(DownOutlined_default, null))));
      }
      const allDisabledData = flattedData.map((record, index2) => {
        const key = getRowKey(record, index2);
        const checkboxProps = checkboxPropsMap.get(key) || {};
        return {
          checked: keySet.has(key),
          ...checkboxProps
        };
      }).filter(({
        disabled: disabled2
      }) => disabled2);
      const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      const allDisabledAndChecked = allDisabled && allDisabledData.every(({
        checked
      }) => checked);
      const allDisabledSomeChecked = allDisabled && allDisabledData.some(({
        checked
      }) => checked);
      const customCheckboxProps = (getTitleCheckboxProps == null ? void 0 : getTitleCheckboxProps()) || {};
      const {
        onChange,
        disabled
      } = customCheckboxProps;
      columnTitleCheckbox = React572.createElement(checkbox_default, {
        "aria-label": customizeSelections ? "Custom selection" : "Select all",
        ...customCheckboxProps,
        checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
        indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        onChange: (e3) => {
          onSelectAllChange();
          onChange == null ? void 0 : onChange(e3);
        },
        disabled: disabled ?? (flattedData.length === 0 || allDisabled),
        skipGroup: true
      });
      title = !hideSelectAll && React572.createElement("div", {
        className: `${prefixCls}-selection`
      }, columnTitleCheckbox, customizeSelections);
    }
    let renderCell;
    if (selectionType === "radio") {
      renderCell = (_, record, index2) => {
        const key = getRowKey(record, index2);
        const checked = keySet.has(key);
        const checkboxProps = checkboxPropsMap.get(key);
        return {
          node: React572.createElement(radio_default2, {
            ...checkboxProps,
            checked,
            onClick: (e3) => {
              var _a2;
              e3.stopPropagation();
              (_a2 = checkboxProps == null ? void 0 : checkboxProps.onClick) == null ? void 0 : _a2.call(checkboxProps, e3);
            },
            onChange: (event) => {
              var _a2;
              if (!keySet.has(key)) {
                triggerSingleSelection(key, true, [key], event.nativeEvent);
              }
              (_a2 = checkboxProps == null ? void 0 : checkboxProps.onChange) == null ? void 0 : _a2.call(checkboxProps, event);
            }
          }),
          checked
        };
      };
    } else {
      renderCell = (_, record, index2) => {
        const key = getRowKey(record, index2);
        const checked = keySet.has(key);
        const indeterminate = derivedHalfSelectedKeySet.has(key);
        const checkboxProps = checkboxPropsMap.get(key);
        let mergedIndeterminate;
        if (expandType === "nest") {
          mergedIndeterminate = indeterminate;
          true ? warning5(typeof (checkboxProps == null ? void 0 : checkboxProps.indeterminate) !== "boolean", "usage", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.") : void 0;
        } else {
          mergedIndeterminate = (checkboxProps == null ? void 0 : checkboxProps.indeterminate) ?? indeterminate;
        }
        return {
          node: React572.createElement(checkbox_default, {
            ...checkboxProps,
            indeterminate: mergedIndeterminate,
            checked,
            skipGroup: true,
            onClick: (e3) => {
              var _a2;
              e3.stopPropagation();
              (_a2 = checkboxProps == null ? void 0 : checkboxProps.onClick) == null ? void 0 : _a2.call(checkboxProps, e3);
            },
            onChange: (event) => {
              var _a2;
              const {
                nativeEvent
              } = event;
              const {
                shiftKey
              } = nativeEvent;
              const currentSelectedIndex = recordKeys.indexOf(key);
              const isMultiple2 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
              if (shiftKey && checkStrictly && isMultiple2) {
                const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
                const keys2 = Array.from(keySet);
                onSelectMultiple == null ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                setSelectedKeys(keys2, "multiple");
              } else {
                const originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                  triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                } else {
                  const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                  const {
                    checkedKeys,
                    halfCheckedKeys
                  } = result;
                  let nextCheckedKeys = checkedKeys;
                  if (checked) {
                    const tempKeySet = new Set(checkedKeys);
                    tempKeySet.delete(key);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                updatePrevSelectedIndex(null);
              } else {
                updatePrevSelectedIndex(currentSelectedIndex);
              }
              (_a2 = checkboxProps == null ? void 0 : checkboxProps.onChange) == null ? void 0 : _a2.call(checkboxProps, event);
            }
          }),
          checked
        };
      };
    }
    const renderSelectionCell = (_, record, index2) => {
      const {
        node: node2,
        checked
      } = renderCell(_, record, index2);
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node2);
      }
      return node2;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex((col) => {
        var _a2;
        return ((_a2 = col[INTERNAL_COL_DEFINE]) == null ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        const [expandColumn, ...restColumns] = cloneColumns;
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    true ? warning5(cloneColumns.filter((col) => col === SELECTION_COLUMN).length <= 1, "usage", "Multiple `SELECTION_COLUMN` exist in `columns`.") : void 0;
    cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
    const prevCol = cloneColumns[selectionColumnIndex - 1];
    const nextCol = cloneColumns[selectionColumnIndex + 1];
    let mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol == null ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol == null ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) == null ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    const columnCls = clsx(`${prefixCls}-selection-col`, {
      [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
    });
    const renderColumnTitle2 = () => {
      if (!(rowSelection == null ? void 0 : rowSelection.columnTitle)) {
        return title;
      }
      if (typeof rowSelection.columnTitle === "function") {
        return rowSelection.columnTitle(columnTitleCheckbox);
      }
      return rowSelection.columnTitle;
    };
    const selectionColumn = {
      fixed: mergedFixed,
      width: selectionColWidth,
      className: `${prefixCls}-selection-column`,
      title: renderColumnTitle2(),
      render: renderSelectionCell,
      onCell: rowSelection.onCell,
      align: rowSelection.align,
      [INTERNAL_COL_DEFINE]: {
        className: columnCls
      }
    };
    return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
};
var useSelection_default = useSelection;

// node_modules/antd/es/table/InternalTable.js
var React590 = __toESM(require_react());

// node_modules/antd/es/table/ExpandIcon.js
var React573 = __toESM(require_react());
function renderExpandIcon2(locale6) {
  return (props) => {
    const {
      prefixCls,
      onExpand,
      record,
      expanded,
      expandable
    } = props;
    const iconPrefix = `${prefixCls}-row-expand-icon`;
    return React573.createElement("button", {
      type: "button",
      onClick: (e3) => {
        onExpand(record, e3);
        e3.stopPropagation();
      },
      className: clsx(iconPrefix, {
        [`${iconPrefix}-spaced`]: !expandable,
        [`${iconPrefix}-expanded`]: expandable && expanded,
        [`${iconPrefix}-collapsed`]: expandable && !expanded
      }),
      "aria-label": expanded ? locale6.collapse : locale6.expand,
      "aria-expanded": expanded
    });
  };
}
var ExpandIcon_default = renderExpandIcon2;

// node_modules/antd/es/table/hooks/useContainerWidth.js
function useContainerWidth(prefixCls) {
  const getContainerWidth = (ele, width) => {
    const container = ele.querySelector(`.${prefixCls}-container`);
    let returnWidth = width;
    if (container) {
      const style2 = getComputedStyle(container);
      const borderLeft = Number.parseInt(style2.borderLeftWidth, 10);
      const borderRight = Number.parseInt(style2.borderRightWidth, 10);
      returnWidth = width - borderLeft - borderRight;
    }
    return returnWidth;
  };
  return getContainerWidth;
}

// node_modules/antd/es/table/hooks/useFilter/index.js
var React586 = __toESM(require_react());

// node_modules/antd/es/table/util.js
var getColumnKey = (column2, defaultKey) => {
  if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
    return column2.key;
  }
  if (column2.dataIndex) {
    return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
  }
  return defaultKey;
};
function getColumnPos(index2, pos) {
  return pos ? `${pos}-${index2}` : `${index2}`;
}
var renderColumnTitle = (title, props) => {
  if (typeof title === "function") {
    return title(props);
  }
  return title;
};
var safeColumnTitle = (title, props) => {
  const res = renderColumnTitle(title, props);
  if (Object.prototype.toString.call(res) === "[object Object]") {
    return "";
  }
  return res;
};

// node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
var React585 = __toESM(require_react());

// node_modules/@rc-component/tree/es/Tree.js
var React578 = __toESM(require_react());

// node_modules/@rc-component/tree/es/DropIndicator.js
var import_react213 = __toESM(require_react());
var DropIndicator = (props) => {
  const {
    dropPosition,
    dropLevelOffset,
    indent
  } = props;
  const style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0;
      style2.left = indent;
      break;
  }
  return import_react213.default.createElement("div", {
    style: style2
  });
};
if (true) {
  DropIndicator.displayName = "DropIndicator";
}
var DropIndicator_default = DropIndicator;

// node_modules/@rc-component/tree/es/NodeList.js
var React577 = __toESM(require_react());

// node_modules/@rc-component/tree/es/MotionTreeNode.js
var React576 = __toESM(require_react());

// node_modules/@rc-component/tree/es/useUnmount.js
var React575 = __toESM(require_react());
function useUnmount(triggerStart, triggerEnd) {
  const [firstMount, setFirstMount] = React575.useState(false);
  useLayoutEffect_default(() => {
    if (firstMount) {
      triggerStart();
      return () => {
        triggerEnd();
      };
    }
  }, [firstMount]);
  useLayoutEffect_default(() => {
    setFirstMount(true);
    return () => {
      setFirstMount(false);
    };
  }, []);
}
var useUnmount_default = useUnmount;

// node_modules/@rc-component/tree/es/MotionTreeNode.js
function _extends91() {
  _extends91 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends91.apply(this, arguments);
}
var MotionTreeNode = React576.forwardRef((oriProps, ref) => {
  const {
    className,
    style: style2,
    motion: motion2,
    motionNodes,
    motionType,
    onMotionStart: onOriginMotionStart,
    onMotionEnd: onOriginMotionEnd,
    active,
    treeNodeRequiredProps,
    ...props
  } = oriProps;
  const [visible, setVisible] = React576.useState(true);
  const {
    prefixCls
  } = React576.useContext(TreeContext);
  const targetVisible = motionNodes && motionType !== "hide";
  useLayoutEffect_default(() => {
    if (motionNodes) {
      if (targetVisible !== visible) {
        setVisible(targetVisible);
      }
    }
  }, [motionNodes]);
  const triggerMotionStart = () => {
    if (motionNodes) {
      onOriginMotionStart();
    }
  };
  const triggerMotionEndRef = React576.useRef(false);
  const triggerMotionEnd = () => {
    if (motionNodes && !triggerMotionEndRef.current) {
      triggerMotionEndRef.current = true;
      onOriginMotionEnd();
    }
  };
  useUnmount_default(triggerMotionStart, triggerMotionEnd);
  const onVisibleChanged = (nextVisible) => {
    if (targetVisible === nextVisible) {
      triggerMotionEnd();
    }
  };
  if (motionNodes) {
    return React576.createElement(es_default2, _extends91({
      ref,
      visible
    }, motion2, {
      motionAppear: motionType === "show",
      onVisibleChanged
    }), ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => React576.createElement("div", {
      ref: motionRef,
      className: clsx(`${prefixCls}-treenode-motion`, motionClassName),
      style: motionStyle
    }, motionNodes.map((treeNode) => {
      const {
        data: {
          ...restProps
        },
        title,
        key,
        isStart,
        isEnd
      } = treeNode;
      delete restProps.children;
      const treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
      return React576.createElement(TreeNode_default, _extends91({}, restProps, treeNodeProps, {
        title,
        active,
        data: treeNode.data,
        key,
        isStart,
        isEnd
      }));
    })));
  }
  return React576.createElement(TreeNode_default, _extends91({
    domRef: ref,
    className,
    style: style2
  }, props, {
    active
  }));
});
if (true) {
  MotionTreeNode.displayName = "MotionTreeNode";
}
var MotionTreeNode_default = MotionTreeNode;

// node_modules/@rc-component/tree/es/utils/diffUtil.js
function findExpandedKeys(prev2 = [], next2 = []) {
  const prevLen = prev2.length;
  const nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find(shorter, longer) {
    const cache = /* @__PURE__ */ new Map();
    shorter.forEach((key) => {
      cache.set(key, true);
    });
    const keys2 = longer.filter((key) => !cache.has(key));
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev2, next2)
    };
  }
  return {
    add: false,
    key: find(next2, prev2)
  };
}
function getExpandRange(shorter, longer, key) {
  const shorterStartIndex = shorter.findIndex((data) => data.key === key);
  const shorterEndNode = shorter[shorterStartIndex + 1];
  const longerStartIndex = longer.findIndex((data) => data.key === key);
  if (shorterEndNode) {
    const longerEndIndex = longer.findIndex((data) => data.key === shorterEndNode.key);
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}

// node_modules/@rc-component/tree/es/NodeList.js
function _extends92() {
  _extends92 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends92.apply(this, arguments);
}
var HIDDEN_STYLE2 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop5 = () => {
};
var MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey2(item) {
  const {
    key,
    pos
  } = item;
  return getKey4(key, pos);
}
function getAccessibilityPath(item) {
  let path2 = String(item.data.key);
  let current = item;
  while (current.parent) {
    current = current.parent;
    path2 = `${current.data.key} > ${path2}`;
  }
  return path2;
}
var NodeList = React577.forwardRef((props, ref) => {
  const {
    prefixCls,
    data,
    selectable,
    checkable,
    expandedKeys,
    selectedKeys,
    checkedKeys,
    loadedKeys,
    loadingKeys,
    halfCheckedKeys,
    keyEntities,
    disabled,
    dragging,
    dragOverNodeKey,
    dropPosition,
    motion: motion2,
    height,
    itemHeight,
    virtual,
    scrollWidth,
    focusable: focusable2,
    activeItem,
    focused,
    tabIndex,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    onActiveChange,
    onListChangeStart,
    onListChangeEnd,
    ...domProps
  } = props;
  const listRef = React577.useRef(null);
  const indentMeasurerRef = React577.useRef(null);
  React577.useImperativeHandle(ref, () => ({
    scrollTo: (scroll) => {
      listRef.current.scrollTo(scroll);
    },
    getIndentWidth: () => indentMeasurerRef.current.offsetWidth
  }));
  const [prevExpandedKeys, setPrevExpandedKeys] = React577.useState(expandedKeys);
  const [prevData, setPrevData] = React577.useState(data);
  const [transitionData, setTransitionData] = React577.useState(data);
  const [transitionRange, setTransitionRange] = React577.useState([]);
  const [motionType, setMotionType] = React577.useState(null);
  const dataRef = React577.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    const latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  useLayoutEffect_default(() => {
    setPrevExpandedKeys(expandedKeys);
    const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        const keyIndex2 = prevData.findIndex(({
          key
        }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
        const newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        const keyIndex2 = data.findIndex(({
          key
        }) => key === diffExpanded.key);
        const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
        const newTransitionData = data.slice();
        newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data) {
      setPrevData(data);
      setTransitionData(data);
    }
  }, [expandedKeys, data]);
  React577.useEffect(() => {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  const mergedData = motion2 ? transitionData : data;
  const treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return React577.createElement(React577.Fragment, null, focused && activeItem && React577.createElement("span", {
    style: HIDDEN_STYLE2,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), React577.createElement("div", null, React577.createElement("input", {
    style: HIDDEN_STYLE2,
    disabled: focusable2 === false || disabled,
    tabIndex: focusable2 !== false ? tabIndex : null,
    onKeyDown: onKeyDown2,
    onFocus,
    onBlur,
    value: "",
    onChange: noop5,
    "aria-label": "for screen reader"
  })), React577.createElement("div", {
    className: `${prefixCls}-treenode`,
    "aria-hidden": true,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden",
      border: 0,
      padding: 0
    }
  }, React577.createElement("div", {
    className: `${prefixCls}-indent`
  }, React577.createElement("div", {
    ref: indentMeasurerRef,
    className: `${prefixCls}-indent-unit`
  }))), React577.createElement(es_default11, _extends92({}, domProps, {
    data: mergedData,
    itemKey: itemKey2,
    height,
    fullHeight: false,
    virtual,
    itemHeight,
    scrollWidth,
    prefixCls: `${prefixCls}-list`,
    ref: listRef,
    role: "tree",
    onVisibleChange: (originList) => {
      if (originList.every((item) => itemKey2(item) !== MOTION_KEY)) {
        onMotionEnd();
      }
    }
  }), (treeNode) => {
    const {
      pos,
      data: {
        ...restProps
      },
      title,
      key,
      isStart,
      isEnd
    } = treeNode;
    const mergedKey = getKey4(key, pos);
    delete restProps.key;
    delete restProps.children;
    const treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return React577.createElement(MotionTreeNode_default, _extends92({}, restProps, treeNodeProps, {
      title,
      active: !!activeItem && key === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion: motion2,
      motionNodes: key === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: () => {
        onActiveChange(null);
      }
    }));
  }));
});
if (true) {
  NodeList.displayName = "NodeList";
}
var NodeList_default = NodeList;

// node_modules/@rc-component/tree/es/Tree.js
function _extends93() {
  _extends93 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends93.apply(this, arguments);
}
var MAX_RETRY_TIMES = 10;
var Tree = class extends React578.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "destroyed", false);
    __publicField(this, "delayedDragEnterLogic");
    __publicField(this, "loadingRetryTimes", {});
    __publicField(this, "state", {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
      dropContainerKey: null,
      // the container key of abstract-drop-node if dropPosition is -1 or 1
      dropLevelOffset: null,
      // the drop level offset of abstract-drag-over-node
      dropTargetPos: null,
      // the pos of abstract-drop-node
      dropAllowed: true,
      // if drop to abstract-drop-node is allowed
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames3()
    });
    __publicField(this, "dragStartMousePosition", null);
    __publicField(this, "dragNodeProps", null);
    __publicField(this, "currentMouseOverDroppableNodeKey", null);
    __publicField(this, "listRef", React578.createRef());
    __publicField(this, "onNodeDragStart", (event, nodeProps) => {
      const {
        expandedKeys,
        keyEntities
      } = this.state;
      const {
        onDragStart
      } = this.props;
      const {
        eventKey
      } = nodeProps;
      this.dragNodeProps = nodeProps;
      this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      const newExpandedKeys = arrDel(expandedKeys, eventKey);
      this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: this.listRef.current.getIndentWidth()
      });
      this.setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", this.onWindowDragEnd);
      onDragStart == null ? void 0 : onDragStart({
        event,
        node: convertNodePropsToEventData(nodeProps)
      });
    });
    /**
     * [Legacy] Select handler is smaller than node,
     * so that this will trigger when drag enter node or select handler.
     * This is a little tricky if customize css without padding.
     * Better for use mouse move event to refresh drag state.
     * But let's just keep it to avoid event trigger logic change.
     */
    __publicField(this, "onNodeDragEnter", (event, nodeProps) => {
      const {
        expandedKeys,
        keyEntities,
        dragChildrenKeys,
        flattenNodes,
        indent
      } = this.state;
      const {
        onDragEnter,
        onExpand,
        allowDrop,
        direction
      } = this.props;
      const {
        pos,
        eventKey
      } = nodeProps;
      if (this.currentMouseOverDroppableNodeKey !== eventKey) {
        this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!this.dragNodeProps) {
        this.resetDragState();
        return;
      }
      const {
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed,
        dragOverNodeKey
      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
      if (
        // don't allow drop inside its children
        dragChildrenKeys.includes(dropTargetKey) || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !dropAllowed
      ) {
        this.resetDragState();
        return;
      }
      if (!this.delayedDragEnterLogic) {
        this.delayedDragEnterLogic = {};
      }
      Object.keys(this.delayedDragEnterLogic).forEach((key) => {
        clearTimeout(this.delayedDragEnterLogic[key]);
      });
      if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {
        event.persist();
        this.delayedDragEnterLogic[pos] = window.setTimeout(() => {
          if (this.state.draggingNodeKey === null) {
            return;
          }
          let newExpandedKeys = [...expandedKeys];
          const entity = getEntity(keyEntities, nodeProps.eventKey);
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);
          }
          if (!this.props.hasOwnProperty("expandedKeys")) {
            this.setExpandedKeys(newExpandedKeys);
          }
          onExpand == null ? void 0 : onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(nodeProps),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
        this.resetDragState();
        return;
      }
      this.setState({
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      onDragEnter == null ? void 0 : onDragEnter({
        event,
        node: convertNodePropsToEventData(nodeProps),
        expandedKeys
      });
    });
    __publicField(this, "onNodeDragOver", (event, nodeProps) => {
      const {
        dragChildrenKeys,
        flattenNodes,
        keyEntities,
        expandedKeys,
        indent
      } = this.state;
      const {
        onDragOver,
        allowDrop,
        direction
      } = this.props;
      if (!this.dragNodeProps) {
        return;
      }
      const {
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed,
        dragOverNodeKey
      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);
      if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {
        return;
      }
      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {
          this.resetDragState();
        }
      } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {
        this.setState({
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      onDragOver == null ? void 0 : onDragOver({
        event,
        node: convertNodePropsToEventData(nodeProps)
      });
    });
    __publicField(this, "onNodeDragLeave", (event, nodeProps) => {
      if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        this.resetDragState();
        this.currentMouseOverDroppableNodeKey = null;
      }
      const {
        onDragLeave
      } = this.props;
      onDragLeave == null ? void 0 : onDragLeave({
        event,
        node: convertNodePropsToEventData(nodeProps)
      });
    });
    // since stopPropagation() is called in treeNode
    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared
    __publicField(this, "onWindowDragEnd", (event) => {
      this.onNodeDragEnd(event, null, true);
      window.removeEventListener("dragend", this.onWindowDragEnd);
    });
    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called
    __publicField(this, "onNodeDragEnd", (event, nodeProps) => {
      const {
        onDragEnd
      } = this.props;
      this.setState({
        dragOverNodeKey: null
      });
      this.cleanDragState();
      onDragEnd == null ? void 0 : onDragEnd({
        event,
        node: convertNodePropsToEventData(nodeProps)
      });
      this.dragNodeProps = null;
      window.removeEventListener("dragend", this.onWindowDragEnd);
    });
    __publicField(this, "onNodeDrop", (event, _, outsideTree = false) => {
      var _a;
      const {
        dragChildrenKeys,
        dropPosition,
        dropTargetKey,
        dropTargetPos,
        dropAllowed
      } = this.state;
      if (!dropAllowed) {
        return;
      }
      const {
        onDrop
      } = this.props;
      this.setState({
        dragOverNodeKey: null
      });
      this.cleanDragState();
      if (dropTargetKey === null)
        return;
      const abstractDropNodeProps = {
        ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),
        active: ((_a = this.getActiveItem()) == null ? void 0 : _a.key) === dropTargetKey,
        data: getEntity(this.state.keyEntities, dropTargetKey).node
      };
      const dropToChild = dragChildrenKeys.includes(dropTargetKey);
      warning_default(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      const posArr = posToArr(dropTargetPos);
      const dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,
        dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop == null ? void 0 : onDrop(dropResult);
      }
      this.dragNodeProps = null;
    });
    __publicField(this, "cleanDragState", () => {
      const {
        draggingNodeKey
      } = this.state;
      if (draggingNodeKey !== null) {
        this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      this.dragStartMousePosition = null;
      this.currentMouseOverDroppableNodeKey = null;
    });
    __publicField(this, "triggerExpandActionExpand", (e3, treeNode) => {
      const {
        expandedKeys,
        flattenNodes
      } = this.state;
      const {
        expanded,
        key,
        isLeaf: isLeaf2
      } = treeNode;
      if (isLeaf2 || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
        return;
      }
      const node2 = flattenNodes.filter((nodeItem) => nodeItem.key === key)[0];
      const eventNode = convertNodePropsToEventData({
        ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),
        data: node2.data
      });
      this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
      this.onNodeExpand(e3, eventNode);
    });
    __publicField(this, "onNodeClick", (e3, treeNode) => {
      const {
        onClick,
        expandAction
      } = this.props;
      if (expandAction === "click") {
        this.triggerExpandActionExpand(e3, treeNode);
      }
      onClick == null ? void 0 : onClick(e3, treeNode);
    });
    __publicField(this, "onNodeDoubleClick", (e3, treeNode) => {
      const {
        onDoubleClick,
        expandAction
      } = this.props;
      if (expandAction === "doubleClick") {
        this.triggerExpandActionExpand(e3, treeNode);
      }
      onDoubleClick == null ? void 0 : onDoubleClick(e3, treeNode);
    });
    __publicField(this, "onNodeSelect", (e3, treeNode) => {
      let {
        selectedKeys
      } = this.state;
      const {
        keyEntities,
        fieldNames
      } = this.state;
      const {
        onSelect,
        multiple
      } = this.props;
      const {
        selected
      } = treeNode;
      const key = treeNode[fieldNames.key];
      const targetSelected = !selected;
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key);
      } else if (!multiple) {
        selectedKeys = [key];
      } else {
        selectedKeys = arrAdd(selectedKeys, key);
      }
      const selectedNodes = selectedKeys.map((selectedKey) => {
        const entity = getEntity(keyEntities, selectedKey);
        return entity ? entity.node : null;
      }).filter(Boolean);
      this.setUncontrolledState({
        selectedKeys
      });
      onSelect == null ? void 0 : onSelect(selectedKeys, {
        event: "select",
        selected: targetSelected,
        node: treeNode,
        selectedNodes,
        nativeEvent: e3.nativeEvent
      });
    });
    __publicField(this, "onNodeCheck", (e3, treeNode, checked) => {
      const {
        keyEntities,
        checkedKeys: oriCheckedKeys,
        halfCheckedKeys: oriHalfCheckedKeys
      } = this.state;
      const {
        checkStrictly,
        onCheck
      } = this.props;
      const {
        key
      } = treeNode;
      let checkedObj;
      const eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e3.nativeEvent
      };
      if (checkStrictly) {
        const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
        const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map((checkedKey) => getEntity(keyEntities, checkedKey)).filter(Boolean).map((entity) => entity.node);
        this.setUncontrolledState({
          checkedKeys
        });
      } else {
        let {
          checkedKeys,
          halfCheckedKeys
        } = conductCheck([...oriCheckedKeys, key], true, keyEntities);
        if (!checked) {
          const keySet = new Set(checkedKeys);
          keySet.delete(key);
          ({
            checkedKeys,
            halfCheckedKeys
          } = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys
          }, keyEntities));
        }
        checkedObj = checkedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = halfCheckedKeys;
        checkedKeys.forEach((checkedKey) => {
          const entity = getEntity(keyEntities, checkedKey);
          if (!entity)
            return;
          const {
            node: node2,
            pos
          } = entity;
          eventObj.checkedNodes.push(node2);
          eventObj.checkedNodesPositions.push({
            node: node2,
            pos
          });
        });
        this.setUncontrolledState({
          checkedKeys
        }, false, {
          halfCheckedKeys
        });
      }
      onCheck == null ? void 0 : onCheck(checkedObj, eventObj);
    });
    __publicField(this, "onNodeLoad", (treeNode) => {
      var _a;
      const {
        key
      } = treeNode;
      const {
        keyEntities
      } = this.state;
      const entity = getEntity(keyEntities, key);
      if ((_a = entity == null ? void 0 : entity.children) == null ? void 0 : _a.length) {
        return;
      }
      const loadPromise = new Promise((resolve, reject) => {
        this.setState(({
          loadedKeys = [],
          loadingKeys = []
        }) => {
          const {
            loadData,
            onLoad
          } = this.props;
          if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {
            return null;
          }
          const promise = loadData(treeNode);
          promise.then(() => {
            const {
              loadedKeys: currentLoadedKeys
            } = this.state;
            const newLoadedKeys = arrAdd(currentLoadedKeys, key);
            onLoad == null ? void 0 : onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
            this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            this.setState((prevState) => ({
              loadingKeys: arrDel(prevState.loadingKeys, key)
            }));
            resolve();
          }).catch((e3) => {
            this.setState((prevState) => ({
              loadingKeys: arrDel(prevState.loadingKeys, key)
            }));
            this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;
            if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
              const {
                loadedKeys: currentLoadedKeys
              } = this.state;
              warning_default(false, "Retry for `loadData` many times but still failed. No more retry.");
              this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key)
              });
              resolve();
            }
            reject(e3);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key)
          };
        });
      });
      loadPromise.catch(() => {
      });
      return loadPromise;
    });
    __publicField(this, "onNodeMouseEnter", (event, node2) => {
      const {
        onMouseEnter
      } = this.props;
      onMouseEnter == null ? void 0 : onMouseEnter({
        event,
        node: node2
      });
    });
    __publicField(this, "onNodeMouseLeave", (event, node2) => {
      const {
        onMouseLeave
      } = this.props;
      onMouseLeave == null ? void 0 : onMouseLeave({
        event,
        node: node2
      });
    });
    __publicField(this, "onNodeContextMenu", (event, node2) => {
      const {
        onRightClick
      } = this.props;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node: node2
        });
      }
    });
    __publicField(this, "onFocus", (...args) => {
      const {
        onFocus
      } = this.props;
      this.setState({
        focused: true
      });
      onFocus == null ? void 0 : onFocus(...args);
    });
    __publicField(this, "onBlur", (...args) => {
      const {
        onBlur
      } = this.props;
      this.setState({
        focused: false
      });
      this.onActiveChange(null);
      onBlur == null ? void 0 : onBlur(...args);
    });
    __publicField(this, "getTreeNodeRequiredProps", () => {
      const {
        expandedKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys,
        checkedKeys,
        halfCheckedKeys,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      } = this.state;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
    });
    // =========================== Expanded ===========================
    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */
    __publicField(this, "setExpandedKeys", (expandedKeys) => {
      const {
        treeData,
        fieldNames
      } = this.state;
      const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      this.setUncontrolledState({
        expandedKeys,
        flattenNodes
      }, true);
    });
    __publicField(this, "onNodeExpand", (e3, treeNode) => {
      let {
        expandedKeys
      } = this.state;
      const {
        listChanging,
        fieldNames
      } = this.state;
      const {
        onExpand,
        loadData
      } = this.props;
      const {
        expanded
      } = treeNode;
      const key = treeNode[fieldNames.key];
      if (listChanging) {
        return;
      }
      const certain = expandedKeys.includes(key);
      const targetExpanded = !expanded;
      warning_default(expanded && certain || !expanded && !certain, "Expand state not sync with index check");
      expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);
      this.setExpandedKeys(expandedKeys);
      onExpand == null ? void 0 : onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e3.nativeEvent
      });
      if (targetExpanded && loadData) {
        const loadPromise = this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(() => {
            const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);
            this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(() => {
            const {
              expandedKeys: currentExpandedKeys
            } = this.state;
            const expandedKeysToRestore = arrDel(currentExpandedKeys, key);
            this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    });
    __publicField(this, "onListChangeStart", () => {
      this.setUncontrolledState({
        listChanging: true
      });
    });
    __publicField(this, "onListChangeEnd", () => {
      setTimeout(() => {
        this.setUncontrolledState({
          listChanging: false
        });
      });
    });
    // =========================== Keyboard ===========================
    __publicField(this, "onActiveChange", (newActiveKey) => {
      const {
        activeKey
      } = this.state;
      const {
        onActiveChange,
        itemScrollOffset = 0
      } = this.props;
      if (activeKey === newActiveKey) {
        return;
      }
      this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        this.scrollTo({
          key: newActiveKey,
          offset: itemScrollOffset
        });
      }
      onActiveChange == null ? void 0 : onActiveChange(newActiveKey);
    });
    __publicField(this, "getActiveItem", () => {
      const {
        activeKey,
        flattenNodes
      } = this.state;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(({
        key
      }) => key === activeKey) || null;
    });
    __publicField(this, "offsetActiveKey", (offset3) => {
      const {
        flattenNodes,
        activeKey
      } = this.state;
      let index2 = flattenNodes.findIndex(({
        key
      }) => key === activeKey);
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.length;
      }
      index2 = (index2 + offset3 + flattenNodes.length) % flattenNodes.length;
      const item = flattenNodes[index2];
      if (item) {
        const {
          key
        } = item;
        this.onActiveChange(key);
      } else {
        this.onActiveChange(null);
      }
    });
    __publicField(this, "onKeyDown", (event) => {
      const {
        activeKey,
        expandedKeys,
        checkedKeys,
        fieldNames
      } = this.state;
      const {
        onKeyDown: onKeyDown2,
        checkable,
        selectable
      } = this.props;
      switch (event.which) {
        case KeyCode_default.UP: {
          this.offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode_default.DOWN: {
          this.offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      const activeItem = this.getActiveItem();
      if (activeItem && activeItem.data) {
        const treeNodeRequiredProps = this.getTreeNodeRequiredProps();
        const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        const eventNode = convertNodePropsToEventData({
          ...getTreeNodeProps(activeKey, treeNodeRequiredProps),
          data: activeItem.data,
          active: true
        });
        switch (event.which) {
          case KeyCode_default.LEFT: {
            if (expandable && expandedKeys.includes(activeKey)) {
              this.onNodeExpand({}, eventNode);
            } else if (activeItem.parent) {
              this.onActiveChange(activeItem.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode_default.RIGHT: {
            if (expandable && !expandedKeys.includes(activeKey)) {
              this.onNodeExpand({}, eventNode);
            } else if (activeItem.children && activeItem.children.length) {
              this.onActiveChange(activeItem.children[0].key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode_default.ENTER:
          case KeyCode_default.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              this.onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      onKeyDown2 == null ? void 0 : onKeyDown2(event);
    });
    /**
     * Only update the value which is not in props
     */
    __publicField(this, "setUncontrolledState", (state, atomic = false, forceState = null) => {
      if (!this.destroyed) {
        let needSync = false;
        let allPassed = true;
        const newState = {};
        Object.keys(state).forEach((name) => {
          if (this.props.hasOwnProperty(name)) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name] = state[name];
        });
        if (needSync && (!atomic || allPassed)) {
          this.setState({
            ...newState,
            ...forceState
          });
        }
      }
    });
    __publicField(this, "scrollTo", (scroll) => {
      this.listRef.current.scrollTo(scroll);
    });
  }
  componentDidMount() {
    this.destroyed = false;
    this.onUpdated();
  }
  componentDidUpdate() {
    this.onUpdated();
  }
  onUpdated() {
    const {
      activeKey,
      itemScrollOffset = 0
    } = this.props;
    if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
      this.setState({
        activeKey
      });
      if (activeKey !== null) {
        this.scrollTo({
          key: activeKey,
          offset: itemScrollOffset
        });
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("dragend", this.onWindowDragEnd);
    this.destroyed = true;
  }
  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps
    } = prevState;
    const newState = {
      prevProps: props
    };
    function needSync(name) {
      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
    }
    let treeData;
    let {
      fieldNames
    } = prevState;
    if (needSync("fieldNames")) {
      fieldNames = fillFieldNames3(props.fieldNames);
      newState.fieldNames = fieldNames;
    }
    if (needSync("treeData")) {
      ({
        treeData
      } = props);
    } else if (needSync("children")) {
      warning_default(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
      treeData = convertTreeToData(props.children);
    }
    if (treeData) {
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData, {
        fieldNames
      });
      newState.keyEntities = {
        [MOTION_KEY]: MotionEntity,
        ...entitiesMap.keyEntities
      };
      if (true) {
        warningWithoutKey(treeData, fieldNames);
      }
    }
    const keyEntities = newState.keyEntities || prevState.keyEntities;
    if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
    } else if (!prevProps && props.defaultExpandAll) {
      const cloneKeyEntities = {
        ...keyEntities
      };
      delete cloneKeyEntities[MOTION_KEY];
      const nextExpandedKeys = [];
      Object.keys(cloneKeyEntities).forEach((key) => {
        const entity = cloneKeyEntities[key];
        if (entity.children && entity.children.length) {
          nextExpandedKeys.push(entity.key);
        }
      });
      newState.expandedKeys = nextExpandedKeys;
    } else if (!prevProps && props.defaultExpandedKeys) {
      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
    }
    if (!newState.expandedKeys) {
      delete newState.expandedKeys;
    }
    if (treeData || newState.expandedKeys) {
      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
      newState.flattenNodes = flattenNodes;
    }
    if (props.selectable) {
      if (needSync("selectedKeys")) {
        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
      } else if (!prevProps && props.defaultSelectedKeys) {
        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
      }
    }
    if (props.checkable) {
      let checkedKeyEntity;
      if (needSync("checkedKeys")) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
      } else if (!prevProps && props.defaultCheckedKeys) {
        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
      } else if (treeData) {
        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
          checkedKeys: prevState.checkedKeys,
          halfCheckedKeys: prevState.halfCheckedKeys
        };
      }
      if (checkedKeyEntity) {
        let {
          checkedKeys = [],
          halfCheckedKeys = []
        } = checkedKeyEntity;
        if (!props.checkStrictly) {
          const conductKeys = conductCheck(checkedKeys, true, keyEntities);
          ({
            checkedKeys,
            halfCheckedKeys
          } = conductKeys);
        }
        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
      }
    }
    if (needSync("loadedKeys")) {
      newState.loadedKeys = props.loadedKeys;
    }
    return newState;
  }
  resetDragState() {
    this.setState({
      dragOverNodeKey: null,
      dropPosition: null,
      dropLevelOffset: null,
      dropTargetKey: null,
      dropContainerKey: null,
      dropTargetPos: null,
      dropAllowed: false
    });
  }
  render() {
    const {
      focused,
      flattenNodes,
      keyEntities,
      draggingNodeKey,
      activeKey,
      dropLevelOffset,
      dropContainerKey,
      dropTargetKey,
      dropPosition,
      dragOverNodeKey,
      indent
    } = this.state;
    const {
      prefixCls,
      className,
      style: style2,
      styles,
      classNames: treeClassNames,
      showLine,
      focusable: focusable2,
      tabIndex = 0,
      selectable,
      showIcon,
      icon,
      switcherIcon,
      draggable,
      checkable,
      checkStrictly,
      disabled,
      motion: motion2,
      loadData,
      filterTreeNode,
      height,
      itemHeight,
      scrollWidth,
      virtual,
      titleRender,
      dropIndicatorRender: dropIndicatorRender2,
      onContextMenu,
      onScroll,
      direction,
      rootClassName,
      rootStyle
    } = this.props;
    const domProps = pickAttrs(this.props, {
      aria: true,
      data: true
    });
    let draggableConfig;
    if (draggable) {
      if (typeof draggable === "object") {
        draggableConfig = draggable;
      } else if (typeof draggable === "function") {
        draggableConfig = {
          nodeDraggable: draggable
        };
      } else {
        draggableConfig = {};
      }
    }
    const contextValue = {
      styles,
      classNames: treeClassNames,
      prefixCls,
      selectable,
      showIcon,
      icon,
      switcherIcon,
      draggable: draggableConfig,
      draggingNodeKey,
      checkable,
      checkStrictly,
      disabled,
      keyEntities,
      dropLevelOffset,
      dropContainerKey,
      dropTargetKey,
      dropPosition,
      dragOverNodeKey,
      indent,
      direction,
      dropIndicatorRender: dropIndicatorRender2,
      loadData,
      filterTreeNode,
      titleRender,
      onNodeClick: this.onNodeClick,
      onNodeDoubleClick: this.onNodeDoubleClick,
      onNodeExpand: this.onNodeExpand,
      onNodeSelect: this.onNodeSelect,
      onNodeCheck: this.onNodeCheck,
      onNodeLoad: this.onNodeLoad,
      onNodeMouseEnter: this.onNodeMouseEnter,
      onNodeMouseLeave: this.onNodeMouseLeave,
      onNodeContextMenu: this.onNodeContextMenu,
      onNodeDragStart: this.onNodeDragStart,
      onNodeDragEnter: this.onNodeDragEnter,
      onNodeDragOver: this.onNodeDragOver,
      onNodeDragLeave: this.onNodeDragLeave,
      onNodeDragEnd: this.onNodeDragEnd,
      onNodeDrop: this.onNodeDrop
    };
    return React578.createElement(TreeContext.Provider, {
      value: contextValue
    }, React578.createElement("div", {
      className: clsx(prefixCls, className, rootClassName, {
        [`${prefixCls}-show-line`]: showLine,
        [`${prefixCls}-focused`]: focused,
        [`${prefixCls}-active-focused`]: activeKey !== null
      }),
      style: rootStyle
    }, React578.createElement(NodeList_default, _extends93({
      ref: this.listRef,
      prefixCls,
      style: style2,
      data: flattenNodes,
      disabled,
      selectable,
      checkable: !!checkable,
      motion: motion2,
      dragging: draggingNodeKey !== null,
      height,
      itemHeight,
      virtual,
      focusable: focusable2,
      focused,
      tabIndex,
      activeItem: this.getActiveItem(),
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onKeyDown: this.onKeyDown,
      onActiveChange: this.onActiveChange,
      onListChangeStart: this.onListChangeStart,
      onListChangeEnd: this.onListChangeEnd,
      onContextMenu,
      onScroll,
      scrollWidth
    }, this.getTreeNodeRequiredProps(), domProps))));
  }
};
__publicField(Tree, "defaultProps", {
  prefixCls: "rc-tree",
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator_default,
  allowDrop: () => true,
  expandAction: false
});
__publicField(Tree, "TreeNode", TreeNode_default);
var Tree_default = Tree;

// node_modules/@rc-component/tree/es/index.js
var es_default33 = Tree_default;

// node_modules/antd/es/tree/DirectoryTree.js
var React582 = __toESM(require_react());

// node_modules/antd/es/tree/Tree.js
var import_react215 = __toESM(require_react());

// node_modules/antd/es/tree/style/directory.js
var genDirectoryStyle = ({
  treeCls,
  treeNodeCls,
  directoryNodeSelectedBg,
  directoryNodeSelectedColor,
  motionDurationMid,
  borderRadius,
  controlItemBgHover
}) => ({
  [`${treeCls}${treeCls}-directory ${treeNodeCls}`]: {
    // >>> Title
    [`${treeCls}-node-content-wrapper`]: {
      position: "static",
      [`&:has(${treeCls}-drop-indicator)`]: {
        position: "relative"
      },
      [`> *:not(${treeCls}-drop-indicator)`]: {
        position: "relative"
      },
      "&:hover": {
        background: "transparent"
      },
      // Expand interactive area to whole line
      "&:before": {
        position: "absolute",
        inset: 0,
        transition: `background-color ${motionDurationMid}`,
        content: '""',
        borderRadius
      },
      "&:hover:before": {
        background: controlItemBgHover
      }
    },
    [`${treeCls}-switcher, ${treeCls}-checkbox, ${treeCls}-draggable-icon`]: {
      zIndex: 1
    },
    // ============= Selected =============
    "&-selected": {
      background: directoryNodeSelectedBg,
      borderRadius,
      [`${treeCls}-switcher, ${treeCls}-draggable-icon`]: {
        color: directoryNodeSelectedColor
      },
      // >>> Title
      [`${treeCls}-node-content-wrapper`]: {
        color: directoryNodeSelectedColor,
        background: "transparent",
        "&, &:hover": {
          color: directoryNodeSelectedColor
        },
        "&:before, &:hover:before": {
          background: directoryNodeSelectedBg
        }
      }
    }
  }
});

// node_modules/antd/es/tree/style/index.js
var treeNodeFX = new Keyframes_default("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
var getSwitchStyle = (prefixCls, token2) => ({
  [`.${prefixCls}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${token2.motionDurationSlow}`
    }
  }
});
var getDropIndicatorStyle = (prefixCls, token2) => ({
  [`.${prefixCls}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token2.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${unit(token2.lineWidthBold)} solid ${token2.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
});
var genBaseStyle15 = (prefixCls, token2) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    titleHeight,
    indentSize,
    nodeSelectedBg,
    nodeHoverBg,
    colorTextQuaternary,
    controlItemBgActiveDisabled
  } = token2;
  return {
    [treeCls]: {
      ...resetComponent(token2),
      // fix https://github.com/ant-design/ant-design/issues/50316
      ["--rc-virtual-list-scrollbar-bg"]: token2.colorSplit,
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadius,
      transition: `background-color ${token2.motionDurationSlow}`,
      "&-rtl": {
        direction: "rtl"
      },
      [`&${treeCls}-rtl ${treeCls}-switcher_close ${treeCls}-switcher-icon svg`]: {
        transform: "rotate(90deg)"
      },
      [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: genFocusOutline(token2),
      // =================== Virtual List ===================
      [`${treeCls}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${treeCls}-block-node`]: {
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${treeNodeCls}.dragging:after`]: {
            position: "absolute",
            inset: 0,
            border: `1px solid ${token2.colorPrimary}`,
            opacity: 0,
            animationName: treeNodeFX,
            animationDuration: token2.motionDurationSlow,
            animationPlayState: "running",
            animationFillMode: "forwards",
            content: '""',
            pointerEvents: "none",
            borderRadius: token2.borderRadius
          }
        }
      },
      // ===================== TreeNode =====================
      [treeNodeCls]: {
        display: "flex",
        alignItems: "flex-start",
        marginBottom: treeNodePadding,
        lineHeight: unit(titleHeight),
        position: "relative",
        //  drop-indicator 
        "&:before": {
          content: '""',
          position: "absolute",
          zIndex: 1,
          insetInlineStart: 0,
          width: "100%",
          top: "100%",
          height: treeNodePadding
        },
        // Disabled
        [`&-disabled ${treeCls}-node-content-wrapper`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover": {
            background: "transparent"
          }
        },
        [`${treeCls}-checkbox-disabled + ${treeCls}-node-selected,&${treeNodeCls}-disabled${treeNodeCls}-selected ${treeCls}-node-content-wrapper`]: {
          backgroundColor: controlItemBgActiveDisabled
        },
        // we can not set pointer-events to none for checkbox in tree
        // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-2605234058
        [`${treeCls}-checkbox-disabled`]: {
          pointerEvents: "unset"
        },
        // not disable
        [`&:not(${treeNodeCls}-disabled)`]: {
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            "&:hover": {
              color: token2.nodeHoverColor
            }
          }
        },
        [`&-active ${treeCls}-node-content-wrapper`]: {
          background: token2.controlItemBgHover
        },
        [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
          color: token2.colorPrimary,
          fontWeight: token2.fontWeightStrong
        },
        "&-draggable": {
          cursor: "grab",
          [`${treeCls}-draggable-icon`]: {
            // https://github.com/ant-design/ant-design/issues/41915
            flexShrink: 0,
            width: titleHeight,
            textAlign: "center",
            visibility: "visible",
            color: colorTextQuaternary
          },
          [`&${treeNodeCls}-disabled ${treeCls}-draggable-icon`]: {
            visibility: "hidden"
          }
        }
      },
      // >>> Indent
      [`${treeCls}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: indentSize
        }
      },
      // >>> Drag Handler
      [`${treeCls}-draggable-icon`]: {
        visibility: "hidden"
      },
      // Switcher / Checkbox
      [`${treeCls}-switcher, ${treeCls}-checkbox`]: {
        marginInlineEnd: token2.calc(token2.calc(titleHeight).sub(token2.controlInteractiveSize)).div(2).equal()
      },
      // >>> Switcher
      [`${treeCls}-switcher`]: {
        ...getSwitchStyle(prefixCls, token2),
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: titleHeight,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        transition: `all ${token2.motionDurationSlow}`,
        "&-noop": {
          cursor: "unset"
        },
        "&:before": {
          pointerEvents: "none",
          content: '""',
          width: titleHeight,
          height: titleHeight,
          position: "absolute",
          left: {
            _skip_check_: true,
            value: 0
          },
          top: 0,
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`
        },
        [`&:not(${treeCls}-switcher-noop):hover:before`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&_close ${treeCls}-switcher-icon svg`]: {
          transform: "rotate(-90deg)"
        },
        "&-loading-icon": {
          color: token2.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
            bottom: token2.calc(treeNodePadding).mul(-1).equal(),
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: token2.calc(token2.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
            height: token2.calc(titleHeight).div(2).equal(),
            borderBottom: `1px solid ${token2.colorBorder}`,
            content: '""'
          }
        }
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${treeCls}-node-content-wrapper`]: {
        position: "relative",
        minHeight: titleHeight,
        paddingBlock: 0,
        paddingInline: token2.paddingXS,
        background: "transparent",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        ...getDropIndicatorStyle(prefixCls, token2),
        "&:hover": {
          backgroundColor: nodeHoverBg
        },
        [`&${treeCls}-node-selected`]: {
          color: token2.nodeSelectedColor,
          backgroundColor: nodeSelectedBg
        },
        // Icon
        [`${treeCls}-iconEle`]: {
          display: "inline-block",
          width: titleHeight,
          height: titleHeight,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      [`${treeNodeCls}.drop-container > [draggable]`]: {
        boxShadow: `0 0 0 2px ${token2.colorPrimary}`
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${treeCls}-indent-unit`]: {
          position: "relative",
          height: "100%",
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
            bottom: token2.calc(treeNodePadding).mul(-1).equal(),
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&-end:before": {
            display: "none"
          }
        },
        // ============== Cover Background ==============
        [`${treeCls}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${treeNodeCls}-leaf-last ${treeCls}-switcher-leaf-line:before`]: {
        top: "auto !important",
        bottom: "auto !important",
        height: `${unit(token2.calc(titleHeight).div(2).equal())} !important`
      }
    }
  };
};
var genTreeStyle = (prefixCls, token2, enableDirectory = true) => {
  const treeCls = `.${prefixCls}`;
  const treeNodeCls = `${treeCls}-treenode`;
  const treeNodePadding = token2.calc(token2.paddingXS).div(2).equal();
  const treeToken = merge2(token2, {
    treeCls,
    treeNodeCls,
    treeNodePadding
  });
  return [
    // Basic
    genBaseStyle15(prefixCls, treeToken),
    // Directory
    enableDirectory && genDirectoryStyle(treeToken)
  ].filter(Boolean);
};
var initComponentToken2 = (token2) => {
  const {
    controlHeightSM,
    controlItemBgHover,
    controlItemBgActive
  } = token2;
  const titleHeight = controlHeightSM;
  return {
    titleHeight,
    indentSize: titleHeight,
    nodeHoverBg: controlItemBgHover,
    nodeHoverColor: token2.colorText,
    nodeSelectedBg: controlItemBgActive,
    nodeSelectedColor: token2.colorText
  };
};
var prepareComponentToken51 = (token2) => {
  const {
    colorTextLightSolid,
    colorPrimary
  } = token2;
  return {
    ...initComponentToken2(token2),
    directoryNodeSelectedColor: colorTextLightSolid,
    directoryNodeSelectedBg: colorPrimary
  };
};
var style_default58 = genStyleHooks("Tree", (token2, {
  prefixCls
}) => [{
  [token2.componentCls]: getStyle(`${prefixCls}-checkbox`, token2)
}, genTreeStyle(prefixCls, token2), collapse_default(token2)], prepareComponentToken51);

// node_modules/antd/es/tree/utils/dropIndicator.js
var import_react214 = __toESM(require_react());
var offset2 = 4;
function dropIndicatorRender(props) {
  const {
    dropPosition,
    dropLevelOffset,
    prefixCls,
    indent,
    direction = "ltr"
  } = props;
  const startPosition = direction === "ltr" ? "left" : "right";
  const endPosition = direction === "ltr" ? "right" : "left";
  const style2 = {
    [startPosition]: -dropLevelOffset * indent + offset2,
    [endPosition]: 0
  };
  switch (dropPosition) {
    case -1:
      style2.top = -3;
      break;
    case 1:
      style2.bottom = -3;
      break;
    default:
      style2.bottom = -3;
      style2[startPosition] = indent + offset2;
      break;
  }
  return import_react214.default.createElement("div", {
    style: style2,
    className: `${prefixCls}-drop-indicator`
  });
}
var dropIndicator_default = dropIndicatorRender;

// node_modules/antd/es/tree/utils/iconUtil.js
var React580 = __toESM(require_react());
var SwitcherIconCom = (props) => {
  var _a, _b;
  const {
    prefixCls,
    switcherIcon,
    treeNodeProps,
    showLine,
    switcherLoadingIcon
  } = props;
  const {
    isLeaf: isLeaf2,
    expanded,
    loading
  } = treeNodeProps;
  if (loading) {
    if (React580.isValidElement(switcherLoadingIcon)) {
      return switcherLoadingIcon;
    }
    return React580.createElement(LoadingOutlined_default, {
      className: `${prefixCls}-switcher-loading-icon`
    });
  }
  let showLeafIcon;
  if (showLine && typeof showLine === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf2) {
    if (!showLine) {
      return null;
    }
    if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
      const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
      const leafCls = `${prefixCls}-switcher-line-custom-icon`;
      if (React580.isValidElement(leafIcon)) {
        return cloneElement3(leafIcon, {
          className: clsx((_a = leafIcon.props) == null ? void 0 : _a.className, leafCls)
        });
      }
      return leafIcon;
    }
    return showLeafIcon ? React580.createElement(FileOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    }) : React580.createElement("span", {
      className: `${prefixCls}-switcher-leaf-line`
    });
  }
  const switcherCls = `${prefixCls}-switcher-icon`;
  const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  if (React580.isValidElement(switcher)) {
    return cloneElement3(switcher, {
      className: clsx((_b = switcher.props) == null ? void 0 : _b.className, switcherCls)
    });
  }
  if (switcher !== void 0) {
    return switcher;
  }
  if (showLine) {
    return expanded ? React580.createElement(MinusSquareOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    }) : React580.createElement(PlusSquareOutlined_default, {
      className: `${prefixCls}-switcher-line-icon`
    });
  }
  return React580.createElement(CaretDownFilled_default, {
    className: switcherCls
  });
};
var iconUtil_default = SwitcherIconCom;

// node_modules/antd/es/tree/Tree.js
var Tree2 = import_react215.default.forwardRef((props, ref) => {
  var _a;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tree");
  const {
    virtual
  } = import_react215.default.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = false,
    showLine,
    switcherIcon,
    switcherLoadingIcon,
    blockNode = false,
    children,
    checkable = false,
    selectable = true,
    draggable,
    disabled,
    motion: customMotion,
    style: style2,
    rootClassName,
    classNames,
    styles
  } = props;
  const contextDisabled = import_react215.default.useContext(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const motion2 = customMotion ?? {
    ...motion_default(rootPrefixCls),
    motionAppear: false
  };
  const mergedProps = {
    ...props,
    showIcon,
    blockNode,
    checkable,
    selectable,
    disabled: mergedDisabled,
    motion: motion2
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const newProps = {
    ...props,
    checkable,
    selectable,
    showIcon,
    motion: motion2,
    blockNode,
    disabled: mergedDisabled,
    showLine: Boolean(showLine),
    dropIndicatorRender: dropIndicator_default
  };
  const [hashId, cssVarCls] = style_default58(prefixCls);
  const [, token2] = useToken();
  const itemHeight = token2.paddingXS / 2 + (((_a = token2.Tree) == null ? void 0 : _a.titleHeight) || token2.controlHeightSM);
  const draggableConfig = import_react215.default.useMemo(() => {
    if (!draggable) {
      return false;
    }
    let mergedDraggable = {};
    switch (typeof draggable) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = {
          ...draggable
        };
        break;
      default:
        break;
    }
    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon || import_react215.default.createElement(HolderOutlined_default, null);
    }
    return mergedDraggable;
  }, [draggable]);
  const renderSwitcherIcon = (nodeProps) => import_react215.default.createElement(iconUtil_default, {
    prefixCls,
    switcherIcon,
    switcherLoadingIcon,
    treeNodeProps: nodeProps,
    showLine
  });
  return (
    // @ts-ignore
    import_react215.default.createElement(es_default33, {
      itemHeight,
      ref,
      virtual,
      ...newProps,
      // newProps may contain style so declare style below it
      prefixCls,
      className: clsx({
        [`${prefixCls}-icon-hide`]: !showIcon,
        [`${prefixCls}-block-node`]: blockNode,
        [`${prefixCls}-unselectable`]: !selectable,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-disabled`]: mergedDisabled
      }, contextClassName, className, hashId, cssVarCls),
      style: {
        ...contextStyle,
        ...style2
      },
      rootClassName: clsx(mergedClassNames == null ? void 0 : mergedClassNames.root, rootClassName),
      rootStyle: mergedStyles == null ? void 0 : mergedStyles.root,
      classNames: mergedClassNames,
      styles: mergedStyles,
      direction,
      checkable: checkable ? import_react215.default.createElement("span", {
        className: `${prefixCls}-checkbox-inner`
      }) : checkable,
      selectable,
      switcherIcon: renderSwitcherIcon,
      draggable: draggableConfig
    }, children)
  );
});
if (true) {
  Tree2.displayName = "Tree";
}
var Tree_default2 = Tree2;

// node_modules/antd/es/tree/utils/dictUtil.js
var RECORD_NONE = 0;
var RECORD_START = 1;
var RECORD_END = 2;
function traverseNodesKey(treeData, callback, fieldNames) {
  const {
    key: fieldKey,
    children: fieldChildren
  } = fieldNames;
  function processNode(dataNode) {
    const key = dataNode[fieldKey];
    const children = dataNode[fieldChildren];
    if (callback(key, dataNode) !== false) {
      traverseNodesKey(children || [], callback, fieldNames);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys({
  treeData,
  expandedKeys,
  startKey,
  endKey,
  fieldNames
}) {
  const keys2 = [];
  let record = RECORD_NONE;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key) {
    return key === startKey || key === endKey;
  }
  traverseNodesKey(treeData, (key) => {
    if (record === RECORD_END) {
      return false;
    }
    if (matchKey(key)) {
      keys2.push(key);
      if (record === RECORD_NONE) {
        record = RECORD_START;
      } else if (record === RECORD_START) {
        record = RECORD_END;
        return false;
      }
    } else if (record === RECORD_START) {
      keys2.push(key);
    }
    return expandedKeys.includes(key);
  }, fillFieldNames3(fieldNames));
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  const restKeys = _toConsumableArray(keys2);
  const nodes = [];
  traverseNodesKey(treeData, (key, node2) => {
    const index2 = restKeys.indexOf(key);
    if (index2 !== -1) {
      nodes.push(node2);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  }, fillFieldNames3(fieldNames));
  return nodes;
}

// node_modules/antd/es/tree/DirectoryTree.js
function getIcon(props) {
  const {
    isLeaf: isLeaf2,
    expanded
  } = props;
  if (isLeaf2) {
    return React582.createElement(FileOutlined_default, null);
  }
  return expanded ? React582.createElement(FolderOpenOutlined_default, null) : React582.createElement(FolderOutlined_default, null);
}
function getTreeData({
  treeData,
  children
}) {
  return treeData || convertTreeToData(children);
}
var DirectoryTree = ({
  defaultExpandAll,
  defaultExpandParent,
  defaultExpandedKeys,
  ...props
}, ref) => {
  const lastSelectedKey = React582.useRef(null);
  const cachedSelectedKeys = React582.useRef(null);
  const getInitExpandedKeys = () => {
    const {
      keyEntities
    } = convertDataToEntities(getTreeData(props), {
      fieldNames: props.fieldNames
    });
    let initExpandedKeys;
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys || [];
    }
    return initExpandedKeys;
  };
  const [selectedKeys, setSelectedKeys] = React582.useState(props.selectedKeys || props.defaultSelectedKeys || []);
  const [expandedKeys, setExpandedKeys] = React582.useState(() => getInitExpandedKeys());
  React582.useEffect(() => {
    if ("selectedKeys" in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  React582.useEffect(() => {
    if ("expandedKeys" in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  const onExpand = (keys2, info) => {
    var _a;
    if (!("expandedKeys" in props)) {
      setExpandedKeys(keys2);
    }
    return (_a = props.onExpand) == null ? void 0 : _a.call(props, keys2, info);
  };
  const onSelect = (keys2, event) => {
    var _a;
    const {
      multiple,
      fieldNames
    } = props;
    const {
      node: node2,
      nativeEvent
    } = event;
    const {
      key = ""
    } = node2;
    const treeData = getTreeData(props);
    const newEvent = {
      ...event,
      selected: true
      // Directory selected always true
    };
    const ctrlPick = (nativeEvent == null ? void 0 : nativeEvent.ctrlKey) || (nativeEvent == null ? void 0 : nativeEvent.metaKey);
    const shiftPick = nativeEvent == null ? void 0 : nativeEvent.shiftKey;
    let newSelectedKeys;
    if (multiple && ctrlPick) {
      newSelectedKeys = keys2;
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else if (multiple && shiftPick) {
      newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
        treeData,
        expandedKeys,
        startKey: key,
        endKey: lastSelectedKey.current,
        fieldNames
      })))));
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    } else {
      newSelectedKeys = [key];
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
    }
    (_a = props.onSelect) == null ? void 0 : _a.call(props, newSelectedKeys, newEvent);
    if (!("selectedKeys" in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  };
  const {
    getPrefixCls,
    direction
  } = React582.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    showIcon = true,
    expandAction = "click",
    ...otherProps
  } = props;
  const prefixCls = getPrefixCls("tree", customizePrefixCls);
  const connectClassName = clsx(`${prefixCls}-directory`, {
    [`${prefixCls}-directory-rtl`]: direction === "rtl"
  }, className);
  return React582.createElement(Tree_default2, {
    icon: getIcon,
    ref,
    blockNode: true,
    ...otherProps,
    showIcon,
    expandAction,
    prefixCls,
    className: connectClassName,
    expandedKeys,
    selectedKeys,
    onSelect,
    onExpand
  });
};
var ForwardDirectoryTree = React582.forwardRef(DirectoryTree);
if (true) {
  ForwardDirectoryTree.displayName = "DirectoryTree";
}
var DirectoryTree_default = ForwardDirectoryTree;

// node_modules/antd/es/tree/index.js
var Tree3 = Tree_default2;
Tree3.DirectoryTree = DirectoryTree_default;
Tree3.TreeNode = TreeNode_default;
var tree_default = Tree3;

// node_modules/antd/es/table/hooks/useFilter/FilterSearch.js
var React583 = __toESM(require_react());
var FilterSearch = (props) => {
  const {
    value,
    filterSearch,
    tablePrefixCls,
    locale: locale6,
    onChange
  } = props;
  if (!filterSearch) {
    return null;
  }
  return React583.createElement("div", {
    className: `${tablePrefixCls}-filter-dropdown-search`
  }, React583.createElement(Input_default5, {
    prefix: React583.createElement(SearchOutlined_default, null),
    placeholder: locale6.filterSearchPlaceholder,
    onChange,
    value,
    // for skip min-width of input
    htmlSize: 1,
    className: `${tablePrefixCls}-filter-dropdown-search-input`
  }));
};
var FilterSearch_default = FilterSearch;

// node_modules/antd/es/table/hooks/useFilter/FilterWrapper.js
var React584 = __toESM(require_react());
var onKeyDown = (event) => {
  const {
    keyCode
  } = event;
  if (keyCode === KeyCode_default.ENTER) {
    event.stopPropagation();
  }
};
var FilterDropdownMenuWrapper = React584.forwardRef((props, ref) => React584.createElement("div", {
  className: props.className,
  onClick: (e3) => e3.stopPropagation(),
  onKeyDown,
  ref
}, props.children));
if (true) {
  FilterDropdownMenuWrapper.displayName = "FilterDropdownMenuWrapper";
}
var FilterWrapper_default = FilterDropdownMenuWrapper;

// node_modules/antd/es/table/hooks/useFilter/FilterDropdown.js
function flattenKeys(filters) {
  let keys2 = [];
  (filters || []).forEach(({
    value,
    children
  }) => {
    keys2.push(value);
    if (children) {
      keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys2;
}
function hasSubMenu(filters) {
  return filters.some(({
    children
  }) => children);
}
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text == null ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems({
  filters,
  prefixCls,
  filteredKeys,
  filterMultiple,
  searchValue,
  filterSearch
}) {
  return filters.map((filter3, index2) => {
    const key = String(filter3.value);
    if (filter3.children) {
      return {
        key: key || index2,
        label: filter3.text,
        popupClassName: `${prefixCls}-dropdown-submenu`,
        children: renderFilterItems({
          filters: filter3.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    }
    const Component8 = filterMultiple ? checkbox_default : radio_default2;
    const item = {
      key: filter3.value !== void 0 ? key : index2,
      label: React585.createElement(React585.Fragment, null, React585.createElement(Component8, {
        checked: filteredKeys.includes(key)
      }), React585.createElement("span", null, filter3.text))
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter3) ? item : null;
      }
      return searchValueMatched(searchValue, filter3.text) ? item : null;
    }
    return item;
  });
}
function wrapStringListType(keys2) {
  return keys2 || [];
}
var FilterDropdown = (props) => {
  var _a;
  const {
    tablePrefixCls,
    prefixCls,
    column: column2,
    dropdownPrefixCls,
    columnKey,
    filterOnClose,
    filterMultiple,
    filterMode = "menu",
    filterSearch = false,
    filterState,
    triggerFilter,
    locale: locale6,
    children,
    getPopupContainer,
    rootClassName
  } = props;
  const {
    filterResetToDefaultFilteredValue,
    defaultFilteredValue,
    filterDropdownProps = {},
    // Deprecated
    filterDropdownOpen,
    onFilterDropdownOpenChange
  } = column2;
  const [visible, setVisible] = React585.useState(false);
  const filtered = !!(filterState && (((_a = filterState.filteredKeys) == null ? void 0 : _a.length) || filterState.forceFiltered));
  const triggerVisible = (newVisible) => {
    var _a2;
    setVisible(newVisible);
    (_a2 = filterDropdownProps.onOpenChange) == null ? void 0 : _a2.call(filterDropdownProps, newVisible);
    onFilterDropdownOpenChange == null ? void 0 : onFilterDropdownOpenChange(newVisible);
  };
  if (true) {
    const warning5 = devUseWarning("Table");
    const deprecatedList = [["filterDropdownOpen", "filterDropdownProps.open"], ["onFilterDropdownOpenChange", "filterDropdownProps.onOpenChange"]];
    deprecatedList.forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in column2), deprecatedName, newName);
    });
    warning5.deprecated(!("filterCheckall" in locale6), "filterCheckall", "locale.filterCheckAll");
  }
  const mergedVisible = filterDropdownProps.open ?? filterDropdownOpen ?? // deprecated
  visible;
  const propFilteredKeys = filterState == null ? void 0 : filterState.filteredKeys;
  const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState2(wrapStringListType(propFilteredKeys));
  const onSelectKeys = ({
    selectedKeys
  }) => {
    setFilteredKeysSync(selectedKeys);
  };
  const onCheck = (keys2, {
    node: node2,
    checked
  }) => {
    if (!filterMultiple) {
      onSelectKeys({
        selectedKeys: checked && node2.key ? [node2.key] : []
      });
    } else {
      onSelectKeys({
        selectedKeys: keys2
      });
    }
  };
  React585.useEffect(() => {
    if (!visible) {
      return;
    }
    onSelectKeys({
      selectedKeys: wrapStringListType(propFilteredKeys)
    });
  }, [propFilteredKeys]);
  const [openKeys, setOpenKeys] = React585.useState([]);
  const onOpenChange = (keys2) => {
    setOpenKeys(keys2);
  };
  const [searchValue, setSearchValue] = React585.useState("");
  const onSearch = (e3) => {
    const {
      value
    } = e3.target;
    setSearchValue(value);
  };
  React585.useEffect(() => {
    if (!visible) {
      setSearchValue("");
    }
  }, [visible]);
  const internalTriggerFilter = (keys2) => {
    const mergedKeys = (keys2 == null ? void 0 : keys2.length) ? keys2 : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (isEqual_default(mergedKeys, filterState == null ? void 0 : filterState.filteredKeys, true)) {
      return null;
    }
    triggerFilter({
      column: column2,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  };
  const onConfirm = () => {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  };
  const onReset = ({
    confirm: confirm2,
    closeDropdown
  } = {
    confirm: false,
    closeDropdown: false
  }) => {
    if (confirm2) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue("");
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
    } else {
      setFilteredKeysSync([]);
    }
  };
  const doFilter = ({
    closeDropdown
  } = {
    closeDropdown: true
  }) => {
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  };
  const onVisibleChange = (newVisible, info) => {
    if (info.source === "trigger") {
      if (newVisible && propFilteredKeys !== void 0) {
        setFilteredKeysSync(wrapStringListType(propFilteredKeys));
      }
      triggerVisible(newVisible);
      if (!newVisible && !column2.filterDropdown && filterOnClose) {
        onConfirm();
      }
    }
  };
  const dropdownMenuClass = clsx({
    [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
  });
  const onCheckAll = (e3) => {
    if (e3.target.checked) {
      const allFilterKeys = flattenKeys(column2 == null ? void 0 : column2.filters).map((key) => String(key));
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  };
  const getTreeData2 = ({
    filters
  }) => (filters || []).map((filter3, index2) => {
    const key = String(filter3.value);
    const item = {
      title: filter3.text,
      key: filter3.value !== void 0 ? key : String(index2)
    };
    if (filter3.children) {
      item.children = getTreeData2({
        filters: filter3.children
      });
    }
    return item;
  });
  const getFilterData2 = (node2) => {
    var _a2;
    return {
      ...node2,
      text: node2.title,
      value: node2.key,
      children: ((_a2 = node2.children) == null ? void 0 : _a2.map((item) => getFilterData2(item))) || []
    };
  };
  let dropdownContent;
  const {
    direction,
    renderEmpty
  } = React585.useContext(ConfigContext);
  if (typeof column2.filterDropdown === "function") {
    dropdownContent = column2.filterDropdown({
      prefixCls: `${dropdownPrefixCls}-custom`,
      setSelectedKeys: (selectedKeys) => onSelectKeys({
        selectedKeys
      }),
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column2.filters,
      visible: mergedVisible,
      close: () => {
        triggerVisible(false);
      }
    });
  } else if (column2.filterDropdown) {
    dropdownContent = column2.filterDropdown;
  } else {
    const selectedKeys = getFilteredKeysSync() || [];
    const getFilterComponent = () => {
      const empty2 = (renderEmpty == null ? void 0 : renderEmpty("Table.filter")) ?? React585.createElement(empty_default2, {
        image: empty_default2.PRESENTED_IMAGE_SIMPLE,
        description: locale6.filterEmptyText,
        styles: {
          image: {
            height: 24
          }
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      });
      if ((column2.filters || []).length === 0) {
        return empty2;
      }
      if (filterMode === "tree") {
        return React585.createElement(React585.Fragment, null, React585.createElement(FilterSearch_default, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale6
        }), React585.createElement("div", {
          className: `${tablePrefixCls}-filter-dropdown-tree`
        }, filterMultiple ? React585.createElement(checkbox_default, {
          checked: selectedKeys.length === flattenKeys(column2.filters).length,
          indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column2.filters).length,
          className: `${tablePrefixCls}-filter-dropdown-checkall`,
          onChange: onCheckAll
        }, (locale6 == null ? void 0 : locale6.filterCheckall) ?? (locale6 == null ? void 0 : locale6.filterCheckAll)) : null, React585.createElement(tree_default, {
          checkable: true,
          selectable: false,
          blockNode: true,
          multiple: filterMultiple,
          checkStrictly: !filterMultiple,
          className: `${dropdownPrefixCls}-menu`,
          onCheck,
          checkedKeys: selectedKeys,
          selectedKeys,
          showIcon: false,
          treeData: getTreeData2({
            filters: column2.filters
          }),
          autoExpandParent: true,
          defaultExpandAll: true,
          filterTreeNode: searchValue.trim() ? (node2) => {
            if (typeof filterSearch === "function") {
              return filterSearch(searchValue, getFilterData2(node2));
            }
            return searchValueMatched(searchValue, node2.title);
          } : void 0
        })));
      }
      const items = renderFilterItems({
        filters: column2.filters || [],
        filterSearch,
        prefixCls,
        filteredKeys: getFilteredKeysSync(),
        filterMultiple,
        searchValue
      });
      const isEmpty2 = items.every((item) => item === null);
      return React585.createElement(React585.Fragment, null, React585.createElement(FilterSearch_default, {
        filterSearch,
        value: searchValue,
        onChange: onSearch,
        tablePrefixCls,
        locale: locale6
      }), isEmpty2 ? empty2 : React585.createElement(menu_default2, {
        selectable: true,
        multiple: filterMultiple,
        prefixCls: `${dropdownPrefixCls}-menu`,
        className: dropdownMenuClass,
        onSelect: onSelectKeys,
        onDeselect: onSelectKeys,
        selectedKeys,
        getPopupContainer,
        openKeys,
        onOpenChange,
        items
      }));
    };
    const getResetDisabled = () => {
      if (filterResetToDefaultFilteredValue) {
        return isEqual_default((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
      }
      return selectedKeys.length === 0;
    };
    dropdownContent = React585.createElement(React585.Fragment, null, getFilterComponent(), React585.createElement("div", {
      className: `${prefixCls}-dropdown-btns`
    }, React585.createElement(Button_default, {
      type: "link",
      size: "small",
      disabled: getResetDisabled(),
      onClick: () => onReset()
    }, locale6.filterReset), React585.createElement(Button_default, {
      type: "primary",
      size: "small",
      onClick: onConfirm
    }, locale6.filterConfirm)));
  }
  if (column2.filterDropdown) {
    dropdownContent = React585.createElement(OverrideProvider, {
      selectable: void 0
    }, dropdownContent);
  }
  dropdownContent = React585.createElement(FilterWrapper_default, {
    className: `${prefixCls}-dropdown`
  }, dropdownContent);
  const getDropdownTrigger = () => {
    let filterIcon;
    if (typeof column2.filterIcon === "function") {
      filterIcon = column2.filterIcon(filtered);
    } else if (column2.filterIcon) {
      filterIcon = column2.filterIcon;
    } else {
      filterIcon = React585.createElement(FilterFilled_default, null);
    }
    return React585.createElement("span", {
      role: "button",
      tabIndex: -1,
      className: clsx(`${prefixCls}-trigger`, {
        active: filtered
      }),
      onClick: (e3) => {
        e3.stopPropagation();
      }
    }, filterIcon);
  };
  const mergedDropdownProps = extendsObject_default({
    trigger: ["click"],
    placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
    children: getDropdownTrigger(),
    getPopupContainer
  }, {
    ...filterDropdownProps,
    rootClassName: clsx(rootClassName, filterDropdownProps.rootClassName),
    open: mergedVisible,
    onOpenChange: onVisibleChange,
    popupRender: () => {
      if (typeof (filterDropdownProps == null ? void 0 : filterDropdownProps.dropdownRender) === "function") {
        return filterDropdownProps.dropdownRender(dropdownContent);
      }
      return dropdownContent;
    }
  });
  return React585.createElement("div", {
    className: `${prefixCls}-column`
  }, React585.createElement("span", {
    className: `${tablePrefixCls}-column-title`
  }, children), React585.createElement(dropdown_default3, {
    ...mergedDropdownProps
  }));
};
var FilterDropdown_default = FilterDropdown;

// node_modules/antd/es/table/hooks/useFilter/index.js
var collectFilterStates = (columns, init, pos) => {
  let filterStates = [];
  (columns || []).forEach((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    const filterDropdownIsDefined = column2.filterDropdown !== void 0;
    if (column2.filters || filterDropdownIsDefined || "onFilter" in column2) {
      if ("filteredValue" in column2) {
        let filteredValues = column2.filteredValue;
        if (!filterDropdownIsDefined) {
          filteredValues = (filteredValues == null ? void 0 : filteredValues.map(String)) ?? filteredValues;
        }
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column2.filtered
        });
      } else {
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
          forceFiltered: column2.filtered
        });
      }
    }
    if ("children" in column2) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos)));
    }
  });
  return filterStates;
};
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale6, triggerFilter, getPopupContainer, pos, rootClassName) {
  return columns.map((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    const {
      filterOnClose = true,
      filterMultiple = true,
      filterMode,
      filterSearch
    } = column2;
    let newColumn = column2;
    if (newColumn.filters || newColumn.filterDropdown) {
      const columnKey = getColumnKey(newColumn, columnPos);
      const filterState = filterStates.find(({
        key
      }) => columnKey === key);
      newColumn = {
        ...newColumn,
        title: (renderProps) => React586.createElement(FilterDropdown_default, {
          tablePrefixCls: prefixCls,
          prefixCls: `${prefixCls}-filter`,
          dropdownPrefixCls,
          column: newColumn,
          columnKey,
          filterState,
          filterOnClose,
          filterMultiple,
          filterMode,
          filterSearch,
          triggerFilter,
          locale: locale6,
          getPopupContainer,
          rootClassName
        }, renderColumnTitle(column2.title, renderProps))
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale6, triggerFilter, getPopupContainer, columnPos, rootClassName)
      };
    }
    return newColumn;
  });
}
var generateFilterInfo = (filterStates) => {
  const currentFilters = {};
  filterStates.forEach(({
    key,
    filteredKeys,
    column: column2
  }) => {
    const keyAsString = key;
    const {
      filters,
      filterDropdown
    } = column2;
    if (filterDropdown) {
      currentFilters[keyAsString] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      const keys2 = flattenKeys(filters);
      currentFilters[keyAsString] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
    } else {
      currentFilters[keyAsString] = null;
    }
  });
  return currentFilters;
};
var getFilterData = (data, filterStates, childrenColumnName) => {
  const filterDatas = filterStates.reduce((currentData, filterState) => {
    const {
      column: {
        onFilter,
        filters
      },
      filteredKeys
    } = filterState;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.map((record) => ({
        ...record
      })).filter((record) => filteredKeys.some((key) => {
        const keys2 = flattenKeys(filters);
        const keyIndex2 = keys2.findIndex((k) => String(k) === String(key));
        const realKey = keyIndex2 !== -1 ? keys2[keyIndex2] : key;
        if (record[childrenColumnName]) {
          record[childrenColumnName] = getFilterData(record[childrenColumnName], filterStates, childrenColumnName);
        }
        return onFilter(realKey, record);
      }));
    }
    return currentData;
  }, data);
  return filterDatas;
};
var getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column2) => {
  if ("children" in column2) {
    return [column2].concat(_toConsumableArray(getMergedColumns(column2.children || [])));
  }
  return [column2];
});
var useFilter = (props) => {
  const {
    prefixCls,
    dropdownPrefixCls,
    mergedColumns: rawMergedColumns,
    onFilterChange,
    getPopupContainer,
    locale: tableLocale,
    rootClassName
  } = props;
  const warning5 = devUseWarning("Table");
  const mergedColumns = React586.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
  const [filterStates, setFilterStates] = React586.useState(() => collectFilterStates(mergedColumns, true));
  const mergedFilterStates = React586.useMemo(() => {
    const collectedStates = collectFilterStates(mergedColumns, false);
    if (collectedStates.length === 0) {
      return collectedStates;
    }
    let filteredKeysIsAllNotControlled = true;
    let filteredKeysIsAllControlled = true;
    collectedStates.forEach(({
      filteredKeys
    }) => {
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      } else {
        filteredKeysIsAllControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      const keyList = (mergedColumns || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
      return filterStates.filter(({
        key
      }) => keyList.includes(key)).map((item) => {
        const col = mergedColumns[keyList.indexOf(item.key)];
        return {
          ...item,
          column: {
            ...item.column,
            ...col
          },
          forceFiltered: col.filtered
        };
      });
    }
    true ? warning5(filteredKeysIsAllControlled, "usage", "Columns should all contain `filteredValue` or not contain `filteredValue`.") : void 0;
    return collectedStates;
  }, [mergedColumns, filterStates]);
  const filters = React586.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
  const triggerFilter = (filterState) => {
    const newFilterStates = mergedFilterStates.filter(({
      key
    }) => key !== filterState.key);
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
  return [transformColumns, mergedFilterStates, filters];
};
var useFilter_default = useFilter;

// node_modules/antd/es/table/hooks/useLazyKVMap.js
var React587 = __toESM(require_react());
var useLazyKVMap = (data, childrenColumnName, getRowKey) => {
  const mapCacheRef = React587.useRef({});
  function getRecordByKey(key) {
    var _a;
    if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig = function(records) {
        records.forEach((record, index2) => {
          const rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record);
          if (record && typeof record === "object" && childrenColumnName in record) {
            dig(record[childrenColumnName] || []);
          }
        });
      };
      const kvMap = /* @__PURE__ */ new Map();
      dig(data);
      mapCacheRef.current = {
        data,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return (_a = mapCacheRef.current.kvMap) == null ? void 0 : _a.get(key);
  }
  return [getRecordByKey];
};
var useLazyKVMap_default = useLazyKVMap;

// node_modules/antd/es/table/hooks/usePagination.js
var import_react216 = __toESM(require_react());
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
  const param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  Object.keys(paginationObj).forEach((pageProp) => {
    const value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
function usePagination(total, onChange, pagination) {
  const {
    total: paginationTotal = 0,
    ...paginationObj
  } = pagination && typeof pagination === "object" ? pagination : {};
  const [innerPagination, setInnerPagination] = (0, import_react216.useState)(() => ({
    current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
    pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
  }));
  const mergedPagination = extendsObject_default(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  });
  const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    mergedPagination.current = maxPage || 1;
  }
  const refreshPagination = (current, pageSize) => {
    setInnerPagination({
      current: current ?? 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  };
  const onInternalChange = (current, pageSize) => {
    var _a;
    if (pagination) {
      (_a = pagination.onChange) == null ? void 0 : _a.call(pagination, current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange(current, pageSize || (mergedPagination == null ? void 0 : mergedPagination.pageSize));
  };
  if (pagination === false) {
    return [{}, () => {
    }];
  }
  return [{
    ...mergedPagination,
    onChange: onInternalChange
  }, refreshPagination];
}
var usePagination_default = usePagination;

// node_modules/antd/es/table/hooks/useSorter.js
var React588 = __toESM(require_react());
var ASCEND = "ascend";
var DESCEND = "descend";
var getMultiplePriority = (column2) => {
  if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
    return column2.sorter.multiple;
  }
  return false;
};
var getSortFunction = (sorter) => {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && typeof sorter === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
};
var nextSortDirection = (sortDirections, current) => {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
};
var collectSortStates = (columns, init, pos) => {
  let sortStates = [];
  const pushState = (column2, columnPos) => {
    sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.sortOrder
    });
  };
  (columns || []).forEach((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    if (column2.children) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)));
    } else if (column2.sorter) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      } else if (init && column2.defaultSortOrder) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
};
var injectSorter = (prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos, a11yLocale) => {
  const finalColumns = (columns || []).map((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    let newColumn = column2;
    if (newColumn.sorter) {
      const sortDirections = newColumn.sortDirections || defaultSortDirections;
      const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      const columnKey = getColumnKey(newColumn, columnPos);
      const sorterState = sorterStates.find(({
        key
      }) => key === columnKey);
      const sortOrder = sorterState ? sorterState.sortOrder : null;
      const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
      let sorter;
      if (column2.sortIcon) {
        sorter = column2.sortIcon({
          sortOrder
        });
      } else {
        const upNode = sortDirections.includes(ASCEND) && React588.createElement(CaretUpOutlined_default, {
          className: clsx(`${prefixCls}-column-sorter-up`, {
            active: sortOrder === ASCEND
          })
        });
        const downNode = sortDirections.includes(DESCEND) && React588.createElement(CaretDownOutlined_default, {
          className: clsx(`${prefixCls}-column-sorter-down`, {
            active: sortOrder === DESCEND
          })
        });
        sorter = React588.createElement("span", {
          className: clsx(`${prefixCls}-column-sorter`, {
            [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
          })
        }, React588.createElement("span", {
          className: `${prefixCls}-column-sorter-inner`,
          "aria-hidden": "true"
        }, upNode, downNode));
      }
      const {
        cancelSort,
        triggerAsc,
        triggerDesc
      } = tableLocale || {};
      let sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      const tooltipProps = typeof showSorterTooltip === "object" ? {
        title: sortTip,
        ...showSorterTooltip
      } : {
        title: sortTip
      };
      newColumn = {
        ...newColumn,
        className: clsx(newColumn.className, {
          [`${prefixCls}-column-sort`]: sortOrder
        }),
        title: (renderProps) => {
          const columnSortersClass = `${prefixCls}-column-sorters`;
          const renderColumnTitleWrapper = React588.createElement("span", {
            className: `${prefixCls}-column-title`
          }, renderColumnTitle(column2.title, renderProps));
          const renderSortTitle = React588.createElement("div", {
            className: columnSortersClass
          }, renderColumnTitleWrapper, sorter);
          if (showSorterTooltip) {
            if (typeof showSorterTooltip !== "boolean" && (showSorterTooltip == null ? void 0 : showSorterTooltip.target) === "sorter-icon") {
              return React588.createElement("div", {
                className: clsx(columnSortersClass, `${columnSortersClass}-tooltip-target-sorter`)
              }, renderColumnTitleWrapper, React588.createElement(tooltip_default, {
                ...tooltipProps
              }, sorter));
            }
            return React588.createElement(tooltip_default, {
              ...tooltipProps
            }, renderSortTitle);
          }
          return renderSortTitle;
        },
        onHeaderCell: (col) => {
          var _a;
          const cell = ((_a = column2.onHeaderCell) == null ? void 0 : _a.call(column2, col)) || {};
          const originOnClick = cell.onClick;
          const originOKeyDown = cell.onKeyDown;
          cell.onClick = (event) => {
            triggerSorter({
              column: column2,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column2)
            });
            originOnClick == null ? void 0 : originOnClick(event);
          };
          cell.onKeyDown = (event) => {
            if (event.keyCode === KeyCode_default.ENTER) {
              triggerSorter({
                column: column2,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column2)
              });
              originOKeyDown == null ? void 0 : originOKeyDown(event);
            }
          };
          const renderTitle = safeColumnTitle(column2.title, {});
          const displayTitle = renderTitle == null ? void 0 : renderTitle.toString();
          if (sortOrder) {
            cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
          }
          cell["aria-description"] = a11yLocale == null ? void 0 : a11yLocale.sortable;
          cell["aria-label"] = displayTitle || "";
          cell.className = clsx(cell.className, `${prefixCls}-column-has-sorters`);
          cell.tabIndex = 0;
          if (column2.ellipsis) {
            cell.title = (renderTitle ?? "").toString();
          }
          return cell;
        }
      };
    }
    if ("children" in newColumn) {
      newColumn = {
        ...newColumn,
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos, a11yLocale)
      };
    }
    return newColumn;
  });
  return finalColumns;
};
var stateToInfo = (sorterState) => {
  const {
    column: column2,
    sortOrder
  } = sorterState;
  return {
    column: column2,
    order: sortOrder,
    field: column2.dataIndex,
    columnKey: column2.key
  };
};
var generateSorterInfo = (sorterStates) => {
  const activeSorters = sorterStates.filter(({
    sortOrder
  }) => sortOrder).map(stateToInfo);
  if (activeSorters.length === 0 && sorterStates.length) {
    const lastIndex = sorterStates.length - 1;
    return {
      ...stateToInfo(sorterStates[lastIndex]),
      column: void 0,
      order: void 0,
      field: void 0,
      columnKey: void 0
    };
  }
  if (activeSorters.length <= 1) {
    return activeSorters[0] || {};
  }
  return activeSorters;
};
var getSortData = (data, sortStates, childrenColumnName) => {
  const innerSorterStates = sortStates.slice().sort((a, b) => b.multiplePriority - a.multiplePriority);
  const cloneData = data.slice();
  const runningSorters = innerSorterStates.filter(({
    column: {
      sorter
    },
    sortOrder
  }) => getSortFunction(sorter) && sortOrder);
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort((record1, record2) => {
    for (let i = 0; i < runningSorters.length; i += 1) {
      const sorterState = runningSorters[i];
      const {
        column: {
          sorter
        },
        sortOrder
      } = sorterState;
      const compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        const compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map((record) => {
    const subRecords = record[childrenColumnName];
    if (subRecords) {
      return {
        ...record,
        [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
      };
    }
    return record;
  });
};
var useFilterSorter = (props) => {
  const {
    prefixCls,
    mergedColumns,
    sortDirections,
    tableLocale,
    showSorterTooltip,
    onSorterChange,
    globalLocale
  } = props;
  const [sortStates, setSortStates] = React588.useState(() => collectSortStates(mergedColumns, true));
  const getColumnKeys = (columns, pos) => {
    const newKeys = [];
    columns.forEach((item, index2) => {
      const columnPos = getColumnPos(index2, pos);
      newKeys.push(getColumnKey(item, columnPos));
      if (Array.isArray(item.children)) {
        const childKeys = getColumnKeys(item.children, columnPos);
        newKeys.push.apply(newKeys, _toConsumableArray(childKeys));
      }
    });
    return newKeys;
  };
  const mergedSorterStates = React588.useMemo(() => {
    let validate = true;
    const collectedStates = collectSortStates(mergedColumns, false);
    if (!collectedStates.length) {
      const mergedColumnsKeys = getColumnKeys(mergedColumns);
      return sortStates.filter(({
        key
      }) => mergedColumnsKeys.includes(key));
    }
    const validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push({
          ...state,
          sortOrder: null
        });
      }
    }
    let multipleMode = null;
    collectedStates.forEach((state) => {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  const columnTitleSorterProps = React588.useMemo(() => {
    var _a, _b;
    const sortColumns = mergedSorterStates.map(({
      column: column2,
      sortOrder
    }) => ({
      column: column2,
      order: sortOrder
    }));
    return {
      sortColumns,
      // Legacy
      sortColumn: (_a = sortColumns[0]) == null ? void 0 : _a.column,
      sortOrder: (_b = sortColumns[0]) == null ? void 0 : _b.order
    };
  }, [mergedSorterStates]);
  const triggerSorter = (sortState) => {
    let newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(({
        key
      }) => key !== sortState.key)), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  };
  const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip, void 0, globalLocale);
  const getSorters = () => generateSorterInfo(mergedSorterStates);
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
};
var useSorter_default = useFilterSorter;

// node_modules/antd/es/table/hooks/useTitleColumns.js
var React589 = __toESM(require_react());
var fillTitle = (columns, columnTitleProps) => {
  const finalColumns = columns.map((column2) => {
    const cloneColumn = {
      ...column2
    };
    cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
  return finalColumns;
};
var useTitleColumns = (columnTitleProps) => {
  const filledColumns = React589.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps]);
  return [filledColumns];
};
var useTitleColumns_default = useTitleColumns;

// node_modules/antd/es/table/RcTable/index.js
var RcTable = genTable((prev2, next2) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev2;
  const {
    _renderTimes: nextRenderTimes
  } = next2;
  return prevRenderTimes !== nextRenderTimes;
});
var RcTable_default = RcTable;

// node_modules/antd/es/table/RcTable/VirtualTable.js
var RcVirtualTable = genVirtualTable((prev2, next2) => {
  const {
    _renderTimes: prevRenderTimes
  } = prev2;
  const {
    _renderTimes: nextRenderTimes
  } = next2;
  return prevRenderTimes !== nextRenderTimes;
});
var VirtualTable_default2 = RcVirtualTable;

// node_modules/antd/es/table/style/bordered.js
var genBorderedStyle4 = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    tableBorderColor,
    tableHeaderBg,
    tablePaddingVertical,
    tablePaddingHorizontal,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
    [`&${componentCls}-${size}`]: {
      [`> ${componentCls}-container`]: {
        [`> ${componentCls}-content, > ${componentCls}-body`]: {
          [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
            [`> ${componentCls}-expanded-row-fixed`]: {
              margin: `${unit(calc(paddingVertical).mul(-1).equal())}
              ${unit(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
            }
          }
        }
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}${componentCls}-bordered`]: {
        // ============================ Title =============================
        [`> ${componentCls}-title`]: {
          border: tableBorder,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${componentCls}-container`]: {
          borderInlineStart: tableBorder,
          borderTop: tableBorder,
          [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              [`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                borderInlineEnd: tableBorder
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: tableBorder
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                [`> ${componentCls}-cell-fix-right-first::after`]: {
                  borderInlineEnd: tableBorder
                }
              },
              // ========================== Expandable ==========================
              [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: lineWidth,
                    bottom: 0,
                    borderInlineEnd: tableBorder,
                    content: '""'
                  }
                }
              }
            }
          }
        },
        // ============================ Scroll ============================
        [`&${componentCls}-scroll-horizontal`]: {
          [`> ${componentCls}-container > ${componentCls}-body`]: {
            "> table > tbody": {
              [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                "> th, > td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        },
        // ============================ Size ============================
        ...getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle),
        ...getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall),
        // ============================ Footer ============================
        [`> ${componentCls}-footer`]: {
          border: tableBorder,
          borderTop: 0
        }
      },
      // ============================ Nested ============================
      [`${componentCls}-cell`]: {
        [`${componentCls}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${unit(lineWidth)} 0 ${unit(lineWidth)} ${tableHeaderBg}`
        }
      },
      [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
        borderInlineEnd: tableBorder
      }
    }
  };
};
var bordered_default2 = genBorderedStyle4;

// node_modules/antd/es/table/style/ellipsis.js
var genEllipsisStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-cell-ellipsis`]: {
        ...textEllipsis,
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${componentCls}-cell-fix-start-shadow,
          &${componentCls}-cell-fix-end-shadow
        `]: {
          overflow: "visible",
          [`${componentCls}-cell-content`]: {
            ...textEllipsis,
            display: "block"
          }
        },
        [`${componentCls}-column-title`]: {
          ...textEllipsis,
          wordBreak: "keep-all"
        }
      }
    }
  };
};
var ellipsis_default = genEllipsisStyle;

// node_modules/antd/es/table/style/empty.js
var genEmptyStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
        textAlign: "center",
        color: token2.colorTextDisabled,
        [`
          &:hover > th,
          &:hover > td,
        `]: {
          background: token2.colorBgContainer
        }
      }
    }
  };
};
var empty_default3 = genEmptyStyle;

// node_modules/antd/es/table/style/expand.js
var genExpandStyle = (token2) => {
  const {
    componentCls,
    antCls,
    motionDurationSlow,
    lineWidth,
    paddingXS,
    lineType,
    tableBorderColor,
    tableExpandIconBg,
    tableExpandColumnWidth,
    borderRadius,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandedRowBg,
    paddingXXS,
    expandIconMarginTop,
    expandIconSize,
    expandIconHalfInner,
    expandIconScale,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-expand-icon-col`]: {
        width: tableExpandColumnWidth
      },
      [`${componentCls}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${componentCls}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${componentCls}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${componentCls}-row-expand-icon`]: {
        ...operationUnit(token2),
        position: "relative",
        float: "left",
        width: expandIconSize,
        height: expandIconSize,
        color: "inherit",
        lineHeight: unit(expandIconSize),
        background: tableExpandIconBg,
        border: tableBorder,
        borderRadius,
        transform: `scale(${expandIconScale})`,
        "&:focus, &:hover, &:active": {
          borderColor: "currentcolor"
        },
        "&::before, &::after": {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${motionDurationSlow} ease-out`,
          content: '""'
        },
        "&::before": {
          top: expandIconHalfInner,
          insetInlineEnd: expandIconLineOffset,
          insetInlineStart: expandIconLineOffset,
          height: lineWidth
        },
        "&::after": {
          top: expandIconLineOffset,
          bottom: expandIconLineOffset,
          insetInlineStart: expandIconHalfInner,
          width: lineWidth,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      },
      [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
        marginTop: expandIconMarginTop,
        marginInlineEnd: paddingXS
      },
      [`tr${componentCls}-expanded-row`]: {
        "&, &:hover": {
          "> th, > td": {
            background: tableExpandedRowBg
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${antCls}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "100%"
          }
        }
      },
      // With fixed
      [`${componentCls}-expanded-row-fixed`]: {
        position: "relative",
        margin: `${unit(calc(tablePaddingVertical).mul(-1).equal())} ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      }
    }
  };
};
var expand_default = genExpandStyle;

// node_modules/antd/es/table/style/filter.js
var genFilterStyle = (token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth,
    paddingXXS,
    paddingXS,
    colorText,
    lineWidth,
    lineType,
    tableBorderColor,
    headerIconColor,
    fontSizeSM,
    tablePaddingHorizontal,
    borderRadius,
    motionDurationSlow,
    colorIcon,
    colorPrimary,
    tableHeaderFilterActiveBg,
    colorTextDisabled,
    tableFilterDropdownBg,
    tableFilterDropdownHeight,
    controlItemBgHover,
    controlItemBgActive,
    boxShadowSecondary,
    filterDropdownMenuBg,
    calc
  } = token2;
  const dropdownPrefixCls = `${antCls}-dropdown`;
  const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
  const treePrefixCls = `${antCls}-tree`;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${componentCls}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: calc(paddingXXS).mul(-1).equal(),
          marginInline: `${unit(paddingXXS)} ${unit(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
          padding: `0 ${unit(paddingXXS)}`,
          color: headerIconColor,
          fontSize: fontSizeSM,
          borderRadius,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIcon,
            background: tableHeaderFilterActiveBg
          },
          "&.active": {
            color: colorPrimary
          }
        }
      }
    },
    {
      // Dropdown
      [`${antCls}-dropdown`]: {
        [tableFilterDropdownPrefixCls]: {
          ...resetComponent(token2),
          minWidth: tableFilterDropdownWidth,
          backgroundColor: tableFilterDropdownBg,
          borderRadius,
          boxShadow: boxShadowSecondary,
          overflow: "hidden",
          // Reset menu
          [`${dropdownPrefixCls}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: tableFilterDropdownHeight,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            borderRadius: "unset",
            backgroundColor: filterDropdownMenuBg,
            "&:empty::after": {
              display: "block",
              padding: `${unit(paddingXS)} 0`,
              color: colorTextDisabled,
              fontSize: fontSizeSM,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${tableFilterDropdownPrefixCls}-tree`]: {
            paddingBlock: `${unit(paddingXS)} 0`,
            paddingInline: paddingXS,
            [treePrefixCls]: {
              padding: 0
            },
            [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
              backgroundColor: controlItemBgHover
            },
            [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: controlItemBgActive
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-search`]: {
            padding: paddingXS,
            borderBottom: tableBorder,
            "&-input": {
              input: {
                minWidth: tableFilterDropdownSearchWidth
              },
              [iconCls]: {
                color: colorTextDisabled
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-checkall`]: {
            width: "100%",
            marginBottom: paddingXXS,
            marginInlineStart: paddingXXS
          },
          // Operation
          [`${tableFilterDropdownPrefixCls}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${unit(calc(paddingXS).sub(lineWidth).equal())} ${unit(paddingXS)}`,
            overflow: "hidden",
            borderTop: tableBorder
          }
        }
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
        // Checkbox
        [`${antCls}-checkbox-wrapper + span`]: {
          paddingInlineStart: paddingXS,
          color: colorText
        },
        "> ul": {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
};
var filter_default = genFilterStyle;

// node_modules/antd/es/table/style/fixed.js
function getShadowStyle({
  colorSplit: shadowColor
}) {
  const leftShadowStyle = {
    boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
  };
  const rightShadowStyle = {
    boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
  };
  return [leftShadowStyle, rightShadowStyle];
}
var genFixedStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    motionDurationSlow,
    zIndexTableFixed: zIndexTableFixed2,
    tableBg,
    calc
  } = token2;
  const cellCls = `${componentCls}-cell`;
  const fixCellCls = `${cellCls}-fix`;
  const sharedShadowStyle = {
    position: "absolute",
    top: 0,
    bottom: calc(lineWidth).mul(-1).equal(),
    width: 30,
    transition: `box-shadow ${motionDurationSlow}`,
    content: '""',
    pointerEvents: "none"
  };
  const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token2);
  return {
    [`${componentCls}-wrapper`]: {
      // ====================== Cell ======================
      [`${cellCls}${fixCellCls}`]: {
        position: "sticky"
      },
      [fixCellCls]: {
        zIndex: `calc(var(--z-offset-reverse) + ${zIndexTableFixed2})`,
        background: tableBg,
        "&:after": sharedShadowStyle,
        // Position
        "&-start:after": {
          insetInlineStart: "100%"
        },
        "&-end:after": {
          insetInlineEnd: "100%"
        },
        // visible
        "&-start-shadow-show:after": leftShadowStyle,
        "&-end-shadow-show:after": rightShadowStyle
      },
      // =================== Container ====================
      [`${componentCls}-container`]: {
        position: "relative",
        "&:before, &:after": {
          ...sharedShadowStyle,
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`
        },
        "&:before": {
          insetInlineStart: 0
        },
        "&:after": {
          insetInlineEnd: 0
        }
      },
      [`${componentCls}-has-fix-start ${componentCls}-container:before`]: {
        display: "none"
      },
      [`${componentCls}-has-fix-end ${componentCls}-container:after`]: {
        display: "none"
      },
      [`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: leftShadowStyle,
      [`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: rightShadowStyle
    }
  };
};
var fixed_default = genFixedStyle;

// node_modules/antd/es/table/style/pagination.js
var genPaginationStyle2 = (token2) => {
  const {
    componentCls,
    antCls,
    margin
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${componentCls}-pagination${antCls}-pagination`]: {
        margin: `${unit(margin)} 0`
      },
      [`${componentCls}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: token2.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-start": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-end": {
          justifyContent: "flex-end"
        }
      }
    }
  };
};
var pagination_default2 = genPaginationStyle2;

// node_modules/antd/es/table/style/radius.js
var genRadiusStyle = (token2) => {
  const {
    componentCls,
    tableRadius
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [componentCls]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${componentCls}-title, ${componentCls}-header`]: {
          borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`
        },
        [`${componentCls}-title + ${componentCls}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          // https://github.com/ant-design/ant-design/issues/41975
          [`${componentCls}-header, table`]: {
            borderRadius: 0
          },
          "table > thead > tr:first-child": {
            "th:first-child, th:last-child, td:first-child, td:last-child": {
              borderRadius: 0
            }
          }
        },
        "&-container": {
          borderStartStartRadius: tableRadius,
          borderStartEndRadius: tableRadius,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: tableRadius
            },
            "> *:last-child": {
              borderStartEndRadius: tableRadius
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${unit(tableRadius)} ${unit(tableRadius)}`
        }
      }
    }
  };
};
var radius_default = genRadiusStyle;

// node_modules/antd/es/table/style/rtl.js
var genStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const [leftShadowStyle, rightShadowStyle] = getShadowStyle(token2);
  return {
    [`${componentCls}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${componentCls}-row-expand-icon`]: {
        float: "right",
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      },
      // ====================== Cell ======================
      [`${componentCls}-cell-fix`]: {
        "&-start-shadow-show:after": rightShadowStyle,
        "&-end-shadow-show:after": leftShadowStyle
      },
      // =================== Container ====================
      [`${componentCls}-container`]: {
        [`${componentCls}-row-indent`]: {
          float: "right"
        }
      },
      [`${componentCls}-fix-start-shadow-show ${componentCls}-container:before`]: rightShadowStyle,
      [`${componentCls}-fix-end-shadow-show ${componentCls}-container:after`]: leftShadowStyle
    }
  };
};
var rtl_default3 = genStyle;

// node_modules/antd/es/table/style/selection.js
var genSelectionStyle = (token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSizeIcon,
    padding,
    paddingXS,
    headerIconColor,
    headerIconHoverColor,
    tableSelectionColumnWidth,
    tableSelectedRowBg,
    tableSelectedRowHoverBg,
    tableRowHoverBg,
    tablePaddingHorizontal,
    calc
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Selections ==========================
      [`${componentCls}-selection-col`]: {
        width: tableSelectionColumnWidth,
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
        }
      },
      [`${componentCls}-bordered ${componentCls}-selection-col`]: {
        width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
        [`&${componentCls}-selection-col-with-dropdown`]: {
          width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
        }
      },
      [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS,
        textAlign: "center",
        [`${antCls}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
        zIndex: calc(token2.zIndexTableFixed).add(1).equal({
          unit: false
        })
      },
      [`table tr th${componentCls}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${componentCls}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${componentCls}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: unit(calc(tablePaddingHorizontal).div(4).equal()),
        [iconCls]: {
          color: headerIconColor,
          fontSize: fontSizeIcon,
          verticalAlign: "baseline",
          "&:hover": {
            color: headerIconHoverColor
          }
        }
      },
      // ============================= Rows =============================
      [`${componentCls}-tbody`]: {
        [`${componentCls}-row`]: {
          [`&${componentCls}-row-selected`]: {
            [`> ${componentCls}-cell`]: {
              background: tableSelectedRowBg,
              "&-row-hover": {
                background: tableSelectedRowHoverBg
              }
            }
          },
          [`> ${componentCls}-cell-row-hover`]: {
            background: tableRowHoverBg
          }
        }
      }
    }
  };
};
var selection_default = genSelectionStyle;

// node_modules/antd/es/table/style/size.js
var genSizeStyle3 = (token2) => {
  const {
    componentCls,
    tableExpandColumnWidth,
    calc
  } = token2;
  const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
    [`${componentCls}${componentCls}-${size}`]: {
      fontSize,
      [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${unit(paddingVertical)} ${unit(paddingHorizontal)}`
      },
      [`${componentCls}-filter-trigger`]: {
        marginInlineEnd: unit(calc(paddingHorizontal).div(2).mul(-1).equal())
      },
      [`${componentCls}-expanded-row-fixed`]: {
        margin: `${unit(calc(paddingVertical).mul(-1).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
      },
      [`${componentCls}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${componentCls}-wrapper:only-child ${componentCls}`]: {
          marginBlock: unit(calc(paddingVertical).mul(-1).equal()),
          marginInline: `${unit(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit(calc(paddingHorizontal).mul(-1).equal())}`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${componentCls}-selection-extra`]: {
        paddingInlineStart: unit(calc(paddingHorizontal).div(4).equal())
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: {
      ...getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle),
      ...getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall)
    }
  };
};
var size_default = genSizeStyle3;

// node_modules/antd/es/table/style/sorter.js
var genSorterStyle = (token2) => {
  const {
    componentCls,
    marginXXS,
    fontSizeIcon,
    headerIconColor,
    headerIconHoverColor
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        // why left 0s? Avoid column header move with transition when left is changed
        // https://github.com/ant-design/ant-design/issues/50588
        transition: `all ${token2.motionDurationSlow}, left 0s`,
        "&:hover": {
          background: token2.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: token2.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
          background: token2.tableFixedHeaderSortActiveBg
        }
      },
      [`${componentCls}-thead th${componentCls}-column-sort`]: {
        background: token2.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${componentCls}-column-sort`]: {
        background: token2.tableBodySortBg
      },
      [`${componentCls}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${componentCls}-column-sorters-tooltip-target-sorter`]: {
        "&::after": {
          content: "none"
        }
      },
      [`${componentCls}-column-sorter`]: {
        marginInlineStart: marginXXS,
        color: headerIconColor,
        fontSize: 0,
        transition: `color ${token2.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: fontSizeIcon,
          "&.active": {
            color: token2.colorPrimary
          }
        },
        [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
        color: headerIconHoverColor
      }
    }
  };
};
var sorter_default = genSorterStyle;

// node_modules/antd/es/table/style/sticky.js
var genStickyStyle = (token2) => {
  const {
    componentCls,
    opacityLoading,
    tableScrollThumbBg,
    tableScrollThumbBgHover,
    tableScrollThumbSize,
    tableScrollBg,
    stickyScrollBarBorderRadius,
    lineWidth,
    lineType,
    tableBorderColor,
    zIndexTableFixed: zIndexTableFixed2
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`,
          background: token2.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${unit(tableScrollThumbSize)} !important`,
          zIndex: `calc(var(--columns-count) * 2 + ${zIndexTableFixed2} + 1)`,
          display: "flex",
          alignItems: "center",
          background: tableScrollBg,
          borderTop: tableBorder,
          opacity: opacityLoading,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: tableScrollThumbSize,
            backgroundColor: tableScrollThumbBg,
            borderRadius: stickyScrollBarBorderRadius,
            transition: `all ${token2.motionDurationSlow}, transform 0s`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: tableScrollThumbBgHover
            }
          }
        }
      }
    }
  };
};
var sticky_default = genStickyStyle;

// node_modules/antd/es/table/style/summary.js
var genSummaryStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    tableBorderColor,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${token2.lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-summary`]: {
        position: "relative",
        zIndex: token2.zIndexTableFixed,
        background: token2.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: tableBorder
          }
        }
      },
      [`div${componentCls}-summary`]: {
        boxShadow: `0 ${unit(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
      }
    }
  };
};
var summary_default = genSummaryStyle;

// node_modules/antd/es/table/style/virtual.js
var genVirtualStyle = (token2) => {
  const {
    componentCls,
    motionDurationMid,
    lineWidth,
    lineType,
    tableBorderColor,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  const rowCellCls = `${componentCls}-expanded-row-cell`;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Row ==========================
      [`${componentCls}-tbody-virtual`]: {
        [`${componentCls}-tbody-virtual-holder-inner`]: {
          [`
            & > ${componentCls}-row, 
            & > div:not(${componentCls}-row) > ${componentCls}-row
          `]: {
            display: "flex",
            boxSizing: "border-box",
            width: "100%"
          }
        },
        [`${componentCls}-cell`]: {
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid}`
        },
        [`${componentCls}-expanded-row`]: {
          [`${rowCellCls}${rowCellCls}-fixed`]: {
            position: "sticky",
            insetInlineStart: 0,
            overflow: "hidden",
            width: `calc(var(--virtual-width) - ${unit(lineWidth)})`,
            borderInlineEnd: "none"
          }
        }
      },
      // ======================== Border =========================
      [`${componentCls}-bordered`]: {
        [`${componentCls}-tbody-virtual`]: {
          "&:after": {
            content: '""',
            insetInline: 0,
            bottom: 0,
            borderBottom: tableBorder,
            position: "absolute"
          },
          [`${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            [`&${componentCls}-cell-fix-right-first:before`]: {
              content: '""',
              position: "absolute",
              insetBlock: 0,
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              borderInlineStart: tableBorder
            }
          }
        },
        // Empty placeholder
        [`&${componentCls}-virtual`]: {
          [`${componentCls}-placeholder ${componentCls}-cell`]: {
            borderInlineEnd: tableBorder,
            borderBottom: tableBorder
          }
        }
      }
    }
  };
};
var virtual_default = genVirtualStyle;

// node_modules/antd/es/table/style/index.js
var genTableStyle = (token2) => {
  const {
    componentCls,
    fontWeightStrong,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandColumnWidth,
    lineWidth,
    lineType,
    tableBorderColor,
    tableFontSize,
    tableBg,
    tableRadius,
    tableHeaderTextColor,
    motionDurationMid,
    tableHeaderBg,
    tableHeaderCellSplitColor,
    tableFooterTextColor,
    tableFooterBg,
    calc
  } = token2;
  const tableBorder = `${unit(lineWidth)} ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      clear: "both",
      maxWidth: "100%",
      // fix https://github.com/ant-design/ant-design/issues/46177
      ["--rc-virtual-list-scrollbar-bg"]: token2.tableScrollBg,
      ...clearFix(),
      [componentCls]: {
        ...resetComponent(token2),
        fontSize: tableFontSize,
        background: tableBg,
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        // https://github.com/ant-design/ant-design/issues/47486
        scrollbarColor: `${token2.tableScrollThumbBg} ${token2.tableScrollBg}`
      },
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${unit(tableRadius)} ${unit(tableRadius)} 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell ==============================
      [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${componentCls}-title`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`
      },
      // ============================ Header ============================
      [`${componentCls}-thead`]: {
        [`
          > tr > th,
          > tr > td
        `]: {
          position: "relative",
          color: tableHeaderTextColor,
          fontWeight: fontWeightStrong,
          textAlign: "start",
          background: tableHeaderBg,
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: tableHeaderCellSplitColor,
            transform: "translateY(-50%)",
            transition: `background-color ${motionDurationMid}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      [`${componentCls}-tbody`]: {
        "> tr": {
          "> th, > td": {
            transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
            borderBottom: tableBorder,
            // ========================= Nest Table ===========================
            [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
              [componentCls]: {
                marginBlock: unit(calc(tablePaddingVertical).mul(-1).equal()),
                marginInline: `${unit(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                [`${componentCls}-tbody > tr:last-child > td`]: {
                  borderBottomWidth: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          "> th": {
            position: "relative",
            color: tableHeaderTextColor,
            fontWeight: fontWeightStrong,
            textAlign: "start",
            background: tableHeaderBg,
            borderBottom: tableBorder,
            transition: `background ${motionDurationMid} ease`
          },
          // measure cell styles
          [`& > ${componentCls}-measure-cell`]: {
            paddingBlock: `0 !important`,
            borderBlock: `0 !important`,
            [`${componentCls}-measure-cell-content`]: {
              height: 0,
              overflow: "hidden",
              pointerEvents: "none"
            }
          }
        }
      },
      // ============================ Footer ============================
      [`${componentCls}-footer`]: {
        padding: `${unit(tablePaddingVertical)} ${unit(tablePaddingHorizontal)}`,
        color: tableFooterTextColor,
        background: tableFooterBg
      }
    }
  };
};
var prepareComponentToken52 = (token2) => {
  const {
    colorFillAlter,
    colorBgContainer,
    colorTextHeading,
    colorFillSecondary,
    colorFillContent,
    controlItemBgActive,
    controlItemBgActiveHover,
    padding,
    paddingSM,
    paddingXS,
    colorBorderSecondary,
    borderRadiusLG,
    controlHeight,
    colorTextPlaceholder,
    fontSize,
    fontSizeSM,
    lineHeight,
    lineWidth,
    colorIcon,
    colorIconHover,
    opacityLoading,
    controlInteractiveSize
  } = token2;
  const colorFillSecondarySolid = new FastColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
  const colorFillContentSolid = new FastColor(colorFillContent).onBackground(colorBgContainer).toHexString();
  const colorFillAlterSolid = new FastColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
  const baseColorAction = new FastColor(colorIcon);
  const baseColorActionHover = new FastColor(colorIconHover);
  const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
  const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
  return {
    headerBg: colorFillAlterSolid,
    headerColor: colorTextHeading,
    headerSortActiveBg: colorFillSecondarySolid,
    headerSortHoverBg: colorFillContentSolid,
    bodySortBg: colorFillAlterSolid,
    rowHoverBg: colorFillAlterSolid,
    rowSelectedBg: controlItemBgActive,
    rowSelectedHoverBg: controlItemBgActiveHover,
    rowExpandedBg: colorFillAlter,
    cellPaddingBlock: padding,
    cellPaddingInline: padding,
    cellPaddingBlockMD: paddingSM,
    cellPaddingInlineMD: paddingXS,
    cellPaddingBlockSM: paddingXS,
    cellPaddingInlineSM: paddingXS,
    borderColor: colorBorderSecondary,
    headerBorderRadius: borderRadiusLG,
    footerBg: colorFillAlterSolid,
    footerColor: colorTextHeading,
    cellFontSize: fontSize,
    cellFontSizeMD: fontSize,
    cellFontSizeSM: fontSize,
    headerSplitColor: colorBorderSecondary,
    fixedHeaderSortActiveBg: colorFillSecondarySolid,
    headerFilterHoverBg: colorFillContent,
    filterDropdownMenuBg: colorBgContainer,
    filterDropdownBg: colorBgContainer,
    expandIconBg: colorBgContainer,
    selectionColumnWidth: controlHeight,
    stickyScrollBarBg: colorTextPlaceholder,
    stickyScrollBarBorderRadius: 100,
    expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
    headerIconColor: baseColorAction.clone().setA(baseColorAction.a * opacityLoading).toRgbString(),
    headerIconHoverColor: baseColorActionHover.clone().setA(baseColorActionHover.a * opacityLoading).toRgbString(),
    expandIconHalfInner,
    expandIconSize,
    expandIconScale: controlInteractiveSize / expandIconSize
  };
};
var zIndexTableFixed = 2;
var style_default59 = genStyleHooks("Table", (token2) => {
  const {
    colorTextHeading,
    colorSplit,
    colorBgContainer,
    controlInteractiveSize: checkboxSize,
    headerBg,
    headerColor,
    headerSortActiveBg,
    headerSortHoverBg,
    bodySortBg,
    rowHoverBg,
    rowSelectedBg,
    rowSelectedHoverBg,
    rowExpandedBg,
    cellPaddingBlock,
    cellPaddingInline,
    cellPaddingBlockMD,
    cellPaddingInlineMD,
    cellPaddingBlockSM,
    cellPaddingInlineSM,
    borderColor,
    footerBg,
    footerColor,
    headerBorderRadius,
    cellFontSize,
    cellFontSizeMD,
    cellFontSizeSM,
    headerSplitColor,
    fixedHeaderSortActiveBg,
    headerFilterHoverBg,
    filterDropdownBg,
    expandIconBg,
    selectionColumnWidth,
    stickyScrollBarBg,
    calc
  } = token2;
  const tableToken = merge2(token2, {
    tableFontSize: cellFontSize,
    tableBg: colorBgContainer,
    tableRadius: headerBorderRadius,
    tablePaddingVertical: cellPaddingBlock,
    tablePaddingHorizontal: cellPaddingInline,
    tablePaddingVerticalMiddle: cellPaddingBlockMD,
    tablePaddingHorizontalMiddle: cellPaddingInlineMD,
    tablePaddingVerticalSmall: cellPaddingBlockSM,
    tablePaddingHorizontalSmall: cellPaddingInlineSM,
    tableBorderColor: borderColor,
    tableHeaderTextColor: headerColor,
    tableHeaderBg: headerBg,
    tableFooterTextColor: footerColor,
    tableFooterBg: footerBg,
    tableHeaderCellSplitColor: headerSplitColor,
    tableHeaderSortBg: headerSortActiveBg,
    tableHeaderSortHoverBg: headerSortHoverBg,
    tableBodySortBg: bodySortBg,
    tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
    tableHeaderFilterActiveBg: headerFilterHoverBg,
    tableFilterDropdownBg: filterDropdownBg,
    tableRowHoverBg: rowHoverBg,
    tableSelectedRowBg: rowSelectedBg,
    tableSelectedRowHoverBg: rowSelectedHoverBg,
    zIndexTableFixed,
    tableFontSizeMiddle: cellFontSizeMD,
    tableFontSizeSmall: cellFontSizeSM,
    tableSelectionColumnWidth: selectionColumnWidth,
    tableExpandIconBg: expandIconBg,
    tableExpandColumnWidth: calc(checkboxSize).add(calc(token2.padding).mul(2)).equal(),
    tableExpandedRowBg: rowExpandedBg,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    // Mac scroll bar size
    tableScrollThumbBg: stickyScrollBarBg,
    tableScrollThumbBgHover: colorTextHeading,
    tableScrollBg: colorSplit
  });
  return [genTableStyle(tableToken), pagination_default2(tableToken), summary_default(tableToken), sorter_default(tableToken), filter_default(tableToken), bordered_default2(tableToken), radius_default(tableToken), expand_default(tableToken), summary_default(tableToken), empty_default3(tableToken), selection_default(tableToken), fixed_default(tableToken), sticky_default(tableToken), ellipsis_default(tableToken), size_default(tableToken), rtl_default3(tableToken), virtual_default(tableToken)];
}, prepareComponentToken52, {
  resetFont: false,
  unitless: {
    expandIconScale: true
  }
});

// node_modules/antd/es/table/InternalTable.js
var EMPTY_LIST6 = [];
var InternalTable = (props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    classNames,
    styles,
    size: customizeSize,
    bordered,
    dropdownPrefixCls: customizeDropdownPrefixCls,
    dataSource,
    pagination,
    rowSelection,
    rowKey: customizeRowKey,
    rowClassName,
    columns,
    children,
    childrenColumnName: legacyChildrenColumnName,
    onChange,
    getPopupContainer,
    loading,
    expandIcon,
    expandable,
    expandedRowRender,
    expandIconColumnIndex,
    indentSize,
    scroll,
    sortDirections,
    locale: locale6,
    showSorterTooltip = {
      target: "full-header"
    },
    virtual
  } = props;
  const warning5 = devUseWarning("Table");
  const baseColumns = React590.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
  const needResponsive = React590.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
  const screens = useBreakpoint_default(needResponsive);
  const mergedColumns = React590.useMemo(() => {
    const matched = new Set(Object.keys(screens).filter((m) => screens[m]));
    return baseColumns.filter((c) => !c.responsive || c.responsive.some((r2) => matched.has(r2)));
  }, [baseColumns, screens]);
  const tableProps = omit(props, ["className", "style", "columns"]);
  const {
    locale: contextLocale = en_US_default6,
    table
  } = React590.useContext(ConfigContext);
  const {
    getPrefixCls,
    direction,
    renderEmpty,
    getPopupContainer: getContextPopupContainer,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("table");
  const mergedSize = useSize_default(customizeSize);
  const mergedProps = {
    ...props,
    size: mergedSize,
    bordered
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    pagination: {
      _default: "root"
    },
    header: {
      _default: "wrapper"
    },
    body: {
      _default: "wrapper"
    }
  });
  const tableLocale = {
    ...contextLocale.Table,
    ...locale6
  };
  const [globalLocale] = useLocale_default("global", en_US_default6.global);
  const rawData = dataSource || EMPTY_LIST6;
  const prefixCls = getPrefixCls("table", customizePrefixCls);
  const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
  const [, token2] = useToken();
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default59(prefixCls, rootCls);
  const mergedExpandable = {
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex,
    ...expandable,
    expandIcon: (expandable == null ? void 0 : expandable.expandIcon) ?? ((_a = table == null ? void 0 : table.expandable) == null ? void 0 : _a.expandIcon)
  };
  const {
    childrenColumnName = "children"
  } = mergedExpandable;
  const expandType = React590.useMemo(() => {
    if (rawData.some((item) => item == null ? void 0 : item[childrenColumnName])) {
      return "nest";
    }
    if (expandedRowRender || (expandable == null ? void 0 : expandable.expandedRowRender)) {
      return "row";
    }
    return null;
  }, [childrenColumnName, rawData]);
  const internalRefs = {
    body: React590.useRef(null)
  };
  const getContainerWidth = useContainerWidth(prefixCls);
  const rootRef = React590.useRef(null);
  const tblRef = React590.useRef(null);
  useProxyImperativeHandle(ref, () => ({
    ...tblRef.current,
    nativeElement: rootRef.current
  }));
  const rowKey = customizeRowKey || (table == null ? void 0 : table.rowKey) || "key";
  if (true) {
    true ? warning5(!(typeof rowKey === "function" && rowKey.length > 1), "usage", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.") : void 0;
  }
  const getRowKey = React590.useMemo(() => {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return (record) => record == null ? void 0 : record[rowKey];
  }, [rowKey]);
  const [getRecordByKey] = useLazyKVMap_default(rawData, childrenColumnName, getRowKey);
  const changeEventInfo = {};
  const triggerOnChange = (info, action, reset = false) => {
    var _a2, _b, _c, _d;
    const changeInfo = {
      ...changeEventInfo,
      ...info
    };
    if (reset) {
      (_a2 = changeEventInfo.resetPagination) == null ? void 0 : _a2.call(changeEventInfo);
      if ((_b = changeInfo.pagination) == null ? void 0 : _b.current) {
        changeInfo.pagination.current = 1;
      }
      if (pagination) {
        (_d = pagination.onChange) == null ? void 0 : _d.call(pagination, 1, (_c = changeInfo.pagination) == null ? void 0 : _c.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo(0, {
        getContainer: () => internalRefs.body.current
      });
    }
    onChange == null ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates, childrenColumnName),
      action
    });
  };
  const onSorterChange = (sorter, sorterStates) => {
    triggerOnChange({
      sorter,
      sorterStates
    }, "sort", false);
  };
  const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useSorter_default({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip,
    globalLocale
  });
  const sortedData = React590.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [childrenColumnName, rawData, sortStates]);
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  const onFilterChange = (filters2, filterStates2) => {
    triggerOnChange({
      filters: filters2,
      filterStates: filterStates2
    }, "filter", true);
  };
  const [transformFilterColumns, filterStates, filters] = useFilter_default({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    rootClassName: clsx(rootClassName, rootCls)
  });
  const mergedData = getFilterData(sortedData, filterStates, childrenColumnName);
  changeEventInfo.filters = filters;
  changeEventInfo.filterStates = filterStates;
  const columnTitleProps = React590.useMemo(() => {
    const mergedFilters = {};
    Object.keys(filters).forEach((filterKey) => {
      if (filters[filterKey] !== null) {
        mergedFilters[filterKey] = filters[filterKey];
      }
    });
    return {
      ...sorterTitleProps,
      filters: mergedFilters
    };
  }, [sorterTitleProps, filters]);
  const [transformTitleColumns] = useTitleColumns_default(columnTitleProps);
  const onPaginationChange = (current, pageSize) => {
    triggerOnChange({
      pagination: {
        ...changeEventInfo.pagination,
        current,
        pageSize
      }
    }, "paginate");
  };
  const [mergedPagination, resetPagination] = usePagination_default(mergedData.length, onPaginationChange, pagination);
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
  changeEventInfo.resetPagination = resetPagination;
  const pageData = React590.useMemo(() => {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    const {
      current = 1,
      total,
      pageSize = DEFAULT_PAGE_SIZE
    } = mergedPagination;
    true ? warning5(current > 0, "usage", "`current` should be positive number.") : void 0;
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        true ? warning5(false, "usage", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.") : void 0;
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination == null ? void 0 : mergedPagination.current, mergedPagination == null ? void 0 : mergedPagination.pageSize, mergedPagination == null ? void 0 : mergedPagination.total]);
  const [transformSelectionColumns, selectedKeySet] = useSelection_default({
    prefixCls,
    data: mergedData,
    pageData,
    getRowKey,
    getRecordByKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer: getPopupContainer || getContextPopupContainer
  }, rowSelection);
  const internalRowClassName = (record, index2, indent) => {
    const resolvedRowClassName = typeof rowClassName === "function" ? rowClassName(record, index2, indent) : rowClassName;
    return clsx({
      [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index2))
    }, resolvedRowClassName);
  };
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || ExpandIcon_default(tableLocale);
  if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  if (typeof mergedExpandable.indentSize !== "number") {
    mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
  }
  const transformColumns = React590.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  let topPaginationNode;
  let bottomPaginationNode;
  if (pagination !== false && (mergedPagination == null ? void 0 : mergedPagination.total)) {
    let paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    }
    const renderPagination = (placement2 = "end") => React590.createElement(pagination_default, {
      ...mergedPagination,
      classNames: mergedClassNames.pagination,
      styles: mergedStyles.pagination,
      className: clsx(`${prefixCls}-pagination ${prefixCls}-pagination-${placement2}`, mergedPagination.className),
      size: paginationSize
    });
    const {
      placement,
      position: position3
    } = mergedPagination;
    const mergedPlacement = placement ?? position3;
    const normalizePlacement = (pos) => {
      const lowerPos = pos.toLowerCase();
      if (lowerPos.includes("center")) {
        return "center";
      }
      return lowerPos.includes("left") || lowerPos.includes("start") ? "start" : "end";
    };
    if (Array.isArray(mergedPlacement)) {
      const [topPos, bottomPos] = ["top", "bottom"].map((dir) => mergedPlacement.find((p) => p.includes(dir)));
      const isDisable = mergedPlacement.every((p) => `${p}` === "none");
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination();
      }
      if (topPos) {
        topPaginationNode = renderPagination(normalizePlacement(topPos));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(normalizePlacement(bottomPos));
      }
    } else {
      bottomPaginationNode = renderPagination();
    }
    if (true) {
      warning5.deprecated(!position3, "pagination.position", "pagination.placement");
    }
  }
  const spinProps = React590.useMemo(() => {
    if (typeof loading === "boolean") {
      return {
        spinning: loading
      };
    } else if (typeof loading === "object" && loading !== null) {
      return {
        spinning: true,
        ...loading
      };
    } else {
      return void 0;
    }
  }, [loading]);
  const wrappercls = clsx(cssVarCls, rootCls, `${prefixCls}-wrapper`, contextClassName, {
    [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
  }, className, rootClassName, mergedClassNames.root, hashId);
  const mergedStyle = {
    ...mergedStyles.root,
    ...contextStyle,
    ...style2
  };
  const mergedEmptyNode = React590.useMemo(() => {
    if ((spinProps == null ? void 0 : spinProps.spinning) && rawData === EMPTY_LIST6) {
      return null;
    }
    if (typeof (locale6 == null ? void 0 : locale6.emptyText) !== "undefined") {
      return locale6.emptyText;
    }
    return (renderEmpty == null ? void 0 : renderEmpty("Table")) || React590.createElement(defaultRenderEmpty_default, {
      componentName: "Table"
    });
  }, [spinProps == null ? void 0 : spinProps.spinning, rawData, locale6 == null ? void 0 : locale6.emptyText, renderEmpty]);
  const TableComponent = virtual ? VirtualTable_default2 : RcTable_default;
  const virtualProps = {};
  const listItemHeight = React590.useMemo(() => {
    const {
      fontSize,
      lineHeight,
      lineWidth,
      padding,
      paddingXS,
      paddingSM
    } = token2;
    const fontHeight = Math.floor(fontSize * lineHeight);
    switch (mergedSize) {
      case "middle":
        return paddingSM * 2 + fontHeight + lineWidth;
      case "small":
        return paddingXS * 2 + fontHeight + lineWidth;
      default:
        return padding * 2 + fontHeight + lineWidth;
    }
  }, [token2, mergedSize]);
  if (virtual) {
    virtualProps.listItemHeight = listItemHeight;
  }
  return React590.createElement("div", {
    ref: rootRef,
    className: wrappercls,
    style: mergedStyle
  }, React590.createElement(spin_default, {
    spinning: false,
    ...spinProps
  }, topPaginationNode, React590.createElement(TableComponent, {
    ...virtualProps,
    ...tableProps,
    classNames: mergedClassNames,
    styles: mergedStyles,
    ref: tblRef,
    columns: mergedColumns,
    direction,
    expandable: mergedExpandable,
    prefixCls,
    className: clsx({
      [`${prefixCls}-middle`]: mergedSize === "middle",
      [`${prefixCls}-small`]: mergedSize === "small",
      [`${prefixCls}-bordered`]: bordered,
      [`${prefixCls}-empty`]: rawData.length === 0
    }, cssVarCls, rootCls, hashId),
    data: pageData,
    rowKey: getRowKey,
    rowClassName: internalRowClassName,
    emptyText: mergedEmptyNode,
    // Internal
    internalHooks: INTERNAL_HOOKS,
    internalRefs,
    transformColumns,
    getContainerWidth,
    measureRowRender: (measureRow) => React590.createElement(config_provider_default, {
      getPopupContainer: (node2) => node2
    }, measureRow)
  }), bottomPaginationNode));
};
var InternalTable_default = React590.forwardRef(InternalTable);

// node_modules/antd/es/table/Table.js
var Table2 = (props, ref) => {
  const renderTimesRef = React591.useRef(0);
  renderTimesRef.current += 1;
  return React591.createElement(InternalTable_default, {
    ...props,
    ref,
    _renderTimes: renderTimesRef.current
  });
};
var ForwardTable = React591.forwardRef(Table2);
ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
ForwardTable.SELECTION_ALL = SELECTION_ALL;
ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
ForwardTable.SELECTION_NONE = SELECTION_NONE;
ForwardTable.Column = Column_default2;
ForwardTable.ColumnGroup = ColumnGroup_default2;
ForwardTable.Summary = FooterComponents;
if (true) {
  ForwardTable.displayName = "Table";
}
var Table_default2 = ForwardTable;

// node_modules/antd/es/table/index.js
var table_default = Table_default2;

// node_modules/antd/es/tag/index.js
var React595 = __toESM(require_react());

// node_modules/antd/es/tag/CheckableTag.js
var React592 = __toESM(require_react());

// node_modules/antd/es/tag/style/index.js
var genBaseStyle16 = (token2) => {
  const {
    paddingXXS,
    lineWidth,
    tagPaddingHorizontal,
    componentCls,
    calc
  } = token2;
  const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
  const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
  return {
    // Result
    [componentCls]: {
      ...resetComponent(token2),
      display: "inline-block",
      height: "auto",
      paddingInline,
      fontSize: token2.tagFontSize,
      lineHeight: token2.tagLineHeight,
      whiteSpace: "nowrap",
      backgroundColor: token2.defaultBg,
      border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: token2.borderRadiusSM,
      opacity: 1,
      transition: `all ${token2.motionDurationMid}`,
      textAlign: "start",
      position: "relative",
      // RTL
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: token2.defaultColor
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: iconMarginInline,
        fontSize: token2.tagIconSize,
        color: token2.colorIcon,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${componentCls}-checkable-checked):hover`]: {
          color: token2.colorPrimary,
          backgroundColor: token2.colorFillSecondary
        },
        "&:active, &-checked": {
          color: token2.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: token2.colorPrimary,
          "&:hover": {
            backgroundColor: token2.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: token2.colorPrimaryActive
        },
        "&-disabled": {
          cursor: "not-allowed",
          [`&:not(${componentCls}-checkable-checked)`]: {
            color: token2.colorTextDisabled,
            "&:hover": {
              backgroundColor: "transparent"
            }
          },
          [`&${componentCls}-checkable-checked`]: {
            color: token2.colorTextDisabled,
            backgroundColor: token2.colorBgContainerDisabled
          },
          "&:hover, &:active": {
            backgroundColor: token2.colorBgContainerDisabled,
            color: token2.colorTextDisabled
          },
          [`&:not(${componentCls}-checkable-checked):hover`]: {
            color: token2.colorTextDisabled
          }
        },
        "&-group": {
          display: "flex",
          flexWrap: "wrap",
          gap: token2.paddingXS
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
        marginInlineStart: paddingInline
      }
    },
    [`&${token2.componentCls}-solid`]: {
      borderColor: "transparent",
      color: token2.colorTextLightSolid,
      backgroundColor: token2.colorBgSolid,
      [`&${componentCls}-default`]: {
        color: token2.solidTextColor
      }
    },
    [`${componentCls}-filled`]: {
      borderColor: "transparent",
      backgroundColor: token2.tagBorderlessBg
    },
    [`&${componentCls}-disabled`]: {
      color: token2.colorTextDisabled,
      cursor: "not-allowed",
      backgroundColor: token2.colorBgContainerDisabled,
      a: {
        cursor: "not-allowed",
        pointerEvents: "none",
        color: token2.colorTextDisabled,
        "&:hover": {
          color: token2.colorTextDisabled
        }
      },
      "a&": {
        "&:hover, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`&${componentCls}-outlined`]: {
        borderColor: token2.colorBorderDisabled
      },
      [`&${componentCls}-solid, &${componentCls}-filled`]: {
        color: token2.colorTextDisabled,
        [`${componentCls}-close-icon`]: {
          color: token2.colorTextDisabled
        }
      },
      [`${componentCls}-close-icon`]: {
        cursor: "not-allowed",
        color: token2.colorTextDisabled,
        "&:hover": {
          color: token2.colorTextDisabled
        }
      }
    }
  };
};
var prepareToken6 = (token2) => {
  const {
    lineWidth,
    fontSizeIcon,
    calc
  } = token2;
  const tagFontSize = token2.fontSizeSM;
  const tagToken = merge2(token2, {
    tagFontSize,
    tagLineHeight: unit(calc(token2.lineHeightSM).mul(tagFontSize).equal()),
    tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
    // Tag icon is much smaller
    tagPaddingHorizontal: 8,
    // Fixed padding.
    tagBorderlessBg: token2.defaultBg
  });
  return tagToken;
};
var prepareComponentToken53 = (token2) => {
  const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
  return {
    defaultBg: new FastColor(token2.colorFillQuaternary).onBackground(token2.colorBgContainer).toHexString(),
    defaultColor: token2.colorText,
    solidTextColor
  };
};
var style_default60 = genStyleHooks("Tag", (token2) => {
  const tagToken = prepareToken6(token2);
  return genBaseStyle16(tagToken);
}, prepareComponentToken53);

// node_modules/antd/es/tag/CheckableTag.js
var CheckableTag = React592.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    style: style2,
    className,
    checked,
    children,
    icon,
    onChange,
    onClick,
    disabled: customDisabled,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    tag
  } = React592.useContext(ConfigContext);
  const disabled = React592.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const handleClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    onChange == null ? void 0 : onChange(!checked);
    onClick == null ? void 0 : onClick(e3);
  };
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [hashId, cssVarCls] = style_default60(prefixCls);
  const cls = clsx(prefixCls, `${prefixCls}-checkable`, {
    [`${prefixCls}-checkable-checked`]: checked,
    [`${prefixCls}-checkable-disabled`]: mergedDisabled
  }, tag == null ? void 0 : tag.className, className, hashId, cssVarCls);
  return React592.createElement("span", {
    ...restProps,
    ref,
    style: {
      ...style2,
      ...tag == null ? void 0 : tag.style
    },
    className: cls,
    onClick: handleClick
  }, icon, React592.createElement("span", null, children));
});
var CheckableTag_default = CheckableTag;

// node_modules/antd/es/tag/CheckableTagGroup.js
var import_react217 = __toESM(require_react());
function CheckableTagGroup(props, ref) {
  const {
    id,
    prefixCls: customizePrefixCls,
    rootClassName,
    className,
    style: style2,
    classNames,
    styles,
    disabled,
    options,
    value,
    defaultValue,
    onChange,
    multiple,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tag");
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-checkable-group`;
  const rootCls = useCSSVarCls_default(prefixCls);
  const [hashId, cssVarCls] = style_default60(prefixCls, rootCls);
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props
  });
  const parsedOptions = (0, import_react217.useMemo)(() => (options || []).map((option) => {
    if (option && typeof option === "object") {
      return option;
    }
    return {
      value: option,
      label: option
    };
  }), [options]);
  const [mergedValue, setMergedValue] = useControlledState(defaultValue, value);
  const handleChange = (checked, option) => {
    let newValue = null;
    if (multiple) {
      const valueList = mergedValue || [];
      newValue = checked ? [].concat(_toConsumableArray(valueList), [option.value]) : valueList.filter((item) => item !== option.value);
    } else {
      newValue = checked ? option.value : null;
    }
    setMergedValue(newValue);
    onChange == null ? void 0 : onChange(newValue);
  };
  const divRef = import_react217.default.useRef(null);
  (0, import_react217.useImperativeHandle)(ref, () => ({
    nativeElement: divRef.current
  }));
  const ariaProps = pickAttrs(restProps, {
    aria: true,
    data: true
  });
  return import_react217.default.createElement("div", {
    ...ariaProps,
    className: clsx(groupPrefixCls, contextClassName, rootClassName, {
      [`${groupPrefixCls}-disabled`]: disabled,
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    }, hashId, cssVarCls, className, mergedClassNames.root),
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style2
    },
    id,
    ref: divRef
  }, parsedOptions.map((option) => import_react217.default.createElement(CheckableTag_default, {
    key: option.value,
    className: clsx(`${groupPrefixCls}-item`, mergedClassNames.item),
    style: mergedStyles.item,
    checked: multiple ? (mergedValue || []).includes(option.value) : mergedValue === option.value,
    onChange: (checked) => handleChange(checked, option),
    disabled
  }, option.label)));
}
var ForwardCheckableTagGroup = import_react217.default.forwardRef(CheckableTagGroup);
if (true) {
  ForwardCheckableTagGroup.displayName = "CheckableTagGroup";
}
var CheckableTagGroup_default = ForwardCheckableTagGroup;

// node_modules/antd/es/tag/hooks/useColor.js
var React594 = __toESM(require_react());
function useColor(props, contextVariant) {
  const {
    color,
    variant,
    bordered
  } = props;
  return React594.useMemo(() => {
    const isInverseColor = color == null ? void 0 : color.endsWith("-inverse");
    let nextVariant;
    if (variant) {
      nextVariant = variant;
    } else if (isInverseColor) {
      nextVariant = "solid";
    } else if (bordered === false) {
      nextVariant = "filled";
    } else {
      nextVariant = contextVariant || "filled";
    }
    const nextColor = isInverseColor ? color == null ? void 0 : color.replace("-inverse", "") : color;
    const nextIsPreset = isPresetColor(color);
    const nextIsStatus = isPresetStatusColor(color);
    const tagStyle = {};
    if (!nextIsPreset && !nextIsStatus && nextColor) {
      if (nextVariant === "solid") {
        tagStyle.backgroundColor = color;
      } else {
        const hsl = new FastColor(nextColor).toHsl();
        hsl.l = 0.95;
        tagStyle.backgroundColor = new FastColor(hsl).toHexString();
        tagStyle.color = color;
        if (nextVariant === "outlined") {
          tagStyle.borderColor = color;
        }
      }
    }
    return [nextVariant, nextColor, nextIsPreset, nextIsStatus, tagStyle];
  }, [color, variant, bordered, contextVariant]);
}

// node_modules/antd/es/tag/style/presetCmp.js
var genPresetStyle = (token2) => genPresetColor(token2, (colorKey, {
  textColor,
  lightBorderColor,
  lightColor,
  darkColor
}) => ({
  [`${token2.componentCls}${token2.componentCls}-${colorKey}:not(${token2.componentCls}-disabled)`]: {
    [`&${token2.componentCls}-outlined`]: {
      backgroundColor: lightColor,
      borderColor: lightBorderColor,
      color: textColor
    },
    [`&${token2.componentCls}-solid`]: {
      backgroundColor: darkColor,
      borderColor: darkColor,
      color: token2.colorTextLightSolid
    },
    [`&${token2.componentCls}-filled`]: {
      backgroundColor: lightColor,
      color: textColor
    }
  }
}));
var presetCmp_default = genSubStyleComponent(["Tag", "preset"], (token2) => {
  const tagToken = prepareToken6(token2);
  return genPresetStyle(tagToken);
}, prepareComponentToken53);

// node_modules/antd/es/_util/capitalize.js
function capitalize(str) {
  if (typeof str !== "string") {
    return str;
  }
  const ret = str.charAt(0).toUpperCase() + str.slice(1);
  return ret;
}

// node_modules/antd/es/tag/style/statusCmp.js
var genTagStatusStyle = (token2, status, cssVariableType) => {
  const capitalizedCssVariableType = capitalize(cssVariableType);
  return {
    [`${token2.componentCls}${token2.componentCls}-${status}:not(${token2.componentCls}-disabled)`]: {
      [`&${token2.componentCls}-outlined`]: {
        backgroundColor: token2[`color${capitalizedCssVariableType}Bg`],
        borderColor: token2[`color${capitalizedCssVariableType}Border`],
        color: token2[`color${cssVariableType}`]
      },
      [`&${token2.componentCls}-solid`]: {
        backgroundColor: token2[`color${cssVariableType}`],
        borderColor: token2[`color${cssVariableType}`]
      },
      [`&${token2.componentCls}-filled`]: {
        backgroundColor: token2[`color${capitalizedCssVariableType}Bg`],
        color: token2[`color${cssVariableType}`]
      }
    }
  };
};
var statusCmp_default = genSubStyleComponent(["Tag", "status"], (token2) => {
  const tagToken = prepareToken6(token2);
  return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
}, prepareComponentToken53);

// node_modules/antd/es/tag/index.js
var InternalTag = React595.forwardRef((props, ref) => {
  var _a;
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    children,
    icon,
    color,
    variant: _variant,
    onClose,
    bordered,
    disabled: customDisabled,
    href,
    target,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    variant: contextVariant,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tag");
  if (true) {
    const warning5 = devUseWarning("Tag");
    warning5.deprecated(bordered !== false, "bordered={false}", 'variant="filled"');
    warning5.deprecated(!(color == null ? void 0 : color.endsWith("-inverse")), 'color="xxx-inverse"', 'variant="solid"');
  }
  const [mergedVariant, mergedColor, isPreset, isStatus, customTagStyle] = useColor(props, contextVariant);
  const isInternalColor = isPreset || isStatus;
  const disabled = React595.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    tag: tagContext
  } = React595.useContext(ConfigContext);
  const [visible, setVisible] = React595.useState(true);
  const domProps = omit(restProps, ["closeIcon", "closable"]);
  const mergedProps = {
    ...props,
    color: mergedColor,
    variant: mergedVariant,
    disabled: mergedDisabled,
    href,
    target,
    icon
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const tagStyle = React595.useMemo(() => {
    let nextTagStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    if (!mergedDisabled) {
      nextTagStyle = {
        ...customTagStyle,
        ...nextTagStyle
      };
    }
    return nextTagStyle;
  }, [mergedStyles.root, contextStyle, style2, customTagStyle, mergedDisabled]);
  const prefixCls = getPrefixCls("tag", customizePrefixCls);
  const [hashId, cssVarCls] = style_default60(prefixCls);
  const tagClassName = clsx(prefixCls, contextClassName, mergedClassNames.root, `${prefixCls}-${mergedVariant}`, {
    [`${prefixCls}-${mergedColor}`]: isInternalColor,
    [`${prefixCls}-hidden`]: !visible,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-disabled`]: mergedDisabled
  }, className, rootClassName, hashId, cssVarCls);
  const handleCloseClick = (e3) => {
    if (mergedDisabled) {
      return;
    }
    e3.stopPropagation();
    onClose == null ? void 0 : onClose(e3);
    if (e3.defaultPrevented) {
      return;
    }
    setVisible(false);
  };
  const [, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(tagContext), {
    closable: false,
    closeIconRender: (iconNode2) => {
      const replacement = React595.createElement("span", {
        className: `${prefixCls}-close-icon`,
        onClick: handleCloseClick
      }, iconNode2);
      return replaceElement(iconNode2, replacement, (originProps) => ({
        onClick: (e3) => {
          var _a2;
          (_a2 = originProps == null ? void 0 : originProps.onClick) == null ? void 0 : _a2.call(originProps, e3);
          handleCloseClick(e3);
        },
        className: clsx(originProps == null ? void 0 : originProps.className, `${prefixCls}-close-icon`)
      }));
    }
  });
  const isNeedWave = typeof restProps.onClick === "function" || children && children.type === "a";
  const iconNode = cloneElement3(icon, {
    className: clsx(React595.isValidElement(icon) ? (_a = icon.props) == null ? void 0 : _a.className : "", mergedClassNames.icon),
    style: mergedStyles.icon
  });
  const child = iconNode ? React595.createElement(React595.Fragment, null, iconNode, children && React595.createElement("span", {
    className: mergedClassNames.content,
    style: mergedStyles.content
  }, children)) : children;
  const TagWrapper = href ? "a" : "span";
  const tagNode = React595.createElement(TagWrapper, {
    ...domProps,
    // @ts-expect-error
    ref,
    className: tagClassName,
    style: tagStyle,
    href: mergedDisabled ? void 0 : href,
    target,
    onClick: mergedDisabled ? void 0 : domProps.onClick,
    ...href && mergedDisabled ? {
      "aria-disabled": true
    } : {}
  }, child, mergedCloseIcon, isPreset && React595.createElement(presetCmp_default, {
    key: "preset",
    prefixCls
  }), isStatus && React595.createElement(statusCmp_default, {
    key: "status",
    prefixCls
  }));
  return isNeedWave ? React595.createElement(wave_default, {
    component: "Tag"
  }, tagNode) : tagNode;
});
var Tag = InternalTag;
if (true) {
  Tag.displayName = "Tag";
}
Tag.CheckableTag = CheckableTag_default;
Tag.CheckableTagGroup = CheckableTagGroup_default;
var tag_default = Tag;

// node_modules/antd/es/theme/getDesignToken.js
var getDesignToken = (config) => {
  const theme = (config == null ? void 0 : config.algorithm) ? createTheme(config.algorithm) : theme_default;
  const mergedToken = {
    ...seed_default,
    ...config == null ? void 0 : config.token
  };
  return getComputedToken(mergedToken, {
    override: config == null ? void 0 : config.token
  }, theme, formatToken);
};
var getDesignToken_default = getDesignToken;

// node_modules/antd/es/theme/themes/compact/genCompactSizeMapToken.js
function genSizeMapToken2(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}

// node_modules/antd/es/theme/themes/compact/index.js
var derivative2 = (token2, mapToken) => {
  const mergedMapToken = mapToken ?? derivative(token2);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return {
    ...mergedMapToken,
    ...genSizeMapToken2(mapToken ?? token2),
    // font
    ...genFontMapToken_default(fontSize),
    // controlHeight
    controlHeight,
    ...genControlHeight_default({
      ...mergedMapToken,
      controlHeight
    })
  };
};
var compact_default3 = derivative2;

// node_modules/antd/es/theme/themes/dark/colorAlgorithm.js
var getAlphaColor3 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
var getSolidColor2 = (baseColor, brightness) => {
  const instance = new FastColor(baseColor);
  return instance.lighten(brightness).toHexString();
};

// node_modules/antd/es/theme/themes/dark/colors.js
var generateColorPalettes2 = (baseColor) => {
  const colors = generate(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
  };
};
var generateNeutralColorPalettes2 = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor3(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor3(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor3(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor3(colorTextBase, 0.25),
    colorFill: getAlphaColor3(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor3(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor3(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor3(colorTextBase, 0.04),
    colorBgSolid: getAlphaColor3(colorTextBase, 0.95),
    colorBgSolidHover: getAlphaColor3(colorTextBase, 1),
    colorBgSolidActive: getAlphaColor3(colorTextBase, 0.9),
    colorBgElevated: getSolidColor2(colorBgBase, 12),
    colorBgContainer: getSolidColor2(colorBgBase, 8),
    colorBgLayout: getSolidColor2(colorBgBase, 0),
    colorBgSpotlight: getSolidColor2(colorBgBase, 26),
    colorBgBlur: getAlphaColor3(colorTextBase, 0.04),
    colorBorder: getSolidColor2(colorBgBase, 26),
    colorBorderDisabled: getSolidColor2(colorBgBase, 26),
    colorBorderSecondary: getSolidColor2(colorBgBase, 19)
  };
};

// node_modules/antd/es/theme/themes/dark/index.js
var derivative3 = (token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate(token2[colorKey], {
      theme: "dark"
    });
    return Array.from({
      length: 10
    }, () => 1).reduce((prev2, _, i) => {
      prev2[`${colorKey}-${i + 1}`] = colors[i];
      prev2[`${colorKey}${i + 1}`] = colors[i];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = {
      ...prev2,
      ...cur
    };
    return prev2;
  }, {});
  const mergedMapToken = mapToken ?? derivative(token2);
  const colorMapToken = genColorMapToken(token2, {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  });
  return {
    ...mergedMapToken,
    // Dark tokens
    ...colorPalettes,
    // Colors
    ...colorMapToken,
    // Customize selected item background color
    // https://github.com/ant-design/ant-design/issues/30524#issuecomment-871961867
    colorPrimaryBg: colorMapToken.colorPrimaryBorder,
    colorPrimaryBgHover: colorMapToken.colorPrimaryBorderHover
  };
};
var dark_default = derivative3;

// node_modules/antd/es/theme/index.js
function useToken2() {
  const [theme, token2, hashId, cssVar] = useToken();
  return {
    theme,
    token: token2,
    hashId,
    cssVar
  };
}
var theme_default3 = {
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  useToken: useToken2,
  defaultAlgorithm: derivative,
  darkAlgorithm: dark_default,
  compactAlgorithm: compact_default3,
  getDesignToken: getDesignToken_default,
  /**
   * @private Private variable
   * @warring  Do not use in production. 
   */
  defaultConfig,
  /**
   * @private Private variable
   * @warring  Do not use in production. 
   */
  _internalContext: DesignTokenContext
};

// node_modules/antd/es/time-picker/index.js
var React596 = __toESM(require_react());
var {
  TimePicker: InternalTimePicker,
  RangePicker: InternalRangePicker
} = date_picker_default;
var RangePicker2 = React596.forwardRef((props, ref) => React596.createElement(InternalRangePicker, {
  ...props,
  picker: "time",
  mode: void 0,
  ref
}));
var TimePicker = React596.forwardRef((props, ref) => {
  const {
    addon,
    renderExtraFooter,
    variant,
    bordered,
    classNames,
    styles,
    popupClassName,
    popupStyle,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("TimePicker");
    warning5.deprecated(!addon, "addon", "renderExtraFooter");
  }
  const [mergedVariant] = useVariants_default("timePicker", variant, bordered);
  const internalRenderExtraFooter = React596.useMemo(() => {
    if (renderExtraFooter) {
      return renderExtraFooter;
    }
    if (addon) {
      return addon;
    }
    return void 0;
  }, [addon, renderExtraFooter]);
  const mergedProps = {
    ...props,
    variant: mergedVariant
  };
  const [mergedClassNames, mergedStyles] = useMergedPickerSemantic_default("timePicker", classNames, styles, popupClassName, popupStyle, mergedProps);
  return React596.createElement(InternalTimePicker, {
    ...restProps,
    mode: void 0,
    ref,
    renderExtraFooter: internalRenderExtraFooter,
    variant: mergedVariant,
    classNames: mergedClassNames,
    styles: mergedStyles
  });
});
if (true) {
  TimePicker.displayName = "TimePicker";
}
var PurePanel16 = PurePanel_default3(TimePicker, "popupAlign", void 0, "picker");
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel16;
TimePicker.RangePicker = RangePicker2;
TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel16;
var time_picker_default = TimePicker;

// node_modules/antd/es/timeline/Timeline.js
var React598 = __toESM(require_react());

// node_modules/antd/es/timeline/style/horizontal.js
var genHorizontalStyle4 = (token2) => {
  const {
    componentCls,
    fontHeight
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}-horizontal`]: {
      "--steps-title-vertical-row-gap": token2.paddingXS,
      "--timeline-content-height": `${unit(fontHeight)}`,
      // =============================================================
      // ==                          Share                          ==
      // =============================================================
      alignItems: "stretch",
      // =============================================================
      // ==                        Alternate                        ==
      // =============================================================
      [`&${componentCls}-layout-alternate`]: {
        [itemCls]: {
          [`${itemCls}-wrapper`]: {
            "--timeline-alternate-content-offset": `calc(var(--timeline-content-height) + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`,
            height: `calc(var(--timeline-content-height) * 2 + var(--steps-title-vertical-row-gap) * 2 + var(--steps-icon-size-max))`
          },
          // Icon
          [`${itemCls}-icon`]: {
            position: "absolute"
          },
          // Icon & Rail
          [`${itemCls}-icon, ${itemCls}-rail`]: {
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%)",
            margin: 0
          },
          // Title & Content
          [`${itemCls}-title, ${itemCls}-subtitle, ${itemCls}-content`]: {
            whiteSpace: "nowrap",
            maxWidth: "unset"
          },
          // Title
          [`${itemCls}-title`]: {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%)"
          },
          // Content
          [`${itemCls}-content`]: {
            position: "absolute",
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%)"
          },
          // Placement
          "&-placement-start": {
            [`${itemCls}-title`]: {
              bottom: "var(--timeline-alternate-content-offset)"
            },
            [`${itemCls}-content`]: {
              top: "var(--timeline-alternate-content-offset)"
            }
          },
          "&-placement-end": {
            [`${itemCls}-title`]: {
              top: "var(--timeline-alternate-content-offset)"
            },
            [`${itemCls}-content`]: {
              bottom: "var(--timeline-alternate-content-offset)"
            }
          }
        }
      },
      // =============================================================
      // ==                        Same Side                        ==
      // =============================================================
      [`&:not(${componentCls}-layout-alternate)`]: {
        [`${itemCls}-placement-end`]: {
          display: "flex",
          alignItems: "flex-end",
          [`${itemCls}-wrapper`]: {
            flex: "auto",
            flexDirection: "column-reverse"
          },
          [`${itemCls}-rail`]: {
            top: "auto",
            bottom: "var(--steps-horizontal-rail-margin)",
            transform: "translateY(50%)"
          }
        }
      }
    }
  };
};
var horizontal_default3 = genHorizontalStyle4;

// node_modules/antd/es/timeline/style/index.js
var genTimelineStyle = (token2) => {
  const {
    componentCls,
    tailColor
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [componentCls]: [
      // ==============================================================
      // ==                           Item                           ==
      // ==============================================================
      {
        ...resetComponent(token2),
        [itemCls]: {
          "--steps-title-horizontal-title-height": token2.fontHeight,
          "--steps-vertical-rail-margin": "0px",
          "--steps-title-horizontal-rail-gap": "0px",
          // Root Level: Record Steps icon size and support fallback
          "--steps-icon-dot-size-origin": "var(--steps-icon-size-active)",
          "--steps-icon-dot-size-custom": token2.dotSize,
          // Item Level: Record Steps icon color and support fallback
          "--steps-item-icon-dot-bg-color-origin": "var(--steps-item-icon-dot-bg-color)",
          "--steps-item-icon-dot-bg-color-custom": token2.dotBg,
          "--steps-icon-size": "var(--steps-icon-dot-size-custom, var(--steps-icon-dot-size-origin))",
          // Icon
          [`${itemCls}-icon`]: {
            "--steps-dot-icon-border-width": token2.dotBorderWidth,
            "--steps-dot-icon-size": "var(--steps-icon-size)",
            "--steps-item-icon-dot-bg-color": "var(--steps-item-icon-dot-bg-color-custom, var(--steps-item-icon-dot-bg-color-origin))"
          },
          // Title
          [`${itemCls}-title`]: {
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          },
          // Content
          [`${itemCls}-content`]: {
            color: token2.colorText
          },
          // Rail
          [`${itemCls}-rail`]: {
            "--steps-item-solid-line-color": tailColor,
            "--steps-rail-size": token2.tailWidth
          }
        }
      },
      // ==============================================================
      // ==                          Status                          ==
      // ==============================================================
      {
        [itemCls]: {
          "--steps-item-process-rail-line-style": "dotted"
        },
        [`${itemCls}${itemCls}${itemCls}-color`]: {
          "&-blue": {
            "--steps-item-icon-dot-color": token2.colorPrimary
          },
          "&-red": {
            "--steps-item-icon-dot-color": token2.colorError
          },
          "&-green": {
            "--steps-item-icon-dot-color": token2.colorSuccess
          },
          "&-gray": {
            "--steps-item-icon-dot-color": token2.colorTextDisabled
          }
        }
      }
    ]
  };
};
var genVerticalStyle4 = (token2) => {
  const {
    calc,
    componentCls,
    itemPaddingBottom
  } = token2;
  const itemCls = `${componentCls}-item`;
  return {
    [`${componentCls}:not(${componentCls}-horizontal)`]: {
      "--timeline-head-span": "12",
      "--timeline-head-span-ptg": "calc(var(--timeline-head-span) / 24 * 100%)",
      // =============================================================
      // ==                        Alternate                        ==
      // =============================================================
      [`&${componentCls}-layout-alternate`]: {
        [itemCls]: {
          "--timeline-alternate-gap": calc(token2.margin).mul(2).add("var(--steps-dot-icon-size)").equal(),
          minHeight: "auto",
          paddingBottom: itemPaddingBottom,
          // Icon & Rail
          [`${itemCls}-icon, ${itemCls}-rail`]: {
            position: "absolute",
            insetInlineStart: "var(--timeline-head-span-ptg)"
          },
          // Icon
          [`${itemCls}-icon`]: {
            marginInlineStart: `calc(var(--steps-icon-size) / -2)`
          },
          // Section
          [`${itemCls}-section`]: {
            display: "flex",
            flexWrap: "nowrap",
            gap: "var(--timeline-alternate-gap)"
          },
          // >>> Header
          [`${itemCls}-header`]: {
            textAlign: "end",
            flexDirection: "column",
            alignItems: "stretch",
            flex: "1 1 calc(var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
          },
          // >>> Content
          [`${itemCls}-content`]: {
            textAlign: "start",
            flex: "1 1 calc(100% - var(--timeline-head-span-ptg) - var(--timeline-alternate-gap) / 2)"
          },
          // Placement
          "&-placement-end": {
            [`${itemCls}-header`]: {
              textAlign: "start",
              order: 1
            },
            [`${itemCls}-content`]: {
              textAlign: "end"
            },
            [`${itemCls}-icon, ${itemCls}-rail`]: {
              insetInlineStart: "calc(100% - var(--timeline-head-span-ptg))"
            }
          }
        }
      },
      // =============================================================
      // ==                        Same Side                        ==
      // =============================================================
      [`&:not(${componentCls}-layout-alternate)`]: {
        [`${itemCls}-placement-end`]: {
          textAlign: "end",
          [`${itemCls}-icon`]: {
            order: 1
          },
          [`${itemCls}-rail`]: {
            insetInlineStart: "auto",
            insetInlineEnd: "calc(var(--steps-icon-size) / 2)",
            marginInlineEnd: `calc(var(--steps-rail-size) / -2)`
          }
        }
      }
    }
  };
};
var prepareComponentToken54 = (token2) => ({
  tailColor: token2.colorSplit,
  tailWidth: token2.lineWidthBold,
  dotBorderWidth: token2.lineWidthBold,
  dotBg: void 0,
  dotSize: void 0,
  itemPaddingBottom: token2.padding * 1.25
});
var style_default61 = genStyleHooks("Timeline", (token2) => {
  const timeLineToken = merge2(token2, {
    itemHeadSize: 10,
    customHeadPaddingVertical: token2.paddingXXS,
    paddingInlineEnd: 2
  });
  return [genTimelineStyle(timeLineToken), genVerticalStyle4(timeLineToken), horizontal_default3(timeLineToken)];
}, prepareComponentToken54);

// node_modules/antd/es/timeline/useItems.js
var React597 = __toESM(require_react());
function useItems5(prefixCls, mode, items, children, pending, pendingDot) {
  const itemCls = `${prefixCls}-item`;
  const parseItems2 = React597.useMemo(() => {
    return Array.isArray(items) ? items : toArray(children).map((ele) => ({
      ...ele.props
    }));
  }, [items, children]);
  return React597.useMemo(() => {
    const mergedItems = parseItems2.map((item, index2) => {
      const {
        label,
        children: children2,
        title,
        content,
        color,
        className,
        style: style2,
        icon,
        dot,
        placement,
        position: position3,
        loading,
        ...restProps
      } = item;
      let mergedStyle = style2;
      let mergedClassName = className;
      if (color) {
        if (["blue", "red", "green", "gray"].includes(color)) {
          mergedClassName = clsx(className, `${itemCls}-color-${color}`);
        } else {
          mergedStyle = {
            "--steps-item-icon-dot-color": color,
            ...style2
          };
        }
      }
      const mergedPlacement = placement ?? position3 ?? (mode === "alternate" ? index2 % 2 === 0 ? "start" : "end" : mode);
      mergedClassName = clsx(mergedClassName, `${itemCls}-placement-${mergedPlacement}`);
      let mergedIcon = icon ?? dot;
      if (!mergedIcon && loading) {
        mergedIcon = React597.createElement(LoadingOutlined_default, null);
      }
      return {
        ...restProps,
        title: title ?? label,
        content: content ?? children2,
        style: mergedStyle,
        className: mergedClassName,
        icon: mergedIcon,
        status: loading ? "process" : "finish"
      };
    });
    if (pending) {
      mergedItems.push({
        icon: pendingDot ?? React597.createElement(LoadingOutlined_default, null),
        content: pending,
        status: "process"
      });
    }
    return mergedItems;
  }, [parseItems2, pending, pendingDot, itemCls, mode]);
}

// node_modules/antd/es/timeline/Timeline.js
var stepInternalContext = {
  rootComponent: "ol",
  itemComponent: "li"
};
var Timeline = (props) => {
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("timeline");
  const {
    prefixCls: customizePrefixCls,
    // Style
    className,
    style: style2,
    classNames,
    styles,
    // Design
    variant = "outlined",
    mode,
    orientation = "vertical",
    titleSpan,
    // Data
    items,
    children,
    reverse,
    // Legacy Pending
    pending,
    pendingDot,
    ...restProps
  } = props;
  const prefixCls = getPrefixCls("timeline", customizePrefixCls);
  const [hashId, cssVarCls] = style_default61(prefixCls);
  const stepsClassNames = React598.useMemo(() => ({
    item: `${prefixCls}-item`,
    itemTitle: `${prefixCls}-item-title`,
    itemIcon: `${prefixCls}-item-icon`,
    itemContent: `${prefixCls}-item-content`,
    itemRail: `${prefixCls}-item-rail`,
    itemWrapper: `${prefixCls}-item-wrapper`,
    itemSection: `${prefixCls}-item-section`,
    itemHeader: `${prefixCls}-item-header`
  }), [prefixCls]);
  const mergedMode = React598.useMemo(() => {
    if (mode === "left") {
      return "start";
    }
    if (mode === "right") {
      return "end";
    }
    const modeList = ["alternate", "start", "end"];
    return modeList.includes(mode) ? mode : "start";
  }, [mode]);
  const rawItems = useItems5(prefixCls, mergedMode, items, children, pending, pendingDot);
  const mergedItems = React598.useMemo(() => reverse ? _toConsumableArray(rawItems).reverse() : rawItems, [reverse, rawItems]);
  const mergedProps = {
    ...props,
    variant,
    mode: mergedMode,
    orientation,
    items: mergedItems
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([stepsClassNames, contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const stepContext = React598.useMemo(() => ({
    railFollowPrevStatus: reverse
  }), [reverse]);
  const layoutAlternate = React598.useMemo(() => mergedMode === "alternate" || orientation === "vertical" && mergedItems.some((item) => item.title), [mergedItems, mergedMode, orientation]);
  if (true) {
    const warning5 = devUseWarning("Timeline");
    warning5.deprecated(!children, "Timeline.Item", "items");
    const pendingWarning = "You can create a `item` as pending node directly.";
    warning5.deprecated(!pending, "pending", "items", pendingWarning);
    warning5.deprecated(!pendingDot, "pendingDot", "items", pendingWarning);
    warning5.deprecated(mode !== "left" && mode !== "right", "mode=left|right", "mode=start|end");
    const warnItems = items || [];
    [["label", "title"], ["children", "content"], ["dot", "icon"], ["position", "placement"]].forEach(([oldProp, newProp]) => {
      warning5.deprecated(warnItems.every((item) => !item[oldProp]), `items.${oldProp}`, `items.${newProp}`);
    });
  }
  const stepStyle = {
    ...contextStyle,
    ...style2
  };
  if (titleSpan && mergedMode !== "alternate") {
    if (typeof titleSpan === "number") {
      stepStyle["--timeline-head-span"] = titleSpan;
    } else {
      stepStyle["--timeline-head-span-ptg"] = titleSpan;
    }
  }
  return React598.createElement(InternalContext.Provider, {
    value: stepInternalContext
  }, React598.createElement(UnstableContext3.Provider, {
    value: stepContext
  }, React598.createElement(steps_default, {
    ...restProps,
    // Style
    className: clsx(prefixCls, contextClassName, className, hashId, cssVarCls, {
      [`${prefixCls}-${orientation}`]: orientation === "horizontal",
      [`${prefixCls}-layout-alternate`]: layoutAlternate,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }),
    style: stepStyle,
    classNames: mergedClassNames,
    styles: mergedStyles,
    // Design
    variant,
    orientation,
    // Layout
    type: "dot",
    items: mergedItems,
    current: mergedItems.length - 1
  })));
};
Timeline.Item = () => {
};
if (true) {
  Timeline.displayName = "Timeline";
}
var Timeline_default = Timeline;

// node_modules/antd/es/timeline/index.js
var timeline_default = Timeline_default;

// node_modules/antd/es/tour/index.js
var import_react222 = __toESM(require_react());

// node_modules/@rc-component/tour/es/Tour.js
var React604 = __toESM(require_react());
var import_react220 = __toESM(require_react());

// node_modules/@rc-component/tour/es/hooks/useClosable.js
var React599 = __toESM(require_react());
function isConfigObj(closable) {
  return closable !== null && typeof closable === "object";
}
function getClosableConfig(closable, closeIcon, preset) {
  if (closable === false || closeIcon === false && (!isConfigObj(closable) || !closable.closeIcon)) {
    return null;
  }
  const mergedCloseIcon = typeof closeIcon !== "boolean" ? closeIcon : void 0;
  if (isConfigObj(closable)) {
    return {
      ...closable,
      closeIcon: closable.closeIcon ?? mergedCloseIcon
    };
  }
  return preset || closable || closeIcon ? {
    closeIcon: mergedCloseIcon
  } : "empty";
}
function useClosable2(stepClosable, stepCloseIcon, closable, closeIcon) {
  return React599.useMemo(() => {
    const stepClosableConfig = getClosableConfig(stepClosable, stepCloseIcon, false);
    const rootClosableConfig = getClosableConfig(closable, closeIcon, true);
    if (stepClosableConfig !== "empty") {
      return stepClosableConfig;
    }
    return rootClosableConfig;
  }, [closable, closeIcon, stepClosable, stepCloseIcon]);
}

// node_modules/@rc-component/tour/es/hooks/useTarget.js
var import_react218 = __toESM(require_react());

// node_modules/@rc-component/tour/es/util.js
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const {
    top,
    right,
    bottom,
    left
  } = element.getBoundingClientRect();
  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
function getPlacement(targetElement, placement, stepPlacement) {
  return stepPlacement ?? placement ?? (targetElement === null ? "center" : "bottom");
}

// node_modules/@rc-component/tour/es/hooks/useTarget.js
function isValidNumber(val) {
  return typeof val === "number" && !Number.isNaN(val);
}
function useTarget(target, open3, gap, scrollIntoViewOptions, inlineMode, placeholderRef) {
  const [targetElement, setTargetElement] = (0, import_react218.useState)(void 0);
  useLayoutEffect_default(() => {
    const nextElement = typeof target === "function" ? target() : target;
    setTargetElement(nextElement || null);
  });
  const [posInfo, setPosInfo] = (0, import_react218.useState)(null);
  const updatePos = useEvent_default(() => {
    var _a, _b;
    if (targetElement) {
      if (!inlineMode && !isInViewPort(targetElement) && open3) {
        targetElement.scrollIntoView(scrollIntoViewOptions);
      }
      const {
        left,
        top,
        width,
        height
      } = targetElement.getBoundingClientRect();
      const nextPosInfo = {
        left,
        top,
        width,
        height,
        radius: 0
      };
      if (inlineMode) {
        const parentRect = (_b = (_a = placeholderRef.current) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.getBoundingClientRect();
        if (parentRect) {
          nextPosInfo.left -= parentRect.left;
          nextPosInfo.top -= parentRect.top;
        }
      }
      setPosInfo((origin) => {
        if (JSON.stringify(origin) !== JSON.stringify(nextPosInfo)) {
          return nextPosInfo;
        }
        return origin;
      });
    } else {
      setPosInfo(null);
    }
  });
  const getGapOffset = (index2) => (Array.isArray(gap == null ? void 0 : gap.offset) ? gap == null ? void 0 : gap.offset[index2] : gap == null ? void 0 : gap.offset) ?? 6;
  useLayoutEffect_default(() => {
    updatePos();
    window.addEventListener("resize", updatePos);
    window.addEventListener("scroll", updatePos);
    return () => {
      window.removeEventListener("resize", updatePos);
      window.removeEventListener("scroll", updatePos);
    };
  }, [targetElement, open3, updatePos]);
  const mergedPosInfo = (0, import_react218.useMemo)(() => {
    if (!posInfo) {
      return posInfo;
    }
    const gapOffsetX = getGapOffset(0);
    const gapOffsetY = getGapOffset(1);
    const gapRadius = isValidNumber(gap == null ? void 0 : gap.radius) ? gap == null ? void 0 : gap.radius : 2;
    return {
      left: posInfo.left - gapOffsetX,
      top: posInfo.top - gapOffsetY,
      width: posInfo.width + gapOffsetX * 2,
      height: posInfo.height + gapOffsetY * 2,
      radius: gapRadius
    };
  }, [posInfo, gap]);
  return [mergedPosInfo, targetElement];
}

// node_modules/@rc-component/tour/es/Mask.js
var import_react219 = __toESM(require_react());
function _extends94() {
  _extends94 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends94.apply(this, arguments);
}
var COVER_PROPS = {
  fill: "transparent",
  pointerEvents: "auto"
};
var Mask3 = (props) => {
  const {
    prefixCls,
    rootClassName,
    pos,
    showMask,
    style: style2 = {},
    fill = "rgba(0,0,0,0.5)",
    open: open3,
    animated,
    zIndex,
    disabledInteraction,
    styles,
    classNames: tourClassNames,
    getPopupContainer
  } = props;
  const id = useId_default();
  const maskId = `${prefixCls}-mask-${id}`;
  const mergedAnimated = typeof animated === "object" ? animated == null ? void 0 : animated.placeholder : animated;
  const isSafari = typeof navigator !== "undefined" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const maskRectSize = isSafari ? {
    width: "100%",
    height: "100%"
  } : {
    width: "100vw",
    height: "100vh"
  };
  const inlineMode = getPopupContainer === false;
  return import_react219.default.createElement(es_default3, {
    open: open3,
    autoLock: !inlineMode,
    getContainer: getPopupContainer
  }, import_react219.default.createElement("div", {
    className: clsx(`${prefixCls}-mask`, rootClassName, tourClassNames == null ? void 0 : tourClassNames.mask),
    style: {
      position: inlineMode ? "absolute" : "fixed",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      zIndex,
      pointerEvents: pos && !disabledInteraction ? "none" : "auto",
      ...style2,
      ...styles == null ? void 0 : styles.mask
    }
  }, showMask ? import_react219.default.createElement("svg", {
    style: {
      width: "100%",
      height: "100%"
    }
  }, import_react219.default.createElement("defs", null, import_react219.default.createElement("mask", {
    id: maskId
  }, import_react219.default.createElement("rect", _extends94({
    x: "0",
    y: "0"
  }, maskRectSize, {
    fill: "white"
  })), pos && import_react219.default.createElement("rect", {
    x: pos.left,
    y: pos.top,
    rx: pos.radius,
    width: pos.width,
    height: pos.height,
    fill: "black",
    className: mergedAnimated ? `${prefixCls}-placeholder-animated` : ""
  }))), import_react219.default.createElement("rect", {
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    fill,
    mask: `url(#${maskId})`
  }), pos && import_react219.default.createElement(import_react219.default.Fragment, null, import_react219.default.createElement("rect", _extends94({}, COVER_PROPS, {
    x: "0",
    y: "0",
    width: "100%",
    height: Math.max(pos.top, 0)
  })), import_react219.default.createElement("rect", _extends94({}, COVER_PROPS, {
    x: "0",
    y: "0",
    width: Math.max(pos.left, 0),
    height: "100%"
  })), import_react219.default.createElement("rect", _extends94({}, COVER_PROPS, {
    x: "0",
    y: pos.top + pos.height,
    width: "100%",
    height: `calc(100% - ${pos.top + pos.height}px)`
  })), import_react219.default.createElement("rect", _extends94({}, COVER_PROPS, {
    x: pos.left + pos.width,
    y: "0",
    width: `calc(100% - ${pos.left + pos.width}px)`,
    height: "100%"
  })))) : null));
};
var Mask_default2 = Mask3;

// node_modules/@rc-component/tour/es/placements.js
var targetOffset3 = [0, 0];
var basePlacements = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function getPlacements2(arrowPointAtCenter = false) {
  const placements5 = {};
  Object.keys(basePlacements).forEach((key) => {
    placements5[key] = {
      ...basePlacements[key],
      autoArrow: arrowPointAtCenter,
      targetOffset: targetOffset3
    };
  });
  return placements5;
}
var placements4 = getPlacements2();

// node_modules/@rc-component/tour/es/TourStep/index.js
var React602 = __toESM(require_react());

// node_modules/@rc-component/tour/es/TourStep/DefaultPanel.js
var React601 = __toESM(require_react());
function _extends95() {
  _extends95 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends95.apply(this, arguments);
}
function DefaultPanel(props) {
  const {
    prefixCls,
    current,
    total,
    title,
    description,
    onClose,
    onPrev,
    onNext,
    onFinish,
    className,
    closable,
    classNames: tourClassNames,
    styles
  } = props;
  const ariaProps = pickAttrs(closable || {}, true);
  const closeIcon = (closable == null ? void 0 : closable.closeIcon) ?? React601.createElement("span", {
    className: `${prefixCls}-close-x`
  }, "");
  const mergedClosable = !!closable;
  return React601.createElement("div", {
    className: clsx(`${prefixCls}-panel`, className)
  }, React601.createElement("div", {
    className: clsx(`${prefixCls}-section`, tourClassNames == null ? void 0 : tourClassNames.section),
    style: styles == null ? void 0 : styles.section
  }, mergedClosable && React601.createElement("button", _extends95({
    type: "button",
    onClick: onClose,
    "aria-label": "Close"
  }, ariaProps, {
    className: `${prefixCls}-close`
  }), closeIcon), React601.createElement("div", {
    className: clsx(`${prefixCls}-header`, tourClassNames == null ? void 0 : tourClassNames.header),
    style: styles == null ? void 0 : styles.header
  }, React601.createElement("div", {
    className: clsx(`${prefixCls}-title`, tourClassNames == null ? void 0 : tourClassNames.title),
    style: styles == null ? void 0 : styles.title
  }, title)), React601.createElement("div", {
    className: clsx(`${prefixCls}-description`, tourClassNames == null ? void 0 : tourClassNames.description),
    style: styles == null ? void 0 : styles.description
  }, description), React601.createElement("div", {
    className: clsx(`${prefixCls}-footer`, tourClassNames == null ? void 0 : tourClassNames.footer),
    style: styles == null ? void 0 : styles.footer
  }, React601.createElement("div", {
    className: `${prefixCls}-sliders`
  }, total > 1 ? [...Array.from({
    length: total
  }).keys()].map((item, index2) => {
    return React601.createElement("span", {
      key: item,
      className: index2 === current ? "active" : ""
    });
  }) : null), React601.createElement("div", {
    className: clsx(`${prefixCls}-actions`, tourClassNames == null ? void 0 : tourClassNames.actions),
    style: styles == null ? void 0 : styles.actions
  }, current !== 0 ? React601.createElement("button", {
    className: `${prefixCls}-prev-btn`,
    onClick: onPrev
  }, "Prev") : null, current === total - 1 ? React601.createElement("button", {
    className: `${prefixCls}-finish-btn`,
    onClick: onFinish
  }, "Finish") : React601.createElement("button", {
    className: `${prefixCls}-next-btn`,
    onClick: onNext
  }, "Next")))));
}

// node_modules/@rc-component/tour/es/TourStep/index.js
var TourStep = (props) => {
  const {
    current,
    renderPanel
  } = props;
  return React602.createElement(React602.Fragment, null, typeof renderPanel === "function" ? renderPanel(props, current) : React602.createElement(DefaultPanel, props));
};
var TourStep_default = TourStep;

// node_modules/@rc-component/tour/es/Placeholder.js
var React603 = __toESM(require_react());
var Placeholder2 = React603.forwardRef((props, ref) => {
  const {
    open: open3,
    autoLock,
    getContainer,
    domRef,
    className,
    style: style2,
    fallbackDOM
  } = props;
  React603.useImperativeHandle(ref, () => domRef.current || fallbackDOM());
  return React603.createElement(es_default3, {
    open: open3,
    autoLock,
    getContainer
  }, React603.createElement("div", {
    ref: domRef,
    className,
    style: style2
  }));
});
if (true) {
  Placeholder2.displayName = "Placeholder";
}
var Placeholder_default = Placeholder2;

// node_modules/@rc-component/tour/es/Tour.js
function _extends96() {
  _extends96 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends96.apply(this, arguments);
}
var CENTER_PLACEHOLDER = {
  left: "50%",
  top: "50%",
  width: 1,
  height: 1
};
var defaultScrollIntoViewOptions = {
  block: "center",
  inline: "center"
};
var Tour = (props) => {
  const {
    prefixCls = "rc-tour",
    steps = [],
    defaultCurrent,
    current,
    onChange,
    onClose,
    onFinish,
    open: open3,
    defaultOpen,
    mask = true,
    arrow = true,
    rootClassName,
    placement,
    renderPanel,
    gap,
    animated,
    scrollIntoViewOptions = defaultScrollIntoViewOptions,
    zIndex = 1001,
    closeIcon,
    closable,
    builtinPlacements,
    disabledInteraction,
    styles,
    classNames: tourClassNames,
    className,
    style: style2,
    getPopupContainer,
    ...restProps
  } = props;
  const triggerRef = React604.useRef();
  const [mergedCurrent, setMergedCurrent] = useControlledState(defaultCurrent || 0, current);
  const [internalOpen, setMergedOpen] = useControlledState(defaultOpen, open3);
  const mergedOpen = mergedCurrent < 0 || mergedCurrent >= steps.length ? false : internalOpen ?? true;
  const [hasOpened, setHasOpened] = React604.useState(mergedOpen);
  const openRef = React604.useRef(mergedOpen);
  useLayoutEffect_default(() => {
    if (mergedOpen) {
      if (!openRef.current) {
        setMergedCurrent(0);
      }
      setHasOpened(true);
    }
    openRef.current = mergedOpen;
  }, [mergedOpen]);
  const {
    target,
    placement: stepPlacement,
    style: stepStyle,
    arrow: stepArrow,
    className: stepClassName,
    mask: stepMask,
    scrollIntoViewOptions: stepScrollIntoViewOptions = defaultScrollIntoViewOptions,
    closeIcon: stepCloseIcon,
    closable: stepClosable
  } = steps[mergedCurrent] || {};
  const mergedClosable = useClosable2(stepClosable, stepCloseIcon, closable, closeIcon);
  const mergedMask = mergedOpen && (stepMask ?? mask);
  const mergedScrollIntoViewOptions = stepScrollIntoViewOptions ?? scrollIntoViewOptions;
  const placeholderRef = React604.useRef(null);
  const inlineMode = getPopupContainer === false;
  const [posInfo, targetElement] = useTarget(target, open3, gap, mergedScrollIntoViewOptions, inlineMode, placeholderRef);
  const mergedPlacement = getPlacement(targetElement, placement, stepPlacement);
  const mergedArrow = targetElement ? typeof stepArrow === "undefined" ? arrow : stepArrow : false;
  const arrowPointAtCenter = typeof mergedArrow === "object" ? mergedArrow.pointAtCenter : false;
  useLayoutEffect_default(() => {
    var _a;
    (_a = triggerRef.current) == null ? void 0 : _a.forceAlign();
  }, [arrowPointAtCenter, mergedCurrent]);
  const onInternalChange = (nextCurrent) => {
    setMergedCurrent(nextCurrent);
    onChange == null ? void 0 : onChange(nextCurrent);
  };
  const mergedBuiltinPlacements2 = (0, import_react220.useMemo)(() => {
    if (builtinPlacements) {
      return typeof builtinPlacements === "function" ? builtinPlacements({
        arrowPointAtCenter
      }) : builtinPlacements;
    }
    return getPlacements2(arrowPointAtCenter);
  }, [builtinPlacements, arrowPointAtCenter]);
  if (targetElement === void 0 || !hasOpened) {
    return null;
  }
  const handleClose = () => {
    setMergedOpen(false);
    onClose == null ? void 0 : onClose(mergedCurrent);
  };
  const getPopupElement = () => React604.createElement(TourStep_default, _extends96({
    styles,
    classNames: tourClassNames,
    arrow: mergedArrow,
    key: "content",
    prefixCls,
    total: steps.length,
    renderPanel,
    onPrev: () => {
      onInternalChange(mergedCurrent - 1);
    },
    onNext: () => {
      onInternalChange(mergedCurrent + 1);
    },
    onClose: handleClose,
    current: mergedCurrent,
    onFinish: () => {
      handleClose();
      onFinish == null ? void 0 : onFinish();
    }
  }, steps[mergedCurrent], {
    closable: mergedClosable
  }));
  const mergedShowMask = typeof mergedMask === "boolean" ? mergedMask : !!mergedMask;
  const mergedMaskStyle = typeof mergedMask === "boolean" ? void 0 : mergedMask;
  const fallbackDOM = () => {
    return targetElement || document.body;
  };
  return React604.createElement(React604.Fragment, null, React604.createElement(Mask_default2, {
    getPopupContainer,
    styles,
    classNames: tourClassNames,
    zIndex,
    prefixCls,
    pos: posInfo,
    showMask: mergedShowMask,
    style: mergedMaskStyle == null ? void 0 : mergedMaskStyle.style,
    fill: mergedMaskStyle == null ? void 0 : mergedMaskStyle.color,
    open: mergedOpen,
    animated,
    rootClassName,
    disabledInteraction
  }), React604.createElement(es_default4, _extends96({}, restProps, {
    // `rc-portal` def bug not support `false` but does support and in used.
    getPopupContainer,
    builtinPlacements: mergedBuiltinPlacements2,
    ref: triggerRef,
    popupStyle: stepStyle,
    popupPlacement: mergedPlacement,
    popupVisible: mergedOpen,
    popupClassName: clsx(rootClassName, stepClassName),
    prefixCls,
    popup: getPopupElement,
    forceRender: false,
    autoDestroy: true,
    zIndex,
    arrow: !!mergedArrow
  }), React604.createElement(Placeholder_default, {
    open: mergedOpen,
    autoLock: !inlineMode,
    getContainer: getPopupContainer,
    domRef: placeholderRef,
    fallbackDOM,
    className: clsx(className, rootClassName, `${prefixCls}-target-placeholder`),
    style: {
      ...posInfo || CENTER_PLACEHOLDER,
      position: inlineMode ? "absolute" : "fixed",
      pointerEvents: "none",
      ...style2
    }
  })));
};
var Tour_default = Tour;

// node_modules/@rc-component/tour/es/index.js
var es_default34 = Tour_default;

// node_modules/antd/es/tour/panelRender.js
var import_react221 = __toESM(require_react());
var TourPanel = (props) => {
  const {
    stepProps,
    current,
    type: type5,
    indicatorsRender,
    actionsRender
  } = props;
  const {
    prefixCls,
    total = 1,
    title,
    onClose,
    onPrev,
    onNext,
    onFinish,
    cover,
    description,
    nextButtonProps,
    prevButtonProps,
    type: stepType,
    closable,
    classNames = {},
    styles = {}
  } = stepProps;
  const mergedType = stepType ?? type5;
  const ariaProps = pickAttrs(closable ?? {}, true);
  const [contextLocaleGlobal] = useLocale_default("global", en_US_default6.global);
  const [contextLocaleTour] = useLocale_default("Tour", en_US_default6.Tour);
  const mergedCloseIcon = import_react221.default.createElement("button", {
    type: "button",
    onClick: onClose,
    className: `${prefixCls}-close`,
    "aria-label": contextLocaleGlobal == null ? void 0 : contextLocaleGlobal.close,
    ...ariaProps
  }, (closable == null ? void 0 : closable.closeIcon) || import_react221.default.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  }));
  const isLastStep = current === total - 1;
  const prevBtnClick = () => {
    var _a;
    onPrev == null ? void 0 : onPrev();
    (_a = prevButtonProps == null ? void 0 : prevButtonProps.onClick) == null ? void 0 : _a.call(prevButtonProps);
  };
  const nextBtnClick = () => {
    var _a;
    if (isLastStep) {
      onFinish == null ? void 0 : onFinish();
    } else {
      onNext == null ? void 0 : onNext();
    }
    (_a = nextButtonProps == null ? void 0 : nextButtonProps.onClick) == null ? void 0 : _a.call(nextButtonProps);
  };
  const headerNode = isNonNullable_default(title) ? import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-header`, classNames.header),
    style: styles.header
  }, import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-title`, classNames.title),
    style: styles.title
  }, title)) : null;
  const descriptionNode = isNonNullable_default(description) ? import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-description`, classNames.description),
    style: styles.description
  }, description) : null;
  const coverNode = isNonNullable_default(cover) ? import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-cover`, classNames.cover),
    style: styles.cover
  }, cover) : null;
  let mergedIndicatorNode;
  if (indicatorsRender) {
    mergedIndicatorNode = indicatorsRender(current, total);
  } else {
    mergedIndicatorNode = _toConsumableArray(Array.from({
      length: total
    }).keys()).map((stepItem, index2) => import_react221.default.createElement("span", {
      key: stepItem,
      className: clsx(index2 === current && `${prefixCls}-indicator-active`, `${prefixCls}-indicator`, classNames.indicator),
      style: styles.indicator
    }));
  }
  const mainBtnType = mergedType === "primary" ? "default" : "primary";
  const secondaryBtnProps = {
    type: "default",
    ghost: mergedType === "primary"
  };
  const defaultActionsNode = import_react221.default.createElement(import_react221.default.Fragment, null, current !== 0 ? import_react221.default.createElement(Button_default, {
    size: "small",
    ...secondaryBtnProps,
    ...prevButtonProps,
    onClick: prevBtnClick,
    className: clsx(`${prefixCls}-prev-btn`, prevButtonProps == null ? void 0 : prevButtonProps.className)
  }, (prevButtonProps == null ? void 0 : prevButtonProps.children) ?? (contextLocaleTour == null ? void 0 : contextLocaleTour.Previous)) : null, import_react221.default.createElement(Button_default, {
    size: "small",
    type: mainBtnType,
    ...nextButtonProps,
    onClick: nextBtnClick,
    className: clsx(`${prefixCls}-next-btn`, nextButtonProps == null ? void 0 : nextButtonProps.className)
  }, (nextButtonProps == null ? void 0 : nextButtonProps.children) ?? (isLastStep ? contextLocaleTour == null ? void 0 : contextLocaleTour.Finish : contextLocaleTour == null ? void 0 : contextLocaleTour.Next)));
  return import_react221.default.createElement("div", {
    className: `${prefixCls}-panel`
  }, import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-section`, classNames.section),
    style: styles.section
  }, closable && mergedCloseIcon, coverNode, headerNode, descriptionNode, import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, total > 1 && import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-indicators`, classNames.indicators),
    style: styles.indicators
  }, mergedIndicatorNode), import_react221.default.createElement("div", {
    className: clsx(`${prefixCls}-actions`, classNames.actions),
    style: styles.actions
  }, actionsRender ? actionsRender(defaultActionsNode, {
    current,
    total
  }) : defaultActionsNode))));
};
var panelRender_default = TourPanel;

// node_modules/antd/es/tour/PurePanel.js
var React606 = __toESM(require_react());

// node_modules/antd/es/tour/style/index.js
var genBaseStyle17 = (token2) => {
  const {
    componentCls,
    padding,
    paddingXS,
    borderRadius,
    borderRadiusXS,
    colorPrimary,
    colorFill,
    indicatorHeight,
    indicatorWidth,
    boxShadowTertiary,
    zIndexPopup,
    colorBgElevated,
    fontWeightStrong,
    marginXS,
    colorTextLightSolid,
    tourBorderRadius,
    colorWhite,
    primaryNextBtnHoverBg,
    closeBtnSize,
    motionDurationSlow,
    antCls,
    primaryPrevBtnBg
  } = token2;
  return [
    {
      [componentCls]: {
        ...resetComponent(token2),
        position: "absolute",
        zIndex: zIndexPopup,
        maxWidth: "fit-content",
        visibility: "visible",
        width: 520,
        "--antd-arrow-background-color": colorBgElevated,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${componentCls}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${componentCls}-panel`]: {
          position: "relative"
        },
        [`${componentCls}-section`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: tourBorderRadius,
          boxShadow: boxShadowTertiary,
          position: "relative",
          backgroundColor: colorBgElevated,
          border: "none",
          backgroundClip: "padding-box",
          [`${componentCls}-close`]: {
            position: "absolute",
            top: padding,
            insetInlineEnd: padding,
            color: token2.colorIcon,
            background: "none",
            border: "none",
            width: closeBtnSize,
            height: closeBtnSize,
            borderRadius: token2.borderRadiusSM,
            transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            "&:hover": {
              color: token2.colorIconHover,
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            ...genFocusStyle(token2)
          },
          [`${componentCls}-cover`]: {
            textAlign: "center",
            padding: `${unit(token2.calc(padding).add(closeBtnSize).add(paddingXS).equal())} ${unit(padding)} 0`,
            img: {
              width: "100%"
            }
          },
          [`${componentCls}-header`]: {
            padding: `${unit(padding)} ${unit(padding)} ${unit(paddingXS)}`,
            width: `calc(100% - ${unit(closeBtnSize)})`,
            wordBreak: "break-word",
            [`${componentCls}-title`]: {
              fontWeight: fontWeightStrong
            }
          },
          [`${componentCls}-description`]: {
            padding: `0 ${unit(padding)}`,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            padding: `${unit(paddingXS)} ${unit(padding)} ${unit(padding)}`,
            textAlign: "end",
            borderRadius: `0 0 ${unit(borderRadiusXS)} ${unit(borderRadiusXS)}`,
            display: "flex",
            [`${componentCls}-indicators`]: {
              display: "inline-block",
              [`${componentCls}-indicator`]: {
                width: indicatorWidth,
                height: indicatorHeight,
                display: "inline-block",
                borderRadius: "50%",
                background: colorFill,
                "&:not(:last-child)": {
                  marginInlineEnd: indicatorHeight
                },
                "&-active": {
                  background: colorPrimary
                }
              }
            },
            [`${componentCls}-actions`]: {
              marginInlineStart: "auto",
              [`${antCls}-btn`]: {
                marginInlineStart: marginXS
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${componentCls}-primary, &${componentCls}-primary`]: {
          "--antd-arrow-background-color": colorPrimary,
          [`${componentCls}-section`]: {
            color: colorTextLightSolid,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: colorPrimary,
            borderRadius,
            boxShadow: boxShadowTertiary,
            [`${componentCls}-close`]: {
              color: colorTextLightSolid
            },
            [`${componentCls}-indicators`]: {
              [`${componentCls}-indicator`]: {
                background: primaryPrevBtnBg,
                "&-active": {
                  background: colorTextLightSolid
                }
              }
            },
            [`${componentCls}-prev-btn`]: {
              color: colorTextLightSolid,
              borderColor: primaryPrevBtnBg,
              backgroundColor: colorPrimary,
              "&:hover": {
                backgroundColor: primaryPrevBtnBg,
                borderColor: "transparent"
              }
            },
            [`${componentCls}-next-btn`]: {
              color: colorPrimary,
              borderColor: "transparent",
              background: colorWhite,
              "&:hover": {
                background: primaryNextBtnHoverBg
              }
            }
          }
        }
      },
      // ============================= mask ===========================
      [`${componentCls}-mask`]: {
        [`${componentCls}-placeholder-animated`]: {
          transition: `all ${motionDurationSlow}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
        [`${componentCls}-section`]: {
          borderRadius: token2.min(tourBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
        }
      }
    },
    // ============================= Arrow ===========================
    getArrowStyle(token2, "var(--antd-arrow-background-color)")
  ];
};
var prepareComponentToken55 = (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 70,
  closeBtnSize: token2.fontSize * token2.lineHeight,
  primaryPrevBtnBg: new FastColor(token2.colorTextLightSolid).setA(0.15).toRgbString(),
  primaryNextBtnHoverBg: new FastColor(token2.colorBgTextHover).onBackground(token2.colorWhite).toRgbString(),
  ...getArrowOffsetToken({
    contentRadius: token2.borderRadiusLG,
    limitVerticalRadius: true
  }),
  ...getArrowToken(token2)
});
var style_default62 = genStyleHooks("Tour", (token2) => {
  const {
    borderRadiusLG
  } = token2;
  const TourToken = merge2(token2, {
    indicatorWidth: 6,
    indicatorHeight: 6,
    tourBorderRadius: borderRadiusLG
  });
  return genBaseStyle17(TourToken);
}, prepareComponentToken55);

// node_modules/antd/es/tour/PurePanel.js
var PurePanel17 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    current = 0,
    total = 6,
    className,
    style: style2,
    type: type5,
    closable,
    closeIcon,
    ...restProps
  } = props;
  const {
    getPrefixCls
  } = React606.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [hashId, cssVarCls] = style_default62(prefixCls);
  const [mergedClosable, mergedCloseIcon] = useClosable({
    closable,
    closeIcon
  }, null, {
    closable: true,
    closeIconRender: (icon) => {
      var _a;
      return React606.isValidElement(icon) ? cloneElement3(icon, {
        className: clsx((_a = icon.props) == null ? void 0 : _a.className, `${prefixCls}-close-icon`)
      }) : icon;
    }
  });
  return React606.createElement(RawPurePanel, {
    prefixCls,
    hashId,
    className: clsx(className, `${prefixCls}-pure`, type5 && `${prefixCls}-${type5}`, cssVarCls),
    style: style2
  }, React606.createElement(panelRender_default, {
    stepProps: {
      ...restProps,
      prefixCls,
      total,
      closable: mergedClosable ? {
        closeIcon: mergedCloseIcon
      } : void 0
    },
    current,
    type: type5
  }));
};
var PurePanel_default9 = withPureRenderTheme(PurePanel17);

// node_modules/antd/es/tour/index.js
var Tour2 = (props) => {
  const {
    prefixCls: customizePrefixCls,
    type: type5,
    rootClassName,
    indicatorsRender,
    actionsRender,
    steps,
    closeIcon,
    classNames,
    styles,
    className,
    style: style2,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction,
    closeIcon: contextCloseIcon,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("tour");
  const prefixCls = getPrefixCls("tour", customizePrefixCls);
  const [hashId, cssVarCls] = style_default62(prefixCls);
  const [, token2] = useToken();
  const mergedSteps = import_react222.default.useMemo(() => steps == null ? void 0 : steps.map((step) => ({
    ...step,
    className: clsx(step.className, {
      [`${prefixCls}-primary`]: (step.type ?? type5) === "primary"
    })
  })), [prefixCls, steps, type5]);
  const mergedProps = {
    ...props,
    steps: mergedSteps
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const builtinPlacements = (config) => getPlacements({
    arrowPointAtCenter: (config == null ? void 0 : config.arrowPointAtCenter) ?? true,
    autoAdjustOverflow: true,
    offset: token2.marginXXS,
    arrowWidth: token2.sizePopupArrow,
    borderRadius: token2.borderRadius
  });
  const mergedRootClassName = clsx({
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, cssVarCls, rootClassName, contextClassName, mergedClassNames.root, className);
  const semanticStyles = {
    ...mergedStyles,
    mask: {
      ...mergedStyles.root,
      ...mergedStyles.mask,
      ...contextStyle,
      ...style2
    }
  };
  const mergedRenderPanel = (stepProps, stepCurrent) => import_react222.default.createElement(panelRender_default, {
    styles: semanticStyles,
    classNames: mergedClassNames,
    type: type5,
    stepProps,
    current: stepCurrent,
    indicatorsRender,
    actionsRender
  });
  const [zIndex, contextZIndex] = useZIndex("Tour", restProps.zIndex);
  return import_react222.default.createElement(zindexContext_default.Provider, {
    value: contextZIndex
  }, import_react222.default.createElement(es_default34, {
    ...restProps,
    styles: semanticStyles,
    classNames: mergedClassNames,
    closeIcon: closeIcon ?? contextCloseIcon,
    zIndex,
    rootClassName: mergedRootClassName,
    prefixCls,
    animated: true,
    renderPanel: mergedRenderPanel,
    builtinPlacements,
    steps: mergedSteps
  }));
};
if (true) {
  Tour2.displayName = "Tour";
}
Tour2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel_default9;
var tour_default = Tour2;

// node_modules/antd/es/transfer/index.js
var import_react225 = __toESM(require_react());

// node_modules/antd/es/_util/transKeys.js
var groupKeysMap = (keys2) => {
  const map = /* @__PURE__ */ new Map();
  keys2.forEach((key, index2) => {
    map.set(key, index2);
  });
  return map;
};
var groupDisabledKeysMap = (dataSource) => {
  const map = /* @__PURE__ */ new Map();
  dataSource.forEach(({
    disabled,
    key
  }, index2) => {
    if (disabled) {
      map.set(key, index2);
    }
  });
  return map;
};

// node_modules/antd/es/transfer/Actions.js
var import_react223 = __toESM(require_react());
function getArrowIcon(type5, direction) {
  const isRight = type5 === "right";
  if (direction !== "rtl") {
    return isRight ? import_react223.default.createElement(RightOutlined_default, null) : import_react223.default.createElement(LeftOutlined_default, null);
  }
  return isRight ? import_react223.default.createElement(LeftOutlined_default, null) : import_react223.default.createElement(RightOutlined_default, null);
}
var Action = ({
  type: type5,
  actions,
  moveToLeft,
  moveToRight,
  leftActive,
  rightActive,
  direction,
  disabled
}) => {
  const isRight = type5 === "right";
  const button = isRight ? actions[0] : actions[1];
  const moveHandler = isRight ? moveToRight : moveToLeft;
  const active = isRight ? rightActive : leftActive;
  const icon = getArrowIcon(type5, direction);
  if (import_react223.default.isValidElement(button)) {
    const element = button;
    const onClick = (event) => {
      var _a, _b;
      (_b = (_a = element == null ? void 0 : element.props) == null ? void 0 : _a.onClick) == null ? void 0 : _b.call(_a, event);
      moveHandler == null ? void 0 : moveHandler(event);
    };
    return import_react223.default.cloneElement(element, {
      disabled: disabled || !active,
      onClick
    });
  }
  return import_react223.default.createElement(Button_default, {
    type: "primary",
    size: "small",
    disabled: disabled || !active,
    onClick: (event) => moveHandler == null ? void 0 : moveHandler(event),
    icon
  }, button);
};
var Actions = (props) => {
  const {
    className,
    style: style2,
    oneWay,
    actions,
    ...restProps
  } = props;
  return import_react223.default.createElement("div", {
    className,
    style: style2
  }, import_react223.default.createElement(Action, {
    type: "right",
    actions,
    ...restProps
  }), !oneWay && import_react223.default.createElement(Action, {
    type: "left",
    actions,
    ...restProps
  }), actions.slice(oneWay ? 1 : 2));
};
if (true) {
  Actions.displayName = "Actions";
}
var Actions_default = Actions;

// node_modules/antd/es/transfer/hooks/useData.js
var React609 = __toESM(require_react());
var useData = (dataSource, rowKey, targetKeys) => {
  const mergedDataSource = React609.useMemo(() => (dataSource || []).map((record) => {
    if (rowKey) {
      return {
        ...record,
        key: rowKey(record)
      };
    }
    return record;
  }), [dataSource, rowKey]);
  const [leftDataSource, rightDataSource] = React609.useMemo(() => {
    const leftData = [];
    const rightData = Array.from({
      length: (targetKeys == null ? void 0 : targetKeys.length) ?? 0
    });
    const targetKeysMap = groupKeysMap(targetKeys || []);
    mergedDataSource.forEach((record) => {
      if (targetKeysMap.has(record.key)) {
        const idx = targetKeysMap.get(record.key);
        rightData[idx] = record;
      } else {
        leftData.push(record);
      }
    });
    return [leftData, rightData];
  }, [mergedDataSource, targetKeys]);
  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];
};
var useData_default = useData;

// node_modules/antd/es/transfer/hooks/useSelection.js
var React610 = __toESM(require_react());
var EMPTY_KEYS = [];
function filterKeys(keys2, dataKeys) {
  const filteredKeys = keys2.filter((key) => dataKeys.has(key));
  return keys2.length === filteredKeys.length ? keys2 : filteredKeys;
}
function flattenKeys2(keys2) {
  return Array.from(keys2).join(";");
}
function useSelection2(leftDataSource, rightDataSource, selectedKeys) {
  const [leftKeys, rightKeys] = React610.useMemo(() => [new Set(leftDataSource.map((src) => src == null ? void 0 : src.key)), new Set(rightDataSource.map((src) => src == null ? void 0 : src.key))], [leftDataSource, rightDataSource]);
  const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(EMPTY_KEYS, selectedKeys);
  const sourceSelectedKeys = React610.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]);
  const targetSelectedKeys = React610.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
  React610.useEffect(() => {
    setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
  }, [flattenKeys2(leftKeys), flattenKeys2(rightKeys)]);
  const setSourceSelectedKeys = useEvent_default((nextSrcKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
  });
  const setTargetSelectedKeys = useEvent_default((nextTargetKeys) => {
    setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
  });
  return [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Updater
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ];
}
var useSelection_default2 = useSelection2;

// node_modules/antd/es/transfer/search.js
var React611 = __toESM(require_react());
var Search2 = (props) => {
  const {
    placeholder = "",
    value,
    prefixCls,
    disabled,
    onChange,
    handleClear
  } = props;
  const handleChange = React611.useCallback((e3) => {
    onChange == null ? void 0 : onChange(e3);
    if (e3.target.value === "") {
      handleClear == null ? void 0 : handleClear();
    }
  }, [onChange]);
  return React611.createElement(Input_default5, {
    placeholder,
    className: prefixCls,
    value,
    onChange: handleChange,
    disabled,
    allowClear: true,
    prefix: React611.createElement(SearchOutlined_default, null)
  });
};
if (true) {
  Search2.displayName = "Search";
}
var search_default2 = Search2;

// node_modules/antd/es/transfer/Section.js
var import_react224 = __toESM(require_react());

// node_modules/antd/es/transfer/ListBody.js
var React613 = __toESM(require_react());

// node_modules/antd/es/transfer/ListItem.js
var React612 = __toESM(require_react());
var ListItem = (props) => {
  const {
    prefixCls,
    classNames,
    styles,
    renderedText,
    renderedEl,
    item,
    checked,
    disabled,
    onClick,
    onRemove,
    showRemove
  } = props;
  const classes = clsx(`${prefixCls}-content-item`, classNames.item, {
    [`${prefixCls}-content-item-disabled`]: disabled || item.disabled,
    [`${prefixCls}-content-item-checked`]: checked && !item.disabled
  });
  let title;
  if (typeof renderedText === "string" || typeof renderedText === "number") {
    title = String(renderedText);
  }
  const [contextLocale] = useLocale_default("Transfer", en_US_default6.Transfer);
  const liProps = {
    className: classes,
    style: styles.item,
    title
  };
  const labelNode = React612.createElement("span", {
    className: clsx(`${prefixCls}-content-item-text`, classNames.itemContent),
    style: styles.itemContent
  }, renderedEl);
  if (showRemove) {
    return React612.createElement("li", {
      ...liProps
    }, labelNode, React612.createElement("button", {
      type: "button",
      disabled: disabled || item.disabled,
      className: `${prefixCls}-content-item-remove`,
      "aria-label": contextLocale == null ? void 0 : contextLocale.remove,
      onClick: () => onRemove == null ? void 0 : onRemove(item)
    }, React612.createElement(DeleteOutlined_default, null)));
  }
  liProps.onClick = disabled || item.disabled ? void 0 : (event) => onClick(item, event);
  return React612.createElement("li", {
    ...liProps
  }, React612.createElement(checkbox_default, {
    className: clsx(`${prefixCls}-checkbox`, classNames.itemIcon),
    style: styles.itemIcon,
    checked,
    disabled: disabled || item.disabled
  }), labelNode);
};
var ListItem_default = React612.memo(ListItem);

// node_modules/antd/es/transfer/ListBody.js
var OmitProps = ["handleFilter", "handleClear", "checkedKeys"];
var parsePagination = (pagination) => {
  const defaultPagination = {
    simple: true,
    showSizeChanger: false,
    showLessItems: false
  };
  return {
    ...defaultPagination,
    ...pagination
  };
};
var TransferListBody = (props, ref) => {
  const {
    prefixCls,
    classNames,
    styles,
    filteredRenderItems,
    selectedKeys,
    disabled: globalDisabled,
    showRemove,
    pagination,
    onScroll,
    onItemSelect,
    onItemRemove
  } = props;
  const [current, setCurrent] = React613.useState(1);
  const mergedPagination = React613.useMemo(() => {
    if (!pagination) {
      return null;
    }
    const convertPagination = typeof pagination === "object" ? pagination : {};
    return parsePagination(convertPagination);
  }, [pagination]);
  const [pageSize, setPageSize] = useControlledState(10, mergedPagination == null ? void 0 : mergedPagination.pageSize);
  React613.useEffect(() => {
    if (mergedPagination) {
      const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
      setCurrent(Math.min(current, maxPageCount));
    }
  }, [filteredRenderItems, mergedPagination, pageSize]);
  const onInternalClick = (item, e3) => {
    onItemSelect(item.key, !selectedKeys.includes(item.key), e3);
  };
  const onRemove = (item) => {
    onItemRemove == null ? void 0 : onItemRemove([item.key]);
  };
  const onPageChange = (cur) => {
    setCurrent(cur);
  };
  const onSizeChange = (cur, size) => {
    setCurrent(cur);
    setPageSize(size);
  };
  const memoizedItems = React613.useMemo(() => {
    const displayItems = mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
    return displayItems;
  }, [current, filteredRenderItems, mergedPagination, pageSize]);
  React613.useImperativeHandle(ref, () => ({
    items: memoizedItems
  }));
  const paginationNode = mergedPagination ? React613.createElement(pagination_default, {
    size: "small",
    disabled: globalDisabled,
    simple: mergedPagination.simple,
    pageSize,
    showLessItems: mergedPagination.showLessItems,
    showSizeChanger: mergedPagination.showSizeChanger,
    className: `${prefixCls}-pagination`,
    total: filteredRenderItems.length,
    current,
    onChange: onPageChange,
    onShowSizeChange: onSizeChange
  }) : null;
  return React613.createElement(React613.Fragment, null, React613.createElement("ul", {
    className: clsx(`${prefixCls}-content`, classNames.list, {
      [`${prefixCls}-content-show-remove`]: showRemove
    }),
    style: styles.list,
    onScroll
  }, (memoizedItems || []).map(({
    renderedEl,
    renderedText,
    item
  }) => React613.createElement(ListItem_default, {
    key: item.key,
    prefixCls,
    classNames,
    styles,
    item,
    renderedText,
    renderedEl,
    showRemove,
    onClick: onInternalClick,
    onRemove,
    checked: selectedKeys.includes(item.key),
    disabled: globalDisabled || item.disabled
  }))), paginationNode);
};
if (true) {
  TransferListBody.displayName = "TransferListBody";
}
var ListBody_default = React613.forwardRef(TransferListBody);

// node_modules/antd/es/transfer/Section.js
var defaultRender2 = () => null;
function isRenderResultPlainObject(result) {
  return !!(result && !import_react224.default.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
}
function getEnabledItemKeys(items) {
  return items.filter((data) => !data.disabled).map((data) => data.key);
}
var isValidIcon = (icon) => icon !== void 0;
var getShowSearchOption = (showSearch) => {
  if (showSearch && typeof showSearch === "object") {
    return {
      ...showSearch,
      defaultValue: showSearch.defaultValue || ""
    };
  }
  return {
    defaultValue: "",
    placeholder: ""
  };
};
var TransferSection = (props) => {
  const {
    prefixCls,
    style: style2,
    classNames,
    styles,
    dataSource = [],
    titleText = "",
    checkedKeys,
    disabled,
    showSearch = false,
    searchPlaceholder,
    notFoundContent,
    selectAll,
    deselectAll,
    selectCurrent,
    selectInvert,
    removeAll,
    removeCurrent,
    showSelectAll = true,
    showRemove,
    pagination,
    direction,
    itemsUnit,
    itemUnit,
    selectAllLabel,
    selectionsIcon,
    footer,
    renderList,
    onItemSelectAll,
    onItemRemove,
    handleFilter,
    handleClear,
    filterOption: filterOption2,
    render: render2 = defaultRender2
  } = props;
  const sectionPrefixCls = `${prefixCls}-section`;
  const listPrefixCls = `${prefixCls}-list`;
  const searchOptions = getShowSearchOption(showSearch);
  const [filterValue, setFilterValue] = (0, import_react224.useState)(searchOptions.defaultValue);
  const listBodyRef = (0, import_react224.useRef)({});
  const internalHandleFilter = (e3) => {
    setFilterValue(e3.target.value);
    handleFilter(e3);
  };
  const internalHandleClear = () => {
    setFilterValue("");
    handleClear();
  };
  const matchFilter = (text, item) => {
    if (typeof filterOption2 === "function") {
      return filterOption2(filterValue, item, direction);
    }
    return text.includes(filterValue);
  };
  const customRenderListBody = (listProps) => {
    let bodyContent = renderList ? renderList({
      ...listProps,
      onItemSelect: (key, check) => listProps.onItemSelect(key, check)
    }) : null;
    const customize = !!bodyContent;
    if (!customize) {
      bodyContent = import_react224.default.createElement(ListBody_default, {
        ref: listBodyRef,
        ...listProps,
        prefixCls: listPrefixCls
      });
    }
    return {
      customize,
      bodyContent
    };
  };
  const renderItem2 = (item) => {
    const renderResult = render2(item);
    const isRenderResultPlain = isRenderResultPlainObject(renderResult);
    return {
      item,
      renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
      renderedText: isRenderResultPlain ? renderResult.value : renderResult
    };
  };
  const notFoundContentEle = (0, import_react224.useMemo)(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]);
  const [filteredItems, filteredRenderItems] = (0, import_react224.useMemo)(() => {
    const filterItems = [];
    const filterRenderItems = [];
    dataSource.forEach((item) => {
      const renderedItem = renderItem2(item);
      if (filterValue && !matchFilter(renderedItem.renderedText, item)) {
        return;
      }
      filterItems.push(item);
      filterRenderItems.push(renderedItem);
    });
    return [filterItems, filterRenderItems];
  }, [dataSource, filterValue]);
  const checkedActiveItems = (0, import_react224.useMemo)(() => {
    return filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled);
  }, [checkedKeys, filteredItems]);
  const checkStatus = (0, import_react224.useMemo)(() => {
    if (checkedActiveItems.length === 0) {
      return "none";
    }
    const checkedKeysMap = groupKeysMap(checkedKeys);
    if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) {
      return "all";
    }
    return "part";
  }, [checkedActiveItems.length, checkedKeys, filteredItems]);
  const renderListBody = () => {
    const search = showSearch ? import_react224.default.createElement("div", {
      className: `${listPrefixCls}-body-search-wrapper`
    }, import_react224.default.createElement(search_default2, {
      prefixCls: `${listPrefixCls}-search`,
      onChange: internalHandleFilter,
      handleClear: internalHandleClear,
      placeholder: searchOptions.placeholder || searchPlaceholder,
      value: filterValue,
      disabled
    })) : null;
    const {
      customize,
      bodyContent
    } = customRenderListBody({
      ...omit(props, OmitProps),
      filteredItems,
      filteredRenderItems,
      selectedKeys: checkedKeys,
      classNames,
      styles
    });
    let bodyNode;
    if (customize) {
      bodyNode = import_react224.default.createElement("div", {
        className: `${listPrefixCls}-body-customize-wrapper`
      }, bodyContent);
    } else {
      bodyNode = filteredItems.length ? bodyContent : import_react224.default.createElement("div", {
        className: `${listPrefixCls}-body-not-found`
      }, notFoundContentEle);
    }
    return import_react224.default.createElement("div", {
      className: clsx(`${listPrefixCls}-body`, {
        [`${listPrefixCls}-body-with-search`]: showSearch
      }, classNames.body),
      style: styles.body
    }, search, bodyNode);
  };
  const checkBox = import_react224.default.createElement(checkbox_default, {
    disabled: dataSource.filter((d) => !d.disabled).length === 0 || disabled,
    checked: checkStatus === "all",
    indeterminate: checkStatus === "part",
    className: `${listPrefixCls}-checkbox`,
    onChange: () => {
      onItemSelectAll == null ? void 0 : onItemSelectAll(filteredItems.filter((item) => !item.disabled).map(({
        key
      }) => key), checkStatus !== "all");
    }
  });
  const getSelectAllLabel = (selectedCount, totalCount) => {
    if (selectAllLabel) {
      return typeof selectAllLabel === "function" ? selectAllLabel({
        selectedCount,
        totalCount
      }) : selectAllLabel;
    }
    const unit3 = totalCount > 1 ? itemsUnit : itemUnit;
    return import_react224.default.createElement(import_react224.default.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit3);
  };
  const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, {
    direction
  }));
  const listFooter = footerDom ? import_react224.default.createElement("div", {
    className: clsx(`${listPrefixCls}-footer`, classNames.footer),
    style: styles.footer
  }, footerDom) : null;
  const checkAllCheckbox = !showRemove && !pagination && checkBox;
  let items;
  if (showRemove) {
    items = [
      /* Remove Current Page */
      pagination ? {
        key: "removeCurrent",
        label: removeCurrent,
        onClick() {
          var _a;
          const pageKeys = getEnabledItemKeys((((_a = listBodyRef.current) == null ? void 0 : _a.items) || []).map((entity) => entity.item));
          onItemRemove == null ? void 0 : onItemRemove(pageKeys);
        }
      } : null,
      /* Remove All */
      {
        key: "removeAll",
        label: removeAll,
        onClick() {
          onItemRemove == null ? void 0 : onItemRemove(getEnabledItemKeys(filteredItems));
        }
      }
    ].filter(Boolean);
  } else {
    items = [{
      key: "selectAll",
      label: checkStatus === "all" ? deselectAll : selectAll,
      onClick() {
        const keys2 = getEnabledItemKeys(filteredItems);
        onItemSelectAll == null ? void 0 : onItemSelectAll(keys2, keys2.length !== checkedKeys.length);
      }
    }, pagination ? {
      key: "selectCurrent",
      label: selectCurrent,
      onClick() {
        var _a;
        const pageItems = ((_a = listBodyRef.current) == null ? void 0 : _a.items) || [];
        onItemSelectAll == null ? void 0 : onItemSelectAll(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
      }
    } : null, {
      key: "selectInvert",
      label: selectInvert,
      onClick() {
        var _a;
        const availablePageItemKeys = getEnabledItemKeys((((_a = listBodyRef.current) == null ? void 0 : _a.items) || []).map((entity) => entity.item));
        const checkedKeySet = new Set(checkedKeys);
        const newCheckedKeysSet = new Set(checkedKeySet);
        availablePageItemKeys.forEach((key) => {
          if (checkedKeySet.has(key)) {
            newCheckedKeysSet.delete(key);
          } else {
            newCheckedKeysSet.add(key);
          }
        });
        onItemSelectAll == null ? void 0 : onItemSelectAll(Array.from(newCheckedKeysSet), "replace");
      }
    }];
  }
  const dropdown = import_react224.default.createElement(dropdown_default3, {
    className: `${listPrefixCls}-header-dropdown`,
    menu: {
      items
    },
    disabled
  }, isValidIcon(selectionsIcon) ? selectionsIcon : import_react224.default.createElement(DownOutlined_default, null));
  return import_react224.default.createElement("div", {
    className: clsx(sectionPrefixCls, classNames.section, {
      [`${sectionPrefixCls}-with-pagination`]: !!pagination,
      [`${sectionPrefixCls}-with-footer`]: !!footerDom
    }),
    style: {
      ...style2,
      ...styles.section
    }
  }, import_react224.default.createElement("div", {
    className: clsx(`${listPrefixCls}-header`, classNames.header),
    style: styles.header
  }, showSelectAll ? import_react224.default.createElement(import_react224.default.Fragment, null, checkAllCheckbox, dropdown) : null, import_react224.default.createElement("span", {
    className: `${listPrefixCls}-header-selected`
  }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), import_react224.default.createElement("span", {
    className: clsx(`${listPrefixCls}-header-title`, classNames.title),
    style: styles.title
  }, titleText)), renderListBody(), listFooter);
};
if (true) {
  TransferSection.displayName = "TransferSection";
}
var Section_default = TransferSection;

// node_modules/antd/es/transfer/style/index.js
var genTransferCustomizeStyle = (token2) => {
  const {
    antCls,
    componentCls,
    listHeight,
    controlHeightLG
  } = token2;
  const tableCls = `${antCls}-table`;
  const inputCls = `${antCls}-input`;
  return {
    [`${componentCls}-customize-list`]: {
      [`${componentCls}-section`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: listHeight,
        minWidth: 0
      },
      // =================== Hook Components ===================
      [`${tableCls}-wrapper`]: {
        [`${tableCls}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${tableCls}-selection-column`]: {
            width: controlHeightLG,
            minWidth: controlHeightLG
          }
        },
        [`${tableCls}-pagination${tableCls}-pagination`]: {
          margin: 0,
          padding: token2.paddingXS
        }
      },
      [`${inputCls}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
};
var genTransferStatusColor = (token2, color) => {
  const {
    componentCls,
    colorBorder
  } = token2;
  return {
    [`${componentCls}-section`]: {
      borderColor: color,
      [`${componentCls}-list-search:not([disabled])`]: {
        borderColor: colorBorder
      }
    }
  };
};
var genTransferStatusStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-status-error`]: {
      ...genTransferStatusColor(token2, token2.colorError)
    },
    [`${componentCls}-status-warning`]: {
      ...genTransferStatusColor(token2, token2.colorWarning)
    }
  };
};
var genTransferListStyle = (token2) => {
  const {
    componentCls,
    colorBorder,
    colorSplit,
    lineWidth,
    itemHeight,
    headerHeight,
    transferHeaderVerticalPadding,
    itemPaddingBlock,
    controlItemBgActive,
    colorTextDisabled,
    colorTextSecondary,
    listHeight,
    listWidth,
    listWidthLG,
    fontSizeIcon,
    marginXS,
    paddingSM,
    lineType,
    antCls,
    iconCls,
    motionDurationSlow,
    controlItemBgHover,
    borderRadiusLG,
    colorBgContainer,
    colorText,
    controlItemBgActiveHover
  } = token2;
  const contentBorderRadius = unit(token2.calc(borderRadiusLG).sub(lineWidth).equal());
  return {
    display: "flex",
    flexDirection: "column",
    width: listWidth,
    height: listHeight,
    border: `${unit(lineWidth)} ${lineType} ${colorBorder}`,
    borderRadius: token2.borderRadiusLG,
    "&-with-pagination": {
      width: listWidthLG,
      height: "auto"
    },
    [`${componentCls}-list`]: {
      "&-search": {
        [`${iconCls}-search`]: {
          color: colorTextDisabled
        }
      },
      "&-header": {
        display: "flex",
        flex: "none",
        alignItems: "center",
        height: headerHeight,
        // border-top is on the transfer dom. We should minus 1px for this
        padding: `${unit(token2.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit(paddingSM)} ${unit(transferHeaderVerticalPadding)}`,
        color: colorText,
        background: colorBgContainer,
        borderBottom: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        borderRadius: `${unit(borderRadiusLG)} ${unit(borderRadiusLG)} 0 0`,
        "> *:not(:last-child)": {
          marginInlineEnd: 4
          // This is magic and fixed number, DO NOT use token since it may change.
        },
        "> *": {
          flex: "none"
        },
        "&-title": {
          ...textEllipsis,
          flex: "0 1 auto",
          textAlign: "end",
          marginInlineStart: "auto"
        },
        "&-dropdown": {
          ...resetIcon(),
          fontSize: fontSizeIcon,
          transform: "translateY(10%)",
          cursor: "pointer",
          "&[disabled]": {
            cursor: "not-allowed"
          }
        }
      },
      "&-body": {
        display: "flex",
        flex: "auto",
        flexDirection: "column",
        fontSize: token2.fontSize,
        // https://blog.csdn.net/qq449245884/article/details/107373672/
        minHeight: 0,
        "&-search-wrapper": {
          position: "relative",
          flex: "none",
          padding: paddingSM
        }
      },
      "&-content": {
        flex: "auto",
        margin: 0,
        padding: 0,
        overflow: "auto",
        listStyle: "none",
        borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
        "&-item": {
          display: "flex",
          alignItems: "center",
          minHeight: itemHeight,
          padding: `${unit(itemPaddingBlock)} ${unit(paddingSM)}`,
          transition: `all ${motionDurationSlow}`,
          "> *:not(:last-child)": {
            marginInlineEnd: marginXS
          },
          "> *": {
            flex: "none"
          },
          "&-text": {
            ...textEllipsis,
            flex: "auto"
          },
          "&-remove": {
            ...operationUnit(token2),
            color: colorBorder,
            "&:hover, &:focus": {
              color: colorTextSecondary
            }
          },
          [`&:not(${componentCls}-list-content-item-disabled)`]: {
            "&:hover": {
              backgroundColor: controlItemBgHover,
              cursor: "pointer"
            },
            [`&${componentCls}-list-content-item-checked:hover`]: {
              backgroundColor: controlItemBgActiveHover
            }
          },
          "&-checked": {
            backgroundColor: controlItemBgActive
          },
          "&-disabled": {
            color: colorTextDisabled,
            cursor: "not-allowed"
          }
        },
        // Do not change hover style when `oneWay` mode
        [`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
          background: "transparent",
          cursor: "default"
        }
      },
      "&-pagination": {
        padding: token2.paddingXS,
        textAlign: "end",
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`,
        [`${antCls}-pagination-options`]: {
          paddingInlineEnd: token2.paddingXS
        }
      },
      "&-body-not-found": {
        flex: "none",
        width: "100%",
        margin: "auto 0",
        color: colorTextDisabled,
        textAlign: "center"
      },
      "&-footer": {
        borderTop: `${unit(lineWidth)} ${lineType} ${colorSplit}`
      },
      // fix: https://github.com/ant-design/ant-design/issues/44489
      "&-checkbox": {
        lineHeight: 1
      }
    }
  };
};
var genTransferStyle = (token2) => {
  const {
    antCls,
    iconCls,
    componentCls,
    marginXS,
    marginXXS,
    fontSizeIcon,
    colorBgContainerDisabled
  } = token2;
  return {
    [componentCls]: {
      ...resetComponent(token2),
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${componentCls}-disabled`]: {
        [`${componentCls}-section`]: {
          background: colorBgContainerDisabled
        }
      },
      [`${componentCls}-section`]: genTransferListStyle(token2),
      [`${componentCls}-actions`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${unit(marginXS)}`,
        verticalAlign: "middle",
        gap: marginXXS,
        [`${antCls}-btn ${iconCls}`]: {
          fontSize: fontSizeIcon
        }
      }
    }
  };
};
var genTransferRTLStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var prepareComponentToken56 = (token2) => {
  const {
    fontSize,
    lineHeight,
    controlHeight,
    controlHeightLG,
    lineWidth
  } = token2;
  const fontHeight = Math.round(fontSize * lineHeight);
  return {
    listWidth: 180,
    listHeight: 200,
    listWidthLG: 250,
    headerHeight: controlHeightLG,
    itemHeight: controlHeight,
    itemPaddingBlock: (controlHeight - fontHeight) / 2,
    transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
  };
};
var style_default63 = genStyleHooks("Transfer", (token2) => {
  const transferToken = merge2(token2);
  return [genTransferStyle(transferToken), genTransferCustomizeStyle(transferToken), genTransferStatusStyle(transferToken), genTransferRTLStyle(transferToken)];
}, prepareComponentToken56);

// node_modules/antd/es/transfer/index.js
var Transfer = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    classNames,
    styles,
    style: style2,
    listStyle,
    operationStyle,
    operations,
    actions,
    dataSource,
    targetKeys = [],
    selectedKeys,
    selectAllLabels = [],
    locale: locale6 = {},
    titles,
    disabled,
    showSearch = false,
    showSelectAll,
    oneWay,
    pagination,
    status: customStatus,
    selectionsIcon,
    filterOption: filterOption2,
    render: render2,
    footer,
    children,
    rowKey,
    onScroll,
    onChange,
    onSearch,
    onSelectChange
  } = props;
  const {
    getPrefixCls,
    renderEmpty,
    direction: dir,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles,
    selectionsIcon: contextSelectionsIcon
  } = useComponentConfig("transfer");
  const contextDisabled = (0, import_react225.useContext)(DisabledContext_default);
  const mergedDisabled = disabled ?? contextDisabled;
  const mergedProps = {
    ...props,
    disabled: mergedDisabled
  };
  const prefixCls = getPrefixCls("transfer", customizePrefixCls);
  const [hashId, cssVarCls] = style_default63(prefixCls);
  const mergedActions = actions || operations || [];
  const [mergedDataSource, leftDataSource, rightDataSource] = useData_default(dataSource, rowKey, targetKeys);
  const [
    // Keys
    sourceSelectedKeys,
    targetSelectedKeys,
    // Setters
    setSourceSelectedKeys,
    setTargetSelectedKeys
  ] = useSelection_default2(leftDataSource, rightDataSource, selectedKeys);
  const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
  const setStateKeys = (0, import_react225.useCallback)((direction, keys2) => {
    if (direction === "left") {
      const nextKeys = typeof keys2 === "function" ? keys2(sourceSelectedKeys || []) : keys2;
      setSourceSelectedKeys(nextKeys);
    } else {
      const nextKeys = typeof keys2 === "function" ? keys2(targetSelectedKeys || []) : keys2;
      setTargetSelectedKeys(nextKeys);
    }
  }, [sourceSelectedKeys, targetSelectedKeys]);
  const setPrevSelectedIndex = (direction, value) => {
    const isLeftDirection = direction === "left";
    const updatePrevSelectedIndex = isLeftDirection ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex;
    updatePrevSelectedIndex(value);
  };
  const handleSelectChange = (0, import_react225.useCallback)((direction, holder) => {
    if (direction === "left") {
      onSelectChange == null ? void 0 : onSelectChange(holder, targetSelectedKeys);
    } else {
      onSelectChange == null ? void 0 : onSelectChange(sourceSelectedKeys, holder);
    }
  }, [sourceSelectedKeys, targetSelectedKeys]);
  const getTitles = (transferLocale) => titles ?? transferLocale.titles ?? [];
  const handleLeftScroll = (e3) => {
    onScroll == null ? void 0 : onScroll("left", e3);
  };
  const handleRightScroll = (e3) => {
    onScroll == null ? void 0 : onScroll("right", e3);
  };
  const moveTo = (direction) => {
    const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
    const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
    const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
    const newMoveKeysMap = groupKeysMap(newMoveKeys);
    const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
    const oppositeDirection = direction === "right" ? "left" : "right";
    setStateKeys(oppositeDirection, []);
    handleSelectChange(oppositeDirection, []);
    onChange == null ? void 0 : onChange(newTargetKeys, direction, newMoveKeys);
  };
  const moveToLeft = () => {
    moveTo("left");
    setPrevSelectedIndex("left", null);
  };
  const moveToRight = () => {
    moveTo("right");
    setPrevSelectedIndex("right", null);
  };
  const onItemSelectAll = (direction, keys2, checkAll) => {
    setStateKeys(direction, (prevKeys) => {
      let mergedCheckedKeys = [];
      if (checkAll === "replace") {
        mergedCheckedKeys = keys2;
      } else if (checkAll) {
        mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys2))));
      } else {
        const selectedKeysMap = groupKeysMap(keys2);
        mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
      }
      handleSelectChange(direction, mergedCheckedKeys);
      return mergedCheckedKeys;
    });
    setPrevSelectedIndex(direction, null);
  };
  const onLeftItemSelectAll = (keys2, checkAll) => {
    onItemSelectAll("left", keys2, checkAll);
  };
  const onRightItemSelectAll = (keys2, checkAll) => {
    onItemSelectAll("right", keys2, checkAll);
  };
  const leftFilter = (e3) => onSearch == null ? void 0 : onSearch("left", e3.target.value);
  const rightFilter = (e3) => onSearch == null ? void 0 : onSearch("right", e3.target.value);
  const handleLeftClear = () => onSearch == null ? void 0 : onSearch("left", "");
  const handleRightClear = () => onSearch == null ? void 0 : onSearch("right", "");
  const handleSingleSelect = (direction, holder, selectedKey, checked, currentSelectedIndex) => {
    const isSelected = holder.has(selectedKey);
    if (isSelected) {
      holder.delete(selectedKey);
      setPrevSelectedIndex(direction, null);
    }
    if (checked) {
      holder.add(selectedKey);
      setPrevSelectedIndex(direction, currentSelectedIndex);
    }
  };
  const handleMultipleSelect = (direction, data, holder, currentSelectedIndex) => {
    const isLeftDirection = direction === "left";
    const multipleSelect = isLeftDirection ? leftMultipleSelect : rightMultipleSelect;
    multipleSelect(currentSelectedIndex, data, holder);
  };
  const onItemSelect = (direction, selectedKey, checked, multiple) => {
    const isLeftDirection = direction === "left";
    const holder = _toConsumableArray(isLeftDirection ? sourceSelectedKeys : targetSelectedKeys);
    const holderSet = new Set(holder);
    const data = _toConsumableArray(isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !(item == null ? void 0 : item.disabled));
    const currentSelectedIndex = data.findIndex((item) => item.key === selectedKey);
    if (multiple && holder.length > 0) {
      handleMultipleSelect(direction, data, holderSet, currentSelectedIndex);
    } else {
      handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
    }
    const holderArr = Array.from(holderSet);
    handleSelectChange(direction, holderArr);
    if (!props.selectedKeys) {
      setStateKeys(direction, holderArr);
    }
  };
  const onLeftItemSelect = (selectedKey, checked, e3) => {
    onItemSelect("left", selectedKey, checked, e3 == null ? void 0 : e3.shiftKey);
  };
  const onRightItemSelect = (selectedKey, checked, e3) => {
    onItemSelect("right", selectedKey, checked, e3 == null ? void 0 : e3.shiftKey);
  };
  const onRightItemRemove = (keys2) => {
    setStateKeys("right", []);
    onChange == null ? void 0 : onChange(targetKeys.filter((key) => !keys2.includes(key)), "left", _toConsumableArray(keys2));
  };
  const handleListStyle = (direction) => {
    if (typeof listStyle === "function") {
      return listStyle({
        direction
      });
    }
    return listStyle || {};
  };
  const formItemContext = (0, import_react225.useContext)(FormItemInputContext);
  const {
    hasFeedback,
    status
  } = formItemContext;
  const getLocale = (transferLocale) => ({
    ...transferLocale,
    notFoundContent: (renderEmpty == null ? void 0 : renderEmpty("Transfer")) || import_react225.default.createElement(defaultRenderEmpty_default, {
      componentName: "Transfer"
    }),
    ...locale6
  });
  const mergedStatus = getMergedStatus(status, customStatus);
  const mergedPagination = !children && pagination;
  const leftActive = rightDataSource.filter((d) => targetSelectedKeys.includes(d.key) && !d.disabled).length > 0;
  const rightActive = leftDataSource.filter((d) => sourceSelectedKeys.includes(d.key) && !d.disabled).length > 0;
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const cls = clsx(prefixCls, {
    [`${prefixCls}-disabled`]: mergedDisabled,
    [`${prefixCls}-customize-list`]: !!children,
    [`${prefixCls}-rtl`]: dir === "rtl"
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
  const [contextLocale] = useLocale_default("Transfer", en_US_default6.Transfer);
  const listLocale = getLocale(contextLocale);
  const [leftTitle, rightTitle] = getTitles(listLocale);
  const mergedSelectionsIcon = selectionsIcon ?? contextSelectionsIcon;
  if (true) {
    const warning5 = devUseWarning("Transfer");
    true ? warning5(!pagination || !children, "usage", "`pagination` not support customize render list.") : void 0;
    [["listStyle", "styles.section"], ["operationStyle", "styles.actions"], ["operations", "actions"]].forEach(([deprecatedName, newName]) => {
      warning5.deprecated(!(deprecatedName in props), deprecatedName, newName);
    });
  }
  return import_react225.default.createElement("div", {
    className: cls,
    style: {
      ...contextStyle,
      ...mergedStyles.root,
      ...style2
    }
  }, import_react225.default.createElement(Section_default, {
    prefixCls,
    style: handleListStyle("left"),
    classNames: mergedClassNames,
    styles: mergedStyles,
    titleText: leftTitle,
    dataSource: leftDataSource,
    filterOption: filterOption2,
    checkedKeys: sourceSelectedKeys,
    handleFilter: leftFilter,
    handleClear: handleLeftClear,
    onItemSelect: onLeftItemSelect,
    onItemSelectAll: onLeftItemSelectAll,
    render: render2,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleLeftScroll,
    disabled: mergedDisabled,
    direction: dir === "rtl" ? "right" : "left",
    showSelectAll,
    selectAllLabel: selectAllLabels[0],
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon,
    ...listLocale
  }), import_react225.default.createElement(Actions_default, {
    className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
    rightActive,
    moveToRight,
    leftActive,
    actions: mergedActions,
    moveToLeft,
    style: {
      ...operationStyle,
      ...mergedStyles.actions
    },
    disabled: mergedDisabled,
    direction: dir,
    oneWay
  }), import_react225.default.createElement(Section_default, {
    prefixCls,
    style: handleListStyle("right"),
    classNames: mergedClassNames,
    styles: mergedStyles,
    titleText: rightTitle,
    dataSource: rightDataSource,
    filterOption: filterOption2,
    checkedKeys: targetSelectedKeys,
    handleFilter: rightFilter,
    handleClear: handleRightClear,
    onItemSelect: onRightItemSelect,
    onItemSelectAll: onRightItemSelectAll,
    onItemRemove: onRightItemRemove,
    render: render2,
    showSearch,
    renderList: children,
    footer,
    onScroll: handleRightScroll,
    disabled: mergedDisabled,
    direction: dir === "rtl" ? "left" : "right",
    showSelectAll,
    selectAllLabel: selectAllLabels[1],
    showRemove: oneWay,
    pagination: mergedPagination,
    selectionsIcon: mergedSelectionsIcon,
    ...listLocale
  }));
};
if (true) {
  Transfer.displayName = "Transfer";
}
Transfer.List = Section_default;
Transfer.Search = search_default2;
Transfer.Operation = Actions_default;
var transfer_default = Transfer;

// node_modules/antd/es/tree-select/index.js
var React628 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeSelect.js
var React627 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/hooks/useCache.js
var React616 = __toESM(require_react());
var useCache_default2 = (values) => {
  const cacheRef = React616.useRef({
    valueLabels: /* @__PURE__ */ new Map()
  });
  return React616.useMemo(() => {
    const {
      valueLabels
    } = cacheRef.current;
    const valueLabelsCache = /* @__PURE__ */ new Map();
    const filledValues = values.map((item) => {
      const {
        value,
        label
      } = item;
      const mergedLabel = label ?? valueLabels.get(value);
      valueLabelsCache.set(value, mergedLabel);
      return {
        ...item,
        label: mergedLabel
      };
    });
    cacheRef.current.valueLabels = valueLabelsCache;
    return [filledValues];
  }, [values]);
};

// node_modules/@rc-component/tree-select/es/hooks/useCheckedKeys.js
var React617 = __toESM(require_react());
var useCheckedKeys = (rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities) => {
  return React617.useMemo(() => {
    const extractValues = (values) => values.map(({
      value
    }) => value);
    const checkedKeys = extractValues(rawLabeledValues);
    const halfCheckedKeys = extractValues(rawHalfCheckedValues);
    const missingValues = checkedKeys.filter((key) => !keyEntities[key]);
    let finalCheckedKeys = checkedKeys;
    let finalHalfCheckedKeys = halfCheckedKeys;
    if (treeConduction) {
      const conductResult = conductCheck(checkedKeys, true, keyEntities);
      finalCheckedKeys = conductResult.checkedKeys;
      finalHalfCheckedKeys = conductResult.halfCheckedKeys;
    }
    return [Array.from(/* @__PURE__ */ new Set([...missingValues, ...finalCheckedKeys])), finalHalfCheckedKeys];
  }, [rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities]);
};
var useCheckedKeys_default = useCheckedKeys;

// node_modules/@rc-component/tree-select/es/hooks/useDataEntities.js
var React618 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/utils/valueUtil.js
var toArray9 = (value) => Array.isArray(value) ? value : value !== void 0 ? [value] : [];
var fillFieldNames4 = (fieldNames) => {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  return {
    _title: label ? [label] : ["title", "label"],
    value: value || "value",
    key: value || "value",
    children: children || "children"
  };
};
var isCheckDisabled2 = (node2) => !node2 || node2.disabled || node2.disableCheckbox || node2.checkable === false;
var getAllKeys = (treeData, fieldNames) => {
  const keys2 = [];
  const dig = (list) => {
    list.forEach((item) => {
      const children = item[fieldNames.children];
      if (children) {
        keys2.push(item[fieldNames.value]);
        dig(children);
      }
    });
  };
  dig(treeData);
  return keys2;
};
var isNil = (val) => val === null || val === void 0;

// node_modules/@rc-component/tree-select/es/hooks/useDataEntities.js
var useDataEntities_default = (treeData, fieldNames) => React618.useMemo(() => {
  const collection = convertDataToEntities(treeData, {
    fieldNames,
    initWrapper: (wrapper) => ({
      ...wrapper,
      valueEntities: /* @__PURE__ */ new Map()
    }),
    processEntity: (entity, wrapper) => {
      const val = entity.node[fieldNames.value];
      if (true) {
        const key = entity.node.key;
        warning_default(!isNil(val), "TreeNode `value` is invalidate: undefined");
        warning_default(!wrapper.valueEntities.has(val), `Same \`value\` exist in the tree: ${val}`);
        warning_default(!key || String(key) === String(val), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${key}, value: ${val}.`);
      }
      wrapper.valueEntities.set(val, entity);
    }
  });
  return collection;
}, [treeData, fieldNames]);

// node_modules/@rc-component/tree-select/es/hooks/useFilterTreeData.js
var React620 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/utils/legacyUtil.js
var React619 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeNode.js
var TreeNode2 = () => null;
var TreeNode_default2 = TreeNode2;

// node_modules/@rc-component/tree-select/es/utils/legacyUtil.js
function convertChildrenToData2(nodes) {
  return toArray(nodes).map((node2) => {
    if (!React619.isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      key,
      props: {
        children,
        value,
        ...restProps
      }
    } = node2;
    const data = {
      key,
      value,
      ...restProps
    };
    const childData = convertChildrenToData2(children);
    if (childData.length) {
      data.children = childData;
    }
    return data;
  }).filter((data) => data);
}
function fillLegacyProps(dataNode) {
  if (!dataNode) {
    return dataNode;
  }
  const cloneNode = {
    ...dataNode
  };
  if (!("props" in cloneNode)) {
    Object.defineProperty(cloneNode, "props", {
      get() {
        warning_default(false, "New `rc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access.");
        return cloneNode;
      }
    });
  }
  return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
  let triggerNode = null;
  let nodeList = null;
  function generateMap() {
    function dig(list, level = "0", parentIncluded = false) {
      return list.map((option, index2) => {
        const pos = `${level}-${index2}`;
        const value = option[fieldNames.value];
        const included = checkedValues.includes(value);
        const children = dig(option[fieldNames.children] || [], pos, included);
        const node2 = React619.createElement(TreeNode_default2, option, children.map((child) => child.node));
        if (triggerValue === value) {
          triggerNode = node2;
        }
        if (included) {
          const checkedNode = {
            pos,
            node: node2,
            children
          };
          if (!parentIncluded) {
            nodeList.push(checkedNode);
          }
          return checkedNode;
        }
        return null;
      }).filter((node2) => node2);
    }
    if (!nodeList) {
      nodeList = [];
      dig(treeData);
      nodeList.sort(({
        node: {
          props: {
            value: val1
          }
        }
      }, {
        node: {
          props: {
            value: val2
          }
        }
      }) => {
        const index1 = checkedValues.indexOf(val1);
        const index2 = checkedValues.indexOf(val2);
        return index1 - index2;
      });
    }
  }
  Object.defineProperty(extra, "triggerNode", {
    get() {
      warning_default(false, "`triggerNode` is deprecated. Please consider decoupling data with node.");
      generateMap();
      return triggerNode;
    }
  });
  Object.defineProperty(extra, "allCheckedNodes", {
    get() {
      warning_default(false, "`allCheckedNodes` is deprecated. Please consider decoupling data with node.");
      generateMap();
      if (showPosition) {
        return nodeList;
      }
      return nodeList.map(({
        node: node2
      }) => node2);
    }
  });
}

// node_modules/@rc-component/tree-select/es/hooks/useFilterTreeData.js
var useFilterTreeData = (treeData, searchValue, options) => {
  const {
    fieldNames,
    treeNodeFilterProp,
    filterTreeNode
  } = options;
  const {
    children: fieldChildren
  } = fieldNames;
  return React620.useMemo(() => {
    if (!searchValue || filterTreeNode === false) {
      return treeData;
    }
    const filterOptionFunc = typeof filterTreeNode === "function" ? filterTreeNode : (_, dataNode) => String(dataNode[treeNodeFilterProp]).toUpperCase().includes(searchValue.toUpperCase());
    const filterTreeNodes = (nodes, keepAll = false) => nodes.reduce((filtered, node2) => {
      const children = node2[fieldChildren];
      const isMatch = keepAll || filterOptionFunc(searchValue, fillLegacyProps(node2));
      const filteredChildren = filterTreeNodes(children || [], isMatch);
      if (isMatch || filteredChildren.length) {
        filtered.push({
          ...node2,
          isLeaf: void 0,
          [fieldChildren]: filteredChildren
        });
      }
      return filtered;
    }, []);
    return filterTreeNodes(treeData);
  }, [treeData, searchValue, fieldChildren, treeNodeFilterProp, filterTreeNode]);
};
var useFilterTreeData_default = useFilterTreeData;

// node_modules/@rc-component/tree-select/es/hooks/useRefFunc.js
var React621 = __toESM(require_react());
function useRefFunc2(callback) {
  const funcRef = React621.useRef();
  funcRef.current = callback;
  const cacheFn = React621.useCallback((...args) => {
    return funcRef.current(...args);
  }, []);
  return cacheFn;
}

// node_modules/@rc-component/tree-select/es/hooks/useTreeData.js
var React622 = __toESM(require_react());
function buildTreeStructure(nodes, config) {
  const {
    id,
    pId,
    rootPId
  } = config;
  const nodeMap = /* @__PURE__ */ new Map();
  const rootNodes = [];
  nodes.forEach((node2) => {
    const nodeKey = node2[id];
    const clonedNode = {
      ...node2,
      key: node2.key || nodeKey
    };
    nodeMap.set(nodeKey, clonedNode);
  });
  nodeMap.forEach((node2) => {
    const parentKey = node2[pId];
    const parent = nodeMap.get(parentKey);
    if (parent) {
      parent.children = parent.children || [];
      parent.children.push(node2);
    } else if (parentKey === rootPId || rootPId === null) {
      rootNodes.push(node2);
    }
  });
  return rootNodes;
}
function useTreeData(treeData, children, simpleMode) {
  return React622.useMemo(() => {
    if (treeData) {
      if (simpleMode) {
        const config = {
          id: "id",
          pId: "pId",
          rootPId: null,
          ...typeof simpleMode === "object" ? simpleMode : {}
        };
        return buildTreeStructure(treeData, config);
      }
      return treeData;
    }
    return convertChildrenToData2(children);
  }, [children, simpleMode, treeData]);
}

// node_modules/@rc-component/tree-select/es/LegacyContext.js
var React623 = __toESM(require_react());
var LegacySelectContext = React623.createContext(null);
var LegacyContext_default = LegacySelectContext;

// node_modules/@rc-component/tree-select/es/OptionList.js
var React625 = __toESM(require_react());

// node_modules/@rc-component/tree-select/es/TreeSelectContext.js
var React624 = __toESM(require_react());
var TreeSelectContext = React624.createContext(null);
var TreeSelectContext_default = TreeSelectContext;

// node_modules/@rc-component/tree-select/es/OptionList.js
function _extends97() {
  _extends97 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends97.apply(this, arguments);
}
var HIDDEN_STYLE3 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var OptionList2 = (_, ref) => {
  const {
    prefixCls,
    multiple,
    searchValue,
    toggleOpen,
    open: open3,
    notFoundContent
  } = useBaseProps();
  const {
    virtual,
    listHeight,
    listItemHeight,
    listItemScrollOffset,
    treeData,
    fieldNames,
    onSelect,
    popupMatchSelectWidth,
    treeExpandAction,
    treeTitleRender,
    onPopupScroll,
    leftMaxCount,
    leafCountOnly,
    valueEntities,
    classNames: treeClassNames,
    styles
  } = React625.useContext(TreeSelectContext_default);
  const {
    checkable,
    checkedKeys,
    halfCheckedKeys,
    treeExpandedKeys,
    treeDefaultExpandAll,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeLine,
    treeNodeFilterProp,
    loadData,
    treeLoadedKeys,
    treeMotion,
    onTreeLoad,
    keyEntities
  } = React625.useContext(LegacyContext_default);
  const treeRef = React625.useRef();
  const memoTreeData = useMemo(
    () => treeData,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [open3, treeData],
    (prev2, next2) => next2[0] && prev2[1] !== next2[1]
  );
  const mergedCheckedKeys = React625.useMemo(() => {
    if (!checkable) {
      return null;
    }
    return {
      checked: checkedKeys,
      halfChecked: halfCheckedKeys
    };
  }, [checkable, checkedKeys, halfCheckedKeys]);
  React625.useEffect(() => {
    var _a;
    if (open3 && !multiple && checkedKeys.length) {
      (_a = treeRef.current) == null ? void 0 : _a.scrollTo({
        key: checkedKeys[0]
      });
    }
  }, [open3]);
  const onListMouseDown = (event) => {
    event.preventDefault();
  };
  const onInternalSelect = (__, info) => {
    const {
      node: node2
    } = info;
    if (checkable && isCheckDisabled2(node2)) {
      return;
    }
    onSelect(node2.key, {
      selected: !checkedKeys.includes(node2.key)
    });
    if (!multiple) {
      toggleOpen(false);
    }
  };
  const [expandedKeys, setExpandedKeys] = React625.useState(treeDefaultExpandedKeys);
  const [searchExpandedKeys, setSearchExpandedKeys] = React625.useState(null);
  const mergedExpandedKeys = React625.useMemo(() => {
    if (treeExpandedKeys) {
      return [...treeExpandedKeys];
    }
    return searchValue ? searchExpandedKeys : expandedKeys;
  }, [expandedKeys, searchExpandedKeys, treeExpandedKeys, searchValue]);
  const onInternalExpand = (keys2) => {
    setExpandedKeys(keys2);
    setSearchExpandedKeys(keys2);
    if (onTreeExpand) {
      onTreeExpand(keys2);
    }
  };
  const lowerSearchValue = String(searchValue).toLowerCase();
  const filterTreeNode = (treeNode) => {
    if (!lowerSearchValue) {
      return false;
    }
    return String(treeNode[treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue);
  };
  React625.useEffect(() => {
    if (searchValue) {
      setSearchExpandedKeys(getAllKeys(treeData, fieldNames));
    }
  }, [searchValue]);
  const [disabledCache, setDisabledCache] = React625.useState(() => /* @__PURE__ */ new Map());
  React625.useEffect(() => {
    if (leftMaxCount) {
      setDisabledCache(/* @__PURE__ */ new Map());
    }
  }, [leftMaxCount]);
  function getDisabledWithCache(node2) {
    const value = node2[fieldNames.value];
    if (!disabledCache.has(value)) {
      const entity = valueEntities.get(value);
      const isLeaf2 = (entity.children || []).length === 0;
      if (!isLeaf2) {
        const checkableChildren = entity.children.filter((childTreeNode) => !childTreeNode.node.disabled && !childTreeNode.node.disableCheckbox && !checkedKeys.includes(childTreeNode.node[fieldNames.value]));
        const checkableChildrenCount = checkableChildren.length;
        disabledCache.set(value, checkableChildrenCount > leftMaxCount);
      } else {
        disabledCache.set(value, false);
      }
    }
    return disabledCache.get(value);
  }
  const nodeDisabled = useEvent_default((node2) => {
    const nodeValue = node2[fieldNames.value];
    if (checkedKeys.includes(nodeValue)) {
      return false;
    }
    if (leftMaxCount === null) {
      return false;
    }
    if (leftMaxCount <= 0) {
      return true;
    }
    if (leafCountOnly && leftMaxCount) {
      return getDisabledWithCache(node2);
    }
    return false;
  });
  const getFirstMatchingNode = (nodes) => {
    for (const node2 of nodes) {
      if (node2.disabled || node2.selectable === false) {
        continue;
      }
      if (searchValue) {
        if (filterTreeNode(node2)) {
          return node2;
        }
      } else {
        return node2;
      }
      if (node2[fieldNames.children]) {
        const matchInChildren = getFirstMatchingNode(node2[fieldNames.children]);
        if (matchInChildren) {
          return matchInChildren;
        }
      }
    }
    return null;
  };
  const [activeKey, setActiveKey] = React625.useState(null);
  const activeEntity = keyEntities[activeKey];
  React625.useEffect(() => {
    if (!open3) {
      return;
    }
    let nextActiveKey = null;
    const getFirstNode = () => {
      const firstNode = getFirstMatchingNode(memoTreeData);
      return firstNode ? firstNode[fieldNames.value] : null;
    };
    if (!multiple && checkedKeys.length && !searchValue) {
      nextActiveKey = checkedKeys[0];
    } else {
      nextActiveKey = getFirstNode();
    }
    setActiveKey(nextActiveKey);
  }, [open3, searchValue]);
  React625.useImperativeHandle(ref, () => {
    var _a;
    return {
      scrollTo: (_a = treeRef.current) == null ? void 0 : _a.scrollTo,
      onKeyDown: (event) => {
        var _a2;
        const {
          which
        } = event;
        switch (which) {
          case KeyCode_default.UP:
          case KeyCode_default.DOWN:
          case KeyCode_default.LEFT:
          case KeyCode_default.RIGHT:
            (_a2 = treeRef.current) == null ? void 0 : _a2.onKeyDown(event);
            break;
          case KeyCode_default.ENTER: {
            if (activeEntity) {
              const isNodeDisabled = nodeDisabled(activeEntity.node);
              const {
                selectable,
                value,
                disabled
              } = (activeEntity == null ? void 0 : activeEntity.node) || {};
              if (selectable !== false && !disabled && !isNodeDisabled) {
                onInternalSelect(null, {
                  node: {
                    key: activeKey
                  },
                  selected: !checkedKeys.includes(value)
                });
              }
            }
            break;
          }
          case KeyCode_default.ESC: {
            toggleOpen(false);
          }
        }
      },
      onKeyUp: () => {
      }
    };
  });
  const hasLoadDataFn = useMemo(
    () => searchValue ? false : true,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchValue, treeExpandedKeys || expandedKeys],
    ([preSearchValue], [nextSearchValue, nextExcludeSearchExpandedKeys]) => preSearchValue !== nextSearchValue && !!(nextSearchValue || nextExcludeSearchExpandedKeys)
  );
  const syncLoadData = hasLoadDataFn ? loadData : null;
  if (memoTreeData.length === 0) {
    return React625.createElement("div", {
      role: "listbox",
      className: `${prefixCls}-empty`,
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  const treeProps = {
    fieldNames
  };
  if (treeLoadedKeys) {
    treeProps.loadedKeys = treeLoadedKeys;
  }
  if (mergedExpandedKeys) {
    treeProps.expandedKeys = mergedExpandedKeys;
  }
  return React625.createElement("div", {
    onMouseDown: onListMouseDown
  }, activeEntity && open3 && React625.createElement("span", {
    style: HIDDEN_STYLE3,
    "aria-live": "assertive"
  }, activeEntity.node.value), React625.createElement(UnstableContext4.Provider, {
    value: {
      nodeDisabled
    }
  }, React625.createElement(es_default33, _extends97({
    classNames: treeClassNames == null ? void 0 : treeClassNames.popup,
    styles: styles == null ? void 0 : styles.popup,
    ref: treeRef,
    focusable: false,
    prefixCls: `${prefixCls}-tree`,
    treeData: memoTreeData,
    height: listHeight,
    itemHeight: listItemHeight,
    itemScrollOffset: listItemScrollOffset,
    virtual: virtual !== false && popupMatchSelectWidth !== false,
    multiple,
    icon: treeIcon,
    showIcon: showTreeIcon,
    switcherIcon,
    showLine: treeLine,
    loadData: syncLoadData,
    motion: treeMotion,
    activeKey,
    checkable,
    checkStrictly: true,
    checkedKeys: mergedCheckedKeys,
    selectedKeys: !checkable ? checkedKeys : [],
    defaultExpandAll: treeDefaultExpandAll,
    titleRender: treeTitleRender
  }, treeProps, {
    // Proxy event out
    onActiveChange: setActiveKey,
    onSelect: onInternalSelect,
    onCheck: onInternalSelect,
    onExpand: onInternalExpand,
    onLoad: onTreeLoad,
    filterTreeNode,
    expandAction: treeExpandAction,
    onScroll: onPopupScroll
  }))));
};
var RefOptionList3 = React625.forwardRef(OptionList2);
if (true) {
  RefOptionList3.displayName = "OptionList";
}
var OptionList_default3 = RefOptionList3;

// node_modules/@rc-component/tree-select/es/utils/strategyUtil.js
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT3 = "SHOW_PARENT";
var SHOW_CHILD3 = "SHOW_CHILD";
function formatStrategyValues2(values, strategy, keyEntities, fieldNames) {
  const valueSet = new Set(values);
  if (strategy === SHOW_CHILD3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      return !entity || !entity.children || !entity.children.some(({
        node: node2
      }) => valueSet.has(node2[fieldNames.value])) || !entity.children.every(({
        node: node2
      }) => isCheckDisabled2(node2) || valueSet.has(node2[fieldNames.value]));
    });
  }
  if (strategy === SHOW_PARENT3) {
    return values.filter((key) => {
      const entity = keyEntities[key];
      const parent = entity ? entity.parent : null;
      return !parent || isCheckDisabled2(parent.node) || !valueSet.has(parent.key);
    });
  }
  return values;
}

// node_modules/@rc-component/tree-select/es/utils/warningPropsUtil.js
function warningProps2(props) {
  const {
    searchPlaceholder,
    treeCheckStrictly,
    treeCheckable,
    labelInValue,
    value,
    multiple,
    showCheckedStrategy,
    maxCount
  } = props;
  warning_default(!searchPlaceholder, "`searchPlaceholder` has been removed.");
  if (treeCheckStrictly && labelInValue === false) {
    warning_default(false, "`treeCheckStrictly` will force set `labelInValue` to `true`.");
  }
  if (labelInValue || treeCheckStrictly) {
    warning_default(toArray9(value).every((val) => val && typeof val === "object" && "value" in val), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead.");
  }
  if (treeCheckStrictly || multiple || treeCheckable) {
    warning_default(!value || Array.isArray(value), "`value` should be an array when `TreeSelect` is checkable or multiple.");
  } else {
    warning_default(!Array.isArray(value), "`value` should not be array when `TreeSelect` is single mode.");
  }
  if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) {
    warning_default(false, "`maxCount` not work with `showCheckedStrategy=SHOW_ALL` (when `treeCheckStrictly=false`) or `showCheckedStrategy=SHOW_PARENT`.");
  }
}
var warningPropsUtil_default2 = warningProps2;

// node_modules/@rc-component/tree-select/es/hooks/useSearchConfig.js
var React626 = __toESM(require_react());
function useSearchConfig3(showSearch, props) {
  const {
    searchValue,
    inputValue,
    onSearch,
    autoClearSearchValue,
    filterTreeNode,
    treeNodeFilterProp
  } = props;
  return React626.useMemo(() => {
    const isObject2 = typeof showSearch === "object";
    const searchConfig = {
      searchValue: searchValue ?? inputValue,
      onSearch,
      autoClearSearchValue,
      filterTreeNode,
      treeNodeFilterProp,
      ...isObject2 ? showSearch : {}
    };
    return [isObject2 ? true : showSearch, searchConfig];
  }, [showSearch, searchValue, inputValue, onSearch, autoClearSearchValue, filterTreeNode, treeNodeFilterProp]);
}

// node_modules/@rc-component/tree-select/es/TreeSelect.js
function _extends98() {
  _extends98 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends98.apply(this, arguments);
}
function isRawValue2(value) {
  return !value || typeof value !== "object";
}
var TreeSelect = React627.forwardRef((props, ref) => {
  const {
    id,
    prefixCls = "rc-tree-select",
    // Value
    value,
    defaultValue,
    onChange,
    onSelect,
    onDeselect,
    // Search
    showSearch,
    searchValue: legacySearchValue,
    inputValue: legacyinputValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterTreeNode: legacyFilterTreeNode,
    treeNodeFilterProp: legacytreeNodeFilterProp,
    // Selector
    showCheckedStrategy,
    treeNodeLabelProp,
    //  Mode
    multiple,
    treeCheckable,
    treeCheckStrictly,
    labelInValue,
    maxCount,
    // FieldNames
    fieldNames,
    // Data
    treeDataSimpleMode,
    treeData,
    children,
    loadData,
    treeLoadedKeys,
    onTreeLoad,
    // Expanded
    treeDefaultExpandAll,
    treeExpandedKeys,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeExpandAction,
    // Options
    virtual,
    listHeight = 200,
    listItemHeight = 20,
    listItemScrollOffset = 0,
    onPopupVisibleChange,
    popupMatchSelectWidth = true,
    // Tree
    treeLine,
    treeIcon,
    showTreeIcon,
    switcherIcon,
    treeMotion,
    treeTitleRender,
    onPopupScroll,
    classNames: treeSelectClassNames,
    styles,
    ...restProps
  } = props;
  const mergedId = useId_default(id);
  const treeConduction = treeCheckable && !treeCheckStrictly;
  const mergedCheckable = treeCheckable || treeCheckStrictly;
  const mergedLabelInValue = treeCheckStrictly || labelInValue;
  const mergedMultiple = mergedCheckable || multiple;
  const searchProps = {
    searchValue: legacySearchValue,
    inputValue: legacyinputValue,
    onSearch: legacyOnSearch,
    autoClearSearchValue: legacyAutoClearSearchValue,
    filterTreeNode: legacyFilterTreeNode,
    treeNodeFilterProp: legacytreeNodeFilterProp
  };
  const [mergedShowSearch, searchConfig] = useSearchConfig3(showSearch, searchProps);
  const {
    searchValue,
    onSearch,
    autoClearSearchValue = true,
    filterTreeNode,
    treeNodeFilterProp = "value"
  } = searchConfig;
  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);
  const mergedShowCheckedStrategy = React627.useMemo(() => {
    if (!treeCheckable) {
      return SHOW_ALL;
    }
    return showCheckedStrategy || SHOW_CHILD3;
  }, [showCheckedStrategy, treeCheckable]);
  if (true) {
    warningPropsUtil_default2(props);
  }
  const mergedFieldNames = React627.useMemo(
    () => fillFieldNames4(fieldNames),
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(fieldNames)]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
  const mergedSearchValue = internalSearchValue || "";
  const onInternalSearch = (searchText) => {
    setSearchValue(searchText);
    onSearch == null ? void 0 : onSearch(searchText);
  };
  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);
  const {
    keyEntities,
    valueEntities
  } = useDataEntities_default(mergedTreeData, mergedFieldNames);
  const splitRawValues = React627.useCallback((newRawValues) => {
    const missingRawValues = [];
    const existRawValues = [];
    newRawValues.forEach((val) => {
      if (valueEntities.has(val)) {
        existRawValues.push(val);
      } else {
        missingRawValues.push(val);
      }
    });
    return {
      missingRawValues,
      existRawValues
    };
  }, [valueEntities]);
  const filteredTreeData = useFilterTreeData_default(mergedTreeData, mergedSearchValue, {
    fieldNames: mergedFieldNames,
    treeNodeFilterProp,
    filterTreeNode
  });
  const getLabel = React627.useCallback((item) => {
    if (item) {
      if (treeNodeLabelProp) {
        return item[treeNodeLabelProp];
      }
      const {
        _title: titleList
      } = mergedFieldNames;
      for (let i = 0; i < titleList.length; i += 1) {
        const title = item[titleList[i]];
        if (title !== void 0) {
          return title;
        }
      }
    }
  }, [mergedFieldNames, treeNodeLabelProp]);
  const toLabeledValues = React627.useCallback((draftValues) => {
    const values = toArray9(draftValues);
    return values.map((val) => {
      if (isRawValue2(val)) {
        return {
          value: val
        };
      }
      return val;
    });
  }, []);
  const convert2LabelValues = React627.useCallback((draftValues) => {
    const values = toLabeledValues(draftValues);
    return values.map((item) => {
      let {
        label: rawLabel
      } = item;
      const {
        value: rawValue,
        halfChecked: rawHalfChecked
      } = item;
      let rawDisabled;
      const entity = valueEntities.get(rawValue);
      if (entity) {
        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);
        rawDisabled = entity.node.disabled;
      } else if (rawLabel === void 0) {
        const labelInValueItem = toLabeledValues(internalValue).find((labeledItem) => labeledItem.value === rawValue);
        rawLabel = labelInValueItem.label;
      }
      return {
        label: rawLabel,
        value: rawValue,
        halfChecked: rawHalfChecked,
        disabled: rawDisabled
      };
    });
  }, [valueEntities, getLabel, toLabeledValues, internalValue]);
  const rawMixedLabeledValues = React627.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);
  const [rawLabeledValues, rawHalfLabeledValues] = React627.useMemo(() => {
    const fullCheckValues = [];
    const halfCheckValues = [];
    rawMixedLabeledValues.forEach((item) => {
      if (item.halfChecked) {
        halfCheckValues.push(item);
      } else {
        fullCheckValues.push(item);
      }
    });
    return [fullCheckValues, halfCheckValues];
  }, [rawMixedLabeledValues]);
  const rawValues = React627.useMemo(() => rawLabeledValues.map((item) => item.value), [rawLabeledValues]);
  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys_default(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);
  const displayValues = React627.useMemo(() => {
    const displayKeys = formatStrategyValues2(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
    const values = displayKeys.map((key) => {
      var _a, _b;
      return ((_b = (_a = keyEntities[key]) == null ? void 0 : _a.node) == null ? void 0 : _b[mergedFieldNames.value]) ?? key;
    });
    const labeledValues = values.map((val) => {
      const targetItem = rawLabeledValues.find((item) => item.value === val);
      const label = labelInValue ? targetItem == null ? void 0 : targetItem.label : treeTitleRender == null ? void 0 : treeTitleRender(targetItem);
      return {
        value: val,
        label
      };
    });
    const rawDisplayValues = convert2LabelValues(labeledValues);
    const firstVal = rawDisplayValues[0];
    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {
      return [];
    }
    return rawDisplayValues.map((item) => ({
      ...item,
      label: item.label ?? item.value
    }));
  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);
  const [cachedDisplayValues] = useCache_default2(displayValues);
  const mergedMaxCount = React627.useMemo(() => {
    if (mergedMultiple && (mergedShowCheckedStrategy === "SHOW_CHILD" || treeCheckStrictly || !treeCheckable)) {
      return maxCount;
    }
    return null;
  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);
  const triggerChange = useRefFunc2((newRawValues, extra, source) => {
    const formattedKeyList = formatStrategyValues2(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);
    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {
      return;
    }
    const labeledValues = convert2LabelValues(newRawValues);
    setInternalValue(labeledValues);
    if (autoClearSearchValue) {
      setSearchValue("");
    }
    if (onChange) {
      let eventValues = newRawValues;
      if (treeConduction) {
        eventValues = formattedKeyList.map((key) => {
          const entity = valueEntities.get(key);
          return entity ? entity.node[mergedFieldNames.value] : key;
        });
      }
      const {
        triggerValue,
        selected
      } = extra || {
        triggerValue: void 0,
        selected: void 0
      };
      let returnRawValues = eventValues;
      if (treeCheckStrictly) {
        const halfValues = rawHalfLabeledValues.filter((item) => !eventValues.includes(item.value));
        returnRawValues = [...returnRawValues, ...halfValues];
      }
      const returnLabeledValues = convert2LabelValues(returnRawValues);
      const additionalInfo = {
        // [Legacy] Always return as array contains label & value
        preValue: rawLabeledValues,
        triggerValue
      };
      let showPosition = true;
      if (treeCheckStrictly || source === "selection" && !selected) {
        showPosition = false;
      }
      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);
      if (mergedCheckable) {
        additionalInfo.checked = selected;
      } else {
        additionalInfo.selected = selected;
      }
      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map((item) => item.value);
      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map((item) => item.label), additionalInfo);
    }
  });
  const onOptionSelect = React627.useCallback((selectedKey, {
    selected,
    source
  }) => {
    const entity = keyEntities[selectedKey];
    const node2 = entity == null ? void 0 : entity.node;
    const selectedValue = (node2 == null ? void 0 : node2[mergedFieldNames.value]) ?? selectedKey;
    if (!mergedMultiple) {
      triggerChange([selectedValue], {
        selected: true,
        triggerValue: selectedValue
      }, "option");
    } else {
      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter((v) => v !== selectedValue);
      if (treeConduction) {
        const {
          missingRawValues,
          existRawValues
        } = splitRawValues(newRawValues);
        const keyList = existRawValues.map((val) => valueEntities.get(val).key);
        let checkedKeys;
        if (selected) {
          ({
            checkedKeys
          } = conductCheck(keyList, true, keyEntities));
        } else {
          ({
            checkedKeys
          } = conductCheck(keyList, {
            checked: false,
            halfCheckedKeys: rawHalfCheckedValues
          }, keyEntities));
        }
        newRawValues = [...missingRawValues, ...checkedKeys.map((key) => keyEntities[key].node[mergedFieldNames.value])];
      }
      triggerChange(newRawValues, {
        selected,
        triggerValue: selectedValue
      }, source || "option");
    }
    if (selected || !mergedMultiple) {
      onSelect == null ? void 0 : onSelect(selectedValue, fillLegacyProps(node2));
    } else {
      onDeselect == null ? void 0 : onDeselect(selectedValue, fillLegacyProps(node2));
    }
  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);
  const onInternalPopupVisibleChange = React627.useCallback((open3) => {
    if (onPopupVisibleChange) {
      onPopupVisibleChange(open3);
    }
  }, [onPopupVisibleChange]);
  const onDisplayValuesChange = useRefFunc2((newValues, info) => {
    const newRawValues = newValues.map((item) => item.value);
    if (info.type === "clear") {
      triggerChange(newRawValues, {}, "selection");
      return;
    }
    if (info.values.length) {
      onOptionSelect(info.values[0].value, {
        selected: false,
        source: "selection"
      });
    }
  });
  const treeSelectContext = React627.useMemo(() => {
    return {
      virtual,
      popupMatchSelectWidth,
      listHeight,
      listItemHeight,
      listItemScrollOffset,
      treeData: filteredTreeData,
      fieldNames: mergedFieldNames,
      onSelect: onOptionSelect,
      treeExpandAction,
      treeTitleRender,
      onPopupScroll,
      leftMaxCount: maxCount === void 0 ? null : maxCount - cachedDisplayValues.length,
      leafCountOnly: mergedShowCheckedStrategy === "SHOW_CHILD" && !treeCheckStrictly && !!treeCheckable,
      valueEntities,
      classNames: treeSelectClassNames,
      styles
    };
  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);
  const legacyContext = React627.useMemo(() => ({
    checkable: mergedCheckable,
    loadData,
    treeLoadedKeys,
    onTreeLoad,
    checkedKeys: rawCheckedValues,
    halfCheckedKeys: rawHalfCheckedValues,
    treeDefaultExpandAll,
    treeExpandedKeys,
    treeDefaultExpandedKeys,
    onTreeExpand,
    treeIcon,
    treeMotion,
    showTreeIcon,
    switcherIcon,
    treeLine,
    treeNodeFilterProp,
    keyEntities
  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);
  return React627.createElement(TreeSelectContext_default.Provider, {
    value: treeSelectContext
  }, React627.createElement(LegacyContext_default.Provider, {
    value: legacyContext
  }, React627.createElement(BaseSelect_default, _extends98({
    ref
  }, restProps, {
    classNames: treeSelectClassNames,
    styles,
    id: mergedId,
    prefixCls,
    mode: mergedMultiple ? "multiple" : void 0,
    displayValues: cachedDisplayValues,
    onDisplayValuesChange,
    autoClearSearchValue,
    showSearch: mergedShowSearch,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    OptionList: OptionList_default3,
    emptyOptions: !mergedTreeData.length,
    onPopupVisibleChange: onInternalPopupVisibleChange,
    popupMatchSelectWidth
  }))));
});
if (true) {
  TreeSelect.displayName = "TreeSelect";
}
var GenericTreeSelect = TreeSelect;
GenericTreeSelect.TreeNode = TreeNode_default2;
GenericTreeSelect.SHOW_ALL = SHOW_ALL;
GenericTreeSelect.SHOW_PARENT = SHOW_PARENT3;
GenericTreeSelect.SHOW_CHILD = SHOW_CHILD3;
var TreeSelect_default = GenericTreeSelect;

// node_modules/@rc-component/tree-select/es/index.js
var es_default35 = TreeSelect_default;

// node_modules/antd/es/tree-select/style/index.js
var genBaseStyle18 = (token2) => {
  const {
    componentCls,
    treePrefixCls,
    colorBgElevated
  } = token2;
  const treeCls = `.${treePrefixCls}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${componentCls}-dropdown`]: [
        {
          padding: `${unit(token2.paddingXS)} ${unit(token2.calc(token2.paddingXS).div(2).equal())}`
        },
        // ====================== Tree ======================
        genTreeStyle(treePrefixCls, merge2(token2, {
          colorBgContainer: colorBgElevated
        }), false),
        {
          [treeCls]: {
            borderRadius: 0,
            [`${treeCls}-list-holder-inner`]: {
              alignItems: "stretch",
              [`${treeCls}-treenode`]: {
                [`${treeCls}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        getStyle(`${treePrefixCls}-checkbox`, token2),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${treeCls}-switcher${treeCls}-switcher_close`]: {
              [`${treeCls}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function useTreeSelectStyle(prefixCls, treePrefixCls, rootCls) {
  return genStyleHooks("TreeSelect", (token2) => {
    const treeSelectToken = merge2(token2, {
      treePrefixCls
    });
    return genBaseStyle18(treeSelectToken);
  }, initComponentToken2, {
    resetFont: false
  })(prefixCls, rootCls);
}

// node_modules/antd/es/tree-select/index.js
var InternalTreeSelect = (props, ref) => {
  var _a, _b, _c, _d;
  const {
    prefixCls: customizePrefixCls,
    size: customizeSize,
    disabled: customDisabled,
    bordered = true,
    style: style2,
    className,
    rootClassName,
    treeCheckable,
    multiple,
    listHeight = 256,
    listItemHeight: customListItemHeight,
    placement,
    notFoundContent,
    switcherIcon: customSwitcherIcon,
    treeLine,
    getPopupContainer,
    popupClassName,
    dropdownClassName,
    treeIcon = false,
    transitionName,
    choiceTransitionName = "",
    status: customStatus,
    treeExpandAction,
    builtinPlacements,
    dropdownMatchSelectWidth,
    popupMatchSelectWidth,
    allowClear,
    variant: customVariant,
    dropdownStyle: _dropdownStyle,
    dropdownRender,
    popupRender,
    onDropdownVisibleChange,
    onOpenChange,
    tagRender,
    maxCount,
    showCheckedStrategy,
    treeCheckStrictly,
    styles,
    classNames,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    getPopupContainer: getContextPopupContainer,
    direction,
    styles: contextStyles,
    classNames: contextClassNames,
    switcherIcon
  } = useComponentConfig("treeSelect");
  const {
    renderEmpty,
    virtual,
    popupMatchSelectWidth: contextPopupMatchSelectWidth,
    popupOverflow
  } = React628.useContext(ConfigContext);
  const [, token2] = useToken();
  const listItemHeight = customListItemHeight ?? (token2 == null ? void 0 : token2.controlHeightSM) + (token2 == null ? void 0 : token2.paddingXXS);
  if (true) {
    const warning5 = devUseWarning("TreeSelect");
    const deprecatedProps = {
      dropdownMatchSelectWidth: "popupMatchSelectWidth",
      dropdownStyle: "styles.popup.root",
      dropdownClassName: "classNames.popup.root",
      popupClassName: "classNames.popup.root",
      dropdownRender: "popupRender",
      onDropdownVisibleChange: "onOpenChange",
      bordered: "variant"
    };
    Object.entries(deprecatedProps).forEach(([oldProp, newProp]) => {
      warning5.deprecated(!(oldProp in props), oldProp, newProp);
    });
    true ? warning5(multiple !== false || !treeCheckable, "usage", "`multiple` will always be `true` when `treeCheckable` is true") : void 0;
    true ? warning5(!("showArrow" in props), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null.") : void 0;
  }
  const rootPrefixCls = getPrefixCls();
  const prefixCls = getPrefixCls("select", customizePrefixCls);
  const treePrefixCls = getPrefixCls("select-tree", customizePrefixCls);
  const treeSelectPrefixCls = getPrefixCls("tree-select", customizePrefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const rootCls = useCSSVarCls_default(prefixCls);
  const treeSelectRootCls = useCSSVarCls_default(treeSelectPrefixCls);
  const [hashId, cssVarCls] = style_default13(prefixCls, rootCls);
  useTreeSelectStyle(treeSelectPrefixCls, treePrefixCls, treeSelectRootCls);
  const [variant, enableVariantCls] = useVariants_default("treeSelect", customVariant, bordered);
  const mergedSize = useSize_default((ctx) => customizeSize ?? compactSize ?? ctx);
  const disabled = React628.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const {
    status: contextStatus,
    hasFeedback,
    isFormItemInput,
    feedbackIcon
  } = React628.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const mergedProps = {
    ...props,
    size: mergedSize,
    disabled: mergedDisabled,
    status: mergedStatus,
    variant
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  }, {
    popup: {
      _default: "root"
    }
  });
  const mergedPopupClassName = clsx(popupClassName || dropdownClassName, `${treeSelectPrefixCls}-dropdown`, {
    [`${treeSelectPrefixCls}-dropdown-rtl`]: direction === "rtl"
  }, rootClassName, mergedClassNames.root, (_a = mergedClassNames.popup) == null ? void 0 : _a.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
  const mergedPopupRender = usePopupRender_default(popupRender || dropdownRender);
  const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
  const isMultiple2 = !!(treeCheckable || multiple);
  const mergedMaxCount = React628.useMemo(() => {
    if (maxCount && (showCheckedStrategy === "SHOW_ALL" && !treeCheckStrictly || showCheckedStrategy === "SHOW_PARENT")) {
      return void 0;
    }
    return maxCount;
  }, [maxCount, showCheckedStrategy, treeCheckStrictly]);
  const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
  const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
  const {
    suffixIcon,
    removeIcon,
    clearIcon
  } = useIcons({
    ...restProps,
    multiple: isMultiple2,
    showSuffixIcon,
    hasFeedback,
    feedbackIcon,
    prefixCls,
    componentName: "TreeSelect"
  });
  const mergedAllowClear = allowClear === true ? {
    clearIcon
  } : allowClear;
  let mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else {
    mergedNotFound = (renderEmpty == null ? void 0 : renderEmpty("Select")) || React628.createElement(defaultRenderEmpty_default, {
      componentName: "Select"
    });
  }
  const selectProps = omit(restProps, ["suffixIcon", "removeIcon", "clearIcon", "itemIcon", "switcherIcon", "style"]);
  const memoizedPlacement = React628.useMemo(() => {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  }, [placement, direction]);
  const mergedClassName = clsx(!customizePrefixCls && treeSelectPrefixCls, {
    [`${prefixCls}-lg`]: mergedSize === "large",
    [`${prefixCls}-sm`]: mergedSize === "small",
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${variant}`]: enableVariantCls,
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, rootClassName, mergedClassNames == null ? void 0 : mergedClassNames.root, cssVarCls, rootCls, treeSelectRootCls, hashId);
  const mergedSwitcherIcon = customSwitcherIcon ?? switcherIcon;
  const renderSwitcherIcon = (nodeProps) => React628.createElement(iconUtil_default, {
    prefixCls: treePrefixCls,
    switcherIcon: mergedSwitcherIcon,
    treeNodeProps: nodeProps,
    showLine: treeLine
  });
  const [zIndex] = useZIndex("SelectLike", (_c = (_b = mergedStyles.popup) == null ? void 0 : _b.root) == null ? void 0 : _c.zIndex);
  return React628.createElement(es_default35, {
    classNames: mergedClassNames,
    styles: mergedStyles,
    virtual,
    disabled: mergedDisabled,
    ...selectProps,
    popupMatchSelectWidth: mergedPopupMatchSelectWidth,
    builtinPlacements: mergedBuiltinPlacements_default(builtinPlacements, popupOverflow),
    ref,
    prefixCls,
    className: mergedClassName,
    style: {
      ...mergedStyles == null ? void 0 : mergedStyles.root,
      ...style2
    },
    listHeight,
    listItemHeight,
    treeCheckable: treeCheckable ? React628.createElement("span", {
      className: `${prefixCls}-tree-checkbox-inner`
    }) : treeCheckable,
    treeLine: !!treeLine,
    suffixIcon,
    multiple: isMultiple2,
    placement: memoizedPlacement,
    removeIcon,
    allowClear: mergedAllowClear,
    switcherIcon: renderSwitcherIcon,
    showTreeIcon: treeIcon,
    notFoundContent: mergedNotFound,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    treeMotion: null,
    popupClassName: mergedPopupClassName,
    popupStyle: {
      ...mergedStyles.root,
      ...(_d = mergedStyles.popup) == null ? void 0 : _d.root,
      zIndex
    },
    popupRender: mergedPopupRender,
    onPopupVisibleChange: mergedOnOpenChange,
    choiceTransitionName: getTransitionName2(rootPrefixCls, "", choiceTransitionName),
    transitionName: getTransitionName2(rootPrefixCls, "slide-up", transitionName),
    treeExpandAction,
    tagRender: isMultiple2 ? tagRender : void 0,
    maxCount: mergedMaxCount,
    showCheckedStrategy,
    treeCheckStrictly
  });
};
var TreeSelectRef = React628.forwardRef(InternalTreeSelect);
var TreeSelect2 = TreeSelectRef;
var PurePanel18 = PurePanel_default3(TreeSelect2, "popupAlign", (props) => omit(props, ["visible"]));
TreeSelect2.TreeNode = TreeNode_default2;
TreeSelect2.SHOW_ALL = SHOW_ALL;
TreeSelect2.SHOW_PARENT = SHOW_PARENT3;
TreeSelect2.SHOW_CHILD = SHOW_CHILD3;
TreeSelect2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel18;
if (true) {
  TreeSelect2.displayName = "TreeSelect";
}
var tree_select_default = TreeSelect2;

// node_modules/antd/es/typography/Link.js
var React637 = __toESM(require_react());

// node_modules/antd/es/typography/Base/index.js
var React636 = __toESM(require_react());

// node_modules/antd/es/typography/Editable.js
var React629 = __toESM(require_react());

// node_modules/antd/es/typography/style/mixins.js
var getTitleStyle = (fontSize, lineHeight, color, token2) => {
  const {
    titleMarginBottom,
    fontWeightStrong
  } = token2;
  return {
    marginBottom: titleMarginBottom,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
};
var getTitleStyles = (token2) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
  });
  return styles;
};
var getLinkStyles = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    "a&, a": {
      ...operationUnit(token2),
      userSelect: "text",
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token2.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    }
  };
};
var getResetStyles = (token2) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: token2.fontWeightStrong
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: token2.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
});
var getEditableStyles = (token2) => {
  const {
    componentCls,
    paddingSM
  } = token2;
  const inputShift = paddingSM;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: token2.calc(token2.paddingSM).mul(-1).equal(),
        insetBlockStart: token2.calc(inputShift).div(-2).add(1).equal(),
        marginBottom: token2.calc(inputShift).div(2).sub(2).equal()
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token2.calc(token2.marginXS).add(2).equal(),
        insetBlockEnd: token2.marginXS,
        color: token2.colorIcon,
        // default style
        fontWeight: "normal",
        fontSize: token2.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
};
var getCopyableStyles = (token2) => ({
  [`${token2.componentCls}-copy-success`]: {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token2.colorSuccess
    }
  },
  [`${token2.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
});
var getEllipsisStyles = () => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-ellipsis-single-line": {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
});

// node_modules/antd/es/typography/style/index.js
var genTypographyStyle = (token2) => {
  const {
    componentCls,
    titleMarginTop
  } = token2;
  return {
    [componentCls]: {
      color: token2.colorText,
      wordBreak: "break-word",
      lineHeight: token2.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token2.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token2.colorSuccessText
      },
      [`&${componentCls}-warning`]: {
        color: token2.colorWarningText
      },
      [`&${componentCls}-danger`]: {
        color: token2.colorErrorText,
        "a&:active, a&:focus": {
          color: token2.colorErrorTextActive
        },
        "a&:hover": {
          color: token2.colorErrorTextHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      },
      ...getTitleStyles(token2),
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: titleMarginTop
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: titleMarginTop
        }
      },
      ...getResetStyles(token2),
      ...getLinkStyles(token2),
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: {
        ...operationUnit(token2),
        marginInlineStart: token2.marginXXS
      },
      ...getEditableStyles(token2),
      ...getCopyableStyles(token2),
      ...getEllipsisStyles(),
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
var prepareComponentToken57 = () => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
});
var style_default64 = genStyleHooks("Typography", genTypographyStyle, prepareComponentToken57);

// node_modules/antd/es/typography/Editable.js
var Editable = (props) => {
  const {
    prefixCls,
    "aria-label": ariaLabel,
    className,
    style: style2,
    direction,
    maxLength,
    autoSize = true,
    value,
    onSave,
    onCancel,
    onEnd,
    component,
    enterIcon = React629.createElement(EnterOutlined_default, null)
  } = props;
  const ref = React629.useRef(null);
  const inComposition = React629.useRef(false);
  const lastKeyCode = React629.useRef(null);
  const [current, setCurrent] = React629.useState(value);
  React629.useEffect(() => {
    setCurrent(value);
  }, [value]);
  React629.useEffect(() => {
    var _a;
    if ((_a = ref.current) == null ? void 0 : _a.resizableTextArea) {
      const {
        textArea
      } = ref.current.resizableTextArea;
      textArea.focus();
      const {
        length: length2
      } = textArea.value;
      textArea.setSelectionRange(length2, length2);
    }
  }, []);
  const onChange = ({
    target
  }) => {
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  };
  const onCompositionStart = () => {
    inComposition.current = true;
  };
  const onCompositionEnd = () => {
    inComposition.current = false;
  };
  const onKeyDown2 = ({
    keyCode
  }) => {
    if (inComposition.current) {
      return;
    }
    lastKeyCode.current = keyCode;
  };
  const confirmChange = () => {
    onSave(current.trim());
  };
  const onKeyUp = ({
    keyCode,
    ctrlKey,
    altKey,
    metaKey,
    shiftKey
  }) => {
    if (lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey) {
      return;
    }
    if (keyCode === KeyCode_default.ENTER) {
      confirmChange();
      onEnd == null ? void 0 : onEnd();
    } else if (keyCode === KeyCode_default.ESC) {
      onCancel();
    }
  };
  const onBlur = () => {
    confirmChange();
  };
  const [hashId, cssVarCls] = style_default64(prefixCls);
  const textAreaClassName = clsx(prefixCls, `${prefixCls}-edit-content`, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${component}`]: !!component
  }, className, hashId, cssVarCls);
  return React629.createElement("div", {
    className: textAreaClassName,
    style: style2
  }, React629.createElement(TextArea_default2, {
    ref,
    maxLength,
    value: current,
    onChange,
    onKeyDown: onKeyDown2,
    onKeyUp,
    onCompositionStart,
    onCompositionEnd,
    onBlur,
    "aria-label": ariaLabel,
    rows: 1,
    autoSize
  }), enterIcon !== null ? cloneElement3(enterIcon, {
    className: `${prefixCls}-edit-content-confirm`
  }) : null);
};
var Editable_default = Editable;

// node_modules/antd/es/typography/hooks/useCopyClick.js
var React630 = __toESM(require_react());

// node_modules/antd/es/_util/copy.js
var execCopy = (text, isHtmlFormat) => {
  let copySuccess = false;
  const onCopy = (event) => {
    var _a, _b, _c;
    event.stopPropagation();
    event.preventDefault();
    (_a = event.clipboardData) == null ? void 0 : _a.clearData();
    (_b = event.clipboardData) == null ? void 0 : _b.setData("text/plain", text);
    if (isHtmlFormat) {
      (_c = event.clipboardData) == null ? void 0 : _c.setData("text/html", text);
    }
    copySuccess = true;
  };
  try {
    document.addEventListener("copy", onCopy, {
      capture: true
    });
    document.execCommand("copy");
    return copySuccess;
  } catch {
    return false;
  } finally {
    document.removeEventListener("copy", onCopy, {
      capture: true
    });
  }
};
var asyncCopy = async (text, isHtmlFormat) => {
  try {
    if (isHtmlFormat) {
      await navigator.clipboard.write([new ClipboardItem({
        "text/html": new Blob([text], {
          type: "text/html"
        }),
        "text/plain": new Blob([text], {
          type: "text/plain"
        })
      })]);
    } else {
      await navigator.clipboard.writeText(text);
    }
    return true;
  } catch {
    return false;
  }
};
async function copy2(text, config) {
  if (typeof text !== "string") {
    true ? warning_default2(false, "The clipboard content must be of string type", "") : void 0;
    return false;
  }
  const isHtmlFormat = (config == null ? void 0 : config.format) === "text/html";
  if (await asyncCopy(text, isHtmlFormat)) {
    return true;
  }
  if (execCopy(text, isHtmlFormat)) {
    return true;
  }
  return false;
}
var copy_default = copy2;

// node_modules/antd/es/typography/hooks/useCopyClick.js
var useCopyClick = ({
  copyConfig,
  children
}) => {
  const [copied, setCopied] = React630.useState(false);
  const [copyLoading, setCopyLoading] = React630.useState(false);
  const copyIdRef = React630.useRef(null);
  const cleanCopyId = () => {
    if (copyIdRef.current) {
      clearTimeout(copyIdRef.current);
    }
  };
  const copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  React630.useEffect(() => cleanCopyId, []);
  const onClick = useEvent_default(async (e3) => {
    var _a;
    e3 == null ? void 0 : e3.preventDefault();
    e3 == null ? void 0 : e3.stopPropagation();
    setCopyLoading(true);
    try {
      const text = typeof copyConfig.text === "function" ? await copyConfig.text() : copyConfig.text;
      await copy_default(text || toList_default(children, true).join("") || "", copyOptions);
      setCopyLoading(false);
      setCopied(true);
      cleanCopyId();
      copyIdRef.current = setTimeout(() => {
        setCopied(false);
      }, 3e3);
      (_a = copyConfig.onCopy) == null ? void 0 : _a.call(copyConfig, e3);
    } catch (error) {
      setCopyLoading(false);
      throw error;
    }
  });
  return {
    copied,
    copyLoading,
    onClick
  };
};
var useCopyClick_default = useCopyClick;

// node_modules/antd/es/typography/hooks/useMergedConfig.js
var React631 = __toESM(require_react());
function useMergedConfig(propConfig, templateConfig) {
  return React631.useMemo(() => {
    const support = !!propConfig;
    return [support, {
      ...templateConfig,
      ...support && typeof propConfig === "object" ? propConfig : null
    }];
  }, [propConfig]);
}

// node_modules/antd/es/typography/hooks/usePrevious.js
var import_react226 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = (0, import_react226.useRef)(void 0);
  (0, import_react226.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};
var usePrevious_default = usePrevious;

// node_modules/antd/es/typography/hooks/useTooltipProps.js
var import_react227 = __toESM(require_react());
var useTooltipProps = (tooltip, editConfigText, children) => (0, import_react227.useMemo)(() => {
  if (tooltip === true) {
    return {
      title: editConfigText ?? children
    };
  }
  if ((0, import_react227.isValidElement)(tooltip)) {
    return {
      title: tooltip
    };
  }
  if (typeof tooltip === "object") {
    return {
      title: editConfigText ?? children,
      ...tooltip
    };
  }
  return {
    title: tooltip
  };
}, [tooltip, editConfigText, children]);
var useTooltipProps_default = useTooltipProps;

// node_modules/antd/es/typography/Typography.js
var React632 = __toESM(require_react());
var Typography = React632.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    component: Component8 = "article",
    className,
    rootClassName,
    children,
    direction: typographyDirection,
    style: style2,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction: contextDirection,
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("typography");
  const direction = typographyDirection ?? contextDirection;
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const [hashId, cssVarCls] = style_default64(prefixCls);
  const componentClassName = clsx(prefixCls, contextClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId, cssVarCls);
  const mergedStyle = {
    ...contextStyle,
    ...style2
  };
  return (
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    React632.createElement(Component8, {
      className: componentClassName,
      style: mergedStyle,
      ref,
      ...restProps
    }, children)
  );
});
if (true) {
  Typography.displayName = "Typography";
}
var Typography_default = Typography;

// node_modules/antd/es/typography/Base/CopyBtn.js
var React633 = __toESM(require_react());

// node_modules/antd/es/typography/Base/util.js
function toList2(val) {
  if (val === false) {
    return [false, false];
  }
  return Array.isArray(val) ? val : [val];
}
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === void 0) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
function isEleEllipsis(ele) {
  const childDiv = document.createElement("em");
  ele.appendChild(childDiv);
  if (true) {
    childDiv.className = "ant-typography-css-ellipsis-content-measure";
  }
  const rect = ele.getBoundingClientRect();
  const childRect = childDiv.getBoundingClientRect();
  ele.removeChild(childDiv);
  return (
    // Horizontal out of range
    rect.left > childRect.left || childRect.right > rect.right || // Vertical out of range
    rect.top > childRect.top || childRect.bottom > rect.bottom
  );
}
var isValidText = (val) => ["string", "number"].includes(typeof val);

// node_modules/antd/es/typography/Base/CopyBtn.js
var CopyBtn = ({
  prefixCls,
  copied,
  locale: locale6,
  iconOnly,
  tooltips,
  icon,
  tabIndex,
  onCopy,
  loading: btnLoading
}) => {
  const tooltipNodes = toList2(tooltips);
  const iconNodes = toList2(icon);
  const {
    copied: copiedText,
    copy: copyText
  } = locale6 ?? {};
  const systemStr = copied ? copiedText : copyText;
  const copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr);
  const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
  return React633.createElement(tooltip_default, {
    title: copyTitle
  }, React633.createElement("button", {
    type: "button",
    className: clsx(`${prefixCls}-copy`, {
      [`${prefixCls}-copy-success`]: copied,
      [`${prefixCls}-copy-icon-only`]: iconOnly
    }),
    onClick: onCopy,
    "aria-label": ariaLabel,
    tabIndex
  }, copied ? getNode(iconNodes[1], React633.createElement(CheckOutlined_default, null), true) : getNode(iconNodes[0], btnLoading ? React633.createElement(LoadingOutlined_default, null) : React633.createElement(CopyOutlined_default, null), true)));
};
var CopyBtn_default = CopyBtn;

// node_modules/antd/es/typography/Base/Ellipsis.js
var React634 = __toESM(require_react());
var MeasureText = React634.forwardRef(({
  style: style2,
  children
}, ref) => {
  const spanRef = React634.useRef(null);
  React634.useImperativeHandle(ref, () => ({
    isExceed: () => {
      const span = spanRef.current;
      return span.scrollHeight > span.clientHeight;
    },
    getHeight: () => spanRef.current.clientHeight
  }));
  return React634.createElement("span", {
    "aria-hidden": true,
    ref: spanRef,
    style: {
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)",
      ...style2
    }
  }, children);
});
var getNodesLen = (nodeList) => nodeList.reduce((totalLen, node2) => totalLen + (isValidText(node2) ? String(node2).length : 1), 0);
function sliceNodes(nodeList, len) {
  let currLen = 0;
  const currentNodeList = [];
  for (let i = 0; i < nodeList.length; i += 1) {
    if (currLen === len) {
      return currentNodeList;
    }
    const node2 = nodeList[i];
    const canCut = isValidText(node2);
    const nodeLen = canCut ? String(node2).length : 1;
    const nextLen = currLen + nodeLen;
    if (nextLen > len) {
      const restLen = len - currLen;
      currentNodeList.push(String(node2).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node2);
    currLen = nextLen;
  }
  return nodeList;
}
var STATUS_MEASURE_NONE = 0;
var STATUS_MEASURE_PREPARE = 1;
var STATUS_MEASURE_START = 2;
var STATUS_MEASURE_NEED_ELLIPSIS = 3;
var STATUS_MEASURE_NO_NEED_ELLIPSIS = 4;
var lineClipStyle = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function EllipsisMeasure(props) {
  const {
    enableMeasure,
    width,
    text,
    children,
    rows,
    expanded,
    miscDeps,
    onEllipsis
  } = props;
  const nodeList = React634.useMemo(() => toArray(text), [text]);
  const nodeLen = React634.useMemo(() => getNodesLen(nodeList), [text]);
  const fullContent = React634.useMemo(() => children(nodeList, false), [text]);
  const [ellipsisCutIndex, setEllipsisCutIndex] = React634.useState(null);
  const cutMidRef = React634.useRef(null);
  const measureWhiteSpaceRef = React634.useRef(null);
  const needEllipsisRef = React634.useRef(null);
  const descRowsEllipsisRef = React634.useRef(null);
  const symbolRowEllipsisRef = React634.useRef(null);
  const [canEllipsis, setCanEllipsis] = React634.useState(false);
  const [needEllipsis, setNeedEllipsis] = React634.useState(STATUS_MEASURE_NONE);
  const [ellipsisHeight, setEllipsisHeight] = React634.useState(0);
  const [parentWhiteSpace, setParentWhiteSpace] = React634.useState(null);
  useLayoutEffect_default(() => {
    if (enableMeasure && width && nodeLen) {
      setNeedEllipsis(STATUS_MEASURE_PREPARE);
    } else {
      setNeedEllipsis(STATUS_MEASURE_NONE);
    }
  }, [width, text, rows, enableMeasure, nodeList]);
  useLayoutEffect_default(() => {
    var _a, _b, _c, _d;
    if (needEllipsis === STATUS_MEASURE_PREPARE) {
      setNeedEllipsis(STATUS_MEASURE_START);
      const nextWhiteSpace = measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace;
      setParentWhiteSpace(nextWhiteSpace);
    } else if (needEllipsis === STATUS_MEASURE_START) {
      const isOverflow = !!((_a = needEllipsisRef.current) == null ? void 0 : _a.isExceed());
      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
      setCanEllipsis(isOverflow);
      const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) == null ? void 0 : _b.getHeight()) || 0;
      const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) == null ? void 0 : _c.getHeight()) || 0;
      const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) == null ? void 0 : _d.getHeight()) || 0;
      const maxRowsHeight = Math.max(
        baseRowsEllipsisHeight,
        // height of rows with ellipsis
        descRowsEllipsisHeight + symbolRowEllipsisHeight
      );
      setEllipsisHeight(maxRowsHeight + 1);
      onEllipsis(isOverflow);
    }
  }, [needEllipsis]);
  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
  useLayoutEffect_default(() => {
    var _a;
    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
    if (minIndex !== maxIndex) {
      const midHeight = ((_a = cutMidRef.current) == null ? void 0 : _a.getHeight()) || 0;
      const isOverflow = midHeight > ellipsisHeight;
      let targetMidIndex = cutMidIndex;
      if (maxIndex - minIndex === 1) {
        targetMidIndex = isOverflow ? minIndex : maxIndex;
      }
      setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
    }
  }, [ellipsisCutIndex, cutMidIndex]);
  const finalContent = React634.useMemo(() => {
    if (!enableMeasure) {
      return children(nodeList, false);
    }
    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
      const content = children(nodeList, false);
      if ([STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis)) {
        return content;
      }
      return React634.createElement("span", {
        style: {
          ...lineClipStyle,
          WebkitLineClamp: rows
        }
      }, content);
    }
    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));
  const measureStyle = {
    width,
    margin: 0,
    padding: 0,
    whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
  };
  return React634.createElement(React634.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && React634.createElement(React634.Fragment, null, React634.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: rows
    },
    ref: needEllipsisRef
  }, fullContent), React634.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: rows - 1
    },
    ref: descRowsEllipsisRef
  }, fullContent), React634.createElement(MeasureText, {
    style: {
      ...measureStyle,
      ...lineClipStyle,
      WebkitLineClamp: 1
    },
    ref: symbolRowEllipsisRef
  }, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && React634.createElement(MeasureText, {
    style: {
      ...measureStyle,
      top: 400
    },
    ref: cutMidRef
  }, children(sliceNodes(nodeList, cutMidIndex), true)), needEllipsis === STATUS_MEASURE_PREPARE && React634.createElement("span", {
    style: {
      whiteSpace: "inherit"
    },
    ref: measureWhiteSpaceRef
  }));
}

// node_modules/antd/es/typography/Base/EllipsisTooltip.js
var React635 = __toESM(require_react());
var EllipsisTooltip = ({
  enableEllipsis,
  isEllipsis,
  children,
  tooltipProps
}) => {
  if (!(tooltipProps == null ? void 0 : tooltipProps.title) || !enableEllipsis) {
    return children;
  }
  return React635.createElement(tooltip_default, {
    open: isEllipsis ? void 0 : false,
    ...tooltipProps
  }, children);
};
if (true) {
  EllipsisTooltip.displayName = "EllipsisTooltip";
}
var EllipsisTooltip_default = EllipsisTooltip;

// node_modules/antd/es/typography/Base/index.js
function wrapperDecorations({
  mark,
  code,
  underline,
  delete: del,
  strong,
  keyboard,
  italic
}, content) {
  let currentContent = content;
  function wrap(tag, needed) {
    if (!needed) {
      return;
    }
    currentContent = React636.createElement(tag, {}, currentContent);
  }
  wrap("strong", strong);
  wrap("u", underline);
  wrap("del", del);
  wrap("code", code);
  wrap("mark", mark);
  wrap("kbd", keyboard);
  wrap("i", italic);
  return currentContent;
}
var ELLIPSIS_STR = "...";
var DECORATION_PROPS = ["delete", "mark", "code", "underline", "strong", "keyboard", "italic"];
var Base = React636.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    type: type5,
    disabled,
    children,
    ellipsis,
    editable,
    copyable,
    component,
    title,
    ...restProps
  } = props;
  const {
    getPrefixCls,
    direction
  } = React636.useContext(ConfigContext);
  const [textLocale] = useLocale_default("Text");
  const typographyRef = React636.useRef(null);
  const editIconRef = React636.useRef(null);
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const textProps = omit(restProps, DECORATION_PROPS);
  const [enableEdit, editConfig] = useMergedConfig(editable);
  const [editing, setEditing] = useControlledState(false, editConfig.editing);
  const {
    triggerType = ["icon"]
  } = editConfig;
  const triggerEdit = (edit) => {
    var _a;
    if (edit) {
      (_a = editConfig.onStart) == null ? void 0 : _a.call(editConfig);
    }
    setEditing(edit);
  };
  const prevEditing = usePrevious_default(editing);
  useLayoutEffect_default(() => {
    var _a;
    if (!editing && prevEditing) {
      (_a = editIconRef.current) == null ? void 0 : _a.focus();
    }
  }, [editing]);
  const onEditClick = (e3) => {
    e3 == null ? void 0 : e3.preventDefault();
    triggerEdit(true);
  };
  const onEditChange = (value) => {
    var _a;
    (_a = editConfig.onChange) == null ? void 0 : _a.call(editConfig, value);
    triggerEdit(false);
  };
  const onEditCancel = () => {
    var _a;
    (_a = editConfig.onCancel) == null ? void 0 : _a.call(editConfig);
    triggerEdit(false);
  };
  const [enableCopy, copyConfig] = useMergedConfig(copyable);
  const {
    copied,
    copyLoading,
    onClick: onCopyClick
  } = useCopyClick_default({
    copyConfig,
    children
  });
  const [isLineClampSupport, setIsLineClampSupport] = React636.useState(false);
  const [isTextOverflowSupport, setIsTextOverflowSupport] = React636.useState(false);
  const [isJsEllipsis, setIsJsEllipsis] = React636.useState(false);
  const [isNativeEllipsis, setIsNativeEllipsis] = React636.useState(false);
  const [isNativeVisible, setIsNativeVisible] = React636.useState(true);
  const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
    expandable: false,
    symbol: (isExpanded) => isExpanded ? textLocale == null ? void 0 : textLocale.collapse : textLocale == null ? void 0 : textLocale.expand
  });
  const [expanded, setExpanded] = useControlledState(ellipsisConfig.defaultExpanded || false, ellipsisConfig.expanded);
  const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
  const {
    rows = 1
  } = ellipsisConfig;
  const needMeasureEllipsis = React636.useMemo(() => (
    // Disable ellipsis
    mergedEnableEllipsis && // Provide suffix
    (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    ellipsisConfig.expandable || enableEdit || enableCopy)
  ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect_default(() => {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
      setIsTextOverflowSupport(isStyleSupport("textOverflow"));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  const [cssEllipsis, setCssEllipsis] = React636.useState(mergedEnableEllipsis);
  const canUseCssEllipsis = React636.useMemo(() => {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  useLayoutEffect_default(() => {
    setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
  }, [canUseCssEllipsis, mergedEnableEllipsis]);
  const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  const onExpandClick = (e3, info) => {
    var _a;
    setExpanded(info.expanded);
    (_a = ellipsisConfig.onExpand) == null ? void 0 : _a.call(ellipsisConfig, e3, info);
  };
  const [ellipsisWidth, setEllipsisWidth] = React636.useState(0);
  const onResize2 = ({
    offsetWidth
  }) => {
    setEllipsisWidth(offsetWidth);
  };
  const onJsEllipsis = (jsEllipsis) => {
    var _a;
    setIsJsEllipsis(jsEllipsis);
    if (isJsEllipsis !== jsEllipsis) {
      (_a = ellipsisConfig.onEllipsis) == null ? void 0 : _a.call(ellipsisConfig, jsEllipsis);
    }
  };
  React636.useEffect(() => {
    const textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      const currentEllipsis = isEleEllipsis(textEle);
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible, ellipsisWidth]);
  React636.useEffect(() => {
    const textEle = typographyRef.current;
    if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
      return;
    }
    const observer2 = new IntersectionObserver(() => {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    observer2.observe(textEle);
    return () => {
      observer2.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  const tooltipProps = useTooltipProps_default(ellipsisConfig.tooltip, editConfig.text, children);
  const topAriaLabel = React636.useMemo(() => {
    if (!enableEllipsis || cssEllipsis) {
      return void 0;
    }
    return [editConfig.text, children, title, tooltipProps.title].find(isValidText);
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  if (editing) {
    return React636.createElement(Editable_default, {
      value: editConfig.text ?? (typeof children === "string" ? children : ""),
      onSave: onEditChange,
      onCancel: onEditCancel,
      onEnd: editConfig.onEnd,
      prefixCls,
      className,
      style: style2,
      direction,
      component,
      maxLength: editConfig.maxLength,
      autoSize: editConfig.autoSize,
      enterIcon: editConfig.enterIcon
    });
  }
  const renderExpand = () => {
    const {
      expandable,
      symbol
    } = ellipsisConfig;
    return expandable ? React636.createElement("button", {
      type: "button",
      key: "expand",
      className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
      onClick: (e3) => onExpandClick(e3, {
        expanded: !expanded
      }),
      "aria-label": expanded ? textLocale.collapse : textLocale == null ? void 0 : textLocale.expand
    }, typeof symbol === "function" ? symbol(expanded) : symbol) : null;
  };
  const renderEdit = () => {
    if (!enableEdit) {
      return;
    }
    const {
      icon,
      tooltip,
      tabIndex
    } = editConfig;
    const editTitle = toArray(tooltip)[0] || (textLocale == null ? void 0 : textLocale.edit);
    const ariaLabel = typeof editTitle === "string" ? editTitle : "";
    return triggerType.includes("icon") ? React636.createElement(tooltip_default, {
      key: "edit",
      title: tooltip === false ? "" : editTitle
    }, React636.createElement("button", {
      type: "button",
      ref: editIconRef,
      className: `${prefixCls}-edit`,
      onClick: onEditClick,
      "aria-label": ariaLabel,
      tabIndex
    }, icon || React636.createElement(EditOutlined_default, {
      role: "button"
    }))) : null;
  };
  const renderCopy = () => {
    if (!enableCopy) {
      return null;
    }
    return React636.createElement(CopyBtn_default, {
      key: "copy",
      ...copyConfig,
      prefixCls,
      copied,
      locale: textLocale,
      onCopy: onCopyClick,
      loading: copyLoading,
      iconOnly: !isNonNullable_default(children)
    });
  };
  const renderOperations = (canEllipsis) => [canEllipsis && renderExpand(), renderEdit(), renderCopy()];
  const renderEllipsis = (canEllipsis) => [canEllipsis && !expanded && React636.createElement("span", {
    "aria-hidden": true,
    key: "ellipsis"
  }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(canEllipsis)];
  return React636.createElement(es_default, {
    onResize: onResize2,
    disabled: !mergedEnableEllipsis
  }, (resizeRef) => React636.createElement(EllipsisTooltip_default, {
    tooltipProps,
    enableEllipsis: mergedEnableEllipsis,
    isEllipsis: isMergedEllipsis
  }, React636.createElement(Typography_default, {
    className: clsx({
      [`${prefixCls}-${type5}`]: type5,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-ellipsis`]: enableEllipsis,
      [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
      [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
    }, className),
    prefixCls: customizePrefixCls,
    style: {
      ...style2,
      WebkitLineClamp: cssLineClamp ? rows : void 0
    },
    component,
    ref: composeRef(resizeRef, typographyRef, ref),
    direction,
    onClick: triggerType.includes("text") ? onEditClick : void 0,
    "aria-label": topAriaLabel == null ? void 0 : topAriaLabel.toString(),
    title,
    ...textProps
  }, React636.createElement(EllipsisMeasure, {
    enableMeasure: mergedEnableEllipsis && !cssEllipsis,
    text: children,
    rows,
    width: ellipsisWidth,
    onEllipsis: onJsEllipsis,
    expanded,
    miscDeps: [copied, expanded, copyLoading, enableEdit, enableCopy, textLocale].concat(_toConsumableArray(DECORATION_PROPS.map((key) => props[key])))
  }, (node2, canEllipsis) => wrapperDecorations(props, React636.createElement(React636.Fragment, null, node2.length > 0 && canEllipsis && !expanded && topAriaLabel ? React636.createElement("span", {
    key: "show-content",
    "aria-hidden": true
  }, node2) : node2, renderEllipsis(canEllipsis)))))));
});
var Base_default = Base;

// node_modules/antd/es/typography/Link.js
var Link = React637.forwardRef((props, ref) => {
  const {
    ellipsis,
    rel,
    children,
    // @ts-expect-error: https://github.com/ant-design/ant-design/issues/26622
    navigate: _navigate,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Typography.Link");
    true ? warning5(typeof ellipsis !== "object", "usage", "`ellipsis` only supports boolean value.") : void 0;
  }
  const mergedProps = {
    ...restProps,
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  };
  return React637.createElement(Base_default, {
    ...mergedProps,
    ref,
    ellipsis: !!ellipsis,
    component: "a"
  }, children);
});
var Link_default = Link;

// node_modules/antd/es/typography/Paragraph.js
var React638 = __toESM(require_react());
var Paragraph2 = React638.forwardRef((props, ref) => {
  const {
    children,
    ...restProps
  } = props;
  return React638.createElement(Base_default, {
    ref,
    ...restProps,
    component: "div"
  }, children);
});
var Paragraph_default2 = Paragraph2;

// node_modules/antd/es/typography/Text.js
var React639 = __toESM(require_react());
var Text = (props, ref) => {
  const {
    ellipsis,
    children,
    ...restProps
  } = props;
  const mergedEllipsis = React639.useMemo(() => {
    if (ellipsis && typeof ellipsis === "object") {
      return omit(ellipsis, ["expandable", "rows"]);
    }
    return ellipsis;
  }, [ellipsis]);
  if (true) {
    const warning5 = devUseWarning("Typography.Text");
    true ? warning5(typeof ellipsis !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "usage", "`ellipsis` do not support `expandable` or `rows` props.") : void 0;
  }
  return React639.createElement(Base_default, {
    ref,
    ...restProps,
    ellipsis: mergedEllipsis,
    component: "span"
  }, children);
};
var Text_default = React639.forwardRef(Text);

// node_modules/antd/es/typography/Title.js
var React640 = __toESM(require_react());
var TITLE_ELE_LIST = [1, 2, 3, 4, 5];
var Title2 = React640.forwardRef((props, ref) => {
  const {
    level = 1,
    children,
    ...restProps
  } = props;
  if (true) {
    const warning5 = devUseWarning("Typography.Title");
    true ? warning5(TITLE_ELE_LIST.includes(level), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.") : void 0;
  }
  const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : `h1`;
  return React640.createElement(Base_default, {
    ref,
    ...restProps,
    component
  }, children);
});
var Title_default2 = Title2;

// node_modules/antd/es/typography/index.js
var Typography2 = Typography_default;
Typography2.Text = Text_default;
Typography2.Link = Link_default;
Typography2.Title = Title_default2;
Typography2.Paragraph = Paragraph_default2;
var typography_default = Typography2;

// node_modules/antd/es/upload/Dragger.js
var React646 = __toESM(require_react());

// node_modules/antd/es/upload/Upload.js
var React645 = __toESM(require_react());
var import_react_dom8 = __toESM(require_react_dom());

// node_modules/@rc-component/upload/es/Upload.js
var import_react229 = __toESM(require_react());

// node_modules/@rc-component/upload/es/AjaxUploader.js
var import_react228 = __toESM(require_react());

// node_modules/@rc-component/upload/es/attr-accept.js
var attr_accept_default = (file, acceptedFiles) => {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name || "";
    const mimeType = file.type || "";
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type5) => {
      const validType = type5.trim();
      if (/^\*(\/\*)?$/.test(type5)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        const lowerFileName = fileName.toLowerCase();
        const lowerType = validType.toLowerCase();
        let affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some((affix) => lowerFileName.endsWith(affix));
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        warning_default(false, `Upload takes an invalidate 'accept' type '${validType}'.Skip for check.`);
        return true;
      }
      return false;
    });
  }
  return true;
};

// node_modules/@rc-component/upload/es/request.js
function getError(option, xhr) {
  const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e3) {
    return text;
  }
}
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e3) {
      if (e3.total > 0) {
        e3.percent = e3.loaded / e3.total * 100;
      }
      option.onProgress(e3);
    };
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach((key) => {
      const value = option.data[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key}[]`, item);
        });
        return;
      }
      formData.append(key, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = function error(e3) {
    option.onError(e3);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h) => {
    if (headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}

// node_modules/@rc-component/upload/es/traverseFileTree.js
var traverseFileTree = async (files, isAccepted) => {
  const flattenFileList = [];
  const progressFileList = [];
  files.forEach((file) => progressFileList.push(file.webkitGetAsEntry()));
  async function readDirectory(directory) {
    const dirReader = directory.createReader();
    const entries = [];
    while (true) {
      const results = await new Promise((resolve) => {
        dirReader.readEntries(resolve, () => resolve([]));
      });
      const n2 = results.length;
      if (!n2) {
        break;
      }
      for (let i = 0; i < n2; i++) {
        entries.push(results[i]);
      }
    }
    return entries;
  }
  async function readFile(item) {
    return new Promise((reslove) => {
      item.file((file) => {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          reslove(file);
        } else {
          reslove(null);
        }
      });
    });
  }
  const _traverseFileTree = async (item, path2) => {
    if (!item) {
      return;
    }
    item.path = path2 || "";
    if (item.isFile) {
      const file = await readFile(item);
      if (file) {
        flattenFileList.push(file);
      }
    } else if (item.isDirectory) {
      const entries = await readDirectory(item);
      progressFileList.push(...entries);
    }
  };
  let wipIndex = 0;
  while (wipIndex < progressFileList.length) {
    await _traverseFileTree(progressFileList[wipIndex]);
    wipIndex++;
  }
  return flattenFileList;
};
var traverseFileTree_default = traverseFileTree;

// node_modules/@rc-component/upload/es/uid.js
var now = +/* @__PURE__ */ new Date();
var index = 0;
function uid2() {
  return `rc-upload-${now}-${++index}`;
}

// node_modules/@rc-component/upload/es/AjaxUploader.js
function _extends99() {
  _extends99 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends99.apply(this, arguments);
}
var AjaxUploader = class extends import_react228.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      uid: uid2()
    });
    __publicField(this, "reqs", {});
    __publicField(this, "fileInput");
    __publicField(this, "_isMounted");
    __publicField(this, "filterFile", (file, force = false) => {
      const {
        accept,
        directory
      } = this.props;
      let filterFn;
      let acceptFormat;
      if (typeof accept === "string") {
        acceptFormat = accept;
      } else {
        const {
          filter: filter3,
          format: format3
        } = accept || {};
        acceptFormat = format3;
        if (filter3 === "native") {
          filterFn = () => true;
        } else {
          filterFn = filter3;
        }
      }
      const mergedFilter = filterFn || (directory || force ? (currentFile) => attr_accept_default(currentFile, acceptFormat) : () => true);
      return mergedFilter(file);
    });
    __publicField(this, "onChange", (e3) => {
      const {
        files
      } = e3.target;
      const acceptedFiles = [...files].filter((file) => this.filterFile(file));
      this.uploadFiles(acceptedFiles);
      this.reset();
    });
    __publicField(this, "onClick", (event) => {
      const el = this.fileInput;
      if (!el) {
        return;
      }
      const target = event.target;
      const {
        onClick
      } = this.props;
      if (target && target.tagName === "BUTTON") {
        const parent = el.parentNode;
        parent.focus();
        target.blur();
      }
      el.click();
      if (onClick) {
        onClick(event);
      }
    });
    __publicField(this, "onKeyDown", (e3) => {
      if (e3.key === "Enter") {
        this.onClick(e3);
      }
    });
    __publicField(this, "onDataTransferFiles", async (dataTransfer, existFileCallback) => {
      const {
        multiple,
        directory
      } = this.props;
      const items = [...dataTransfer.items || []];
      let files = [...dataTransfer.files || []];
      if (files.length > 0 || items.some((item) => item.kind === "file")) {
        existFileCallback == null ? void 0 : existFileCallback();
      }
      if (directory) {
        files = await traverseFileTree_default(Array.prototype.slice.call(items), this.filterFile);
        this.uploadFiles(files);
      } else {
        let acceptFiles = [...files].filter((file) => this.filterFile(file, true));
        if (multiple === false) {
          acceptFiles = files.slice(0, 1);
        }
        this.uploadFiles(acceptFiles);
      }
    });
    __publicField(this, "onFilePaste", async (e3) => {
      const {
        pastable
      } = this.props;
      if (!pastable) {
        return;
      }
      if (e3.type === "paste") {
        const clipboardData = e3.clipboardData;
        return this.onDataTransferFiles(clipboardData, () => {
          e3.preventDefault();
        });
      }
    });
    __publicField(this, "onFileDragOver", (e3) => {
      e3.preventDefault();
    });
    __publicField(this, "onFileDrop", async (e3) => {
      e3.preventDefault();
      if (e3.type === "drop") {
        const dataTransfer = e3.dataTransfer;
        return this.onDataTransferFiles(dataTransfer);
      }
    });
    __publicField(this, "uploadFiles", (files) => {
      const originFiles = [...files];
      const postFiles = originFiles.map((file) => {
        file.uid = uid2();
        return this.processFile(file, originFiles);
      });
      Promise.all(postFiles).then((fileList) => {
        const {
          onBatchStart
        } = this.props;
        onBatchStart == null ? void 0 : onBatchStart(fileList.map(({
          origin,
          parsedFile
        }) => ({
          file: origin,
          parsedFile
        })));
        fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
          this.post(file);
        });
      });
    });
    /**
     * Process file before upload. When all the file is ready, we start upload.
     */
    __publicField(this, "processFile", async (file, fileList) => {
      const {
        beforeUpload
      } = this.props;
      let transformedFile = file;
      if (beforeUpload) {
        try {
          transformedFile = await beforeUpload(file, fileList);
        } catch (e3) {
          transformedFile = false;
        }
        if (transformedFile === false) {
          return {
            origin: file,
            parsedFile: null,
            action: null,
            data: null
          };
        }
      }
      const {
        action
      } = this.props;
      let mergedAction;
      if (typeof action === "function") {
        mergedAction = await action(file);
      } else {
        mergedAction = action;
      }
      const {
        data
      } = this.props;
      let mergedData;
      if (typeof data === "function") {
        mergedData = await data(file);
      } else {
        mergedData = data;
      }
      const parsedData = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file
      );
      let parsedFile;
      if (parsedData instanceof File) {
        parsedFile = parsedData;
      } else {
        parsedFile = new File([parsedData], file.name, {
          type: file.type
        });
      }
      const mergedParsedFile = parsedFile;
      mergedParsedFile.uid = file.uid;
      return {
        origin: file,
        data: mergedData,
        parsedFile: mergedParsedFile,
        action: mergedAction
      };
    });
    __publicField(this, "saveFileInput", (node2) => {
      this.fileInput = node2;
    });
  }
  componentDidMount() {
    this._isMounted = true;
    const {
      pastable
    } = this.props;
    if (pastable) {
      document.addEventListener("paste", this.onFilePaste);
    }
  }
  componentWillUnmount() {
    this._isMounted = false;
    this.abort();
    document.removeEventListener("paste", this.onFilePaste);
  }
  componentDidUpdate(prevProps) {
    const {
      pastable
    } = this.props;
    if (pastable && !prevProps.pastable) {
      document.addEventListener("paste", this.onFilePaste);
    } else if (!pastable && prevProps.pastable) {
      document.removeEventListener("paste", this.onFilePaste);
    }
  }
  post({
    data,
    origin,
    action,
    parsedFile
  }) {
    if (!this._isMounted) {
      return;
    }
    const {
      onStart,
      customRequest,
      name,
      headers,
      withCredentials,
      method: method4
    } = this.props;
    const {
      uid: uid3
    } = origin;
    const request = customRequest || upload;
    const requestOption = {
      action,
      filename: name,
      data,
      file: parsedFile,
      headers,
      withCredentials,
      method: method4 || "post",
      onProgress: (e3) => {
        const {
          onProgress
        } = this.props;
        onProgress == null ? void 0 : onProgress(e3, parsedFile);
      },
      onSuccess: (ret, xhr) => {
        const {
          onSuccess
        } = this.props;
        onSuccess == null ? void 0 : onSuccess(ret, parsedFile, xhr);
        delete this.reqs[uid3];
      },
      onError: (err, ret) => {
        const {
          onError
        } = this.props;
        onError == null ? void 0 : onError(err, ret, parsedFile);
        delete this.reqs[uid3];
      }
    };
    onStart(origin);
    this.reqs[uid3] = request(requestOption, {
      defaultRequest: upload
    });
  }
  reset() {
    this.setState({
      uid: uid2()
    });
  }
  abort(file) {
    const {
      reqs
    } = this;
    if (file) {
      const uid3 = file.uid ? file.uid : file;
      if (reqs[uid3] && reqs[uid3].abort) {
        reqs[uid3].abort();
      }
      delete reqs[uid3];
    } else {
      Object.keys(reqs).forEach((uid3) => {
        if (reqs[uid3] && reqs[uid3].abort) {
          reqs[uid3].abort();
        }
        delete reqs[uid3];
      });
    }
  }
  render() {
    const {
      component: Tag2,
      prefixCls,
      className,
      classNames = {},
      disabled,
      id,
      name,
      style: style2,
      styles = {},
      multiple,
      accept,
      capture,
      children,
      directory,
      openFileDialogOnClick,
      onMouseEnter,
      onMouseLeave,
      hasControlInside,
      ...otherProps
    } = this.props;
    const acceptFormat = typeof accept === "string" ? accept : accept == null ? void 0 : accept.format;
    const cls = clsx(prefixCls, {
      [`${prefixCls}-disabled`]: disabled,
      [className]: className
    });
    const dirProps = directory ? {
      directory: "directory",
      webkitdirectory: "webkitdirectory"
    } : {};
    const events = disabled ? {} : {
      onClick: openFileDialogOnClick ? this.onClick : () => {
      },
      onKeyDown: openFileDialogOnClick ? this.onKeyDown : () => {
      },
      onMouseEnter,
      onMouseLeave,
      onDrop: this.onFileDrop,
      onDragOver: this.onFileDragOver,
      tabIndex: hasControlInside ? void 0 : "0"
    };
    return import_react228.default.createElement(Tag2, _extends99({}, events, {
      className: cls,
      role: hasControlInside ? void 0 : "button",
      style: style2
    }), import_react228.default.createElement("input", _extends99({}, pickAttrs(otherProps, {
      aria: true,
      data: true
    }), {
      id,
      name,
      disabled,
      type: "file",
      ref: this.saveFileInput,
      onClick: (e3) => e3.stopPropagation(),
      key: this.state.uid,
      style: {
        display: "none",
        ...styles.input
      },
      className: classNames.input,
      accept: acceptFormat
    }, dirProps, {
      multiple,
      onChange: this.onChange
    }, capture != null ? {
      capture
    } : {})), children);
  }
};
var AjaxUploader_default = AjaxUploader;

// node_modules/@rc-component/upload/es/Upload.js
function _extends100() {
  _extends100 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends100.apply(this, arguments);
}
function empty() {
}
var Upload = class extends import_react229.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "uploader");
    __publicField(this, "saveUploader", (node2) => {
      this.uploader = node2;
    });
  }
  abort(file) {
    this.uploader.abort(file);
  }
  render() {
    return import_react229.default.createElement(AjaxUploader_default, _extends100({}, this.props, {
      ref: this.saveUploader
    }));
  }
};
__publicField(Upload, "defaultProps", {
  component: "span",
  prefixCls: "rc-upload",
  data: {},
  headers: {},
  name: "file",
  multipart: false,
  onStart: empty,
  onError: empty,
  onSuccess: empty,
  multiple: false,
  beforeUpload: null,
  customRequest: null,
  withCredentials: false,
  openFileDialogOnClick: true,
  hasControlInside: false
});
var Upload_default = Upload;

// node_modules/@rc-component/upload/es/index.js
var es_default36 = Upload_default;

// node_modules/antd/es/upload/style/dragger.js
var genDraggerStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token2.colorFillAlter,
        border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [componentCls]: {
          padding: token2.padding
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none",
          borderRadius: token2.borderRadiusLG,
          "&:focus-visible": {
            outline: `${unit(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`
          }
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
          borderColor: token2.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token2.margin,
          [iconCls]: {
            color: token2.colorPrimary,
            fontSize: token2.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${unit(token2.marginXXS)}`,
          color: token2.colorTextHeading,
          fontSize: token2.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token2.colorTextDescription,
          fontSize: token2.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token2.colorTextDisabled
          }
        }
      }
    }
  };
};
var dragger_default = genDraggerStyle;

// node_modules/antd/es/upload/style/list.js
var genListStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    fontSize,
    lineHeight,
    calc
  } = token2;
  const itemCls = `${componentCls}-list-item`;
  const actionsCls = `${itemCls}-actions`;
  const actionCls = `${itemCls}-action`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: {
        ...clearFix(),
        lineHeight: token2.lineHeight,
        [itemCls]: {
          position: "relative",
          height: calc(token2.lineHeight).mul(fontSize).equal(),
          marginTop: token2.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token2.motionDurationSlow}`,
          borderRadius: token2.borderRadiusSM,
          "&:hover": {
            backgroundColor: token2.controlItemBgHover
          },
          [`${itemCls}-name`]: {
            ...textEllipsis,
            padding: `0 ${unit(token2.paddingXS)}`,
            lineHeight,
            flex: "auto",
            transition: `all ${token2.motionDurationSlow}`
          },
          [actionsCls]: {
            whiteSpace: "nowrap",
            [actionCls]: {
              opacity: 0
            },
            [iconCls]: {
              color: token2.actionsColor,
              transition: `all ${token2.motionDurationSlow}`
            },
            [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token2.colorIcon,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: token2.calc(token2.uploadProgressOffset).mul(-1).equal(),
            width: "100%",
            paddingInlineStart: calc(fontSize).add(token2.paddingXS).equal(),
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1
        },
        [`${itemCls}-error`]: {
          color: token2.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token2.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token2.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      }
    }
  };
};
var list_default2 = genListStyle;

// node_modules/antd/es/upload/style/motion.js
var genMotionStyle3 = (token2) => {
  const {
    componentCls
  } = token2;
  const uploadAnimateInlineIn = new Keyframes_default("uploadAnimateInlineIn", {
    from: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  });
  const uploadAnimateInlineOut = new Keyframes_default("uploadAnimateInlineOut", {
    to: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: token2.calc(token2.marginXS).div(-2).equal()
    }
  });
  const inlineCls = `${componentCls}-animate-inline`;
  return [{
    [`${componentCls}-wrapper`]: {
      [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${inlineCls}-appear, ${inlineCls}-enter`]: {
        animationName: uploadAnimateInlineIn
      },
      [`${inlineCls}-leave`]: {
        animationName: uploadAnimateInlineOut
      }
    }
  }, {
    [`${componentCls}-wrapper`]: initFadeMotion(token2)
  }, uploadAnimateInlineIn, uploadAnimateInlineOut];
};
var motion_default4 = genMotionStyle3;

// node_modules/antd/es/upload/style/picture.js
var genPictureStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    uploadThumbnailSize,
    uploadProgressOffset,
    calc
  } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 
      [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
        [itemCls]: {
          position: "relative",
          height: calc(uploadThumbnailSize).add(calc(token2.lineWidth).mul(2)).add(calc(token2.paddingXS).mul(2)).equal(),
          padding: token2.paddingXS,
          border: `${unit(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: {
            ...textEllipsis,
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: unit(calc(uploadThumbnailSize).add(token2.paddingSM).equal()),
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token2.fontSizeHeading2,
              color: token2.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          },
          [`${itemCls}-progress`]: {
            bottom: uploadProgressOffset,
            width: `calc(100% - ${unit(calc(token2.paddingSM).mul(2).equal())})`,
            marginTop: 0,
            paddingInlineStart: calc(uploadThumbnailSize).add(token2.paddingXS).equal()
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token2.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='${blue[0]}']`]: {
              fill: token2.colorErrorBg
            },
            [`svg path[fill='${blue.primary}']`]: {
              fill: token2.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      },
      [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
        [`&, &::before, ${itemCls}-thumbnail`]: {
          borderRadius: "50%"
        }
      }
    }
  };
};
var genPictureCardStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    fontSizeLG,
    colorTextLightSolid,
    calc
  } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  const uploadPictureCardSize = token2.uploadPicCardSize;
  return {
    [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: {
      ...clearFix(),
      display: "block",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token2.colorFillAlter,
        border: `${unit(token2.lineWidth)} dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token2.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
        display: "flex",
        flexWrap: "wrap",
        "@supports not (gap: 1px)": {
          "& > *": {
            marginBlockEnd: token2.marginXS,
            marginInlineEnd: token2.marginXS
          }
        },
        "@supports (gap: 1px)": {
          gap: token2.marginXS
        },
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        "&::before": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
            height: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
            backgroundColor: token2.colorBgMask,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          [`
            ${iconCls}-eye,
            ${iconCls}-download,
            ${iconCls}-delete
          `]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${unit(token2.marginXXS)}`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            color: colorTextLightSolid,
            "&:hover": {
              color: colorTextLightSolid
            },
            svg: {
              verticalAlign: "baseline"
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token2.margin,
          display: "block",
          width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token2.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token2.marginXL,
          width: `calc(100% - ${unit(calc(token2.paddingXS).mul(2).equal())})`,
          paddingInlineStart: 0
        }
      }
    },
    [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
      [`${componentCls}${componentCls}-select`]: {
        borderRadius: "50%"
      }
    }
  };
};

// node_modules/antd/es/upload/style/rtl.js
var genRtlStyle4 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
var rtl_default4 = genRtlStyle4;

// node_modules/antd/es/upload/style/index.js
var genBaseStyle19 = (token2) => {
  const {
    componentCls,
    colorTextDisabled
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      ...resetComponent(token2),
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-hidden`]: {
        display: "none"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  };
};
var prepareComponentToken58 = (token2) => ({
  actionsColor: token2.colorIcon,
  pictureCardSize: token2.controlHeightLG * 2.55
});
var style_default65 = genStyleHooks("Upload", (token2) => {
  const {
    fontSizeHeading3,
    fontHeight,
    lineWidth,
    pictureCardSize,
    calc
  } = token2;
  const uploadToken = merge2(token2, {
    uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
    uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
    uploadPicCardSize: pictureCardSize
  });
  return [genBaseStyle19(uploadToken), dragger_default(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), list_default2(uploadToken), motion_default4(uploadToken), rtl_default4(uploadToken), collapse_default(uploadToken)];
}, prepareComponentToken58);

// node_modules/antd/es/upload/UploadList/index.js
var React644 = __toESM(require_react());

// node_modules/antd/es/upload/utils.js
function file2Obj(file) {
  return {
    ...file,
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  };
}
function updateFileList(file, fileList) {
  const nextFileList = _toConsumableArray(fileList);
  const fileIndex = nextFileList.findIndex(({
    uid: uid3
  }) => uid3 === file.uid);
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
var extname = (url2 = "") => {
  const temp = url2.split("/");
  const filename = temp[temp.length - 1];
  const filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = (type5) => type5.indexOf("image/") === 0;
var isImageUrl = (file) => {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  const url2 = file.thumbUrl || file.url || "";
  const extension = extname(url2);
  if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url2)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
      const {
        width,
        height
      } = img;
      let drawWidth = MEASURE_SIZE;
      let drawHeight = MEASURE_SIZE;
      let offsetX = 0;
      let offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      window.URL.revokeObjectURL(img.src);
      resolve(dataURL);
    };
    img.crossOrigin = "anonymous";
    if (file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result && typeof reader.result === "string") {
          img.src = reader.result;
        }
      };
      reader.readAsDataURL(file);
    } else if (file.type.startsWith("image/gif")) {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result) {
          resolve(reader.result);
        }
      };
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}

// node_modules/antd/es/upload/UploadList/ListItem.js
var React643 = __toESM(require_react());
var ListItem2 = React643.forwardRef(({
  prefixCls,
  className,
  style: style2,
  classNames: itemClassNames,
  styles,
  locale: locale6,
  listType,
  file,
  items,
  progress: progressProps,
  iconRender,
  actionIconRender,
  itemRender,
  isImgUrl,
  showPreviewIcon,
  showRemoveIcon,
  showDownloadIcon,
  previewIcon: customPreviewIcon,
  removeIcon: customRemoveIcon,
  downloadIcon: customDownloadIcon,
  extra: customExtra,
  onPreview,
  onDownload,
  onClose
}, ref) => {
  var _a, _b;
  const {
    status
  } = file;
  const [mergedStatus, setMergedStatus] = React643.useState(status);
  React643.useEffect(() => {
    if (status !== "removed") {
      setMergedStatus(status);
    }
  }, [status]);
  const [showProgress, setShowProgress] = React643.useState(false);
  React643.useEffect(() => {
    const timer = setTimeout(() => {
      setShowProgress(true);
    }, 300);
    return () => {
      clearTimeout(timer);
    };
  }, []);
  const iconNode = iconRender(file);
  let icon = React643.createElement("div", {
    className: `${prefixCls}-icon`
  }, iconNode);
  if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
    if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
      const uploadingClassName = clsx(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
      });
      icon = React643.createElement("div", {
        className: uploadingClassName
      }, iconNode);
    } else {
      const thumbnail = (isImgUrl == null ? void 0 : isImgUrl(file)) ? React643.createElement("img", {
        src: file.thumbUrl || file.url,
        alt: file.name,
        className: `${prefixCls}-list-item-image`,
        crossOrigin: file.crossOrigin
      }) : iconNode;
      const aClassName = clsx(`${prefixCls}-list-item-thumbnail`, {
        [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
      });
      icon = React643.createElement("a", {
        className: aClassName,
        onClick: (e3) => onPreview(file, e3),
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer"
      }, thumbnail);
    }
  }
  const listItemClassName = clsx(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`, itemClassNames == null ? void 0 : itemClassNames.item);
  const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
  const removeIcon = (typeof showRemoveIcon === "function" ? showRemoveIcon(file) : showRemoveIcon) ? actionIconRender(
    (typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || React643.createElement(DeleteOutlined_default, null),
    () => onClose(file),
    prefixCls,
    locale6.removeFile,
    // acceptUploadDisabled is true, only remove icon will follow Upload disabled prop
    // https://github.com/ant-design/ant-design/issues/46171
    true
  ) : null;
  const downloadIcon = (typeof showDownloadIcon === "function" ? showDownloadIcon(file) : showDownloadIcon) && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || React643.createElement(DownloadOutlined_default, null), () => onDownload(file), prefixCls, locale6.downloadFile) : null;
  const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && React643.createElement("span", {
    key: "download-delete",
    className: clsx(`${prefixCls}-list-item-actions`, {
      picture: listType === "picture"
    })
  }, downloadIcon, removeIcon);
  const extraContent = typeof customExtra === "function" ? customExtra(file) : customExtra;
  const extra = extraContent && React643.createElement("span", {
    className: `${prefixCls}-list-item-extra`
  }, extraContent);
  const listItemNameClass = clsx(`${prefixCls}-list-item-name`);
  const fileName = file.url ? React643.createElement("a", {
    key: "view",
    target: "_blank",
    rel: "noopener noreferrer",
    className: listItemNameClass,
    title: file.name,
    ...linkProps,
    href: file.url,
    onClick: (e3) => onPreview(file, e3)
  }, file.name, extra) : React643.createElement("span", {
    key: "view",
    className: listItemNameClass,
    onClick: (e3) => onPreview(file, e3),
    title: file.name
  }, file.name, extra);
  const previewIcon = (typeof showPreviewIcon === "function" ? showPreviewIcon(file) : showPreviewIcon) && (file.url || file.thumbUrl) ? React643.createElement("a", {
    href: file.url || file.thumbUrl,
    target: "_blank",
    rel: "noopener noreferrer",
    onClick: (e3) => onPreview(file, e3),
    title: locale6.previewFile
  }, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || React643.createElement(EyeOutlined_default, null)) : null;
  const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && React643.createElement("span", {
    className: `${prefixCls}-list-item-actions`
  }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
  const {
    getPrefixCls
  } = React643.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const dom = React643.createElement("div", {
    className: listItemClassName,
    style: styles == null ? void 0 : styles.item
  }, icon, fileName, downloadOrDelete, pictureCardActions, showProgress && React643.createElement(es_default2, {
    motionName: `${rootPrefixCls}-fade`,
    visible: mergedStatus === "uploading",
    motionDeadline: 2e3
  }, ({
    className: motionClassName
  }) => {
    const loadingProgress = "percent" in file ? React643.createElement(progress_default2, {
      type: "line",
      percent: file.percent,
      "aria-label": file["aria-label"],
      "aria-labelledby": file["aria-labelledby"],
      ...progressProps
    }) : null;
    return React643.createElement("div", {
      className: clsx(`${prefixCls}-list-item-progress`, motionClassName)
    }, loadingProgress);
  }));
  const message2 = file.response && typeof file.response === "string" ? file.response : ((_a = file.error) == null ? void 0 : _a.statusText) || ((_b = file.error) == null ? void 0 : _b.message) || locale6.uploadError;
  const item = mergedStatus === "error" ? React643.createElement(tooltip_default, {
    title: message2,
    getPopupContainer: (node2) => node2.parentNode
  }, dom) : dom;
  return React643.createElement("div", {
    className: clsx(`${prefixCls}-list-item-container`, className),
    style: style2,
    ref
  }, itemRender ? itemRender(item, file, items, {
    download: onDownload.bind(null, file),
    preview: onPreview.bind(null, file),
    remove: onClose.bind(null, file)
  }) : item);
});
var ListItem_default2 = ListItem2;

// node_modules/antd/es/upload/UploadList/index.js
var InternalUploadList = (props, ref) => {
  const {
    listType = "text",
    previewFile = previewImage,
    onPreview,
    onDownload,
    onRemove,
    locale: locale6,
    iconRender,
    isImageUrl: isImgUrl = isImageUrl,
    prefixCls: customizePrefixCls,
    items = [],
    showPreviewIcon = true,
    showRemoveIcon = true,
    showDownloadIcon = false,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra,
    progress = {
      size: [-1, 2],
      showInfo: false
    },
    appendAction,
    appendActionVisible = true,
    itemRender,
    disabled,
    classNames: uploadListClassNames,
    styles
  } = props;
  const [, forceUpdate] = useForceUpdate();
  const [motionAppear, setMotionAppear] = React644.useState(false);
  const isPictureCardOrCirle = ["picture-card", "picture-circle"].includes(listType);
  React644.useEffect(() => {
    if (!listType.startsWith("picture")) {
      return;
    }
    (items || []).forEach((file) => {
      if (!(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
        return;
      }
      file.thumbUrl = "";
      previewFile == null ? void 0 : previewFile(file.originFileObj).then((previewDataUrl) => {
        file.thumbUrl = previewDataUrl || "";
        forceUpdate();
      });
    });
  }, [listType, items, previewFile]);
  React644.useEffect(() => {
    setMotionAppear(true);
  }, []);
  const onInternalPreview = (file, e3) => {
    if (!onPreview) {
      return;
    }
    e3 == null ? void 0 : e3.preventDefault();
    return onPreview(file);
  };
  const onInternalDownload = (file) => {
    if (typeof onDownload === "function") {
      onDownload(file);
    } else if (file.url) {
      window.open(file.url);
    }
  };
  const onInternalClose = (file) => {
    onRemove == null ? void 0 : onRemove(file);
  };
  const internalIconRender = (file) => {
    if (iconRender) {
      return iconRender(file, listType);
    }
    const isLoading = file.status === "uploading";
    if (listType.startsWith("picture")) {
      const loadingIcon = listType === "picture" ? React644.createElement(LoadingOutlined_default, null) : locale6.uploading;
      const fileIcon = (isImgUrl == null ? void 0 : isImgUrl(file)) ? React644.createElement(PictureTwoTone_default, null) : React644.createElement(FileTwoTone_default, null);
      return isLoading ? loadingIcon : fileIcon;
    }
    return isLoading ? React644.createElement(LoadingOutlined_default, null) : React644.createElement(PaperClipOutlined_default, null);
  };
  const actionIconRender = (customIcon, callback, prefixCls2, title, acceptUploadDisabled) => {
    const btnProps = {
      type: "text",
      size: "small",
      title,
      onClick: (e3) => {
        var _a, _b;
        callback();
        if (React644.isValidElement(customIcon)) {
          (_b = (_a = customIcon.props).onClick) == null ? void 0 : _b.call(_a, e3);
        }
      },
      className: `${prefixCls2}-list-item-action`,
      disabled: acceptUploadDisabled ? disabled : false
    };
    return React644.isValidElement(customIcon) ? React644.createElement(Button_default, {
      ...btnProps,
      icon: cloneElement3(customIcon, {
        ...customIcon.props,
        onClick: () => {
        }
      })
    }) : React644.createElement(Button_default, {
      ...btnProps
    }, React644.createElement("span", null, customIcon));
  };
  React644.useImperativeHandle(ref, () => ({
    handlePreview: onInternalPreview,
    handleDownload: onInternalDownload
  }));
  const {
    getPrefixCls
  } = React644.useContext(ConfigContext);
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const listClassNames = clsx(`${prefixCls}-list`, `${prefixCls}-list-${listType}`, uploadListClassNames == null ? void 0 : uploadListClassNames.list);
  const listItemMotion = React644.useMemo(() => omit(motion_default(rootPrefixCls), ["onAppearEnd", "onEnterEnd", "onLeaveEnd"]), [rootPrefixCls]);
  const motionConfig = {
    ...isPictureCardOrCirle ? {} : listItemMotion,
    motionDeadline: 2e3,
    motionName: `${prefixCls}-${isPictureCardOrCirle ? "animate-inline" : "animate"}`,
    keys: _toConsumableArray(items.map((file) => ({
      key: file.uid,
      file
    }))),
    motionAppear
  };
  return React644.createElement("div", {
    className: listClassNames,
    style: styles == null ? void 0 : styles.list
  }, React644.createElement(CSSMotionList_default, {
    ...motionConfig,
    component: false
  }, ({
    key,
    file,
    className: motionClassName,
    style: motionStyle
  }) => React644.createElement(ListItem_default2, {
    key,
    locale: locale6,
    prefixCls,
    className: motionClassName,
    style: motionStyle,
    classNames: uploadListClassNames,
    styles,
    file,
    items,
    progress,
    listType,
    isImgUrl,
    showPreviewIcon,
    showRemoveIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra,
    iconRender: internalIconRender,
    actionIconRender,
    itemRender,
    onPreview: onInternalPreview,
    onDownload: onInternalDownload,
    onClose: onInternalClose
  })), appendAction && React644.createElement(es_default2, {
    ...motionConfig,
    visible: appendActionVisible,
    forceRender: true
  }, ({
    className: motionClassName,
    style: motionStyle
  }) => cloneElement3(appendAction, (oriProps) => ({
    className: clsx(oriProps.className, motionClassName),
    style: {
      ...motionStyle,
      // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
      pointerEvents: motionClassName ? "none" : void 0,
      ...oriProps.style
    }
  }))));
};
var UploadList = React644.forwardRef(InternalUploadList);
if (true) {
  UploadList.displayName = "UploadList";
}
var UploadList_default = UploadList;

// node_modules/antd/es/upload/Upload.js
var LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
var InternalUpload = (props, ref) => {
  const config = useComponentConfig("upload");
  const {
    fileList,
    defaultFileList,
    onRemove,
    showUploadList = true,
    listType = "text",
    onPreview,
    onDownload,
    onChange,
    onDrop,
    previewFile,
    disabled: customDisabled,
    locale: propLocale,
    iconRender,
    isImageUrl: isImageUrl2,
    progress,
    prefixCls: customizePrefixCls,
    className,
    type: type5 = "select",
    children,
    style: style2,
    itemRender,
    maxCount,
    data = {},
    multiple = false,
    hasControlInside = true,
    action = "",
    accept = "",
    supportServerRender = true,
    rootClassName,
    styles,
    classNames
  } = props;
  const disabled = React645.useContext(DisabledContext_default);
  const mergedDisabled = customDisabled ?? disabled;
  const customRequest = props.customRequest || config.customRequest;
  const [internalFileList, setMergedFileList] = useControlledState(defaultFileList, fileList);
  const mergedFileList = internalFileList || [];
  const [dragState, setDragState] = React645.useState("drop");
  const upload2 = React645.useRef(null);
  const wrapRef = React645.useRef(null);
  if (true) {
    const warning5 = devUseWarning("Upload");
    true ? warning5("fileList" in props || !("value" in props), "usage", "`value` is not a valid prop, do you mean `fileList`?") : void 0;
  }
  React645.useMemo(() => {
    const timestamp = Date.now();
    (fileList || []).forEach((file, index2) => {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = `__AUTO__${timestamp}_${index2}__`;
      }
    });
  }, [fileList]);
  const onInternalChange = (file, changedFileList, event) => {
    let cloneList = _toConsumableArray(changedFileList);
    let exceedMaxCount = false;
    if (maxCount === 1) {
      cloneList = cloneList.slice(-1);
    } else if (maxCount) {
      exceedMaxCount = cloneList.length > maxCount;
      cloneList = cloneList.slice(0, maxCount);
    }
    (0, import_react_dom8.flushSync)(() => {
      setMergedFileList(cloneList);
    });
    const changeInfo = {
      file,
      fileList: cloneList
    };
    if (event) {
      changeInfo.event = event;
    }
    if (!exceedMaxCount || file.status === "removed" || // We should ignore event if current file is exceed `maxCount`
    cloneList.some((f) => f.uid === file.uid)) {
      (0, import_react_dom8.flushSync)(() => {
        onChange == null ? void 0 : onChange(changeInfo);
      });
    }
  };
  const mergedBeforeUpload = async (file, fileListArgs) => {
    const {
      beforeUpload
    } = props;
    let parsedFile = file;
    if (beforeUpload) {
      const result = await beforeUpload(file, fileListArgs);
      if (result === false) {
        return false;
      }
      delete file[LIST_IGNORE];
      if (result === LIST_IGNORE) {
        Object.defineProperty(file, LIST_IGNORE, {
          value: true,
          configurable: true
        });
        return false;
      }
      if (typeof result === "object" && result) {
        parsedFile = result;
      }
    }
    return parsedFile;
  };
  const onBatchStart = (batchFileInfoList) => {
    const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
    if (!filteredFileInfoList.length) {
      return;
    }
    const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
    let newFileList = _toConsumableArray(mergedFileList);
    objectFileList.forEach((fileObj) => {
      newFileList = updateFileList(fileObj, newFileList);
    });
    objectFileList.forEach((fileObj, index2) => {
      let triggerFileObj = fileObj;
      if (!filteredFileInfoList[index2].parsedFile) {
        const {
          originFileObj
        } = fileObj;
        let clone;
        try {
          clone = new File([originFileObj], originFileObj.name, {
            type: originFileObj.type
          });
        } catch {
          clone = new Blob([originFileObj], {
            type: originFileObj.type
          });
          clone.name = originFileObj.name;
          clone.lastModifiedDate = /* @__PURE__ */ new Date();
          clone.lastModified = (/* @__PURE__ */ new Date()).getTime();
        }
        clone.uid = fileObj.uid;
        triggerFileObj = clone;
      } else {
        fileObj.status = "uploading";
      }
      onInternalChange(triggerFileObj, newFileList);
    });
  };
  const onSuccess = (response, file, xhr) => {
    try {
      if (typeof response === "string") {
        response = JSON.parse(response);
      }
    } catch {
    }
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "done";
    targetItem.percent = 100;
    targetItem.response = response;
    targetItem.xhr = xhr;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  const onProgress = (e3, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.status = "uploading";
    targetItem.percent = e3.percent;
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList, e3);
  };
  const onError = (error, response, file) => {
    if (!getFileItem(file, mergedFileList)) {
      return;
    }
    const targetItem = file2Obj(file);
    targetItem.error = error;
    targetItem.response = response;
    targetItem.status = "error";
    const nextFileList = updateFileList(targetItem, mergedFileList);
    onInternalChange(targetItem, nextFileList);
  };
  const handleRemove = (file) => {
    let currentFile;
    Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
      var _a;
      if (ret === false) {
        return;
      }
      const removedFileList = removeFileItem(file, mergedFileList);
      if (removedFileList) {
        currentFile = {
          ...file,
          status: "removed"
        };
        mergedFileList == null ? void 0 : mergedFileList.forEach((item) => {
          const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
          if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
            item.status = "removed";
          }
        });
        (_a = upload2.current) == null ? void 0 : _a.abort(currentFile);
        onInternalChange(currentFile, removedFileList);
      }
    });
  };
  const onFileDrop = (e3) => {
    setDragState(e3.type);
    if (e3.type === "drop") {
      onDrop == null ? void 0 : onDrop(e3);
    }
  };
  React645.useImperativeHandle(ref, () => ({
    onBatchStart,
    onSuccess,
    onProgress,
    onError,
    fileList: mergedFileList,
    upload: upload2.current,
    nativeElement: wrapRef.current
  }));
  const {
    getPrefixCls,
    direction,
    className: contextClassName,
    style: contextStyle,
    classNames: contextClassNames,
    styles: contextStyles
  } = useComponentConfig("upload");
  const prefixCls = getPrefixCls("upload", customizePrefixCls);
  const mergedProps = {
    ...props,
    listType,
    showUploadList,
    type: type5,
    multiple,
    hasControlInside,
    supportServerRender,
    disabled: mergedDisabled
  };
  const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
    props: mergedProps
  });
  const rcUploadProps = {
    onBatchStart,
    onError,
    onProgress,
    onSuccess,
    ...props,
    customRequest,
    data,
    multiple,
    action,
    accept,
    supportServerRender,
    prefixCls,
    disabled: mergedDisabled,
    beforeUpload: mergedBeforeUpload,
    onChange: void 0,
    hasControlInside
  };
  delete rcUploadProps.className;
  delete rcUploadProps.style;
  if (!children || mergedDisabled) {
    delete rcUploadProps.id;
  }
  const wrapperCls = `${prefixCls}-wrapper`;
  const [hashId, cssVarCls] = style_default65(prefixCls, wrapperCls);
  const [contextLocale] = useLocale_default("Upload", en_US_default6.Upload);
  const {
    showRemoveIcon,
    showPreviewIcon,
    showDownloadIcon,
    removeIcon,
    previewIcon,
    downloadIcon,
    extra
  } = typeof showUploadList === "boolean" ? {} : showUploadList;
  const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : showRemoveIcon;
  const renderUploadList = (button, buttonVisible) => {
    if (!showUploadList) {
      return button;
    }
    return React645.createElement(UploadList_default, {
      classNames: mergedClassNames,
      styles: mergedStyles,
      prefixCls,
      listType,
      items: mergedFileList,
      previewFile,
      onPreview,
      onDownload,
      onRemove: handleRemove,
      showRemoveIcon: realShowRemoveIcon,
      showPreviewIcon,
      showDownloadIcon,
      removeIcon,
      previewIcon,
      downloadIcon,
      iconRender,
      extra,
      locale: {
        ...contextLocale,
        ...propLocale
      },
      isImageUrl: isImageUrl2,
      progress,
      appendAction: button,
      appendActionVisible: buttonVisible,
      itemRender,
      disabled: mergedDisabled
    });
  };
  const mergedRootCls = clsx(wrapperCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
    [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
  });
  const mergedRootStyle = {
    ...mergedStyles.root
  };
  const mergedStyle = {
    ...contextStyle,
    ...style2
  };
  if (type5 === "drag") {
    const dragCls = clsx(hashId, prefixCls, `${prefixCls}-drag`, {
      [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
      [`${prefixCls}-drag-hover`]: dragState === "dragover",
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    return React645.createElement("span", {
      className: mergedRootCls,
      ref: wrapRef,
      style: mergedRootStyle
    }, React645.createElement("div", {
      className: dragCls,
      style: mergedStyle,
      onDrop: onFileDrop,
      onDragOver: onFileDrop,
      onDragLeave: onFileDrop
    }, React645.createElement(es_default36, {
      ...rcUploadProps,
      ref: upload2,
      className: `${prefixCls}-btn`
    }, React645.createElement("div", {
      className: `${prefixCls}-drag-container`
    }, children))), renderUploadList());
  }
  const uploadBtnCls = clsx(prefixCls, `${prefixCls}-select`, {
    [`${prefixCls}-disabled`]: mergedDisabled,
    [`${prefixCls}-hidden`]: !children
  });
  const uploadButton = React645.createElement("div", {
    className: uploadBtnCls,
    style: mergedStyle
  }, React645.createElement(es_default36, {
    ...rcUploadProps,
    ref: upload2
  }));
  if (listType === "picture-card" || listType === "picture-circle") {
    return React645.createElement("span", {
      className: mergedRootCls,
      ref: wrapRef,
      style: mergedRootStyle
    }, renderUploadList(uploadButton, !!children));
  }
  return React645.createElement("span", {
    className: mergedRootCls,
    ref: wrapRef,
    style: mergedRootStyle
  }, uploadButton, renderUploadList());
};
var Upload2 = React645.forwardRef(InternalUpload);
if (true) {
  Upload2.displayName = "Upload";
}
var Upload_default2 = Upload2;

// node_modules/antd/es/upload/Dragger.js
var Dragger = React646.forwardRef((props, ref) => {
  const {
    style: style2,
    height,
    hasControlInside = false,
    children,
    ...restProps
  } = props;
  const mergedStyle = {
    ...style2,
    height
  };
  return React646.createElement(Upload_default2, {
    ref,
    hasControlInside,
    ...restProps,
    style: mergedStyle,
    type: "drag"
  }, children);
});
if (true) {
  Dragger.displayName = "Dragger";
}
var Dragger_default = Dragger;

// node_modules/antd/es/upload/index.js
var Upload3 = Upload_default2;
Upload3.Dragger = Dragger_default;
Upload3.LIST_IGNORE = LIST_IGNORE;
var upload_default = Upload3;

// node_modules/antd/es/watermark/index.js
var import_react234 = __toESM(require_react());

// node_modules/@rc-component/mutate-observer/es/MutateObserver.js
var import_react231 = __toESM(require_react());

// node_modules/@rc-component/mutate-observer/es/useMutateObserver.js
var import_react230 = __toESM(require_react());
var defaultOptions = {
  subtree: true,
  childList: true,
  attributeFilter: ["style", "class"]
};
var useMutateObserver = (nodeOrList, callback, options = defaultOptions) => {
  import_react230.default.useEffect(() => {
    if (!canUseDom() || !nodeOrList) {
      return;
    }
    let instance;
    const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
    if ("MutationObserver" in window) {
      instance = new MutationObserver(callback);
      nodeList.forEach((element) => {
        instance.observe(element, options);
      });
    }
    return () => {
      instance == null ? void 0 : instance.takeRecords();
      instance == null ? void 0 : instance.disconnect();
    };
  }, [options, nodeOrList]);
};
var useMutateObserver_default = useMutateObserver;

// node_modules/antd/es/watermark/useClips.js
var import_react232 = __toESM(require_react());
var FontGap = 3;
var prepareCanvas = (width, height, ratio = 1) => {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const realWidth = width * ratio;
  const realHeight = height * ratio;
  canvas.setAttribute("width", `${realWidth}px`);
  canvas.setAttribute("height", `${realHeight}px`);
  ctx.save();
  return [ctx, canvas, realWidth, realHeight];
};
var getRotatePos = (x, y, angle) => {
  const targetX = x * Math.cos(angle) - y * Math.sin(angle);
  const targetY = x * Math.sin(angle) + y * Math.cos(angle);
  return [targetX, targetY];
};
var useClips = () => {
  const getClips = (content, rotate, ratio, width, height, font, gapX, gapY) => {
    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
    if (content instanceof HTMLImageElement) {
      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
    } else {
      const {
        color,
        fontSize,
        fontStyle,
        fontWeight,
        fontFamily,
        textAlign
      } = font;
      const mergedFontSize = Number(fontSize) * ratio;
      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
      ctx.fillStyle = color;
      ctx.textAlign = textAlign;
      ctx.textBaseline = "top";
      const contents = toList_default(content);
      contents == null ? void 0 : contents.forEach((item, index2) => {
        ctx.fillText(item ?? "", contentWidth / 2, index2 * (mergedFontSize + FontGap * ratio));
      });
    }
    const angle = Math.PI / 180 * Number(rotate);
    const maxSize = Math.max(width, height);
    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
    rCtx.translate(realMaxSize / 2, realMaxSize / 2);
    rCtx.rotate(angle);
    if (contentWidth > 0 && contentHeight > 0) {
      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
    }
    let left = 0;
    let right = 0;
    let top = 0;
    let bottom = 0;
    const halfWidth = contentWidth / 2;
    const halfHeight = contentHeight / 2;
    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];
    points.forEach(([x, y]) => {
      const [targetX, targetY] = getRotatePos(x, y, angle);
      left = Math.min(left, targetX);
      right = Math.max(right, targetX);
      top = Math.min(top, targetY);
      bottom = Math.max(bottom, targetY);
    });
    const cutLeft = left + realMaxSize / 2;
    const cutTop = top + realMaxSize / 2;
    const cutWidth = right - left;
    const cutHeight = bottom - top;
    const realGapX = gapX * ratio;
    const realGapY = gapY * ratio;
    const filledWidth = (cutWidth + realGapX) * 2;
    const filledHeight = cutHeight + realGapY;
    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
    const drawImg = (targetX = 0, targetY = 0) => {
      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
    };
    drawImg();
    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
  };
  return import_react232.default.useCallback(getClips, []);
};
var useClips_default = useClips;

// node_modules/antd/es/watermark/useRafDebounce.js
var import_react233 = __toESM(require_react());
function useRafDebounce(callback) {
  const executeRef = import_react233.default.useRef(false);
  const rafRef = import_react233.default.useRef(null);
  const wrapperCallback = useEvent_default(callback);
  return () => {
    if (executeRef.current) {
      return;
    }
    executeRef.current = true;
    wrapperCallback();
    rafRef.current = raf_default(() => {
      executeRef.current = false;
    });
  };
}

// node_modules/antd/es/watermark/useSingletonCache.js
var React651 = __toESM(require_react());
function useSingletonCache() {
  const cacheRef = React651.useRef([null, null]);
  const getCache = (cacheKeys, callback) => {
    const filteredKeys = cacheKeys.map((item) => item instanceof HTMLElement || Number.isNaN(item) ? "" : item);
    if (!isEqual_default(cacheRef.current[0], filteredKeys)) {
      cacheRef.current = [filteredKeys, callback()];
    }
    return cacheRef.current[1];
  };
  return getCache;
}

// node_modules/antd/es/watermark/useWatermark.js
var React652 = __toESM(require_react());

// node_modules/antd/es/watermark/utils.js
function toLowercaseSeparator(key) {
  return key.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function getStyleStr(style2) {
  return Object.keys(style2).map((key) => `${toLowercaseSeparator(key)}: ${style2[key]};`).join(" ");
}
function getPixelRatio() {
  return window.devicePixelRatio || 1;
}
var reRendering = (mutation, isWatermarkEle) => {
  let flag = false;
  if (mutation.removedNodes.length) {
    flag = Array.from(mutation.removedNodes).some((node2) => isWatermarkEle(node2));
  }
  if (mutation.type === "attributes" && isWatermarkEle(mutation.target)) {
    flag = true;
  }
  return flag;
};

// node_modules/antd/es/watermark/useWatermark.js
var emphasizedStyle = {
  visibility: "visible !important"
};
function useWatermark(markStyle, onRemove) {
  const watermarkMap = React652.useRef(/* @__PURE__ */ new Map());
  const onRemoveEvent = useEvent_default(onRemove);
  const appendWatermark = (base64Url, markWidth, container) => {
    if (container) {
      const exist = watermarkMap.current.get(container);
      if (!exist) {
        const newWatermarkEle = document.createElement("div");
        watermarkMap.current.set(container, newWatermarkEle);
      }
      const watermarkEle = watermarkMap.current.get(container);
      watermarkEle.setAttribute("style", getStyleStr({
        ...markStyle,
        backgroundImage: `url('${base64Url}')`,
        backgroundSize: `${Math.floor(markWidth)}px`,
        ...emphasizedStyle
      }));
      watermarkEle.removeAttribute("class");
      watermarkEle.removeAttribute("hidden");
      if (watermarkEle.parentElement !== container) {
        if (exist && onRemove) {
          onRemoveEvent();
        }
        container.append(watermarkEle);
      }
    }
    return watermarkMap.current.get(container);
  };
  const removeWatermark = (container) => {
    const watermarkEle = watermarkMap.current.get(container);
    if (watermarkEle && container) {
      container.removeChild(watermarkEle);
    }
    watermarkMap.current.delete(container);
  };
  const isWatermarkEle = (ele) => Array.from(watermarkMap.current.values()).includes(ele);
  return [appendWatermark, removeWatermark, isWatermarkEle];
}

// node_modules/antd/es/watermark/index.js
function getSizeDiff(prev2, next2) {
  return prev2.size === next2.size ? prev2 : next2;
}
var DEFAULT_GAP_X = 100;
var DEFAULT_GAP_Y = 100;
var fixedStyle = {
  position: "relative",
  overflow: "hidden"
};
var Watermark = (props) => {
  const {
    /**
     * The antd content layer zIndex is basically below 10
     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335
     */
    zIndex = 9,
    rotate = -22,
    width,
    height,
    image,
    content,
    font = {},
    style: style2,
    className,
    rootClassName,
    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],
    offset: offset3,
    children,
    inherit = true,
    onRemove
  } = props;
  const {
    className: contextClassName,
    style: contextStyle
  } = useComponentConfig("watermark");
  const mergedStyle = {
    ...fixedStyle,
    ...contextStyle,
    ...style2
  };
  const [, token2] = useToken();
  const {
    color = token2.colorFill,
    fontSize = token2.fontSizeLG,
    fontWeight = "normal",
    fontStyle = "normal",
    fontFamily = "sans-serif",
    textAlign = "center"
  } = font;
  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;
  const gapXCenter = gapX / 2;
  const gapYCenter = gapY / 2;
  const offsetLeft = (offset3 == null ? void 0 : offset3[0]) ?? gapXCenter;
  const offsetTop = (offset3 == null ? void 0 : offset3[1]) ?? gapYCenter;
  const markStyle = import_react234.default.useMemo(() => {
    const mergedMarkStyle = {
      zIndex,
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      backgroundRepeat: "repeat"
    };
    let positionLeft = offsetLeft - gapXCenter;
    let positionTop = offsetTop - gapYCenter;
    if (positionLeft > 0) {
      mergedMarkStyle.left = `${positionLeft}px`;
      mergedMarkStyle.width = `calc(100% - ${positionLeft}px)`;
      positionLeft = 0;
    }
    if (positionTop > 0) {
      mergedMarkStyle.top = `${positionTop}px`;
      mergedMarkStyle.height = `calc(100% - ${positionTop}px)`;
      positionTop = 0;
    }
    mergedMarkStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
    return mergedMarkStyle;
  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);
  const [container, setContainer] = import_react234.default.useState();
  const [subElements, setSubElements] = import_react234.default.useState(() => /* @__PURE__ */ new Set());
  const targetElements = import_react234.default.useMemo(() => {
    const list = container ? [container] : [];
    return [].concat(list, _toConsumableArray(Array.from(subElements)));
  }, [container, subElements]);
  const getMarkSize = (ctx) => {
    let defaultWidth = 120;
    let defaultHeight = 64;
    if (!image && ctx.measureText) {
      ctx.font = `${Number(fontSize)}px ${fontFamily}`;
      const contents = toList_default(content);
      const sizes2 = contents.map((item) => {
        const metrics = ctx.measureText(item);
        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];
      });
      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes2.map((size) => size[0]))));
      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes2.map((size) => size[1])))) * contents.length + (contents.length - 1) * FontGap;
    }
    return [width ?? defaultWidth, height ?? defaultHeight];
  };
  const getClips = useClips_default();
  const getClipsCache = useSingletonCache();
  const [watermarkInfo, setWatermarkInfo] = import_react234.default.useState(null);
  const renderWatermark = () => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const ratio = getPixelRatio();
      const [markWidth, markHeight] = getMarkSize(ctx);
      const drawCanvas = (drawContent) => {
        const params = [drawContent || "", rotate, ratio, markWidth, markHeight, {
          color,
          fontSize,
          fontStyle,
          fontWeight,
          fontFamily,
          textAlign
        }, gapX, gapY];
        const [nextClips, clipWidth] = getClipsCache(params, () => getClips.apply(void 0, params));
        setWatermarkInfo([nextClips, clipWidth]);
      };
      if (image) {
        const img = new Image();
        img.onload = () => {
          drawCanvas(img);
        };
        img.onerror = () => {
          drawCanvas(content);
        };
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.src = image;
      } else {
        drawCanvas(content);
      }
    }
  };
  const syncWatermark = useRafDebounce(renderWatermark);
  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle, onRemove);
  (0, import_react234.useEffect)(() => {
    if (watermarkInfo) {
      targetElements.forEach((holder) => {
        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);
      });
    }
  }, [watermarkInfo, targetElements]);
  const onMutate = useEvent_default((mutations) => {
    mutations.forEach((mutation) => {
      if (reRendering(mutation, isWatermarkEle)) {
        syncWatermark();
      } else if (mutation.target === container && mutation.attributeName === "style") {
        const keyStyles = Object.keys(fixedStyle);
        for (let i = 0; i < keyStyles.length; i += 1) {
          const key = keyStyles[i];
          const oriValue = mergedStyle[key];
          const currentValue = container.style[key];
          if (oriValue && oriValue !== currentValue) {
            container.style[key] = oriValue;
          }
        }
      }
    });
  });
  useMutateObserver_default(targetElements, onMutate);
  (0, import_react234.useEffect)(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);
  const watermarkContext = import_react234.default.useMemo(() => ({
    add: (ele) => {
      setSubElements((prev2) => {
        const clone = new Set(prev2);
        clone.add(ele);
        return getSizeDiff(prev2, clone);
      });
    },
    remove: (ele) => {
      removeWatermark(ele);
      setSubElements((prev2) => {
        const clone = new Set(prev2);
        clone.delete(ele);
        return getSizeDiff(prev2, clone);
      });
    }
  }), []);
  const childNode = inherit ? import_react234.default.createElement(context_default4.Provider, {
    value: watermarkContext
  }, children) : children;
  return import_react234.default.createElement("div", {
    ref: setContainer,
    className: clsx(className, contextClassName, rootClassName),
    style: mergedStyle
  }, childNode);
};
if (true) {
  Watermark.displayName = "Watermark";
}
var watermark_default = Watermark;

// node_modules/antd/es/index.js
var unstableSetRender = () => {
  true ? warning_default2(false, "compatible", "antd v6 support React 19 already, it's no need to call the compatible function or just remove `@ant-design/v5-patch-for-react-19`") : void 0;
};
if (true) {
  const majorVersion = getReactMajorVersion();
  true ? warning_default2(majorVersion >= 18, "version", `antd v6 no longer supports React versions below 18. Please upgrade to React 18 or higher.`) : void 0;
}
export {
  affix_default as Affix,
  alert_default as Alert,
  anchor_default as Anchor,
  app_default as App,
  auto_complete_default as AutoComplete,
  avatar_default as Avatar,
  back_top_default as BackTop,
  badge_default as Badge,
  breadcrumb_default as Breadcrumb,
  button_default as Button,
  calendar_default as Calendar,
  card_default as Card,
  carousel_default as Carousel,
  cascader_default as Cascader,
  checkbox_default as Checkbox,
  col_default2 as Col,
  collapse_default2 as Collapse,
  color_picker_default as ColorPicker,
  config_provider_default as ConfigProvider,
  date_picker_default as DatePicker,
  descriptions_default as Descriptions,
  divider_default as Divider,
  drawer_default as Drawer,
  dropdown_default3 as Dropdown,
  empty_default2 as Empty,
  flex_default as Flex,
  float_button_default as FloatButton,
  form_default as Form,
  grid_default as Grid,
  image_default as Image,
  input_default2 as Input,
  input_number_default as InputNumber,
  layout_default2 as Layout,
  list_default as List,
  masonry_default as Masonry,
  mentions_default as Mentions,
  menu_default2 as Menu,
  modal_default as Modal,
  pagination_default as Pagination,
  popconfirm_default as Popconfirm,
  popover_default as Popover,
  progress_default2 as Progress,
  qr_code_default as QRCode,
  radio_default2 as Radio,
  rate_default as Rate,
  result_default as Result,
  row_default2 as Row,
  segmented_default as Segmented,
  select_default as Select,
  skeleton_default as Skeleton,
  slider_default as Slider,
  space_default as Space,
  spin_default as Spin,
  splitter_default as Splitter,
  statistic_default2 as Statistic,
  steps_default as Steps,
  switch_default as Switch,
  table_default as Table,
  tabs_default as Tabs,
  tag_default as Tag,
  time_picker_default as TimePicker,
  timeline_default as Timeline,
  tooltip_default as Tooltip,
  tour_default as Tour,
  transfer_default as Transfer,
  tree_default as Tree,
  tree_select_default as TreeSelect,
  typography_default as Typography,
  upload_default as Upload,
  watermark_default as Watermark,
  message_default as message,
  notification_default as notification,
  theme_default3 as theme,
  unstableSetRender,
  version_default2 as version
};
//# sourceMappingURL=antd.js.map
